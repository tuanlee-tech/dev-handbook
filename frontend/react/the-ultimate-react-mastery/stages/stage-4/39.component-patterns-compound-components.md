# ğŸ“… NGÃ€Y 39: Component Patterns - Compound Components

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] Hiá»ƒu Ä‘Æ°á»£c Compound Components pattern vÃ  khi nÃ o nÃªn sá»­ dá»¥ng
- [ ] Biáº¿t cÃ¡ch xÃ¢y dá»±ng flexible component API vá»›i implicit state sharing
- [ ] Náº¯m vá»¯ng cÃ¡ch káº¿t há»£p Context vá»›i Compound Components
- [ ] So sÃ¡nh Ä‘Æ°á»£c trade-offs giá»¯a cÃ¡c cÃ¡ch thiáº¿t káº¿ component API

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

1. **Context API** (NgÃ y 36-38): LÃ m tháº¿ nÃ o Ä‘á»ƒ share state giá»¯a components khÃ´ng cáº§n props drilling?
2. **Component Composition** (NgÃ y 7): Children pattern vÃ  slots pattern hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o?
3. **Custom Hooks** (NgÃ y 24): Táº¡i sao chÃºng ta cáº§n extract logic thÃ nh custom hooks?

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

TÆ°á»Ÿng tÆ°á»£ng báº¡n cáº§n xÃ¢y dá»±ng má»™t Select component (dropdown). CÃ³ nhiá»u cÃ¡ch thiáº¿t káº¿ API:

**Approach 1: Props-heavy API** âŒ

```jsx
<Select
  options={[
    { value: '1', label: 'One', icon: 'ğŸ¥‡' },
    { value: '2', label: 'Two', icon: 'ğŸ¥ˆ' },
  ]}
  value={value}
  onChange={onChange}
  renderOption={(option) => (
    <div>
      {option.icon} {option.label}
    </div>
  )}
  renderTrigger={(value) => <button>{value}</button>}
/>
```

**Váº¥n Ä‘á»:**

- API phá»©c táº¡p, nhiá»u props
- KhÃ³ customize UI
- Render functions khÃ³ Ä‘á»c
- KhÃ³ má»Ÿ rá»™ng khi thÃªm features

**Approach 2: Compound Components** âœ…

```jsx
<Select
  value={value}
  onChange={onChange}
>
  <Select.Trigger>{value || 'Select...'}</Select.Trigger>
  <Select.Options>
    <Select.Option value='1'>ğŸ¥‡ One</Select.Option>
    <Select.Option value='2'>ğŸ¥ˆ Two</Select.Option>
  </Select.Options>
</Select>
```

**Lá»£i Ã­ch:**

- API rÃµ rÃ ng, dá»… Ä‘á»c
- Flexible - customize dá»… dÃ ng
- Compose Ä‘Æ°á»£c nhÆ° HTML
- Má»Ÿ rá»™ng Ä‘Æ¡n giáº£n

### 1.2 Giáº£i PhÃ¡p - Compound Components Pattern

**Compound Components** lÃ  pattern cho phÃ©p cÃ¡c components "lÃ m viá»‡c cÃ¹ng nhau" Ä‘á»ƒ táº¡o thÃ nh má»™t unit hoÃ n chá»‰nh, chia sáº» state ngáº§m Ä‘á»‹nh (implicit state) thÃ´ng qua Context.

**Äáº·c Ä‘iá»ƒm:**

1. **Parent component** quáº£n lÃ½ shared state
2. **Child components** tá»± Ä‘á»™ng access state qua Context
3. **Flexible composition** - user tá»± sáº¯p xáº¿p UI
4. **Implicit relationship** - khÃ´ng cáº§n pass props manual

### 1.3 Mental Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Select (Parent)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Context Provider            â”‚    â”‚
â”‚  â”‚ (value, onChange, isOpen)   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚           â”‚                          â”‚
â”‚           â”œâ”€ Select.Trigger â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€> useContext(SelectContext)
â”‚           â”‚                          â”‚   â†’ auto access value, toggle
â”‚           â”œâ”€ Select.Options â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€> useContext(SelectContext)
â”‚           â”‚                          â”‚   â†’ auto access isOpen
â”‚           â””â”€ Select.Option â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€> useContext(SelectContext)
â”‚                                      â”‚   â†’ auto access onChange
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Giá»‘ng nhÆ° má»™t "gia Ä‘Ã¬nh":
- Cha máº¹ (Parent) giá»¯ "tiá»n" (state)
- Con cÃ¡i (Children) tá»± Ä‘á»™ng "nháº­n tiá»n" khi cáº§n (qua Context)
- KhÃ´ng cáº§n cha máº¹ Ä‘Æ°a táº­n tay tá»«ng Ä‘á»©a (no props drilling)
```

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

âŒ **"Compound Components = nhiá»u components trong 1 file"**
â†’ Sai! ÄÃ³ chá»‰ lÃ  cÃ¡ch tá»• chá»©c code. Compound Components lÃ  vá» **implicit state sharing** qua Context.

âŒ **"Pháº£i Ä‘áº·t tÃªn kiá»ƒu Parent.Child"**
â†’ KhÃ´ng báº¯t buá»™c, nhÆ°ng lÃ  convention Ä‘á»ƒ code dá»… Ä‘á»c.

âŒ **"Children pháº£i render direct trong Parent"**
â†’ KhÃ´ng! Children cÃ³ thá»ƒ nested sÃ¢u, Context váº«n hoáº¡t Ä‘á»™ng.

âŒ **"Compound Components lÃ  duy nháº¥t cÃ¡ch tá»‘t"**
â†’ KhÃ´ng! Má»—i pattern cÃ³ trade-offs, pháº£i biáº¿t khi nÃ o dÃ¹ng.

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Pattern CÆ¡ Báº£n â­

**XÃ¢y dá»±ng Toggle Compound Component Ä‘Æ¡n giáº£n**

<details>
<summary>ğŸ’¡ Code Example</summary>

```jsx
/**
 * Toggle Component - Compound Components Pattern
 *
 * Features:
 * - Shared state qua Context
 * - Flexible composition
 * - Implicit state access
 */

import { createContext, useContext, useState } from 'react';

// 1. Táº¡o Context
const ToggleContext = createContext(null);

// 2. Custom hook Ä‘á»ƒ access context
const useToggleContext = () => {
  const context = useContext(ToggleContext);
  if (!context) {
    throw new Error('Toggle components must be used within <Toggle>');
  }
  return context;
};

// 3. Parent Component
const Toggle = ({ children }) => {
  const [isOn, setIsOn] = useState(false);

  const toggle = () => setIsOn((prev) => !prev);

  return (
    <ToggleContext.Provider value={{ isOn, toggle }}>
      {children}
    </ToggleContext.Provider>
  );
};

// 4. Child Components
Toggle.Button = function ToggleButton({ children }) {
  const { toggle } = useToggleContext();

  return <button onClick={toggle}>{children}</button>;
};

Toggle.Status = function ToggleStatus() {
  const { isOn } = useToggleContext();

  return <span>Status: {isOn ? 'ON' : 'OFF'}</span>;
};

Toggle.Content = function ToggleContent({ children }) {
  const { isOn } = useToggleContext();

  return isOn ? <div>{children}</div> : null;
};

// âœ… CÃCH DÃ™NG - Flexible composition
function App() {
  return (
    <Toggle>
      <Toggle.Status />
      <Toggle.Button>Toggle Me</Toggle.Button>
      <Toggle.Content>
        <p>This content shows when ON</p>
      </Toggle.Content>
    </Toggle>
  );
}

// CÃ³ thá»ƒ sáº¯p xáº¿p khÃ¡c:
function App2() {
  return (
    <Toggle>
      <Toggle.Button>Click</Toggle.Button>
      <Toggle.Content>Content</Toggle.Content>
      <Toggle.Status />
    </Toggle>
  );
}

// Tháº­m chÃ­ nested:
function App3() {
  return (
    <Toggle>
      <div className='card'>
        <Toggle.Status />
        <div className='footer'>
          <Toggle.Button>Toggle</Toggle.Button>
        </div>
      </div>
      <Toggle.Content>Content</Toggle.Content>
    </Toggle>
  );
}

/*
Káº¿t quáº£:
- Má»i cÃ¡ch dÃ¹ng Ä‘á»u hoáº¡t Ä‘á»™ng
- KhÃ´ng cáº§n pass props
- State tá»± Ä‘á»™ng sync
- UI flexible
*/
```

</details>

### Demo 2: Ká»‹ch Báº£n Thá»±c Táº¿ â­â­

**Tabs Component vá»›i validation vÃ  accessibility**

<details>
<summary>ğŸ’¡ Code Example</summary>

```jsx
/**
 * Tabs Component - Production-ready Compound Components
 *
 * Features:
 * - Keyboard navigation (Arrow keys)
 * - Accessibility (ARIA attributes)
 * - Controlled & Uncontrolled modes
 * - Error boundaries
 */

import { createContext, useContext, useState, useRef, useEffect } from 'react';

const TabsContext = createContext(null);

const useTabsContext = () => {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error('Tabs.* components must be used within <Tabs>');
  }
  return context;
};

const Tabs = ({ children, value: controlledValue, onChange, defaultValue }) => {
  // Há»— trá»£ cáº£ controlled vÃ  uncontrolled
  const [internalValue, setInternalValue] = useState(defaultValue || '');

  const isControlled = controlledValue !== undefined;
  const value = isControlled ? controlledValue : internalValue;

  const handleChange = (newValue) => {
    if (!isControlled) {
      setInternalValue(newValue);
    }
    onChange?.(newValue);
  };

  return (
    <TabsContext.Provider value={{ value, onChange: handleChange }}>
      <div role='tablist'>{children}</div>
    </TabsContext.Provider>
  );
};

Tabs.List = function TabsList({ children }) {
  const tabsRef = useRef([]);

  // Keyboard navigation
  const handleKeyDown = (e) => {
    const tabs = tabsRef.current;
    const currentIndex = tabs.indexOf(e.target);

    let nextIndex;
    if (e.key === 'ArrowRight') {
      nextIndex = (currentIndex + 1) % tabs.length;
    } else if (e.key === 'ArrowLeft') {
      nextIndex = (currentIndex - 1 + tabs.length) % tabs.length;
    } else if (e.key === 'Home') {
      nextIndex = 0;
    } else if (e.key === 'End') {
      nextIndex = tabs.length - 1;
    }

    if (nextIndex !== undefined) {
      tabs[nextIndex]?.focus();
      tabs[nextIndex]?.click();
    }
  };

  return (
    <div
      role='tablist'
      onKeyDown={handleKeyDown}
      className='tabs-list'
    >
      {children}
    </div>
  );
};

Tabs.Tab = function Tab({ value, children }) {
  const { value: selectedValue, onChange } = useTabsContext();
  const isSelected = value === selectedValue;
  const ref = useRef(null);

  return (
    <button
      ref={ref}
      role='tab'
      aria-selected={isSelected}
      aria-controls={`panel-${value}`}
      id={`tab-${value}`}
      tabIndex={isSelected ? 0 : -1}
      onClick={() => onChange(value)}
      style={{
        fontWeight: isSelected ? 'bold' : 'normal',
        borderBottom: isSelected ? '2px solid blue' : 'none',
      }}
    >
      {children}
    </button>
  );
};

Tabs.Panel = function TabPanel({ value, children }) {
  const { value: selectedValue } = useTabsContext();
  const isSelected = value === selectedValue;

  if (!isSelected) return null;

  return (
    <div
      role='tabpanel'
      id={`panel-${value}`}
      aria-labelledby={`tab-${value}`}
      tabIndex={0}
    >
      {children}
    </div>
  );
};

// âœ… CÃCH DÃ™NG
function App() {
  const [activeTab, setActiveTab] = useState('profile');

  return (
    <div>
      {/* Controlled mode */}
      <Tabs
        value={activeTab}
        onChange={setActiveTab}
      >
        <Tabs.List>
          <Tabs.Tab value='profile'>Profile</Tabs.Tab>
          <Tabs.Tab value='settings'>Settings</Tabs.Tab>
          <Tabs.Tab value='billing'>Billing</Tabs.Tab>
        </Tabs.List>

        <Tabs.Panel value='profile'>
          <h2>Profile Content</h2>
          <p>User profile information...</p>
        </Tabs.Panel>

        <Tabs.Panel value='settings'>
          <h2>Settings Content</h2>
          <p>Application settings...</p>
        </Tabs.Panel>

        <Tabs.Panel value='billing'>
          <h2>Billing Content</h2>
          <p>Billing information...</p>
        </Tabs.Panel>
      </Tabs>

      {/* Uncontrolled mode */}
      <Tabs defaultValue='home'>
        <Tabs.List>
          <Tabs.Tab value='home'>Home</Tabs.Tab>
          <Tabs.Tab value='about'>About</Tabs.Tab>
        </Tabs.List>
        <Tabs.Panel value='home'>Home content</Tabs.Panel>
        <Tabs.Panel value='about'>About content</Tabs.Panel>
      </Tabs>
    </div>
  );
}

/*
Káº¿t quáº£:
- âœ… Keyboard navigation works (Arrow keys, Home, End)
- âœ… Screen reader accessible
- âœ… Both controlled/uncontrolled modes
- âœ… No props drilling
*/
```

</details>

### Demo 3: Edge Cases â­â­â­

**Accordion vá»›i nested context vÃ  performance optimization**

<details>
<summary>ğŸ’¡ Code Example</summary>

```jsx
/**
 * Accordion Component - Edge Cases Handling
 *
 * Edge Cases:
 * - Multiple accordions on page (isolated state)
 * - Nested accordions (context conflicts)
 * - Dynamic items (add/remove)
 * - Performance with many items
 */

import {
  createContext,
  useContext,
  useState,
  useCallback,
  useMemo,
} from 'react';

const AccordionContext = createContext(null);

const useAccordionContext = () => {
  const context = useContext(AccordionContext);
  if (!context) {
    throw new Error('Accordion.* must be within <Accordion>');
  }
  return context;
};

const Accordion = ({ children, allowMultiple = false }) => {
  // allowMultiple: cho phÃ©p má»Ÿ nhiá»u items cÃ¹ng lÃºc
  const [openItems, setOpenItems] = useState(new Set());

  const toggleItem = useCallback(
    (id) => {
      setOpenItems((prev) => {
        const next = new Set(prev);

        if (next.has(id)) {
          // Äang má»Ÿ â†’ Ä‘Ã³ng
          next.delete(id);
        } else {
          // Äang Ä‘Ã³ng â†’ má»Ÿ
          if (!allowMultiple) {
            // Single mode: Ä‘Ã³ng táº¥t cáº£ items khÃ¡c
            next.clear();
          }
          next.add(id);
        }

        return next;
      });
    },
    [allowMultiple],
  );

  const isOpen = useCallback(
    (id) => {
      return openItems.has(id);
    },
    [openItems],
  );

  // Memoize value Ä‘á»ƒ trÃ¡nh re-render khÃ´ng cáº§n thiáº¿t
  const value = useMemo(
    () => ({
      toggleItem,
      isOpen,
    }),
    [toggleItem, isOpen],
  );

  return (
    <AccordionContext.Provider value={value}>
      <div className='accordion'>{children}</div>
    </AccordionContext.Provider>
  );
};

Accordion.Item = function AccordionItem({ id, children }) {
  const { isOpen } = useAccordionContext();
  const open = isOpen(id);

  // Táº¡o nested context cho Item
  // Äá»ƒ children cÃ³ thá»ƒ access id mÃ  khÃ´ng cáº§n pass props
  const ItemContext = createContext({ id, isOpen: open });

  return (
    <ItemContext.Provider value={{ id, isOpen: open }}>
      <div
        className='accordion-item'
        data-state={open ? 'open' : 'closed'}
      >
        {children}
      </div>
    </ItemContext.Provider>
  );
};

Accordion.Trigger = function AccordionTrigger({ children, id }) {
  const { toggleItem } = useAccordionContext();

  return (
    <button
      onClick={() => toggleItem(id)}
      aria-expanded={false}
      className='accordion-trigger'
    >
      {children}
    </button>
  );
};

Accordion.Content = function AccordionContent({ children, id }) {
  const { isOpen } = useAccordionContext();
  const open = isOpen(id);

  if (!open) return null;

  return <div className='accordion-content'>{children}</div>;
};

// âœ… CÃCH DÃ™NG - Edge Cases

// Case 1: Single accordion (chá»‰ 1 item má»Ÿ)
function SingleAccordion() {
  return (
    <Accordion>
      <Accordion.Item id='item1'>
        <Accordion.Trigger id='item1'>Item 1</Accordion.Trigger>
        <Accordion.Content id='item1'>Content 1</Accordion.Content>
      </Accordion.Item>

      <Accordion.Item id='item2'>
        <Accordion.Trigger id='item2'>Item 2</Accordion.Trigger>
        <Accordion.Content id='item2'>Content 2</Accordion.Content>
      </Accordion.Item>
    </Accordion>
  );
}

// Case 2: Multiple accordions (nhiá»u items má»Ÿ)
function MultipleAccordion() {
  return (
    <Accordion allowMultiple>
      <Accordion.Item id='a'>
        <Accordion.Trigger id='a'>Section A</Accordion.Trigger>
        <Accordion.Content id='a'>Content A</Accordion.Content>
      </Accordion.Item>
      <Accordion.Item id='b'>
        <Accordion.Trigger id='b'>Section B</Accordion.Trigger>
        <Accordion.Content id='b'>Content B</Accordion.Content>
      </Accordion.Item>
    </Accordion>
  );
}

// Case 3: Nested accordions (KHÃ”NG conflict context)
function NestedAccordion() {
  return (
    <Accordion>
      <Accordion.Item id='parent1'>
        <Accordion.Trigger id='parent1'>Parent 1</Accordion.Trigger>
        <Accordion.Content id='parent1'>
          {/* Nested accordion - cÃ³ context riÃªng */}
          <Accordion>
            <Accordion.Item id='child1'>
              <Accordion.Trigger id='child1'>Child 1</Accordion.Trigger>
              <Accordion.Content id='child1'>Nested content</Accordion.Content>
            </Accordion.Item>
          </Accordion>
        </Accordion.Content>
      </Accordion.Item>
    </Accordion>
  );
}

// Case 4: Dynamic items
function DynamicAccordion() {
  const [items, setItems] = useState([
    { id: '1', title: 'Item 1', content: 'Content 1' },
    { id: '2', title: 'Item 2', content: 'Content 2' },
  ]);

  const addItem = () => {
    const id = String(Date.now());
    setItems((prev) => [
      ...prev,
      {
        id,
        title: `Item ${prev.length + 1}`,
        content: `Content ${prev.length + 1}`,
      },
    ]);
  };

  return (
    <div>
      <button onClick={addItem}>Add Item</button>

      <Accordion>
        {items.map((item) => (
          <Accordion.Item
            key={item.id}
            id={item.id}
          >
            <Accordion.Trigger id={item.id}>{item.title}</Accordion.Trigger>
            <Accordion.Content id={item.id}>{item.content}</Accordion.Content>
          </Accordion.Item>
        ))}
      </Accordion>
    </div>
  );
}

/*
Edge Cases Handled:
âœ… Multiple instances isolated (má»—i <Accordion> cÃ³ state riÃªng)
âœ… Nested accordions khÃ´ng conflict context
âœ… Dynamic items (add/remove) works
âœ… Performance optimized (useMemo, useCallback)
âœ… allowMultiple mode
*/
```

</details>

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ BÃ i 1: Counter vá»›i Compound Components (15 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Ãp dá»¥ng pattern cÆ¡ báº£n nháº¥t

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Táº¡o Counter component vá»›i Compound Components pattern
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: Render Props, HOCs, forwardRef
 *
 * Requirements:
 * 1. Counter parent component quáº£n lÃ½ count state
 * 2. Counter.Display hiá»ƒn thá»‹ count hiá»‡n táº¡i
 * 3. Counter.Increment tÄƒng count
 * 4. Counter.Decrement giáº£m count
 * 5. Counter.Reset vá» 0
 * 6. Táº¥t cáº£ children tá»± Ä‘á»™ng access state qua Context
 *
 * ğŸ’¡ Gá»£i Ã½: Táº¡o Context, custom hook, vÃ  attach children vÃ o parent
 */

// âŒ CÃCH SAI - Props drilling
function CounterWrong() {
  const [count, setCount] = useState(0);

  return (
    <div>
      {/* Pháº£i pass props cho má»—i child */}
      <CounterDisplay count={count} />
      <CounterIncrement setCount={setCount} />
      <CounterDecrement setCount={setCount} />
      <CounterReset setCount={setCount} />
    </div>
  );
}
// Váº¥n Ä‘á»:
// - Pháº£i pass props manual
// - KhÃ´ng flexible (pháº£i wrap trong div)
// - KhÃ³ customize UI

// âœ… CÃCH ÄÃšNG - Compound Components
// Cho phÃ©p:
// <Counter>
//   <Counter.Display />
//   <div className="buttons">
//     <Counter.Increment />
//     <Counter.Decrement />
//   </div>
//   <Counter.Reset />
// </Counter>

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
// TODO: Implement Counter vá»›i Compound Components pattern
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Counter Component - Compound Components Pattern
 *
 * @example
 * <Counter>
 *   <Counter.Display />
 *   <Counter.Increment />
 *   <Counter.Decrement />
 *   <Counter.Reset />
 * </Counter>
 */

import { createContext, useContext, useState } from 'react';

// 1. Táº¡o Context
const CounterContext = createContext(null);

// 2. Custom hook Ä‘á»ƒ access context
const useCounterContext = () => {
  const context = useContext(CounterContext);
  if (!context) {
    throw new Error('Counter.* components must be used within <Counter>');
  }
  return context;
};

// 3. Parent Component
const Counter = ({ children, initialValue = 0 }) => {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount((prev) => prev + 1);
  const decrement = () => setCount((prev) => prev - 1);
  const reset = () => setCount(initialValue);

  return (
    <CounterContext.Provider value={{ count, increment, decrement, reset }}>
      <div className='counter'>{children}</div>
    </CounterContext.Provider>
  );
};

// 4. Child Components
Counter.Display = function CounterDisplay() {
  const { count } = useCounterContext();
  return <div className='count'>Count: {count}</div>;
};

Counter.Increment = function CounterIncrement({ children = '+1' }) {
  const { increment } = useCounterContext();
  return <button onClick={increment}>{children}</button>;
};

Counter.Decrement = function CounterDecrement({ children = '-1' }) {
  const { decrement } = useCounterContext();
  return <button onClick={decrement}>{children}</button>;
};

Counter.Reset = function CounterReset({ children = 'Reset' }) {
  const { reset } = useCounterContext();
  return <button onClick={reset}>{children}</button>;
};

// Test
function App() {
  return (
    <div>
      {/* Flexible composition */}
      <Counter initialValue={10}>
        <Counter.Display />
        <div style={{ display: 'flex', gap: '8px' }}>
          <Counter.Increment>â•</Counter.Increment>
          <Counter.Decrement>â–</Counter.Decrement>
          <Counter.Reset>ğŸ”„</Counter.Reset>
        </div>
      </Counter>

      {/* KhÃ¡c layout */}
      <Counter>
        <div className='card'>
          <h3>My Counter</h3>
          <Counter.Display />
          <Counter.Increment />
          <Counter.Decrement />
        </div>
        <Counter.Reset />
      </Counter>
    </div>
  );
}

/*
Káº¿t quáº£:
âœ… KhÃ´ng cáº§n props drilling
âœ… Flexible UI composition
âœ… State tá»± Ä‘á»™ng sync
âœ… Dá»… customize
*/
```

</details>

---

### â­â­ BÃ i 2: Select Dropdown (25 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Nháº­n biáº¿t khi nÃ o dÃ¹ng Compound Components

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: So sÃ¡nh 2 approaches vÃ  chá»n approach phÃ¹ há»£p
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: XÃ¢y dá»±ng Select component cho form
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 *
 * Approach A: Props-based API
 * Pros:
 * - ÄÆ¡n giáº£n khi dÃ¹ng (chá»‰ pass options array)
 * - Ãt code hÆ¡n trong component sá»­ dá»¥ng
 * - Dá»… validate (vÃ¬ data structure cá»‘ Ä‘á»‹nh)
 *
 * Cons:
 * - KhÃ³ customize UI tá»«ng option
 * - KhÃ´ng linh hoáº¡t khi options phá»©c táº¡p
 * - Pháº£i dÃ¹ng render props náº¿u cáº§n custom
 *
 * Approach B: Compound Components
 * Pros:
 * - Ráº¥t flexible (customize UI dá»… dÃ ng)
 * - Dá»… thÃªm features (icons, badges, etc.)
 * - API rÃµ rÃ ng nhÆ° HTML
 *
 * Cons:
 * - Nhiá»u code hÆ¡n khi dÃ¹ng
 * - Dá»… sai cáº¥u trÃºc (quÃªn Ä‘Ã³ng tag)
 * - KhÃ³ validate structure
 *
 * ğŸ’­ Báº N CHá»ŒN GÃŒ VÃ€ Táº I SAO?
 * Requirement:
 * - Select vá»›i icon cho má»—i option
 * - Custom styling cho selected option
 * - Search filtering (bonus)
 *
 * HÃ£y implement approach báº¡n chá»n vÃ  document lÃ½ do.
 */

// Starter code
// TODO: Implement Select component
```

<details>
<summary>ğŸ’¡ Solution - Approach B (Compound Components)</summary>

```jsx
/**
 * Select Component - Compound Components Pattern
 *
 * LÃ½ do chá»n Compound Components:
 * - Cáº§n customize UI (icons, styling) â†’ Compound Components tá»‘t hÆ¡n
 * - Flexibility > Simplicity trong case nÃ y
 * - Options khÃ´ng quÃ¡ nhiá»u â†’ trade-off acceptable
 *
 * @example
 * <Select value={value} onChange={setValue}>
 *   <Select.Trigger>{value || 'Select...'}</Select.Trigger>
 *   <Select.Options>
 *     <Select.Option value="react">âš›ï¸ React</Select.Option>
 *     <Select.Option value="vue">ğŸ’š Vue</Select.Option>
 *   </Select.Options>
 * </Select>
 */

import { createContext, useContext, useState, useRef, useEffect } from 'react';

const SelectContext = createContext(null);

const useSelectContext = () => {
  const context = useContext(SelectContext);
  if (!context) {
    throw new Error('Select.* components must be used within <Select>');
  }
  return context;
};

const Select = ({ children, value, onChange }) => {
  const [isOpen, setIsOpen] = useState(false);
  const selectRef = useRef(null);

  // Close khi click outside
  useEffect(() => {
    const handleClickOutside = (e) => {
      if (selectRef.current && !selectRef.current.contains(e.target)) {
        setIsOpen(false);
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      return () =>
        document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [isOpen]);

  const handleSelect = (optionValue) => {
    onChange(optionValue);
    setIsOpen(false);
  };

  return (
    <SelectContext.Provider
      value={{
        value,
        isOpen,
        setIsOpen,
        handleSelect,
      }}
    >
      <div
        ref={selectRef}
        className='select'
      >
        {children}
      </div>
    </SelectContext.Provider>
  );
};

Select.Trigger = function SelectTrigger({ children }) {
  const { isOpen, setIsOpen } = useSelectContext();

  return (
    <button
      onClick={() => setIsOpen((prev) => !prev)}
      aria-expanded={isOpen}
      className='select-trigger'
    >
      {children}
      <span>{isOpen ? 'â–²' : 'â–¼'}</span>
    </button>
  );
};

Select.Options = function SelectOptions({ children }) {
  const { isOpen } = useSelectContext();

  if (!isOpen) return null;

  return <div className='select-options'>{children}</div>;
};

Select.Option = function SelectOption({ value, children }) {
  const { value: selectedValue, handleSelect } = useSelectContext();
  const isSelected = value === selectedValue;

  return (
    <div
      onClick={() => handleSelect(value)}
      className={`select-option ${isSelected ? 'selected' : ''}`}
      role='option'
      aria-selected={isSelected}
      style={{
        backgroundColor: isSelected ? '#e3f2fd' : 'transparent',
        fontWeight: isSelected ? 'bold' : 'normal',
        cursor: 'pointer',
        padding: '8px 12px',
      }}
    >
      {children}
      {isSelected && ' âœ“'}
    </div>
  );
};

// Test
function App() {
  const [framework, setFramework] = useState('react');

  return (
    <div>
      <h3>Chá»n Framework:</h3>

      <Select
        value={framework}
        onChange={setFramework}
      >
        <Select.Trigger>
          {framework ? (
            <span>
              {framework === 'react' && 'âš›ï¸ React'}
              {framework === 'vue' && 'ğŸ’š Vue'}
              {framework === 'angular' && 'ğŸ…°ï¸ Angular'}
            </span>
          ) : (
            'Chá»n framework...'
          )}
        </Select.Trigger>

        <Select.Options>
          <Select.Option value='react'>
            âš›ï¸ React - A JavaScript library
          </Select.Option>
          <Select.Option value='vue'>
            ğŸ’š Vue - The Progressive Framework
          </Select.Option>
          <Select.Option value='angular'>
            ğŸ…°ï¸ Angular - Platform for building apps
          </Select.Option>
        </Select.Options>
      </Select>

      <p>Selected: {framework}</p>
    </div>
  );
}

/*
Káº¿t quáº£:
âœ… Flexible UI - dá»… thÃªm icons, text
âœ… Custom styling cho selected option
âœ… Click outside to close
âœ… Accessible (aria attributes)

Trade-offs Accepted:
âŒ Nhiá»u code hÆ¡n props-based
âœ… NhÆ°ng Ä‘á»•i láº¡i Ä‘Æ°á»£c flexibility cao
*/
```

</details>

---

### â­â­â­ BÃ i 3: Modal Dialog System (40 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Giáº£i quyáº¿t real-world scenario

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: XÃ¢y dá»±ng Modal system production-ready
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  user, tÃ´i muá»‘n modal hiá»ƒn thá»‹ vá»›i header, body, footer
 * tÃ¹y chá»‰nh Ä‘á»ƒ cÃ³ thá»ƒ confirm actions quan trá»ng"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Modal.Trigger má»Ÿ modal
 * - [ ] Modal.Header vá»›i title vÃ  close button
 * - [ ] Modal.Body vá»›i content
 * - [ ] Modal.Footer vá»›i action buttons
 * - [ ] Close khi click outside overlay
 * - [ ] Close khi nháº¥n ESC
 * - [ ] Prevent body scroll khi modal má»Ÿ
 * - [ ] Focus trap (focus khÃ´ng ra ngoÃ i modal)
 *
 * ğŸ¨ Technical Constraints:
 * - Sá»­ dá»¥ng Compound Components pattern
 * - Render modal to document.body (Portal - dÃ¹ng ReactDOM.createPortal)
 * - Accessibility: ARIA attributes, keyboard navigation
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Multiple modals (nested)
 * - Close animation
 * - Prevent scroll body
 * - Focus management
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] Context setup
 * - [ ] Portal rendering
 * - [ ] ESC key handler
 * - [ ] Click outside handler
 * - [ ] Focus trap
 * - [ ] Body scroll lock
 */

// Starter code
import { createPortal } from 'react-dom';

// TODO: Implement Modal system
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Modal Component - Production-ready Compound Components
 *
 * Features:
 * - Portal rendering to body
 * - ESC to close
 * - Click outside to close
 * - Body scroll lock
 * - Focus trap
 * - Accessible
 *
 * @example
 * <Modal>
 *   <Modal.Trigger>Open Modal</Modal.Trigger>
 *   <Modal.Content>
 *     <Modal.Header>Title</Modal.Header>
 *     <Modal.Body>Content</Modal.Body>
 *     <Modal.Footer>
 *       <Modal.Close>Cancel</Modal.Close>
 *       <button>Confirm</button>
 *     </Modal.Footer>
 *   </Modal.Content>
 * </Modal>
 */

import { createContext, useContext, useState, useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';

const ModalContext = createContext(null);

const useModalContext = () => {
  const context = useContext(ModalContext);
  if (!context) {
    throw new Error('Modal.* components must be used within <Modal>');
  }
  return context;
};

const Modal = ({ children }) => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <ModalContext.Provider value={{ isOpen, setIsOpen }}>
      {children}
    </ModalContext.Provider>
  );
};

Modal.Trigger = function ModalTrigger({ children }) {
  const { setIsOpen } = useModalContext();

  return <button onClick={() => setIsOpen(true)}>{children}</button>;
};

Modal.Content = function ModalContent({ children }) {
  const { isOpen, setIsOpen } = useModalContext();
  const modalRef = useRef(null);
  const previousActiveElement = useRef(null);

  // ESC key to close
  useEffect(() => {
    if (!isOpen) return;

    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        setIsOpen(false);
      }
    };

    document.addEventListener('keydown', handleEsc);
    return () => document.removeEventListener('keydown', handleEsc);
  }, [isOpen, setIsOpen]);

  // Lock body scroll
  useEffect(() => {
    if (!isOpen) return;

    const originalOverflow = document.body.style.overflow;
    document.body.style.overflow = 'hidden';

    return () => {
      document.body.style.overflow = originalOverflow;
    };
  }, [isOpen]);

  // Focus management
  useEffect(() => {
    if (!isOpen) return;

    // LÆ°u element Ä‘ang focus
    previousActiveElement.current = document.activeElement;

    // Focus vÃ o modal
    const focusableElements = modalRef.current?.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
    );

    if (focusableElements?.length) {
      focusableElements[0].focus();
    }

    // Restore focus khi Ä‘Ã³ng
    return () => {
      previousActiveElement.current?.focus();
    };
  }, [isOpen]);

  // Click outside to close
  const handleOverlayClick = (e) => {
    if (e.target === e.currentTarget) {
      setIsOpen(false);
    }
  };

  if (!isOpen) return null;

  // Render to body using Portal
  return createPortal(
    <div
      className='modal-overlay'
      onClick={handleOverlayClick}
      style={{
        position: 'fixed',
        inset: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
      }}
    >
      <div
        ref={modalRef}
        className='modal-content'
        role='dialog'
        aria-modal='true'
        style={{
          backgroundColor: 'white',
          borderRadius: '8px',
          padding: '24px',
          maxWidth: '500px',
          width: '90%',
          maxHeight: '80vh',
          overflow: 'auto',
        }}
      >
        {children}
      </div>
    </div>,
    document.body,
  );
};

Modal.Header = function ModalHeader({ children }) {
  const { setIsOpen } = useModalContext();

  return (
    <div
      className='modal-header'
      style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '16px',
        paddingBottom: '16px',
        borderBottom: '1px solid #e0e0e0',
      }}
    >
      <h2 style={{ margin: 0 }}>{children}</h2>
      <button
        onClick={() => setIsOpen(false)}
        aria-label='Close modal'
        style={{
          background: 'none',
          border: 'none',
          fontSize: '24px',
          cursor: 'pointer',
        }}
      >
        Ã—
      </button>
    </div>
  );
};

Modal.Body = function ModalBody({ children }) {
  return (
    <div
      className='modal-body'
      style={{ marginBottom: '16px' }}
    >
      {children}
    </div>
  );
};

Modal.Footer = function ModalFooter({ children }) {
  return (
    <div
      className='modal-footer'
      style={{
        display: 'flex',
        gap: '8px',
        justifyContent: 'flex-end',
        paddingTop: '16px',
        borderTop: '1px solid #e0e0e0',
      }}
    >
      {children}
    </div>
  );
};

Modal.Close = function ModalClose({ children }) {
  const { setIsOpen } = useModalContext();

  return (
    <button onClick={() => setIsOpen(false)}>{children || 'Close'}</button>
  );
};

// Test
function App() {
  const [confirmed, setConfirmed] = useState(false);

  return (
    <div style={{ padding: '20px' }}>
      <h1>Modal Demo</h1>

      <Modal>
        <Modal.Trigger>Delete Account</Modal.Trigger>

        <Modal.Content>
          <Modal.Header>Confirm Deletion</Modal.Header>

          <Modal.Body>
            <p>Are you sure you want to delete your account?</p>
            <p style={{ color: 'red' }}>âš ï¸ This action cannot be undone!</p>
          </Modal.Body>

          <Modal.Footer>
            <Modal.Close>Cancel</Modal.Close>
            <button
              onClick={() => {
                setConfirmed(true);
                // Close modal logic handled by Modal.Close
              }}
              style={{
                backgroundColor: 'red',
                color: 'white',
                padding: '8px 16px',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
              }}
            >
              Delete
            </button>
          </Modal.Footer>
        </Modal.Content>
      </Modal>

      {/* Nested modal example */}
      <Modal>
        <Modal.Trigger>Open Settings</Modal.Trigger>
        <Modal.Content>
          <Modal.Header>Settings</Modal.Header>
          <Modal.Body>
            <p>Settings content...</p>

            {/* Nested modal */}
            <Modal>
              <Modal.Trigger>Advanced Settings</Modal.Trigger>
              <Modal.Content>
                <Modal.Header>Advanced</Modal.Header>
                <Modal.Body>Advanced options...</Modal.Body>
                <Modal.Footer>
                  <Modal.Close>Close</Modal.Close>
                </Modal.Footer>
              </Modal.Content>
            </Modal>
          </Modal.Body>
          <Modal.Footer>
            <Modal.Close>Close</Modal.Close>
          </Modal.Footer>
        </Modal.Content>
      </Modal>

      {confirmed && <p>Account deleted!</p>}
    </div>
  );
}

/*
Káº¿t quáº£:
âœ… Portal rendering to body
âœ… ESC key closes modal
âœ… Click outside closes modal
âœ… Body scroll locked when open
âœ… Focus trapped in modal
âœ… Accessible (ARIA, keyboard)
âœ… Nested modals work
âœ… Flexible composition
*/
```

</details>

---

### â­â­â­â­ BÃ i 4: Form Builder vá»›i Validation (60 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Architectural decision making

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Thiáº¿t káº¿ Form component API
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Nhiá»‡m vá»¥:
 * 1. So sÃ¡nh Ã­t nháº¥t 3 approaches:
 *    - A) Props-based: <Form fields={[...]} />
 *    - B) Compound Components: <Form><Form.Field /></Form>
 *    - C) Hybrid: Káº¿t há»£p cáº£ hai
 *
 * 2. Document pros/cons má»—i approach
 *
 * 3. Chá»n approach phÃ¹ há»£p nháº¥t
 *
 * 4. Viáº¿t ADR (Architecture Decision Record)
 *
 * ADR Template:
 * - Context: Form cáº§n support dynamic fields, validation, submit
 * - Decision: [Approach Ä‘Ã£ chá»n]
 * - Rationale: [Táº¡i sao chá»n approach nÃ y]
 * - Consequences: [Trade-offs accepted]
 * - Alternatives Considered: [CÃ¡c options khÃ¡c]
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 *
 * Requirements:
 * - Form.Field vá»›i label, input, error
 * - Form-level validation
 * - Field-level validation
 * - Submit handling
 * - Reset functionality
 *
 * ğŸ§ª PHASE 3: Testing (10 phÃºt)
 * - [ ] Test validation works
 * - [ ] Test submit vá»›i valid/invalid data
 * - [ ] Test reset clears form
 */

// TODO: Write ADR then implement
```

<details>
<summary>ğŸ’¡ Solution - ADR + Implementation</summary>

```jsx
/**
 * ARCHITECTURE DECISION RECORD (ADR)
 *
 * Context:
 * Cáº§n xÃ¢y dá»±ng Form component há»— trá»£:
 * - Dynamic fields (add/remove)
 * - Field-level vÃ  form-level validation
 * - Flexible UI customization
 * - Type-safe validation rules
 *
 * Decision: Compound Components (Approach B)
 *
 * Rationale:
 * 1. Flexibility: Dá»… customize UI cho tá»«ng field
 * 2. Composability: Dá»… thÃªm custom fields
 * 3. Clear API: Readable nhÆ° HTML forms
 * 4. Validation: CÃ³ thá»ƒ attach validation per field
 * 5. Extensibility: Dá»… thÃªm Form.Checkbox, Form.Select, etc.
 *
 * Consequences:
 * âœ… Pros:
 * - Ráº¥t flexible vÃ  extensible
 * - API rÃµ rÃ ng, dá»… maintain
 * - Má»—i field cÃ³ validation riÃªng
 * - Dá»… thÃªm field types má»›i
 *
 * âŒ Cons:
 * - Nhiá»u code hÆ¡n khi sá»­ dá»¥ng
 * - Dá»… sai structure (quÃªn closing tags)
 * - Performance: nhiá»u components render
 *
 * Alternatives Considered:
 * - Props-based: ÄÆ¡n giáº£n nhÆ°ng khÃ´ng flexible
 * - Hybrid: Phá»©c táº¡p, khÃ´ng rÃµ rÃ ng
 *
 * Implementation:
 */

import { createContext, useContext, useState, useCallback } from 'react';

const FormContext = createContext(null);

const useFormContext = () => {
  const context = useContext(FormContext);
  if (!context) {
    throw new Error('Form.* components must be used within <Form>');
  }
  return context;
};

const Form = ({ children, onSubmit, initialValues = {} }) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const setValue = useCallback((name, value) => {
    setValues((prev) => ({ ...prev, [name]: value }));
  }, []);

  const setError = useCallback((name, error) => {
    setErrors((prev) => ({ ...prev, [name]: error }));
  }, []);

  const setFieldTouched = useCallback((name) => {
    setTouched((prev) => ({ ...prev, [name]: true }));
  }, []);

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  }, [initialValues]);

  const handleSubmit = (e) => {
    e.preventDefault();

    // Mark all fields as touched
    const allFieldsTouched = Object.keys(values).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allFieldsTouched);

    // Check if any errors
    const hasErrors = Object.values(errors).some((error) => error);

    if (!hasErrors) {
      onSubmit?.(values);
    }
  };

  return (
    <FormContext.Provider
      value={{
        values,
        errors,
        touched,
        setValue,
        setError,
        setFieldTouched,
        reset,
      }}
    >
      <form onSubmit={handleSubmit}>{children}</form>
    </FormContext.Provider>
  );
};

Form.Field = function FormField({
  name,
  label,
  type = 'text',
  validate,
  required = false,
}) {
  const { values, errors, touched, setValue, setError, setFieldTouched } =
    useFormContext();

  const value = values[name] || '';
  const error = errors[name];
  const isTouched = touched[name];

  const handleChange = (e) => {
    const newValue = e.target.value;
    setValue(name, newValue);

    // Validate
    let validationError = '';

    if (required && !newValue) {
      validationError = `${label} is required`;
    } else if (validate) {
      validationError = validate(newValue) || '';
    }

    setError(name, validationError);
  };

  const handleBlur = () => {
    setFieldTouched(name);
  };

  const showError = isTouched && error;

  return (
    <div
      className='form-field'
      style={{ marginBottom: '16px' }}
    >
      <label
        htmlFor={name}
        style={{ display: 'block', marginBottom: '4px' }}
      >
        {label}
        {required && <span style={{ color: 'red' }}> *</span>}
      </label>

      <input
        id={name}
        name={name}
        type={type}
        value={value}
        onChange={handleChange}
        onBlur={handleBlur}
        aria-invalid={!!showError}
        aria-describedby={showError ? `${name}-error` : undefined}
        style={{
          width: '100%',
          padding: '8px',
          border: showError ? '2px solid red' : '1px solid #ccc',
          borderRadius: '4px',
        }}
      />

      {showError && (
        <div
          id={`${name}-error`}
          role='alert'
          style={{ color: 'red', fontSize: '14px', marginTop: '4px' }}
        >
          {error}
        </div>
      )}
    </div>
  );
};

Form.Submit = function FormSubmit({ children = 'Submit' }) {
  return (
    <button
      type='submit'
      style={{
        padding: '10px 20px',
        backgroundColor: '#007bff',
        color: 'white',
        border: 'none',
        borderRadius: '4px',
        cursor: 'pointer',
      }}
    >
      {children}
    </button>
  );
};

Form.Reset = function FormReset({ children = 'Reset' }) {
  const { reset } = useFormContext();

  return (
    <button
      type='button'
      onClick={reset}
      style={{
        padding: '10px 20px',
        backgroundColor: '#6c757d',
        color: 'white',
        border: 'none',
        borderRadius: '4px',
        cursor: 'pointer',
        marginLeft: '8px',
      }}
    >
      {children}
    </button>
  );
};

// Custom validators
const validators = {
  email: (value) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return !emailRegex.test(value) ? 'Invalid email address' : '';
  },

  minLength: (min) => (value) => {
    return value.length < min ? `Must be at least ${min} characters` : '';
  },

  match: (fieldName, fieldLabel) => (value, formValues) => {
    return value !== formValues[fieldName] ? `Must match ${fieldLabel}` : '';
  },
};

// Test
function App() {
  const handleSubmit = (values) => {
    console.log('Form submitted:', values);
    alert(`Welcome ${values.name}! Check console for data.`);
  };

  return (
    <div style={{ maxWidth: '400px', padding: '20px' }}>
      <h2>Registration Form</h2>

      <Form
        onSubmit={handleSubmit}
        initialValues={{ country: 'VN' }}
      >
        <Form.Field
          name='name'
          label='Full Name'
          required
        />

        <Form.Field
          name='email'
          label='Email'
          type='email'
          required
          validate={validators.email}
        />

        <Form.Field
          name='password'
          label='Password'
          type='password'
          required
          validate={validators.minLength(8)}
        />

        <Form.Field
          name='country'
          label='Country'
        />

        <div style={{ display: 'flex', gap: '8px' }}>
          <Form.Submit>Register</Form.Submit>
          <Form.Reset />
        </div>
      </Form>
    </div>
  );
}

/*
Manual Testing Checklist:
âœ… Required validation works
âœ… Email validation works
âœ… Min length validation works
âœ… Error shows after blur
âœ… Submit works with valid data
âœ… Submit blocked with invalid data
âœ… Reset clears all fields
âœ… Initial values work
âœ… Accessible (ARIA attributes)

Performance Notes:
- setValue memoized â†’ no unnecessary re-renders
- Each field independent â†’ only re-renders when own value changes
- Context split possible if needed (StateContext + DispatchContext)
*/
```

</details>

---

### â­â­â­â­â­ BÃ i 5: Menu System vá»›i Keyboard Navigation (90 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Production-ready component

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: XÃ¢y dá»±ng Menu system Ä‘áº§y Ä‘á»§
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * - Multi-level menus (nested submenus)
 * - Keyboard navigation (Arrow keys, Enter, ESC)
 * - Click outside to close
 * - Hover to open submenu
 * - Icon support
 * - Disabled items
 * - Dividers
 * - Accessibility compliant
 *
 * ğŸ—ï¸ Technical Design Doc:
 * 1. Component Architecture:
 *    - Menu (root context provider)
 *    - Menu.Trigger (open menu button)
 *    - Menu.Content (dropdown container)
 *    - Menu.Item (clickable item)
 *    - Menu.Submenu (nested menu)
 *    - Menu.Divider (separator)
 *
 * 2. State Management:
 *    - isOpen (boolean)
 *    - activeIndex (number, for keyboard nav)
 *    - submenu states (Map or object)
 *
 * 3. Keyboard Navigation:
 *    - ArrowDown: Next item
 *    - ArrowUp: Previous item
 *    - ArrowRight: Open submenu
 *    - ArrowLeft: Close submenu
 *    - Enter: Select item
 *    - ESC: Close menu
 *
 * 4. Performance:
 *    - Memoize callbacks
 *    - Avoid unnecessary re-renders
 *
 * 5. Accessibility:
 *    - role="menu", role="menuitem"
 *    - aria-haspopup, aria-expanded
 *    - Focus management
 *
 * âœ… Production Checklist:
 * - [ ] Keyboard navigation works
 * - [ ] Click outside closes
 * - [ ] Hover opens submenu
 * - [ ] Disabled items
 * - [ ] Focus management
 * - [ ] ARIA attributes
 * - [ ] Portal rendering
 * - [ ] Position calculation (prevent overflow)
 *
 * ğŸ“ Documentation:
 * - Component API
 * - Usage examples
 * - Accessibility notes
 */

// TODO: Implement Menu system
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Menu Component System - Production Ready
 *
 * Features:
 * âœ… Multi-level nested menus
 * âœ… Full keyboard navigation
 * âœ… Click outside to close
 * âœ… Hover behavior
 * âœ… Disabled items
 * âœ… Dividers
 * âœ… Icons support
 * âœ… Accessible (WCAG 2.1)
 * âœ… Portal rendering
 *
 * @example
 * <Menu>
 *   <Menu.Trigger>File</Menu.Trigger>
 *   <Menu.Content>
 *     <Menu.Item onSelect={() => {}}>New</Menu.Item>
 *     <Menu.Submenu label="Open Recent">
 *       <Menu.Item>File 1</Menu.Item>
 *     </Menu.Submenu>
 *     <Menu.Divider />
 *     <Menu.Item disabled>Save</Menu.Item>
 *   </Menu.Content>
 * </Menu>
 */

import {
  createContext,
  useContext,
  useState,
  useRef,
  useEffect,
  useCallback,
} from 'react';
import { createPortal } from 'react-dom';

// Context
const MenuContext = createContext(null);

const useMenuContext = () => {
  const context = useContext(MenuContext);
  if (!context) {
    throw new Error('Menu.* components must be used within <Menu>');
  }
  return context;
};

// Root Menu Component
const Menu = ({ children }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [activeIndex, setActiveIndex] = useState(-1);
  const menuRef = useRef(null);
  const itemsRef = useRef([]);

  // Click outside to close
  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (e) => {
      if (menuRef.current && !menuRef.current.contains(e.target)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isOpen]);

  // ESC to close
  useEffect(() => {
    if (!isOpen) return;

    const handleEsc = (e) => {
      if (e.key === 'Escape') {
        setIsOpen(false);
      }
    };

    document.addEventListener('keydown', handleEsc);
    return () => document.removeEventListener('keydown', handleEsc);
  }, [isOpen]);

  const registerItem = useCallback((ref) => {
    if (ref && !itemsRef.current.includes(ref)) {
      itemsRef.current.push(ref);
    }
  }, []);

  const focusItem = useCallback((index) => {
    const items = itemsRef.current;
    if (items[index]) {
      items[index].focus();
      setActiveIndex(index);
    }
  }, []);

  return (
    <MenuContext.Provider
      value={{
        isOpen,
        setIsOpen,
        activeIndex,
        setActiveIndex,
        menuRef,
        itemsRef,
        registerItem,
        focusItem,
      }}
    >
      <div
        ref={menuRef}
        style={{ position: 'relative', display: 'inline-block' }}
      >
        {children}
      </div>
    </MenuContext.Provider>
  );
};

// Trigger
Menu.Trigger = function MenuTrigger({ children }) {
  const { isOpen, setIsOpen } = useMenuContext();

  return (
    <button
      onClick={() => setIsOpen(!isOpen)}
      aria-haspopup='true'
      aria-expanded={isOpen}
      style={{
        padding: '8px 16px',
        cursor: 'pointer',
        border: '1px solid #ccc',
        borderRadius: '4px',
        background: 'white',
      }}
    >
      {children}
    </button>
  );
};

// Content (Dropdown)
Menu.Content = function MenuContent({ children }) {
  const { isOpen, itemsRef, focusItem } = useMenuContext();
  const contentRef = useRef(null);

  // Keyboard navigation
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e) => {
      const items = itemsRef.current.filter((item) => !item.disabled);
      const currentIndex = items.indexOf(document.activeElement);

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          const nextIndex = (currentIndex + 1) % items.length;
          items[nextIndex]?.focus();
          break;

        case 'ArrowUp':
          e.preventDefault();
          const prevIndex = (currentIndex - 1 + items.length) % items.length;
          items[prevIndex]?.focus();
          break;

        case 'Home':
          e.preventDefault();
          items[0]?.focus();
          break;

        case 'End':
          e.preventDefault();
          items[items.length - 1]?.focus();
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, itemsRef]);

  // Focus first item when opens
  useEffect(() => {
    if (isOpen && itemsRef.current[0]) {
      itemsRef.current[0].focus();
    }
  }, [isOpen, itemsRef]);

  if (!isOpen) return null;

  return createPortal(
    <div
      ref={contentRef}
      role='menu'
      style={{
        position: 'absolute',
        top: '100%',
        left: 0,
        marginTop: '4px',
        backgroundColor: 'white',
        border: '1px solid #ccc',
        borderRadius: '4px',
        boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
        minWidth: '200px',
        padding: '4px 0',
        zIndex: 1000,
      }}
    >
      {children}
    </div>,
    document.body,
  );
};

// Menu Item
Menu.Item = function MenuItem({ children, onSelect, disabled = false, icon }) {
  const { setIsOpen, registerItem } = useMenuContext();
  const ref = useRef(null);

  useEffect(() => {
    registerItem(ref.current);
  }, [registerItem]);

  const handleClick = () => {
    if (disabled) return;
    onSelect?.();
    setIsOpen(false);
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      handleClick();
    }
  };

  return (
    <div
      ref={ref}
      role='menuitem'
      tabIndex={disabled ? -1 : 0}
      onClick={handleClick}
      onKeyDown={handleKeyDown}
      aria-disabled={disabled}
      style={{
        padding: '8px 16px',
        cursor: disabled ? 'not-allowed' : 'pointer',
        opacity: disabled ? 0.5 : 1,
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
        outline: 'none',
        backgroundColor: 'white',
        transition: 'background-color 0.2s',
      }}
      onMouseEnter={(e) => {
        if (!disabled) {
          e.currentTarget.style.backgroundColor = '#f0f0f0';
        }
      }}
      onMouseLeave={(e) => {
        e.currentTarget.style.backgroundColor = 'white';
      }}
    >
      {icon && <span>{icon}</span>}
      {children}
    </div>
  );
};

// Submenu
Menu.Submenu = function MenuSubmenu({ label, children, icon }) {
  const [isOpen, setIsOpen] = useState(false);
  const { registerItem } = useMenuContext();
  const ref = useRef(null);

  useEffect(() => {
    registerItem(ref.current);
  }, [registerItem]);

  const handleMouseEnter = () => setIsOpen(true);
  const handleMouseLeave = () => setIsOpen(false);

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      setIsOpen(true);
    } else if (e.key === 'ArrowLeft') {
      e.preventDefault();
      setIsOpen(false);
    }
  };

  return (
    <div
      ref={ref}
      role='menuitem'
      aria-haspopup='true'
      aria-expanded={isOpen}
      tabIndex={0}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      onKeyDown={handleKeyDown}
      style={{
        padding: '8px 16px',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        gap: '8px',
        position: 'relative',
        outline: 'none',
      }}
      onFocus={(e) => {
        e.currentTarget.style.backgroundColor = '#f0f0f0';
      }}
      onBlur={(e) => {
        e.currentTarget.style.backgroundColor = 'white';
      }}
    >
      <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
        {icon && <span>{icon}</span>}
        {label}
      </div>
      <span>â–¶</span>

      {isOpen && (
        <div
          role='menu'
          style={{
            position: 'absolute',
            left: '100%',
            top: 0,
            backgroundColor: 'white',
            border: '1px solid #ccc',
            borderRadius: '4px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
            minWidth: '200px',
            padding: '4px 0',
            zIndex: 1001,
          }}
        >
          {children}
        </div>
      )}
    </div>
  );
};

// Divider
Menu.Divider = function MenuDivider() {
  return (
    <div
      role='separator'
      style={{
        height: '1px',
        backgroundColor: '#e0e0e0',
        margin: '4px 0',
      }}
    />
  );
};

// Test / Demo
function App() {
  const [lastAction, setLastAction] = useState('');

  return (
    <div style={{ padding: '40px' }}>
      <h2>Menu System Demo</h2>
      <p>Last action: {lastAction || 'None'}</p>

      <Menu>
        <Menu.Trigger>File</Menu.Trigger>
        <Menu.Content>
          <Menu.Item
            icon='ğŸ“„'
            onSelect={() => setLastAction('New file created')}
          >
            New File
          </Menu.Item>

          <Menu.Item
            icon='ğŸ“‚'
            onSelect={() => setLastAction('Open file')}
          >
            Open
          </Menu.Item>

          <Menu.Submenu
            label='Open Recent'
            icon='ğŸ•'
          >
            <Menu.Item onSelect={() => setLastAction('Opened: Project A')}>
              Project A
            </Menu.Item>
            <Menu.Item onSelect={() => setLastAction('Opened: Project B')}>
              Project B
            </Menu.Item>
            <Menu.Submenu label='More'>
              <Menu.Item onSelect={() => setLastAction('Opened: Project C')}>
                Project C
              </Menu.Item>
            </Menu.Submenu>
          </Menu.Submenu>

          <Menu.Divider />

          <Menu.Item
            icon='ğŸ’¾'
            onSelect={() => setLastAction('File saved')}
          >
            Save
          </Menu.Item>

          <Menu.Item
            icon='ğŸ’¾'
            disabled
            onSelect={() => setLastAction('Save As')}
          >
            Save As... (disabled)
          </Menu.Item>

          <Menu.Divider />

          <Menu.Item
            icon='ğŸšª'
            onSelect={() => setLastAction('Exited')}
          >
            Exit
          </Menu.Item>
        </Menu.Content>
      </Menu>

      <div
        style={{
          marginTop: '20px',
          padding: '16px',
          backgroundColor: '#f5f5f5',
          borderRadius: '4px',
        }}
      >
        <h3>Keyboard Shortcuts:</h3>
        <ul style={{ margin: '8px 0', paddingLeft: '20px' }}>
          <li>
            <kbd>â†“</kbd> - Next item
          </li>
          <li>
            <kbd>â†‘</kbd> - Previous item
          </li>
          <li>
            <kbd>â†’</kbd> - Open submenu
          </li>
          <li>
            <kbd>â†</kbd> - Close submenu
          </li>
          <li>
            <kbd>Enter</kbd> - Select item
          </li>
          <li>
            <kbd>ESC</kbd> - Close menu
          </li>
          <li>
            <kbd>Home</kbd> - First item
          </li>
          <li>
            <kbd>End</kbd> - Last item
          </li>
        </ul>
      </div>
    </div>
  );
}

/*
Production Checklist:
âœ… Keyboard navigation (all arrow keys, Enter, ESC, Home, End)
âœ… Click outside closes menu
âœ… Hover opens submenu
âœ… Disabled items cannot be selected
âœ… Focus management works
âœ… ARIA attributes complete
âœ… Portal rendering to body
âœ… Nested submenus work
âœ… Visual feedback (hover, focus)
âœ… Icons support
âœ… Dividers

Performance:
âœ… useCallback for handlers
âœ… Memoized item registration
âœ… Efficient keyboard navigation

Accessibility:
âœ… role="menu", role="menuitem"
âœ… aria-haspopup, aria-expanded
âœ… aria-disabled
âœ… Keyboard navigation
âœ… Focus management
âœ… Screen reader friendly

Trade-offs:
âŒ More complex than simple dropdown
âœ… But provides professional UX
âŒ Requires careful state management
âœ… But isolated in context
*/
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh Trade-offs

| Aspect             | Props-based API | Compound Components | Render Props | HOCs     |
| ------------------ | --------------- | ------------------- | ------------ | -------- |
| **Flexibility**    | â­â­            | â­â­â­â­â­          | â­â­â­â­     | â­â­â­   |
| **Simplicity**     | â­â­â­â­â­      | â­â­â­              | â­â­         | â­â­     |
| **Type Safety**    | â­â­â­â­â­      | â­â­â­â­            | â­â­â­       | â­â­     |
| **Performance**    | â­â­â­â­        | â­â­â­              | â­â­â­       | â­â­â­â­ |
| **Readability**    | â­â­â­â­        | â­â­â­â­â­          | â­â­         | â­â­â­   |
| **Learning Curve** | â­â­â­â­â­      | â­â­â­â­            | â­â­         | â­â­     |

### Chi tiáº¿t tá»«ng approach:

**1. Props-based API**

```jsx
<Select
  options={options}
  value={value}
  onChange={onChange}
  renderOption={(opt) => <div>{opt.label}</div>}
/>
```

- âœ… ÄÆ¡n giáº£n khi dÃ¹ng
- âœ… Type-safe vá»›i TypeScript
- âœ… Ãt code hÆ¡n
- âŒ KhÃ³ customize phá»©c táº¡p
- âŒ Render props khÃ³ Ä‘á»c
- **Khi nÃ o dÃ¹ng:** Simple components, fixed UI structure

**2. Compound Components** â­ Recommended

```jsx
<Select
  value={value}
  onChange={onChange}
>
  <Select.Trigger>Select...</Select.Trigger>
  <Select.Options>
    <Select.Option value='1'>One</Select.Option>
  </Select.Options>
</Select>
```

- âœ… Ráº¥t flexible
- âœ… Readable nhÆ° HTML
- âœ… Dá»… customize
- âœ… Implicit state sharing
- âŒ Nhiá»u code hÆ¡n
- âŒ Dá»… sai structure
- **Khi nÃ o dÃ¹ng:** Complex UI, need flexibility, reusable libraries

**3. Render Props** (Legacy - hiá»ƒu Ä‘á»ƒ Ä‘á»c code cÅ©)

```jsx
<Select>
  {({ isOpen, value }) => (
    <div>
      {isOpen ? 'Open' : 'Closed'}: {value}
    </div>
  )}
</Select>
```

- âœ… Flexible logic
- âœ… Explicit state
- âŒ Callback hell
- âŒ KhÃ³ Ä‘á»c
- **Khi nÃ o dÃ¹ng:** KhÃ´ng - dÃ¹ng Hooks thay tháº¿

**4. HOCs** (Legacy - hiá»ƒu Ä‘á»ƒ Ä‘á»c code cÅ©)

```jsx
const EnhancedSelect = withDropdown(Select);
```

- âœ… Reuse logic
- âŒ Props collision
- âŒ Wrapper hell
- âŒ Static composition
- **Khi nÃ o dÃ¹ng:** KhÃ´ng - dÃ¹ng Hooks thay tháº¿

### Decision Tree

```
Báº¡n cáº§n component cÃ³ API nhÆ° tháº¿ nÃ o?

â”œâ”€ Simple, fixed structure?
â”‚  â””â”€> Props-based API
â”‚     Example: <Button variant="primary" />
â”‚
â”œâ”€ Complex, customizable UI?
â”‚  â”œâ”€ Component library?
â”‚  â”‚  â””â”€> Compound Components
â”‚  â”‚     Example: <Tabs>, <Menu>, <Accordion>
â”‚  â”‚
â”‚  â””â”€ One-off component?
â”‚     â””â”€> Props-based API (Ä‘Æ¡n giáº£n hÆ¡n)
â”‚
â”œâ”€ Share logic giá»¯a components?
â”‚  â””â”€> Custom Hooks
â”‚     Example: useFetch, useToggle
â”‚
â””â”€ Äá»c legacy code?
   â”œâ”€ Tháº¥y render props?
   â”‚  â””â”€> Hiá»ƒu pattern, cÃ¢n nháº¯c refactor
   â”‚
   â””â”€ Tháº¥y HOCs?
      â””â”€> Hiá»ƒu pattern, cÃ¢n nháº¯c refactor

RECOMMENDATION:
- Default: Compound Components cho complex components
- Fallback: Props-based náº¿u quÃ¡ Ä‘Æ¡n giáº£n
- Never: Render Props, HOCs (except legacy code)
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Context Lost in Nested Structure

```jsx
// âŒ Code cÃ³ lá»—i
const Tabs = ({ children }) => {
  const [activeTab, setActiveTab] = useState('tab1');

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      {children}
    </TabsContext.Provider>
  );
};

// Usage
function App() {
  return (
    <Tabs>
      <div className='container'>
        <div className='wrapper'>
          {/* Context bá»‹ lost á»Ÿ Ä‘Ã¢y? */}
          <Tabs.Tab value='tab1'>Tab 1</Tabs.Tab>
        </div>
      </div>
    </Tabs>
  );
}
```

**â“ CÃ¢u há»i:** Code nÃ y cÃ³ bug khÃ´ng? Táº¡i sao?

<details>
<summary>ğŸ’¡ Giáº£i thÃ­ch</summary>

**âœ… KHÃ”NG cÃ³ bug!** Context KHÃ”NG bá»‹ lost.

**Giáº£i thÃ­ch:**

- Context hoáº¡t Ä‘á»™ng qua component tree, KHÃ”NG phá»¥ thuá»™c vÃ o cáº¥u trÃºc DOM
- Children cÃ³ thá»ƒ nested bao nhiÃªu cÅ©ng Ä‘Æ°á»£c
- `<div>` á»Ÿ giá»¯a khÃ´ng áº£nh hÆ°á»Ÿng Context

**Tuy nhiÃªn, cÃ³ thá»ƒ confuse vá»›i bug tháº­t:**

```jsx
// âŒ Bug tháº­t: Provider KHÃ”NG wrap children
const Tabs = ({ children }) => {
  const [activeTab, setActiveTab] = useState('tab1');

  return (
    <div>
      <TabsContext.Provider value={{ activeTab, setActiveTab }} />
      {children} {/* âŒ Children á»Ÿ NGOÃ€I Provider! */}
    </div>
  );
};

// âœ… Fix: Wrap Ä‘Ãºng
const Tabs = ({ children }) => {
  const [activeTab, setActiveTab] = useState('tab1');

  return (
    <TabsContext.Provider value={{ activeTab, setActiveTab }}>
      {children} {/* âœ… Children trong Provider */}
    </TabsContext.Provider>
  );
};
```

</details>

---

### Bug 2: Stale Context Value

```jsx
// âŒ Code cÃ³ lá»—i
const Counter = ({ children }) => {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return (
    <CounterContext.Provider value={{ count, increment }}>
      {children}
    </CounterContext.Provider>
  );
};

Counter.Display = () => {
  const { count } = useContext(CounterContext);
  return <div>Count: {count}</div>;
};

Counter.Button = () => {
  const { increment } = useContext(CounterContext);

  return (
    <button
      onClick={() => {
        increment();
        increment();
        increment();
      }}
    >
      +3
    </button>
  );
};
```

**â“ CÃ¢u há»i:** Click button "+3", count tÄƒng bao nhiÃªu? Táº¡i sao?

<details>
<summary>ğŸ’¡ Giáº£i thÃ­ch</summary>

**Bug:** Count chá»‰ tÄƒng **+1** thay vÃ¬ **+3**!

**NguyÃªn nhÃ¢n:** Stale closure trong `increment`

```jsx
// âŒ SAI
const increment = () => setCount(count + 1);
// count bá»‹ "Ä‘Ã³ng bÄƒng" táº¡i giÃ¡ trá»‹ khi function Ä‘Æ°á»£c táº¡o

// Click button:
increment(); // setCount(0 + 1) = 1
increment(); // setCount(0 + 1) = 1 (cÃ¹ng giÃ¡ trá»‹ count!)
increment(); // setCount(0 + 1) = 1
// => Káº¿t quáº£: 1
```

**âœ… FIX:** DÃ¹ng functional update

```jsx
const Counter = ({ children }) => {
  const [count, setCount] = useState(0);

  // âœ… Functional update
  const increment = () => setCount((prev) => prev + 1);

  return (
    <CounterContext.Provider value={{ count, increment }}>
      {children}
    </CounterContext.Provider>
  );
};

// BÃ¢y giá»:
increment(); // setCount(prev => 0 + 1) = 1
increment(); // setCount(prev => 1 + 1) = 2
increment(); // setCount(prev => 2 + 1) = 3
// => Káº¿t quáº£: 3 âœ…
```

**Lesson:** LuÃ´n dÃ¹ng functional update khi update dá»±a trÃªn giÃ¡ trá»‹ hiá»‡n táº¡i!

</details>

---

### Bug 3: Performance Issue - Re-renders

```jsx
// âŒ Code cÃ³ performance issue
const Form = ({ children }) => {
  const [values, setValues] = useState({});
  const [errors, setErrors] = useState({});

  const setValue = (name, value) => {
    setValues((prev) => ({ ...prev, [name]: value }));
  };

  const setError = (name, error) => {
    setErrors((prev) => ({ ...prev, [name]: error }));
  };

  // âŒ Object Ä‘Æ°á»£c táº¡o má»›i má»—i render!
  return (
    <FormContext.Provider
      value={{
        values,
        errors,
        setValue,
        setError,
      }}
    >
      {children}
    </FormContext.Provider>
  );
};

// 100 fields, má»—i field lÃ  Form.Field component
// GÃµ vÃ o 1 field â†’ Táº¤T Cáº¢ 100 fields re-render!
```

**â“ CÃ¢u há»i:** Táº¡i sao táº¥t cáº£ fields re-render? LÃ m sao fix?

<details>
<summary>ğŸ’¡ Giáº£i thÃ­ch & Fix</summary>

**NguyÃªn nhÃ¢n:** Context value lÃ  object má»›i má»—i render

```jsx
// Má»—i render cá»§a Form:
value={{ values, errors, setValue, setError }}
// â†’ Object Má»šI
// â†’ Context value thay Ä‘á»•i
// â†’ Táº¤T Cáº¢ consumers re-render
```

**âœ… FIX 1: Memoize Context Value**

```jsx
import { useMemo, useCallback } from 'react';

const Form = ({ children }) => {
  const [values, setValues] = useState({});
  const [errors, setErrors] = useState({});

  // Memoize functions
  const setValue = useCallback((name, value) => {
    setValues((prev) => ({ ...prev, [name]: value }));
  }, []);

  const setError = useCallback((name, error) => {
    setErrors((prev) => ({ ...prev, [name]: error }));
  }, []);

  // Memoize context value
  const value = useMemo(
    () => ({
      values,
      errors,
      setValue,
      setError,
    }),
    [values, errors, setValue, setError],
  );

  return <FormContext.Provider value={value}>{children}</FormContext.Provider>;
};
```

**âœ… FIX 2: Split Context (Tá»‘t hÆ¡n!)**

```jsx
// Context riÃªng cho state vÃ  dispatch
const FormStateContext = createContext(null);
const FormDispatchContext = createContext(null);

const Form = ({ children }) => {
  const [values, setValues] = useState({});
  const [errors, setErrors] = useState({});

  const setValue = useCallback((name, value) => {
    setValues((prev) => ({ ...prev, [name]: value }));
  }, []);

  const setError = useCallback((name, error) => {
    setErrors((prev) => ({ ...prev, [name]: error }));
  }, []);

  // State context (thay Ä‘á»•i khi values/errors change)
  const stateValue = useMemo(
    () => ({
      values,
      errors,
    }),
    [values, errors],
  );

  // Dispatch context (KHÃ”NG BAO GIá»œ thay Ä‘á»•i)
  const dispatchValue = useMemo(
    () => ({
      setValue,
      setError,
    }),
    [setValue, setError],
  );

  return (
    <FormDispatchContext.Provider value={dispatchValue}>
      <FormStateContext.Provider value={stateValue}>
        {children}
      </FormStateContext.Provider>
    </FormDispatchContext.Provider>
  );
};

// Custom hooks
const useFormState = () => useContext(FormStateContext);
const useFormDispatch = () => useContext(FormDispatchContext);

// Form.Field chá»‰ subscribe context cáº§n thiáº¿t
Form.Field = ({ name }) => {
  // Chá»‰ re-render khi values[name] hoáº·c errors[name] thay Ä‘á»•i
  const { values, errors } = useFormState();
  const { setValue, setError } = useFormDispatch();

  const value = values[name];
  const error = errors[name];

  // ...
};
```

**Káº¿t quáº£:**

- GÃµ vÃ o field A â†’ chá»‰ field A re-render
- Field B, C, D... khÃ´ng re-render
- Performance tá»‘t hÆ¡n ráº¥t nhiá»u!

**Lesson:**

1. LuÃ´n memoize Context value
2. CÃ¢n nháº¯c split context cho large state
3. Profile performance vá»›i React DevTools

</details>

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

- [ ] TÃ´i hiá»ƒu Compound Components pattern lÃ  gÃ¬
- [ ] TÃ´i biáº¿t khi nÃ o nÃªn dÃ¹ng Compound Components vs Props-based API
- [ ] TÃ´i biáº¿t cÃ¡ch implement implicit state sharing qua Context
- [ ] TÃ´i hiá»ƒu trade-offs cá»§a tá»«ng pattern
- [ ] TÃ´i biáº¿t cÃ¡ch optimize performance vá»›i useMemo/useCallback
- [ ] TÃ´i biáº¿t cÃ¡ch split context Ä‘á»ƒ trÃ¡nh unnecessary re-renders
- [ ] TÃ´i hiá»ƒu accessibility requirements (ARIA, keyboard nav)
- [ ] TÃ´i biáº¿t debug common issues (stale closure, re-renders)

### Code Review Checklist

Khi review Compound Components code:

**Structure:**

- [ ] Context cÃ³ validation (throw error náº¿u dÃ¹ng ngoÃ i Provider)?
- [ ] Custom hook cÃ³ kiá»ƒm tra context existence?
- [ ] Children components cÃ³ naming convention (Parent.Child)?

**Performance:**

- [ ] Context value Ä‘Æ°á»£c memoize?
- [ ] Callbacks Ä‘Æ°á»£c wrap trong useCallback?
- [ ] Expensive computations Ä‘Æ°á»£c wrap trong useMemo?
- [ ] CÃ¢n nháº¯c split context náº¿u state lá»›n?

**Accessibility:**

- [ ] ARIA attributes Ä‘áº§y Ä‘á»§ (role, aria-\*)?
- [ ] Keyboard navigation works?
- [ ] Focus management Ä‘Ãºng?
- [ ] Screen reader friendly?

**Edge Cases:**

- [ ] Nested components hoáº¡t Ä‘á»™ng?
- [ ] Multiple instances isolated?
- [ ] Click outside handled?
- [ ] ESC key handled?

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**Dropdown Menu vá»›i Groups**

Implement Dropdown vá»›i:

- Menu.Group Ä‘á»ƒ nhÃ³m items
- Menu.Label cho group headers
- Keyboard navigation qua groups
- Search filtering (type to search)

```jsx
<Menu>
  <Menu.Trigger>Actions</Menu.Trigger>
  <Menu.Content>
    <Menu.Search placeholder='Search actions...' />

    <Menu.Group>
      <Menu.Label>File</Menu.Label>
      <Menu.Item>New</Menu.Item>
      <Menu.Item>Open</Menu.Item>
    </Menu.Group>

    <Menu.Group>
      <Menu.Label>Edit</Menu.Label>
      <Menu.Item>Cut</Menu.Item>
      <Menu.Item>Copy</Menu.Item>
    </Menu.Group>
  </Menu.Content>
</Menu>
```

### NÃ¢ng cao (60 phÃºt)

**Command Palette (nhÆ° VS Code)**

Features:

- Modal overlay
- Search input
- Categorized commands
- Recent commands
- Keyboard shortcuts display
- Fuzzy search
- Keyboard-only navigation

Inspiration: VS Code Command Palette (Cmd/Ctrl + Shift + P)

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - Composition vs Inheritance**
   https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children

2. **Kent C. Dodds - Compound Components**
   https://kentcdodds.com/blog/compound-components-with-react-hooks

### Äá»c thÃªm

1. **Radix UI Source Code** (production example)
   https://github.com/radix-ui/primitives

2. **Headless UI** (by Tailwind)
   https://headlessui.com

3. **React ARIA** (Adobe's accessible components)
   https://react-spectrum.adobe.com/react-aria/

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (cáº§n tá»« nhá»¯ng ngÃ y trÆ°á»›c)

- **NgÃ y 7:** Component Composition patterns
- **NgÃ y 24:** Custom Hooks
- **NgÃ y 32-34:** Performance optimization (memo, useMemo, useCallback)
- **NgÃ y 36-38:** Context API mastery

### HÆ°á»›ng tá»›i (nhá»¯ng ngÃ y sau sáº½ dÃ¹ng)

- **NgÃ y 40:** Render Props & HOCs (legacy patterns Ä‘á»ƒ so sÃ¡nh)
- **NgÃ y 41-44:** Form patterns sáº½ dÃ¹ng Compound Components
- **NgÃ y 53-57:** Testing Compound Components
- **Projects:** Táº¥t cáº£ complex components sáº½ dÃ¹ng pattern nÃ y

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. API Design Philosophy**

```
Compound Components lÃ  vá» DX (Developer Experience):

Good API:
- Readable (Ä‘á»c nhÆ° English)
- Predictable (behavior rÃµ rÃ ng)
- Flexible (customize dá»…)
- Documented (examples nhiá»u)

Example:
<Select>              âœ… Clear structure
  <Select.Trigger />  âœ… Readable
  <Select.Options>    âœ… Predictable nesting
    <Option />        âœ… Flexible content
  </Select.Options>
</Select>

vs.

<Select              âŒ Opaque
  trigger={...}      âŒ Render props weird
  renderOptions={...}âŒ Hard to customize
/>
```

**2. Performance Trade-offs**

```jsx
// Compound Components cÃ³ cost:
// - Nhiá»u components = nhiá»u re-renders potential
// - Context updates = táº¥t cáº£ consumers re-render

// Solutions:
// 1. Memoize context value
// 2. Split context (state vs dispatch)
// 3. Use memo on expensive children

// Khi nÃ o optimize?
// - Nhiá»u hÆ¡n 50 items
// - Complex rendering logic
// - Profiler shows issues

// Khi nÃ o KHÃ”NG optimize?
// - Premature optimization
// - Simple components
// - No performance issues
```

**3. Library Design**

Khi thiáº¿t káº¿ component library:

```
âœ… DO:
- Document patterns clearly
- Provide TypeScript types
- Show examples (good & bad)
- Explain trade-offs
- Support both controlled/uncontrolled
- Add accessibility by default

âŒ DON'T:
- Over-engineer (YAGNI)
- Break semantic HTML
- Ignore accessibility
- Assume use cases
- Make breaking changes easily
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

Q: "Compound Components lÃ  gÃ¬?"
A: Pattern cho phÃ©p components chia sáº» state ngáº§m Ä‘á»‹nh qua Context, táº¡o flexible API.

**Mid Level:**

Q: "Khi nÃ o dÃ¹ng Compound Components vs Props-based API?"
A:

- Compound: Complex UI, cáº§n flexibility, component libraries
- Props-based: Simple UI, fixed structure, type-safety quan trá»ng

**Senior Level:**

Q: "LÃ m sao optimize performance cá»§a Compound Components?"
A:

- Memoize context value
- Split context (state vs dispatch)
- useCallback cho handlers
- React.memo cho expensive children
- Profile trÆ°á»›c khi optimize

Q: "Trade-offs cá»§a Compound Components?"
A:

- âœ… Flexibility, readability, composability
- âŒ More code, potential structure errors, performance cost
- Best for: UI libraries, complex components
- Avoid for: Simple components, extreme performance needs

### War Stories

**Story 1: Tabs Performance Hell**

```
Problem: Tabs component vá»›i 100 tabs re-render táº¥t cáº£ khi click
Root cause: Context value khÃ´ng Ä‘Æ°á»£c memoize
Solution: useMemo + split context
Result: 10x faster, smooth UX

Lesson: LuÃ´n profile vá»›i realistic data
```

**Story 2: Menu Structure Confusion**

```
Problem: Users quÃªn Ä‘Ã³ng Menu.Content tag
Root cause: No validation
Solution: Add dev-mode warning, better docs
Result: Less support tickets

Lesson: Good DX = fewer bugs
```

**Story 3: Accessibility Lawsuit**

```
Problem: Modal khÃ´ng trap focus, khÃ´ng ESC
Root cause: Rushed implementation
Solution: Complete rewrite vá»›i a11y first
Result: Compliant, better UX

Lesson: Accessibility lÃ  requirement, khÃ´ng pháº£i nice-to-have
```

---

## ğŸ¯ PREVIEW NGÃ€Y 40

**NgÃ y mai:** Component Patterns - Part 2

ChÃºng ta sáº½ há»c:

- Render Props pattern (legacy - Ä‘á»ƒ hiá»ƒu code cÅ©)
- Higher-Order Components (HOCs) (legacy)
- So sÃ¡nh vá»›i Compound Components vÃ  Hooks
- Migration strategies tá»« legacy patterns
- Khi nÃ o pattern nÃ o váº«n relevant

Chuáº©n bá»‹:

- Review Compound Components pattern hÃ´m nay
- Suy nghÄ©: CÃ³ cÃ¡ch nÃ o khÃ¡c Ä‘á»ƒ share logic?
- Äá»c vá» Render Props vÃ  HOCs (overview thÃ´i)

**Má»¥c tiÃªu:** Hiá»ƒu lá»‹ch sá»­ patterns Ä‘á»ƒ Ä‘á»c legacy code vÃ  biáº¿t refactor

---

âœ… **ChÃºc má»«ng báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 39!**

Compound Components lÃ  pattern quan trá»ng cho component library design. HÃ£y thá»±c hÃ nh nhiá»u Ä‘á»ƒ master pattern nÃ y! ğŸš€
