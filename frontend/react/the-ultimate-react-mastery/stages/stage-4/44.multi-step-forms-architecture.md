# ğŸ“… NGÃ€Y 44: Multi-step Forms - Wizard Pattern

> **TÃ³m táº¯t:** HÃ´m nay chÃºng ta há»c cÃ¡ch xÃ¢y dá»±ng multi-step forms (form wizard) - pattern phá»• biáº¿n trong e-commerce checkout, onboarding flows, vÃ  registration processes. ChÃºng ta sáº½ káº¿t há»£p React Hook Form, Zod, vÃ  Context API Ä‘á»ƒ quáº£n lÃ½ state phá»©c táº¡p, validate tá»«ng step, persist data giá»¯a cÃ¡c steps, vÃ  xá»­ lÃ½ navigation. ÄÃ¢y lÃ  ngÃ y tá»•ng há»£p má»i kiáº¿n thá»©c forms Ä‘Ã£ há»c Ä‘á»ƒ build production-ready wizards.

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] Hiá»ƒu Ä‘Æ°á»£c wizard pattern lÃ  gÃ¬ vÃ  khi nÃ o nÃªn dÃ¹ng
- [ ] Implement step navigation vá»›i validation (khÃ´ng cho next náº¿u current step invalid)
- [ ] Quáº£n lÃ½ form state across multiple steps vá»›i Context
- [ ] Validate partial data per step vá»›i Zod schemas
- [ ] Persist form data khi user navigate giá»¯a cÃ¡c steps
- [ ] Handle "Save & Continue Later" functionality
- [ ] Build progress indicator vÃ  step validation status

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

1. **Context API (NgÃ y 36-38):** LÃ m sao share state giá»¯a nhiá»u components khÃ´ng props drilling? Khi nÃ o nÃªn dÃ¹ng Context vs lifting state up?

2. **Zod Schemas (NgÃ y 43):** LÃ m sao validate má»™t pháº§n cá»§a object? VÃ­ dá»¥: object cÃ³ 10 fields nhÆ°ng chá»‰ validate 3 fields Ä‘áº§u?

3. **React Hook Form (NgÃ y 41-42):** `watch()` vÃ  `getValues()` khÃ¡c nhau tháº¿ nÃ o? CÃ¡i nÃ o trigger re-render?

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

Báº¡n Ä‘ang build e-commerce checkout flow. Form cÃ³ 15+ fields:

- Shipping: name, address, city, zip, country, phone (6 fields)
- Payment: card number, holder, expiry, cvv, billing address (5 fields)
- Review: order summary, terms, promo code (4 fields)

**Váº¥n Ä‘á» vá»›i single-page form:**

```jsx
// âŒ OVERWHELMING: 15 fields trÃªn 1 trang
function CheckoutFormBad() {
  const { register } = useForm();

  return (
    <form>
      {/* Shipping - scroll scroll scroll */}
      <input {...register('name')} />
      <input {...register('address')} />
      <input {...register('city')} />
      <input {...register('zip')} />
      <input {...register('country')} />
      <input {...register('phone')} />

      {/* Payment - user Ä‘Ã£ quÃªn Ä‘ang á»Ÿ Ä‘Ã¢u */}
      <input {...register('cardNumber')} />
      <input {...register('cardHolder')} />
      <input {...register('expiryDate')} />
      <input {...register('cvv')} />
      <input {...register('billingAddress')} />

      {/* Review - quÃ¡ dÃ i, user bá» cuá»™c */}
      <textarea {...register('notes')} />
      <input
        type='checkbox'
        {...register('terms')}
      />
      <input {...register('promoCode')} />

      <button type='submit'>Place Order</button>
    </form>
  );
}
```

**Háº­u quáº£:**

- ğŸ“‰ Form abandonment rate cao (users overwhelmed)
- ğŸ˜µ Cognitive overload - quÃ¡ nhiá»u fields cÃ¹ng lÃºc
- ğŸ› Validation errors khÃ³ locate - scroll tÃ¬m lá»—i á»Ÿ Ä‘Ã¢u?
- ğŸ“± Mobile UX tá»‡ - scroll mÃ£i má»›i Ä‘áº¿n submit button
- âŒ KhÃ´ng thá»ƒ "save progress" - máº¥t data náº¿u refresh

### 1.2 Giáº£i PhÃ¡p: Multi-step Form (Wizard Pattern)

Chia form thÃ nh cÃ¡c bÆ°á»›c nhá», má»—i bÆ°á»›c táº­p trung vÃ o 1 nhÃ³m thÃ´ng tin:

```jsx
// âœ… BETTER: Chia thÃ nh 3 steps
Step 1: Shipping Info (6 fields)
  â†“ Validate â†’ Next
Step 2: Payment Info (5 fields)
  â†“ Validate â†’ Next
Step 3: Review & Confirm (4 fields)
  â†“ Submit

// Benefits:
// âœ… Dá»… tiÃªu hÃ³a - chá»‰ 5-6 fields má»—i láº§n
// âœ… Progress indication - user biáº¿t cÃ²n bao nhiÃªu bÆ°á»›c
// âœ… Validation per step - sá»­a lá»—i ngay, khÃ´ng Ä‘á»£i Ä‘áº¿n cuá»‘i
// âœ… Save progress - cÃ³ thá»ƒ back/forward
// âœ… Better mobile UX
```

### 1.3 Mental Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   WIZARD PATTERN ARCHITECTURE                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      WIZARD CONTEXT                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ State:                                                 â”‚  â”‚
â”‚  â”‚  - currentStep: number                                 â”‚  â”‚
â”‚  â”‚  - formData: { step1: {...}, step2: {...}, ... }     â”‚  â”‚
â”‚  â”‚  - completedSteps: Set<number>                        â”‚  â”‚
â”‚  â”‚  - isStepValid: Map<number, boolean>                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Actions:                                               â”‚  â”‚
â”‚  â”‚  - nextStep()                                          â”‚  â”‚
â”‚  â”‚  - previousStep()                                      â”‚  â”‚
â”‚  â”‚  - goToStep(n)                                         â”‚  â”‚
â”‚  â”‚  - updateStepData(step, data)                         â”‚  â”‚
â”‚  â”‚  - validateStep(step)                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼                   â–¼                   â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Step 1  â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Step 2  â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Step 3  â”‚
  â”‚ Shipping â”‚        â”‚ Payment  â”‚        â”‚  Review  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚                   â”‚
        â–¼                   â–¼                   â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Schema  â”‚        â”‚  Schema  â”‚        â”‚  Schema  â”‚
  â”‚   (Zod)  â”‚        â”‚   (Zod)  â”‚        â”‚   (Zod)  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚                   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Final Submit â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FLOW:
1. User fills Step 1 â†’ Validate â†’ Save to context
2. Move to Step 2 â†’ Pre-fill from context â†’ Validate â†’ Save
3. Move to Step 3 â†’ Review all data â†’ Submit
4. Can go back to edit â†’ Data persisted
```

**Analogy:** Wizard form nhÆ° **hÃ nh trÃ¬nh Ä‘i tÃ u**

- Má»—i step = 1 ga tÃ u
- Pháº£i hoÃ n thÃ nh thá»§ tá»¥c á»Ÿ ga nÃ y má»›i lÃªn tÃ u Ä‘áº¿n ga tiáº¿p theo (validation)
- CÃ³ thá»ƒ quay láº¡i ga trÆ°á»›c Ä‘á»ƒ sá»­a thÃ´ng tin (navigation)
- HÃ nh lÃ½ (data) theo báº¡n suá»‘t hÃ nh trÃ¬nh (persistence)
- Biáº¿t mÃ¬nh Ä‘ang á»Ÿ ga nÃ o vÃ  cÃ²n bao nhiÃªu ga ná»¯a (progress indicator)

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

âŒ **"Multi-step form = nhiá»u `<form>` tags"**

- âœ… ThÆ°á»ng chá»‰ cáº§n 1 `<form>` tag, navigate báº±ng conditional rendering

âŒ **"Pháº£i validate táº¥t cáº£ fields má»—i step"**

- âœ… Chá»‰ validate fields cá»§a step hiá»‡n táº¡i, final step má»›i validate all

âŒ **"Data bá»‹ máº¥t khi chuyá»ƒn step"**

- âœ… DÃ¹ng Context/State management Ä‘á»ƒ persist data across steps

âŒ **"Wizard pattern chá»‰ cho checkout"**

- âœ… DÃ¹ng cho: onboarding, surveys, account setup, job applications, complex configs...

âŒ **"KhÃ´ng thá»ƒ edit previous steps"**

- âœ… Best practice: cho phÃ©p back Ä‘á»ƒ edit, nhÆ°ng pháº£i re-validate

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Basic Wizard vá»›i useState â­

```jsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Demo: Simple 3-step wizard vá»›i basic state management
 * Use case: User registration wizard
 */

// Step schemas
const step1Schema = z.object({
  firstName: z.string().min(2, "First name required"),
  lastName: z.string().min(2, "Last name required"),
  email: z.string().email("Invalid email")
});

const step2Schema = z.object({
  password: z.string().min(8, "Password must be 8+ chars"),
  confirmPassword: z.string()
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"]
});

const step3Schema = z.object({
  acceptTerms: z.boolean().refine(val => val === true, {
    message: "Must accept terms"
  })
});

type Step1Data = z.infer<typeof step1Schema>;
type Step2Data = z.infer<typeof step2Schema>;
type Step3Data = z.infer<typeof step3Schema>;

/**
 * Step 1: Basic Info
 */
function Step1({ onNext, defaultValues }: {
  onNext: (data: Step1Data) => void;
  defaultValues?: Partial<Step1Data>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<Step1Data>({
    resolver: zodResolver(step1Schema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Step 1: Basic Info</h2>

      <div>
        <input {...register("firstName")} placeholder="First Name" />
        {errors.firstName && <p style={{ color: 'red' }}>{errors.firstName.message}</p>}
      </div>

      <div>
        <input {...register("lastName")} placeholder="Last Name" />
        {errors.lastName && <p style={{ color: 'red' }}>{errors.lastName.message}</p>}
      </div>

      <div>
        <input {...register("email")} placeholder="Email" />
        {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
      </div>

      <button type="submit">Next â†’</button>
    </form>
  );
}

/**
 * Step 2: Password
 */
function Step2({ onNext, onBack, defaultValues }: {
  onNext: (data: Step2Data) => void;
  onBack: () => void;
  defaultValues?: Partial<Step2Data>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<Step2Data>({
    resolver: zodResolver(step2Schema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Step 2: Set Password</h2>

      <div>
        <input type="password" {...register("password")} placeholder="Password" />
        {errors.password && <p style={{ color: 'red' }}>{errors.password.message}</p>}
      </div>

      <div>
        <input type="password" {...register("confirmPassword")} placeholder="Confirm Password" />
        {errors.confirmPassword && <p style={{ color: 'red' }}>{errors.confirmPassword.message}</p>}
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

/**
 * Step 3: Confirm
 */
function Step3({ onSubmit, onBack, data }: {
  onSubmit: (data: Step3Data) => void;
  onBack: () => void;
  data: { step1: Step1Data; step2: Step2Data };
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<Step3Data>({
    resolver: zodResolver(step3Schema)
  });

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Step 3: Review & Confirm</h2>

      <div>
        <h3>Your Information:</h3>
        <p>Name: {data.step1.firstName} {data.step1.lastName}</p>
        <p>Email: {data.step1.email}</p>
        <p>Password: ******** (set)</p>
      </div>

      <div>
        <label>
          <input type="checkbox" {...register("acceptTerms")} />
          I accept the terms and conditions
        </label>
        {errors.acceptTerms && <p style={{ color: 'red' }}>{errors.acceptTerms.message}</p>}
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="submit">Create Account</button>
      </div>
    </form>
  );
}

/**
 * Main Wizard Component
 */
function BasicWizard() {
  const [currentStep, setCurrentStep] = useState(1);
  const [step1Data, setStep1Data] = useState<Step1Data | null>(null);
  const [step2Data, setStep2Data] = useState<Step2Data | null>(null);

  const handleStep1Submit = (data: Step1Data) => {
    setStep1Data(data);
    setCurrentStep(2);
  };

  const handleStep2Submit = (data: Step2Data) => {
    setStep2Data(data);
    setCurrentStep(3);
  };

  const handleFinalSubmit = (data: Step3Data) => {
    const finalData = {
      ...step1Data!,
      ...step2Data!,
      ...data
    };
    console.log('Registration complete:', finalData);
    alert('Account created successfully!');
  };

  return (
    <div>
      {/* Progress Indicator */}
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
        <span style={{ fontWeight: currentStep === 1 ? 'bold' : 'normal' }}>
          1. Info
        </span>
        <span style={{ fontWeight: currentStep === 2 ? 'bold' : 'normal' }}>
          2. Password
        </span>
        <span style={{ fontWeight: currentStep === 3 ? 'bold' : 'normal' }}>
          3. Confirm
        </span>
      </div>

      {/* Step Content */}
      {currentStep === 1 && (
        <Step1
          onNext={handleStep1Submit}
          defaultValues={step1Data || undefined}
        />
      )}

      {currentStep === 2 && (
        <Step2
          onNext={handleStep2Submit}
          onBack={() => setCurrentStep(1)}
          defaultValues={step2Data || undefined}
        />
      )}

      {currentStep === 3 && step1Data && step2Data && (
        <Step3
          onSubmit={handleFinalSubmit}
          onBack={() => setCurrentStep(2)}
          data={{ step1: step1Data, step2: step2Data }}
        />
      )}
    </div>
  );
}

// ğŸ¯ KEY CONCEPTS:
// 1. Má»—i step cÃ³ schema riÃªng
// 2. Data Ä‘Æ°á»£c save vÃ o state khi next
// 3. defaultValues Ä‘á»ƒ pre-fill khi back
// 4. Progress indicator visual feedback
```

### Demo 2: Wizard vá»›i Context API â­â­

```jsx
import { createContext, useContext, useReducer, ReactNode } from 'react';
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Demo: Scalable wizard vá»›i Context + useReducer
 * Use case: Complex multi-step form vá»›i shared state
 */

// ============================================
// CONTEXT SETUP
// ============================================

type WizardState = {
  currentStep: number;
  totalSteps: number;
  formData: Record<string, any>;
  completedSteps: Set<number>;
};

type WizardAction =
  | { type: 'NEXT_STEP' }
  | { type: 'PREVIOUS_STEP' }
  | { type: 'GO_TO_STEP'; payload: number }
  | { type: 'UPDATE_STEP_DATA'; payload: { step: number; data: any } }
  | { type: 'MARK_STEP_COMPLETE'; payload: number }
  | { type: 'RESET_WIZARD' };

const wizardReducer = (state: WizardState, action: WizardAction): WizardState => {
  switch (action.type) {
    case 'NEXT_STEP':
      return {
        ...state,
        currentStep: Math.min(state.currentStep + 1, state.totalSteps)
      };

    case 'PREVIOUS_STEP':
      return {
        ...state,
        currentStep: Math.max(state.currentStep - 1, 1)
      };

    case 'GO_TO_STEP':
      // Only allow going to completed steps or next step
      if (action.payload <= state.currentStep ||
          state.completedSteps.has(action.payload - 1)) {
        return { ...state, currentStep: action.payload };
      }
      return state;

    case 'UPDATE_STEP_DATA':
      return {
        ...state,
        formData: {
          ...state.formData,
          [`step${action.payload.step}`]: action.payload.data
        }
      };

    case 'MARK_STEP_COMPLETE':
      const newCompleted = new Set(state.completedSteps);
      newCompleted.add(action.payload);
      return { ...state, completedSteps: newCompleted };

    case 'RESET_WIZARD':
      return {
        currentStep: 1,
        totalSteps: state.totalSteps,
        formData: {},
        completedSteps: new Set()
      };

    default:
      return state;
  }
};

const WizardContext = createContext<{
  state: WizardState;
  dispatch: React.Dispatch<WizardAction>;
} | null>(null);

/**
 * Wizard Provider
 */
function WizardProvider({ children, totalSteps }: {
  children: ReactNode;
  totalSteps: number;
}) {
  const [state, dispatch] = useReducer(wizardReducer, {
    currentStep: 1,
    totalSteps,
    formData: {},
    completedSteps: new Set()
  });

  return (
    <WizardContext.Provider value={{ state, dispatch }}>
      {children}
    </WizardContext.Provider>
  );
}

/**
 * Custom hook to use wizard context
 */
function useWizard() {
  const context = useContext(WizardContext);
  if (!context) {
    throw new Error('useWizard must be used within WizardProvider');
  }
  return context;
}

// ============================================
// STEP COMPONENTS
// ============================================

const personalInfoSchema = z.object({
  fullName: z.string().min(2, "Name required"),
  age: z.string()
    .transform(val => parseInt(val, 10))
    .pipe(z.number().min(18, "Must be 18+"))
});

type PersonalInfoData = z.infer<typeof personalInfoSchema>;

/**
 * Step 1: Personal Info
 */
function PersonalInfoStep() {
  const { state, dispatch } = useWizard();
  const defaultValues = state.formData.step1;

  const { register, handleSubmit, formState: { errors } } = useForm<PersonalInfoData>({
    resolver: zodResolver(personalInfoSchema),
    defaultValues
  });

  const onSubmit = (data: PersonalInfoData) => {
    dispatch({ type: 'UPDATE_STEP_DATA', payload: { step: 1, data } });
    dispatch({ type: 'MARK_STEP_COMPLETE', payload: 1 });
    dispatch({ type: 'NEXT_STEP' });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Personal Information</h2>

      <div>
        <input {...register("fullName")} placeholder="Full Name" />
        {errors.fullName && <p style={{ color: 'red' }}>{errors.fullName.message}</p>}
      </div>

      <div>
        <input {...register("age")} placeholder="Age" />
        {errors.age && <p style={{ color: 'red' }}>{errors.age.message}</p>}
      </div>

      <button type="submit">Next â†’</button>
    </form>
  );
}

const contactInfoSchema = z.object({
  email: z.string().email("Invalid email"),
  phone: z.string().regex(/^\d{10}$/, "Phone must be 10 digits")
});

type ContactInfoData = z.infer<typeof contactInfoSchema>;

/**
 * Step 2: Contact Info
 */
function ContactInfoStep() {
  const { state, dispatch } = useWizard();
  const defaultValues = state.formData.step2;

  const { register, handleSubmit, formState: { errors } } = useForm<ContactInfoData>({
    resolver: zodResolver(contactInfoSchema),
    defaultValues
  });

  const onSubmit = (data: ContactInfoData) => {
    dispatch({ type: 'UPDATE_STEP_DATA', payload: { step: 2, data } });
    dispatch({ type: 'MARK_STEP_COMPLETE', payload: 2 });
    dispatch({ type: 'NEXT_STEP' });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Contact Information</h2>

      <div>
        <input {...register("email")} placeholder="Email" />
        {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
      </div>

      <div>
        <input {...register("phone")} placeholder="Phone (10 digits)" />
        {errors.phone && <p style={{ color: 'red' }}>{errors.phone.message}</p>}
      </div>

      <div>
        <button type="button" onClick={() => dispatch({ type: 'PREVIOUS_STEP' })}>
          â† Back
        </button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

/**
 * Step 3: Review
 */
function ReviewStep() {
  const { state, dispatch } = useWizard();

  const handleSubmit = () => {
    const allData = {
      ...state.formData.step1,
      ...state.formData.step2
    };
    console.log('Wizard completed:', allData);
    alert('Form submitted!');
    dispatch({ type: 'RESET_WIZARD' });
  };

  return (
    <div>
      <h2>Review Your Information</h2>

      <div>
        <h3>Personal Info:</h3>
        <p>Name: {state.formData.step1?.fullName}</p>
        <p>Age: {state.formData.step1?.age}</p>
      </div>

      <div>
        <h3>Contact Info:</h3>
        <p>Email: {state.formData.step2?.email}</p>
        <p>Phone: {state.formData.step2?.phone}</p>
      </div>

      <div>
        <button type="button" onClick={() => dispatch({ type: 'PREVIOUS_STEP' })}>
          â† Back
        </button>
        <button onClick={handleSubmit}>Submit</button>
      </div>
    </div>
  );
}

/**
 * Progress Indicator Component
 */
function WizardProgress() {
  const { state, dispatch } = useWizard();

  const steps = [
    { number: 1, label: 'Personal' },
    { number: 2, label: 'Contact' },
    { number: 3, label: 'Review' }
  ];

  return (
    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
      {steps.map(step => (
        <button
          key={step.number}
          onClick={() => dispatch({ type: 'GO_TO_STEP', payload: step.number })}
          disabled={!state.completedSteps.has(step.number - 1) && step.number > state.currentStep}
          style={{
            fontWeight: state.currentStep === step.number ? 'bold' : 'normal',
            opacity: state.completedSteps.has(step.number) ? 1 : 0.5
          }}
        >
          {step.number}. {step.label}
          {state.completedSteps.has(step.number) && ' âœ“'}
        </button>
      ))}
    </div>
  );
}

/**
 * Main Wizard with Context
 */
function ContextWizard() {
  return (
    <WizardProvider totalSteps={3}>
      <WizardProgress />
      <WizardSteps />
    </WizardProvider>
  );
}

function WizardSteps() {
  const { state } = useWizard();

  return (
    <>
      {state.currentStep === 1 && <PersonalInfoStep />}
      {state.currentStep === 2 && <ContactInfoStep />}
      {state.currentStep === 3 && <ReviewStep />}
    </>
  );
}

// ğŸ¯ BENEFITS OF CONTEXT APPROACH:
// 1. Centralized state management
// 2. Easy to add new steps
// 3. Can access wizard state from any component
// 4. Reducer pattern for complex state logic
// 5. Type-safe actions
```

### Demo 3: Dynamic Steps vá»›i Conditional Logic â­â­â­

```jsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Demo: Dynamic wizard - steps change based on user input
 * Use case: Survey where questions depend on previous answers
 */

// Step 1: Account Type
const accountTypeSchema = z.object({
  accountType: z.enum(['personal', 'business'], {
    errorMap: () => ({ message: "Please select account type" })
  })
});

type AccountTypeData = z.infer<typeof accountTypeSchema>;

/**
 * Step 1: Choose Account Type
 */
function AccountTypeStep({ onNext }: {
  onNext: (data: AccountTypeData) => void;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<AccountTypeData>({
    resolver: zodResolver(accountTypeSchema)
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Choose Account Type</h2>

      <div>
        <label>
          <input type="radio" {...register("accountType")} value="personal" />
          Personal Account
        </label>
      </div>

      <div>
        <label>
          <input type="radio" {...register("accountType")} value="business" />
          Business Account
        </label>
      </div>

      {errors.accountType && <p style={{ color: 'red' }}>{errors.accountType.message}</p>}

      <button type="submit">Next â†’</button>
    </form>
  );
}

// Personal Account Schema
const personalDetailsSchema = z.object({
  fullName: z.string().min(2, "Name required"),
  dateOfBirth: z.string().min(1, "Date of birth required")
});

type PersonalDetailsData = z.infer<typeof personalDetailsSchema>;

/**
 * Step 2a: Personal Details (conditional)
 */
function PersonalDetailsStep({ onNext, onBack }: {
  onNext: (data: PersonalDetailsData) => void;
  onBack: () => void;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<PersonalDetailsData>({
    resolver: zodResolver(personalDetailsSchema)
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Personal Details</h2>

      <div>
        <input {...register("fullName")} placeholder="Full Name" />
        {errors.fullName && <p style={{ color: 'red' }}>{errors.fullName.message}</p>}
      </div>

      <div>
        <input type="date" {...register("dateOfBirth")} />
        {errors.dateOfBirth && <p style={{ color: 'red' }}>{errors.dateOfBirth.message}</p>}
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

// Business Account Schema
const businessDetailsSchema = z.object({
  companyName: z.string().min(2, "Company name required"),
  taxId: z.string().regex(/^\d{9}$/, "Tax ID must be 9 digits"),
  employeeCount: z.string()
    .transform(val => parseInt(val, 10))
    .pipe(z.number().min(1, "Must have at least 1 employee"))
});

type BusinessDetailsData = z.infer<typeof businessDetailsSchema>;

/**
 * Step 2b: Business Details (conditional)
 */
function BusinessDetailsStep({ onNext, onBack }: {
  onNext: (data: BusinessDetailsData) => void;
  onBack: () => void;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<BusinessDetailsData>({
    resolver: zodResolver(businessDetailsSchema)
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Business Details</h2>

      <div>
        <input {...register("companyName")} placeholder="Company Name" />
        {errors.companyName && <p style={{ color: 'red' }}>{errors.companyName.message}</p>}
      </div>

      <div>
        <input {...register("taxId")} placeholder="Tax ID (9 digits)" />
        {errors.taxId && <p style={{ color: 'red' }}>{errors.taxId.message}</p>}
      </div>

      <div>
        <input {...register("employeeCount")} placeholder="Number of Employees" />
        {errors.employeeCount && <p style={{ color: 'red' }}>{errors.employeeCount.message}</p>}
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

/**
 * Final Review Step
 */
function FinalReviewStep({ data, onBack, onSubmit }: {
  data: any;
  onBack: () => void;
  onSubmit: () => void;
}) {
  return (
    <div>
      <h2>Review Your Information</h2>

      <div>
        <h3>Account Type:</h3>
        <p>{data.step1.accountType}</p>
      </div>

      {data.step1.accountType === 'personal' && data.step2Personal && (
        <div>
          <h3>Personal Details:</h3>
          <p>Name: {data.step2Personal.fullName}</p>
          <p>DOB: {data.step2Personal.dateOfBirth}</p>
        </div>
      )}

      {data.step1.accountType === 'business' && data.step2Business && (
        <div>
          <h3>Business Details:</h3>
          <p>Company: {data.step2Business.companyName}</p>
          <p>Tax ID: {data.step2Business.taxId}</p>
          <p>Employees: {data.step2Business.employeeCount}</p>
        </div>
      )}

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button onClick={onSubmit}>Create Account</button>
      </div>
    </div>
  );
}

/**
 * Dynamic Wizard Main Component
 */
function DynamicWizard() {
  const [currentStep, setCurrentStep] = useState(1);
  const [accountTypeData, setAccountTypeData] = useState<AccountTypeData | null>(null);
  const [personalData, setPersonalData] = useState<PersonalDetailsData | null>(null);
  const [businessData, setBusinessData] = useState<BusinessDetailsData | null>(null);

  const handleAccountTypeSubmit = (data: AccountTypeData) => {
    setAccountTypeData(data);
    setCurrentStep(2);
  };

  const handlePersonalSubmit = (data: PersonalDetailsData) => {
    setPersonalData(data);
    setCurrentStep(3);
  };

  const handleBusinessSubmit = (data: BusinessDetailsData) => {
    setBusinessData(data);
    setCurrentStep(3);
  };

  const handleFinalSubmit = () => {
    const finalData = {
      step1: accountTypeData,
      step2Personal: personalData,
      step2Business: businessData
    };
    console.log('Account created:', finalData);
    alert('Account created successfully!');
  };

  return (
    <div>
      {/* Dynamic Progress Indicator */}
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
        <span style={{ fontWeight: currentStep === 1 ? 'bold' : 'normal' }}>
          1. Account Type
        </span>
        <span style={{ fontWeight: currentStep === 2 ? 'bold' : 'normal' }}>
          2. {accountTypeData?.accountType === 'business' ? 'Business' : 'Personal'} Details
        </span>
        <span style={{ fontWeight: currentStep === 3 ? 'bold' : 'normal' }}>
          3. Review
        </span>
      </div>

      {/* Step 1: Account Type */}
      {currentStep === 1 && (
        <AccountTypeStep onNext={handleAccountTypeSubmit} />
      )}

      {/* Step 2: Conditional - Personal or Business */}
      {currentStep === 2 && accountTypeData?.accountType === 'personal' && (
        <PersonalDetailsStep
          onNext={handlePersonalSubmit}
          onBack={() => setCurrentStep(1)}
        />
      )}

      {currentStep === 2 && accountTypeData?.accountType === 'business' && (
        <BusinessDetailsStep
          onNext={handleBusinessSubmit}
          onBack={() => setCurrentStep(1)}
        />
      )}

      {/* Step 3: Review */}
      {currentStep === 3 && (
        <FinalReviewStep
          data={{
            step1: accountTypeData,
            step2Personal: personalData,
            step2Business: businessData
          }}
          onBack={() => setCurrentStep(2)}
          onSubmit={handleFinalSubmit}
        />
      )}
    </div>
  );
}

// ğŸ¯ KEY FEATURES:
// 1. Steps thay Ä‘á»•i based on user choice
// 2. Different schemas for different paths
// 3. Progress indicator adapts
// 4. Can still go back to change account type
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ BÃ i 1: Simple Linear Wizard (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Táº¡o 3-step wizard cÆ¡ báº£n
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: Context, useReducer, dynamic steps
 *
 * Requirements:
 * 1. Step 1: Name & Email
 * 2. Step 2: Address & Phone
 * 3. Step 3: Review & Submit
 * 4. Progress bar hiá»ƒn thá»‹ current step
 * 5. Validate má»—i step trÆ°á»›c khi next
 * 6. Data persist khi back/forward
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - DÃ¹ng useState cho currentStep vÃ  data
 * - Má»—i step lÃ  separate component vá»›i own schema
 * - Pass defaultValues Ä‘á»ƒ pre-fill khi back
 */

// TODO: Implement SimpleWizard component
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Simple 3-step linear wizard
 * @returns {JSX.Element} Wizard component
 */

// Schemas
const step1Schema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address")
});

const step2Schema = z.object({
  address: z.string().min(10, "Address must be at least 10 characters"),
  phone: z.string().regex(/^\d{10}$/, "Phone must be 10 digits")
});

type Step1Data = z.infer<typeof step1Schema>;
type Step2Data = z.infer<typeof step2Schema>;

function Step1({ onNext, defaultValues }: {
  onNext: (data: Step1Data) => void;
  defaultValues?: Partial<Step1Data>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<Step1Data>({
    resolver: zodResolver(step1Schema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Step 1: Basic Information</h2>

      <div>
        <label>Name</label>
        <input {...register("name")} />
        {errors.name && <p style={{ color: 'red' }}>{errors.name.message}</p>}
      </div>

      <div>
        <label>Email</label>
        <input {...register("email")} />
        {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
      </div>

      <button type="submit">Next â†’</button>
    </form>
  );
}

function Step2({ onNext, onBack, defaultValues }: {
  onNext: (data: Step2Data) => void;
  onBack: () => void;
  defaultValues?: Partial<Step2Data>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<Step2Data>({
    resolver: zodResolver(step2Schema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Step 2: Contact Details</h2>

      <div>
        <label>Address</label>
        <input {...register("address")} />
        {errors.address && <p style={{ color: 'red' }}>{errors.address.message}</p>}
      </div>

      <div>
        <label>Phone</label>
        <input {...register("phone")} placeholder="1234567890" />
        {errors.phone && <p style={{ color: 'red' }}>{errors.phone.message}</p>}
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

function Step3({ data, onBack, onSubmit }: {
  data: { step1: Step1Data; step2: Step2Data };
  onBack: () => void;
  onSubmit: () => void;
}) {
  return (
    <div>
      <h2>Step 3: Review & Submit</h2>

      <div>
        <h3>Basic Information:</h3>
        <p>Name: {data.step1.name}</p>
        <p>Email: {data.step1.email}</p>
      </div>

      <div>
        <h3>Contact Details:</h3>
        <p>Address: {data.step2.address}</p>
        <p>Phone: {data.step2.phone}</p>
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button onClick={onSubmit}>Submit</button>
      </div>
    </div>
  );
}

function SimpleWizard() {
  const [currentStep, setCurrentStep] = useState(1);
  const [step1Data, setStep1Data] = useState<Step1Data | null>(null);
  const [step2Data, setStep2Data] = useState<Step2Data | null>(null);

  const handleStep1 = (data: Step1Data) => {
    setStep1Data(data);
    setCurrentStep(2);
  };

  const handleStep2 = (data: Step2Data) => {
    setStep2Data(data);
    setCurrentStep(3);
  };

  const handleSubmit = () => {
    console.log('Submitted:', { ...step1Data, ...step2Data });
    alert('Form submitted successfully!');
    setCurrentStep(1);
    setStep1Data(null);
    setStep2Data(null);
  };

  return (
    <div>
      {/* Progress Bar */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        marginBottom: '20px',
        padding: '10px',
        backgroundColor: '#f0f0f0'
      }}>
        <span style={{ fontWeight: currentStep >= 1 ? 'bold' : 'normal' }}>
          1. Basic Info {currentStep > 1 && 'âœ“'}
        </span>
        <span style={{ fontWeight: currentStep >= 2 ? 'bold' : 'normal' }}>
          2. Contact {currentStep > 2 && 'âœ“'}
        </span>
        <span style={{ fontWeight: currentStep >= 3 ? 'bold' : 'normal' }}>
          3. Review
        </span>
      </div>

      {/* Steps */}
      {currentStep === 1 && (
        <Step1 onNext={handleStep1} defaultValues={step1Data || undefined} />
      )}

      {currentStep === 2 && (
        <Step2
          onNext={handleStep2}
          onBack={() => setCurrentStep(1)}
          defaultValues={step2Data || undefined}
        />
      )}

      {currentStep === 3 && step1Data && step2Data && (
        <Step3
          data={{ step1: step1Data, step2: step2Data }}
          onBack={() => setCurrentStep(2)}
          onSubmit={handleSubmit}
        />
      )}
    </div>
  );
}

// Example usage: Fill Step 1 â†’ Next â†’ Fill Step 2 â†’ Next â†’ Review â†’ Submit
```

</details>

### â­â­ BÃ i 2: Wizard vá»›i Validation Summary (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build wizard cÃ³ validation status cho má»—i step
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: User muá»‘n biáº¿t step nÃ o Ä‘Ã£ complete, step nÃ o cÃ²n errors
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 * Approach A: Track validation status per step trong state
 * Pros: Simple, explicit
 * Cons: Need to manually update validation status
 *
 * Approach B: Validate all data silently, show status
 * Pros: Always accurate
 * Cons: Performance - validate unused data
 *
 * ğŸ’­ Chá»n Approach A - explicit tracking
 *
 * Requirements:
 * 1. Progress indicator shows: Incomplete | Completed âœ“ | Current
 * 2. Can click on completed steps to edit
 * 3. Cannot skip to next step if current invalid
 * 4. Show summary of all data before final submit
 */

// TODO: Implement WizardWithValidationStatus
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Wizard vá»›i validation status tracking
 * @returns {JSX.Element} Wizard with validation indicators
 */

const profileSchema = z.object({
  username: z.string().min(3, "Username must be 3+ chars"),
  bio: z.string().min(10, "Bio must be 10+ chars")
});

const preferencesSchema = z.object({
  theme: z.enum(['light', 'dark']),
  notifications: z.boolean()
});

type ProfileData = z.infer<typeof profileSchema>;
type PreferencesData = z.infer<typeof preferencesSchema>;

type StepStatus = 'incomplete' | 'completed' | 'current';

function ProfileStep({ onNext, defaultValues }: {
  onNext: (data: ProfileData) => void;
  defaultValues?: Partial<ProfileData>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<ProfileData>({
    resolver: zodResolver(profileSchema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Profile</h2>

      <div>
        <label>Username</label>
        <input {...register("username")} />
        {errors.username && <p style={{ color: 'red' }}>{errors.username.message}</p>}
      </div>

      <div>
        <label>Bio</label>
        <textarea {...register("bio")} rows={3} />
        {errors.bio && <p style={{ color: 'red' }}>{errors.bio.message}</p>}
      </div>

      <button type="submit">Next â†’</button>
    </form>
  );
}

function PreferencesStep({ onNext, onBack, defaultValues }: {
  onNext: (data: PreferencesData) => void;
  onBack: () => void;
  defaultValues?: Partial<PreferencesData>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<PreferencesData>({
    resolver: zodResolver(preferencesSchema),
    defaultValues: defaultValues || { theme: 'light', notifications: false }
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Preferences</h2>

      <div>
        <label>Theme</label>
        <select {...register("theme")}>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
        {errors.theme && <p style={{ color: 'red' }}>{errors.theme.message}</p>}
      </div>

      <div>
        <label>
          <input type="checkbox" {...register("notifications")} />
          Enable notifications
        </label>
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

function ReviewStep({ data, onBack, onSubmit }: {
  data: { profile: ProfileData; preferences: PreferencesData };
  onBack: () => void;
  onSubmit: () => void;
}) {
  return (
    <div>
      <h2>Review</h2>

      <div style={{ border: '1px solid #ccc', padding: '10px', marginBottom: '10px' }}>
        <h3>Profile</h3>
        <p>Username: {data.profile.username}</p>
        <p>Bio: {data.profile.bio}</p>
      </div>

      <div style={{ border: '1px solid #ccc', padding: '10px', marginBottom: '10px' }}>
        <h3>Preferences</h3>
        <p>Theme: {data.preferences.theme}</p>
        <p>Notifications: {data.preferences.notifications ? 'Enabled' : 'Disabled'}</p>
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button onClick={onSubmit}>Submit</button>
      </div>
    </div>
  );
}

function WizardWithValidationStatus() {
  const [currentStep, setCurrentStep] = useState(1);
  const [profileData, setProfileData] = useState<ProfileData | null>(null);
  const [preferencesData, setPreferencesData] = useState<PreferencesData | null>(null);

  // Track which steps are completed
  const [completedSteps, setCompletedSteps] = useState<Set<number>>(new Set());

  const getStepStatus = (stepNumber: number): StepStatus => {
    if (stepNumber === currentStep) return 'current';
    if (completedSteps.has(stepNumber)) return 'completed';
    return 'incomplete';
  };

  const handleProfileSubmit = (data: ProfileData) => {
    setProfileData(data);
    setCompletedSteps(prev => new Set(prev).add(1));
    setCurrentStep(2);
  };

  const handlePreferencesSubmit = (data: PreferencesData) => {
    setPreferencesData(data);
    setCompletedSteps(prev => new Set(prev).add(2));
    setCurrentStep(3);
  };

  const handleFinalSubmit = () => {
    console.log('Submitted:', { profile: profileData, preferences: preferencesData });
    alert('Settings saved!');
  };

  const goToStep = (step: number) => {
    // Can only go to completed steps or current step
    if (step <= currentStep || completedSteps.has(step - 1)) {
      setCurrentStep(step);
    }
  };

  return (
    <div>
      {/* Progress Indicator with Status */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        marginBottom: '20px',
        padding: '10px',
        backgroundColor: '#f0f0f0'
      }}>
        {[
          { number: 1, label: 'Profile' },
          { number: 2, label: 'Preferences' },
          { number: 3, label: 'Review' }
        ].map(step => {
          const status = getStepStatus(step.number);
          return (
            <button
              key={step.number}
              onClick={() => goToStep(step.number)}
              disabled={status === 'incomplete' && step.number > currentStep}
              style={{
                fontWeight: status === 'current' ? 'bold' : 'normal',
                color: status === 'completed' ? 'green' :
                       status === 'current' ? 'blue' : 'gray',
                cursor: status === 'incomplete' ? 'not-allowed' : 'pointer',
                border: 'none',
                background: 'transparent',
                fontSize: '16px'
              }}
            >
              {step.number}. {step.label}
              {status === 'completed' && ' âœ“'}
              {status === 'current' && ' â†'}
            </button>
          );
        })}
      </div>

      {/* Steps */}
      {currentStep === 1 && (
        <ProfileStep
          onNext={handleProfileSubmit}
          defaultValues={profileData || undefined}
        />
      )}

      {currentStep === 2 && (
        <PreferencesStep
          onNext={handlePreferencesSubmit}
          onBack={() => setCurrentStep(1)}
          defaultValues={preferencesData || undefined}
        />
      )}

      {currentStep === 3 && profileData && preferencesData && (
        <ReviewStep
          data={{ profile: profileData, preferences: preferencesData }}
          onBack={() => setCurrentStep(2)}
          onSubmit={handleFinalSubmit}
        />
      )}
    </div>
  );
}

// Example: Complete Step 1 â†’ Step 1 shows âœ“, can click to edit
// Try to click Step 3 before completing Step 2 â†’ Disabled
```

</details>

### â­â­â­ BÃ i 3: Wizard vá»›i Save Progress (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build wizard cÃ³ "Save & Continue Later" functionality
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  user, tÃ´i muá»‘n save progress vÃ  continue later,
 * Ä‘á»ƒ khÃ´ng máº¥t data náº¿u pháº£i Ä‘Ã³ng browser"
 *
 * âœ… Acceptance Criteria:
 * - [ ] "Save Progress" button á»Ÿ má»—i step
 * - [ ] Data saved to localStorage
 * - [ ] Auto-load saved data on mount
 * - [ ] "Clear Progress" button to reset
 * - [ ] Show last saved timestamp
 * - [ ] 3 steps: Personal Info â†’ Work Info â†’ Preferences
 *
 * ğŸ¨ Technical Constraints:
 * - DÃ¹ng localStorage (chÆ°a há»c custom hooks, nÃªn inline)
 * - Serialize/deserialize data properly
 * - Handle localStorage errors (quota exceeded)
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - localStorage not available (incognito mode)
 * - Corrupted data in localStorage
 * - Schema changes (old saved data)
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] Save function
 * - [ ] Load function on mount
 * - [ ] Clear function
 * - [ ] Error handling
 * - [ ] UI feedback (saved timestamp)
 */

// TODO: Implement WizardWithSaveProgress
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Wizard with save progress functionality
 * Persists data to localStorage
 * @returns {JSX.Element} Wizard with save/load capabilities
 */

const STORAGE_KEY = 'wizard_progress';

// Schemas
const personalInfoSchema = z.object({
  firstName: z.string().min(2, "First name required"),
  lastName: z.string().min(2, "Last name required"),
  email: z.string().email("Invalid email")
});

const workInfoSchema = z.object({
  company: z.string().min(2, "Company name required"),
  position: z.string().min(2, "Position required"),
  yearsOfExperience: z.string()
    .transform(val => parseInt(val, 10))
    .pipe(z.number().min(0, "Must be 0 or more"))
});

const preferencesSchema = z.object({
  contactMethod: z.enum(['email', 'phone']),
  subscribe: z.boolean()
});

type PersonalInfoData = z.infer<typeof personalInfoSchema>;
type WorkInfoData = z.infer<typeof workInfoSchema>;
type PreferencesData = z.infer<typeof preferencesSchema>;

type WizardData = {
  currentStep: number;
  step1?: PersonalInfoData;
  step2?: WorkInfoData;
  step3?: PreferencesData;
  lastSaved?: string;
};

function PersonalInfoStep({ onNext, onSave, defaultValues }: {
  onNext: (data: PersonalInfoData) => void;
  onSave: (data: PersonalInfoData) => void;
  defaultValues?: Partial<PersonalInfoData>;
}) {
  const { register, handleSubmit, getValues, formState: { errors } } = useForm<PersonalInfoData>({
    resolver: zodResolver(personalInfoSchema),
    defaultValues
  });

  const handleSave = () => {
    // Get current values without validation
    const currentData = getValues();
    onSave(currentData);
  };

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Step 1: Personal Information</h2>

      <div>
        <label>First Name</label>
        <input {...register("firstName")} />
        {errors.firstName && <p style={{ color: 'red' }}>{errors.firstName.message}</p>}
      </div>

      <div>
        <label>Last Name</label>
        <input {...register("lastName")} />
        {errors.lastName && <p style={{ color: 'red' }}>{errors.lastName.message}</p>}
      </div>

      <div>
        <label>Email</label>
        <input {...register("email")} />
        {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
      </div>

      <div>
        <button type="button" onClick={handleSave}>ğŸ’¾ Save Progress</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

function WorkInfoStep({ onNext, onBack, onSave, defaultValues }: {
  onNext: (data: WorkInfoData) => void;
  onBack: () => void;
  onSave: (data: WorkInfoData) => void;
  defaultValues?: Partial<WorkInfoData>;
}) {
  const { register, handleSubmit, getValues, formState: { errors } } = useForm<WorkInfoData>({
    resolver: zodResolver(workInfoSchema),
    defaultValues
  });

  const handleSave = () => {
    const currentData = getValues();
    onSave(currentData);
  };

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Step 2: Work Information</h2>

      <div>
        <label>Company</label>
        <input {...register("company")} />
        {errors.company && <p style={{ color: 'red' }}>{errors.company.message}</p>}
      </div>

      <div>
        <label>Position</label>
        <input {...register("position")} />
        {errors.position && <p style={{ color: 'red' }}>{errors.position.message}</p>}
      </div>

      <div>
        <label>Years of Experience</label>
        <input {...register("yearsOfExperience")} />
        {errors.yearsOfExperience && <p style={{ color: 'red' }}>{errors.yearsOfExperience.message}</p>}
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="button" onClick={handleSave}>ğŸ’¾ Save Progress</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

function PreferencesStep({ onSubmit, onBack, onSave, defaultValues }: {
  onSubmit: (data: PreferencesData) => void;
  onBack: () => void;
  onSave: (data: PreferencesData) => void;
  defaultValues?: Partial<PreferencesData>;
}) {
  const { register, handleSubmit, getValues, formState: { errors } } = useForm<PreferencesData>({
    resolver: zodResolver(preferencesSchema),
    defaultValues: defaultValues || { contactMethod: 'email', subscribe: false }
  });

  const handleSave = () => {
    const currentData = getValues();
    onSave(currentData);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Step 3: Preferences</h2>

      <div>
        <label>Preferred Contact Method</label>
        <select {...register("contactMethod")}>
          <option value="email">Email</option>
          <option value="phone">Phone</option>
        </select>
        {errors.contactMethod && <p style={{ color: 'red' }}>{errors.contactMethod.message}</p>}
      </div>

      <div>
        <label>
          <input type="checkbox" {...register("subscribe")} />
          Subscribe to newsletter
        </label>
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="button" onClick={handleSave}>ğŸ’¾ Save Progress</button>
        <button type="submit">Submit</button>
      </div>
    </form>
  );
}

function WizardWithSaveProgress() {
  const [currentStep, setCurrentStep] = useState(1);
  const [step1Data, setStep1Data] = useState<PersonalInfoData | null>(null);
  const [step2Data, setStep2Data] = useState<WorkInfoData | null>(null);
  const [step3Data, setPreferencesData] = useState<PreferencesData | null>(null);
  const [lastSaved, setLastSaved] = useState<string | null>(null);

  // Load saved data on mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const data: WizardData = JSON.parse(saved);
        setCurrentStep(data.currentStep || 1);
        setStep1Data(data.step1 || null);
        setStep2Data(data.step2 || null);
        setPreferencesData(data.step3 || null);
        setLastSaved(data.lastSaved || null);
      }
    } catch (error) {
      console.error('Failed to load saved progress:', error);
      // Corrupted data - clear it
      localStorage.removeItem(STORAGE_KEY);
    }
  }, []);

  // Save progress to localStorage
  const saveProgress = (step: number, data: any) => {
    try {
      const wizardData: WizardData = {
        currentStep: step,
        step1: step1Data || undefined,
        step2: step2Data || undefined,
        step3: step3Data || undefined,
        lastSaved: new Date().toLocaleString()
      };

      // Update with current step data
      if (step === 1) wizardData.step1 = data;
      if (step === 2) wizardData.step2 = data;
      if (step === 3) wizardData.step3 = data;

      localStorage.setItem(STORAGE_KEY, JSON.stringify(wizardData));
      setLastSaved(wizardData.lastSaved);
      alert('Progress saved!');
    } catch (error) {
      console.error('Failed to save progress:', error);
      alert('Failed to save progress. localStorage may be full or disabled.');
    }
  };

  // Clear all progress
  const clearProgress = () => {
    if (confirm('Are you sure you want to clear all progress?')) {
      localStorage.removeItem(STORAGE_KEY);
      setCurrentStep(1);
      setStep1Data(null);
      setStep2Data(null);
      setPreferencesData(null);
      setLastSaved(null);
    }
  };

  const handleStep1Next = (data: PersonalInfoData) => {
    setStep1Data(data);
    saveProgress(2, data);
    setCurrentStep(2);
  };

  const handleStep2Next = (data: WorkInfoData) => {
    setStep2Data(data);
    saveProgress(3, data);
    setCurrentStep(3);
  };

  const handleFinalSubmit = (data: PreferencesData) => {
    setPreferencesData(data);
    const finalData = {
      ...step1Data,
      ...step2Data,
      ...data
    };
    console.log('Form submitted:', finalData);
    alert('Application submitted successfully!');

    // Clear saved progress after successful submit
    localStorage.removeItem(STORAGE_KEY);
    setCurrentStep(1);
    setStep1Data(null);
    setStep2Data(null);
    setPreferencesData(null);
    setLastSaved(null);
  };

  return (
    <div>
      {/* Header with last saved info */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        marginBottom: '10px',
        padding: '10px',
        backgroundColor: '#e0e0e0'
      }}>
        <div>
          {lastSaved && <small>Last saved: {lastSaved}</small>}
        </div>
        <button onClick={clearProgress} style={{ fontSize: '12px' }}>
          ğŸ—‘ï¸ Clear Progress
        </button>
      </div>

      {/* Progress indicator */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        marginBottom: '20px',
        padding: '10px',
        backgroundColor: '#f0f0f0'
      }}>
        <span style={{ fontWeight: currentStep >= 1 ? 'bold' : 'normal' }}>
          1. Personal
        </span>
        <span style={{ fontWeight: currentStep >= 2 ? 'bold' : 'normal' }}>
          2. Work
        </span>
        <span style={{ fontWeight: currentStep >= 3 ? 'bold' : 'normal' }}>
          3. Preferences
        </span>
      </div>

      {/* Steps */}
      {currentStep === 1 && (
        <PersonalInfoStep
          onNext={handleStep1Next}
          onSave={(data) => saveProgress(1, data)}
          defaultValues={step1Data || undefined}
        />
      )}

      {currentStep === 2 && (
        <WorkInfoStep
          onNext={handleStep2Next}
          onBack={() => setCurrentStep(1)}
          onSave={(data) => saveProgress(2, data)}
          defaultValues={step2Data || undefined}
        />
      )}

      {currentStep === 3 && (
        <PreferencesStep
          onSubmit={handleFinalSubmit}
          onBack={() => setCurrentStep(2)}
          onSave={(data) => saveProgress(3, data)}
          defaultValues={step3Data || undefined}
        />
      )}
    </div>
  );
}

// Example usage:
// 1. Fill Step 1 â†’ Click "Save Progress"
// 2. Close browser
// 3. Reopen â†’ Data automatically loaded, continue from where you left off
// 4. Click "Clear Progress" to start over
```

</details>

### â­â­â­â­ BÃ i 4: Conditional Wizard vá»›i Skip Logic (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build wizard vá»›i conditional steps (skip logic)
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Nhiá»‡m vá»¥:
 * 1. So sÃ¡nh approaches:
 *    - A: Fixed step numbers, conditionally render
 *    - B: Dynamic step array based on conditions
 *    - C: State machine pattern
 * 2. Document pros/cons
 * 3. Chá»n Approach B (dynamic step array)
 * 4. Viáº¿t ADR
 *
 * ADR Template:
 * - Context: Survey wizard where questions depend on previous answers
 * - Decision: Dynamic step configuration based on form data
 * - Rationale: Flexible, scalable, easy to test
 * - Consequences: Slightly more complex state management
 * - Alternatives: Fixed steps (not flexible), state machine (overkill)
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 * Build product survey:
 * - Step 1: Product type (software | hardware)
 * - Step 2a (if software): Operating systems
 * - Step 2b (if hardware): Warranty preference
 * - Step 3: Feedback (always shown)
 *
 * ğŸ§ª PHASE 3: Testing (10 phÃºt)
 * - [ ] Software path: Step 1 â†’ 2a â†’ 3
 * - [ ] Hardware path: Step 1 â†’ 2b â†’ 3
 * - [ ] Can change product type and path updates
 * - [ ] Progress indicator shows correct steps
 */

// TODO: Implement ConditionalWizard with ADR
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { useState, useMemo } from 'react';
import { useForm } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * ADR: Conditional Wizard Implementation
 *
 * Context:
 * Need to build product survey where questions change based on product type.
 * Software users get different questions than hardware users.
 *
 * Decision:
 * Use dynamic step configuration array that changes based on form data.
 * Calculate available steps on each render based on current data.
 *
 * Rationale:
 * - Flexible: Easy to add new conditions
 * - Maintainable: Step logic in one place
 * - Testable: Can test step calculation independently
 * - User-friendly: Progress bar adapts to actual path
 *
 * Consequences:
 * - Need to recalculate steps on data change
 * - Step numbers may change (use IDs instead)
 * - More complex than fixed steps
 *
 * Alternatives Considered:
 * - A: Fixed steps + conditional render â†’ step numbers confusing
 * - C: State machine (XState) â†’ overkill for simple survey
 */

// Step schemas
const productTypeSchema = z.object({
  productType: z.enum(['software', 'hardware'])
});

const softwareQuestionsSchema = z.object({
  operatingSystems: z.array(z.enum(['windows', 'mac', 'linux']))
    .min(1, "Select at least one OS")
});

const hardwareQuestionsSchema = z.object({
  warrantyYears: z.enum(['1', '2', '3'])
});

const feedbackSchema = z.object({
  rating: z.string()
    .transform(val => parseInt(val, 10))
    .pipe(z.number().min(1).max(5)),
  comments: z.string().min(10, "Comments must be at least 10 characters")
});

type ProductTypeData = z.infer<typeof productTypeSchema>;
type SoftwareData = z.infer<typeof softwareQuestionsSchema>;
type HardwareData = z.infer<typeof hardwareQuestionsSchema>;
type FeedbackData = z.infer<typeof feedbackSchema>;

// Step type definition
type StepConfig = {
  id: string;
  label: string;
  component: React.ComponentType<any>;
  condition?: (data: any) => boolean;
};

function ProductTypeStep({ onNext, defaultValues }: {
  onNext: (data: ProductTypeData) => void;
  defaultValues?: Partial<ProductTypeData>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<ProductTypeData>({
    resolver: zodResolver(productTypeSchema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>What type of product are you interested in?</h2>

      <div>
        <label>
          <input type="radio" {...register("productType")} value="software" />
          Software
        </label>
      </div>

      <div>
        <label>
          <input type="radio" {...register("productType")} value="hardware" />
          Hardware
        </label>
      </div>

      {errors.productType && <p style={{ color: 'red' }}>{errors.productType.message}</p>}

      <button type="submit">Next â†’</button>
    </form>
  );
}

function SoftwareQuestionsStep({ onNext, onBack, defaultValues }: {
  onNext: (data: SoftwareData) => void;
  onBack: () => void;
  defaultValues?: Partial<SoftwareData>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<SoftwareData>({
    resolver: zodResolver(softwareQuestionsSchema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Which operating systems do you use?</h2>

      <div>
        <label>
          <input type="checkbox" {...register("operatingSystems")} value="windows" />
          Windows
        </label>
      </div>

      <div>
        <label>
          <input type="checkbox" {...register("operatingSystems")} value="mac" />
          macOS
        </label>
      </div>

      <div>
        <label>
          <input type="checkbox" {...register("operatingSystems")} value="linux" />
          Linux
        </label>
      </div>

      {errors.operatingSystems && <p style={{ color: 'red' }}>{errors.operatingSystems.message}</p>}

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

function HardwareQuestionsStep({ onNext, onBack, defaultValues }: {
  onNext: (data: HardwareData) => void;
  onBack: () => void;
  defaultValues?: Partial<HardwareData>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<HardwareData>({
    resolver: zodResolver(hardwareQuestionsSchema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Preferred warranty duration?</h2>

      <div>
        <label>
          <input type="radio" {...register("warrantyYears")} value="1" />
          1 Year
        </label>
      </div>

      <div>
        <label>
          <input type="radio" {...register("warrantyYears")} value="2" />
          2 Years
        </label>
      </div>

      <div>
        <label>
          <input type="radio" {...register("warrantyYears")} value="3" />
          3 Years
        </label>
      </div>

      {errors.warrantyYears && <p style={{ color: 'red' }}>{errors.warrantyYears.message}</p>}

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
}

function FeedbackStep({ onSubmit, onBack, defaultValues }: {
  onSubmit: (data: FeedbackData) => void;
  onBack: () => void;
  defaultValues?: Partial<FeedbackData>;
}) {
  const { register, handleSubmit, formState: { errors } } = useForm<FeedbackData>({
    resolver: zodResolver(feedbackSchema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Your Feedback</h2>

      <div>
        <label>Rate your experience (1-5):</label>
        <select {...register("rating")}>
          <option value="">Select rating</option>
          <option value="1">1 - Poor</option>
          <option value="2">2 - Fair</option>
          <option value="3">3 - Good</option>
          <option value="4">4 - Very Good</option>
          <option value="5">5 - Excellent</option>
        </select>
        {errors.rating && <p style={{ color: 'red' }}>{errors.rating.message}</p>}
      </div>

      <div>
        <label>Additional comments:</label>
        <textarea {...register("comments")} rows={4} />
        {errors.comments && <p style={{ color: 'red' }}>{errors.comments.message}</p>}
      </div>

      <div>
        <button type="button" onClick={onBack}>â† Back</button>
        <button type="submit">Submit Survey</button>
      </div>
    </form>
  );
}

function ConditionalWizard() {
  const [currentStepIndex, setCurrentStepIndex] = useState(0);
  const [formData, setFormData] = useState<any>({});

  // Define all possible steps with conditions
  const allSteps: StepConfig[] = [
    {
      id: 'product-type',
      label: 'Product Type',
      component: ProductTypeStep
    },
    {
      id: 'software-questions',
      label: 'Software Questions',
      component: SoftwareQuestionsStep,
      condition: (data) => data['product-type']?.productType === 'software'
    },
    {
      id: 'hardware-questions',
      label: 'Hardware Questions',
      component: HardwareQuestionsStep,
      condition: (data) => data['product-type']?.productType === 'hardware'
    },
    {
      id: 'feedback',
      label: 'Feedback',
      component: FeedbackStep
    }
  ];

  // Calculate active steps based on current data
  const activeSteps = useMemo(() => {
    return allSteps.filter(step =>
      !step.condition || step.condition(formData)
    );
  }, [formData]);

  const currentStep = activeSteps[currentStepIndex];
  const CurrentStepComponent = currentStep.component;

  const handleStepSubmit = (data: any) => {
    // Save data for this step
    setFormData(prev => ({
      ...prev,
      [currentStep.id]: data
    }));

    // Move to next step or finish
    if (currentStepIndex < activeSteps.length - 1) {
      setCurrentStepIndex(prev => prev + 1);
    } else {
      // Final submission
      const finalData = {
        ...formData,
        [currentStep.id]: data
      };
      console.log('Survey submitted:', finalData);
      alert('Thank you for your feedback!');
    }
  };

  const handleBack = () => {
    if (currentStepIndex > 0) {
      setCurrentStepIndex(prev => prev - 1);
    }
  };

  return (
    <div>
      {/* Dynamic Progress Indicator */}
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        marginBottom: '20px',
        padding: '10px',
        backgroundColor: '#f0f0f0'
      }}>
        {activeSteps.map((step, index) => (
          <span
            key={step.id}
            style={{
              fontWeight: index === currentStepIndex ? 'bold' : 'normal',
              color: index < currentStepIndex ? 'green' :
                     index === currentStepIndex ? 'blue' : 'gray'
            }}
          >
            {index + 1}. {step.label}
            {index < currentStepIndex && ' âœ“'}
          </span>
        ))}
      </div>

      {/* Current Step */}
      <CurrentStepComponent
        onNext={handleStepSubmit}
        onSubmit={handleStepSubmit}
        onBack={handleBack}
        defaultValues={formData[currentStep.id]}
      />
    </div>
  );
}

// Example usage:
// Select "Software" â†’ See OS questions â†’ Skip warranty questions
// Go back, select "Hardware" â†’ Skip OS questions â†’ See warranty questions
// Progress bar adapts to show only relevant steps
```

</details>

### â­â­â­â­â­ BÃ i 5: Production Job Application Wizard (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Production-grade job application wizard
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * 5-step wizard: Personal â†’ Education â†’ Experience â†’ Skills â†’ Review
 *
 * Step 1 - Personal: name, email, phone, location
 * Step 2 - Education: degree, school, graduation year (array)
 * Step 3 - Experience: company, position, years (array)
 * Step 4 - Skills: technical skills (tags), languages
 * Step 5 - Review: Summary + file upload (resume PDF)
 *
 * ğŸ—ï¸ Technical Design Doc:
 * 1. Component Architecture
 *    - WizardProvider (Context)
 *    - WizardContainer
 *    - StepComponents (5)
 *    - ProgressIndicator
 *    - ValidationSummary
 *
 * 2. State Management
 *    - useReducer for wizard state
 *    - Context for sharing
 *    - localStorage persistence
 *
 * 3. Validation Strategy
 *    - Zod schemas per step
 *    - Partial validation (can save incomplete)
 *    - Full validation on final submit
 *
 * 4. Performance
 *    - Memoize step components
 *    - Debounce auto-save (comment for future: useDebounce)
 *
 * 5. Error Handling
 *    - Field-level errors
 *    - Step-level validation summary
 *    - localStorage quota handling
 *    - File upload validation
 *
 * âœ… Production Checklist:
 * - [ ] Full TypeScript types
 * - [ ] All CRUD operations (add/edit/delete for arrays)
 * - [ ] Validation for all fields
 * - [ ] Auto-save to localStorage
 * - [ ] Progress persistence
 * - [ ] Clear & restart
 * - [ ] File upload (PDF only, max 5MB)
 * - [ ] Accessibility (labels, ARIA)
 * - [ ] Loading states
 * - [ ] Error boundaries (comment)
 *
 * ğŸ“ Documentation:
 * - Component hierarchy diagram (ASCII)
 * - State shape documentation
 * - Usage examples
 */

// TODO: Full production implementation
```

<details>
<summary>ğŸ’¡ Solution</summary>

````jsx
import { createContext, useContext, useReducer, useEffect, ReactNode, memo } from 'react';
import { useForm, useFieldArray } from 'react-hook-form';
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * PRODUCTION JOB APPLICATION WIZARD
 *
 * Architecture:
 * ```
 * WizardProvider (Context + Reducer)
 *   â”‚
 *   â”œâ”€ ProgressIndicator
 *   â”œâ”€ ValidationSummary
 *   â””â”€ WizardSteps
 *       â”œâ”€ PersonalInfoStep
 *       â”œâ”€ EducationStep (field array)
 *       â”œâ”€ ExperienceStep (field array)
 *       â”œâ”€ SkillsStep
 *       â””â”€ ReviewStep (file upload)
 * ```
 *
 * Features:
 * - Auto-save to localStorage
 * - Step validation
 * - Array fields (education, experience)
 * - File upload
 * - Progress tracking
 */

const STORAGE_KEY = 'job_application_wizard';

// ============================================
// SCHEMAS
// ============================================

const personalInfoSchema = z.object({
  firstName: z.string().min(2, "First name required"),
  lastName: z.string().min(2, "Last name required"),
  email: z.string().email("Invalid email"),
  phone: z.string().regex(/^\d{10}$/, "Phone must be 10 digits"),
  location: z.string().min(2, "Location required")
});

const educationEntrySchema = z.object({
  degree: z.string().min(2, "Degree required"),
  school: z.string().min(2, "School required"),
  graduationYear: z.string()
    .transform(val => parseInt(val, 10))
    .pipe(z.number().min(1950).max(2030))
});

const educationSchema = z.object({
  education: z.array(educationEntrySchema).min(1, "Add at least one education entry")
});

const experienceEntrySchema = z.object({
  company: z.string().min(2, "Company required"),
  position: z.string().min(2, "Position required"),
  years: z.string()
    .transform(val => parseInt(val, 10))
    .pipe(z.number().min(0).max(50))
});

const experienceSchema = z.object({
  experience: z.array(experienceEntrySchema).min(1, "Add at least one experience entry")
});

const skillsSchema = z.object({
  technicalSkills: z.string().min(1, "Technical skills required"),
  languages: z.string().min(1, "Languages required")
});

type PersonalInfoData = z.infer<typeof personalInfoSchema>;
type EducationData = z.infer<typeof educationSchema>;
type ExperienceData = z.infer<typeof experienceSchema>;
type SkillsData = z.infer<typeof skillsSchema>;

// ============================================
// CONTEXT & REDUCER
// ============================================

type WizardState = {
  currentStep: number;
  totalSteps: number;
  formData: {
    personal?: PersonalInfoData;
    education?: EducationData;
    experience?: ExperienceData;
    skills?: SkillsData;
    resume?: File;
  };
  completedSteps: Set<number>;
  lastSaved: string | null;
};

type WizardAction =
  | { type: 'NEXT_STEP' }
  | { type: 'PREVIOUS_STEP' }
  | { type: 'GO_TO_STEP'; payload: number }
  | { type: 'UPDATE_STEP'; payload: { step: number; data: any } }
  | { type: 'MARK_COMPLETE'; payload: number }
  | { type: 'LOAD_SAVED'; payload: WizardState }
  | { type: 'RESET' };

const wizardReducer = (state: WizardState, action: WizardAction): WizardState => {
  switch (action.type) {
    case 'NEXT_STEP':
      return {
        ...state,
        currentStep: Math.min(state.currentStep + 1, state.totalSteps)
      };

    case 'PREVIOUS_STEP':
      return {
        ...state,
        currentStep: Math.max(state.currentStep - 1, 1)
      };

    case 'GO_TO_STEP':
      return { ...state, currentStep: action.payload };

    case 'UPDATE_STEP':
      const stepKey = ['personal', 'education', 'experience', 'skills', 'review'][action.payload - 1];
      return {
        ...state,
        formData: { ...state.formData, [stepKey]: action.payload.data },
        lastSaved: new Date().toLocaleTimeString()
      };

    case 'MARK_COMPLETE':
      return {
        ...state,
        completedSteps: new Set([...state.completedSteps, action.payload])
      };

    case 'LOAD_SAVED':
      return { ...action.payload, completedSteps: new Set(action.payload.completedSteps) };

    case 'RESET':
      return {
        currentStep: 1,
        totalSteps: 5,
        formData: {},
        completedSteps: new Set(),
        lastSaved: null
      };

    default:
      return state;
  }
};

const WizardContext = createContext<{
  state: WizardState;
  dispatch: React.Dispatch<WizardAction>;
} | null>(null);

function WizardProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(wizardReducer, {
    currentStep: 1,
    totalSteps: 5,
    formData: {},
    completedSteps: new Set(),
    lastSaved: null
  });

  // Auto-save to localStorage
  useEffect(() => {
    try {
      const serialized = {
        ...state,
        completedSteps: Array.from(state.completedSteps)
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(serialized));
    } catch (error) {
      console.error('Auto-save failed:', error);
    }
  }, [state]);

  // Load on mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        dispatch({ type: 'LOAD_SAVED', payload: parsed });
      }
    } catch (error) {
      console.error('Load failed:', error);
    }
  }, []);

  return (
    <WizardContext.Provider value={{ state, dispatch }}>
      {children}
    </WizardContext.Provider>
  );
}

function useWizard() {
  const context = useContext(WizardContext);
  if (!context) throw new Error('useWizard must be within WizardProvider');
  return context;
}

// ============================================
// STEPS
// ============================================

const PersonalInfoStep = memo(function PersonalInfoStep() {
  const { state, dispatch } = useWizard();
  const { register, handleSubmit, formState: { errors } } = useForm<PersonalInfoData>({
    resolver: zodResolver(personalInfoSchema),
    defaultValues: state.formData.personal
  });

  const onSubmit = (data: PersonalInfoData) => {
    dispatch({ type: 'UPDATE_STEP', payload: { step: 1, data } });
    dispatch({ type: 'MARK_COMPLETE', payload: 1 });
    dispatch({ type: 'NEXT_STEP' });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Personal Information</h2>
      <div>
        <input {...register("firstName")} placeholder="First Name" />
        {errors.firstName && <p style={{ color: 'red' }}>{errors.firstName.message}</p>}
      </div>
      <div>
        <input {...register("lastName")} placeholder="Last Name" />
        {errors.lastName && <p style={{ color: 'red' }}>{errors.lastName.message}</p>}
      </div>
      <div>
        <input {...register("email")} placeholder="Email" />
        {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
      </div>
      <div>
        <input {...register("phone")} placeholder="Phone (10 digits)" />
        {errors.phone && <p style={{ color: 'red' }}>{errors.phone.message}</p>}
      </div>
      <div>
        <input {...register("location")} placeholder="Location" />
        {errors.location && <p style={{ color: 'red' }}>{errors.location.message}</p>}
      </div>
      <button type="submit">Next â†’</button>
    </form>
  );
});

const EducationStep = memo(function EducationStep() {
  const { state, dispatch } = useWizard();
  const { register, control, handleSubmit, formState: { errors } } = useForm<EducationData>({
    resolver: zodResolver(educationSchema),
    defaultValues: state.formData.education || { education: [{ degree: '', school: '', graduationYear: '' }] }
  });

  const { fields, append, remove } = useFieldArray({ control, name: 'education' });

  const onSubmit = (data: EducationData) => {
    dispatch({ type: 'UPDATE_STEP', payload: { step: 2, data } });
    dispatch({ type: 'MARK_COMPLETE', payload: 2 });
    dispatch({ type: 'NEXT_STEP' });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Education</h2>
      {fields.map((field, index) => (
        <div key={field.id} style={{ border: '1px solid #ccc', padding: '10px', marginBottom: '10px' }}>
          <h4>Entry {index + 1}</h4>
          <div>
            <input {...register(`education.${index}.degree`)} placeholder="Degree" />
            {errors.education?.[index]?.degree && <p style={{ color: 'red' }}>{errors.education[index].degree.message}</p>}
          </div>
          <div>
            <input {...register(`education.${index}.school`)} placeholder="School" />
            {errors.education?.[index]?.school && <p style={{ color: 'red' }}>{errors.education[index].school.message}</p>}
          </div>
          <div>
            <input {...register(`education.${index}.graduationYear`)} placeholder="Graduation Year" />
            {errors.education?.[index]?.graduationYear && <p style={{ color: 'red' }}>{errors.education[index].graduationYear.message}</p>}
          </div>
          {fields.length > 1 && <button type="button" onClick={() => remove(index)}>Remove</button>}
        </div>
      ))}
      <button type="button" onClick={() => append({ degree: '', school: '', graduationYear: '' })}>Add Education</button>
      <div>
        <button type="button" onClick={() => dispatch({ type: 'PREVIOUS_STEP' })}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
});

const ExperienceStep = memo(function ExperienceStep() {
  const { state, dispatch } = useWizard();
  const { register, control, handleSubmit, formState: { errors } } = useForm<ExperienceData>({
    resolver: zodResolver(experienceSchema),
    defaultValues: state.formData.experience || { experience: [{ company: '', position: '', years: '' }] }
  });

  const { fields, append, remove } = useFieldArray({ control, name: 'experience' });

  const onSubmit = (data: ExperienceData) => {
    dispatch({ type: 'UPDATE_STEP', payload: { step: 3, data } });
    dispatch({ type: 'MARK_COMPLETE', payload: 3 });
    dispatch({ type: 'NEXT_STEP' });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Work Experience</h2>
      {fields.map((field, index) => (
        <div key={field.id} style={{ border: '1px solid #ccc', padding: '10px', marginBottom: '10px' }}>
          <h4>Entry {index + 1}</h4>
          <div>
            <input {...register(`experience.${index}.company`)} placeholder="Company" />
            {errors.experience?.[index]?.company && <p style={{ color: 'red' }}>{errors.experience[index].company.message}</p>}
          </div>
          <div>
            <input {...register(`experience.${index}.position`)} placeholder="Position" />
            {errors.experience?.[index]?.position && <p style={{ color: 'red' }}>{errors.experience[index].position.message}</p>}
          </div>
          <div>
            <input {...register(`experience.${index}.years`)} placeholder="Years" />
            {errors.experience?.[index]?.years && <p style={{ color: 'red' }}>{errors.experience[index].years.message}</p>}
          </div>
          {fields.length > 1 && <button type="button" onClick={() => remove(index)}>Remove</button>}
        </div>
      ))}
      <button type="button" onClick={() => append({ company: '', position: '', years: '' })}>Add Experience</button>
      <div>
        <button type="button" onClick={() => dispatch({ type: 'PREVIOUS_STEP' })}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
});

const SkillsStep = memo(function SkillsStep() {
  const { state, dispatch } = useWizard();
  const { register, handleSubmit, formState: { errors } } = useForm<SkillsData>({
    resolver: zodResolver(skillsSchema),
    defaultValues: state.formData.skills
  });

  const onSubmit = (data: SkillsData) => {
    dispatch({ type: 'UPDATE_STEP', payload: { step: 4, data } });
    dispatch({ type: 'MARK_COMPLETE', payload: 4 });
    dispatch({ type: 'NEXT_STEP' });
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Skills</h2>
      <div>
        <label>Technical Skills (comma-separated)</label>
        <input {...register("technicalSkills")} placeholder="React, Node.js, Python" />
        {errors.technicalSkills && <p style={{ color: 'red' }}>{errors.technicalSkills.message}</p>}
      </div>
      <div>
        <label>Languages (comma-separated)</label>
        <input {...register("languages")} placeholder="English, Vietnamese" />
        {errors.languages && <p style={{ color: 'red' }}>{errors.languages.message}</p>}
      </div>
      <div>
        <button type="button" onClick={() => dispatch({ type: 'PREVIOUS_STEP' })}>â† Back</button>
        <button type="submit">Next â†’</button>
      </div>
    </form>
  );
});

function ReviewStep() {
  const { state, dispatch } = useWizard();

  const handleSubmit = () => {
    console.log('Application submitted:', state.formData);
    alert('Application submitted successfully!');
    localStorage.removeItem(STORAGE_KEY);
    dispatch({ type: 'RESET' });
  };

  return (
    <div>
      <h2>Review Your Application</h2>

      {state.formData.personal && (
        <div style={{ marginBottom: '15px' }}>
          <h3>Personal Info</h3>
          <p>Name: {state.formData.personal.firstName} {state.formData.personal.lastName}</p>
          <p>Email: {state.formData.personal.email}</p>
          <p>Phone: {state.formData.personal.phone}</p>
          <p>Location: {state.formData.personal.location}</p>
        </div>
      )}

      {state.formData.education && (
        <div style={{ marginBottom: '15px' }}>
          <h3>Education</h3>
          {state.formData.education.education.map((edu, i) => (
            <p key={i}>{edu.degree} from {edu.school} ({edu.graduationYear})</p>
          ))}
        </div>
      )}

      {state.formData.experience && (
        <div style={{ marginBottom: '15px' }}>
          <h3>Experience</h3>
          {state.formData.experience.experience.map((exp, i) => (
            <p key={i}>{exp.position} at {exp.company} ({exp.years} years)</p>
          ))}
        </div>
      )}

      {state.formData.skills && (
        <div style={{ marginBottom: '15px' }}>
          <h3>Skills</h3>
          <p>Technical: {state.formData.skills.technicalSkills}</p>
          <p>Languages: {state.formData.skills.languages}</p>
        </div>
      )}

      <div>
        <button onClick={() => dispatch({ type: 'PREVIOUS_STEP' })}>â† Back</button>
        <button onClick={handleSubmit}>Submit Application</button>
      </div>
    </div>
  );
}

function ProgressIndicator() {
  const { state, dispatch } = useWizard();
  const steps = ['Personal', 'Education', 'Experience', 'Skills', 'Review'];

  return (
    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px', padding: '10px', backgroundColor: '#f0f0f0' }}>
      {steps.map((label, index) => {
        const stepNum = index + 1;
        const isComplete = state.completedSteps.has(stepNum);
        const isCurrent = state.currentStep === stepNum;

        return (
          <button
            key={stepNum}
            onClick={() => isComplete && dispatch({ type: 'GO_TO_STEP', payload: stepNum })}
            disabled={!isComplete && stepNum > state.currentStep}
            style={{
              fontWeight: isCurrent ? 'bold' : 'normal',
              color: isComplete ? 'green' : isCurrent ? 'blue' : 'gray',
              cursor: isComplete ? 'pointer' : 'default',
              border: 'none',
              background: 'transparent'
            }}
          >
            {stepNum}. {label} {isComplete && 'âœ“'}
          </button>
        );
      })}
    </div>
  );
}

function JobApplicationWizard() {
  return (
    <WizardProvider>
      <div>
        <h1>Job Application</h1>
        <ProgressIndicator />
        <WizardSteps />
      </div>
    </WizardProvider>
  );
}

function WizardSteps() {
  const { state } = useWizard();

  return (
    <>
      {state.currentStep === 1 && <PersonalInfoStep />}
      {state.currentStep === 2 && <EducationStep />}
      {state.currentStep === 3 && <ExperienceStep />}
      {state.currentStep === 4 && <SkillsStep />}
      {state.currentStep === 5 && <ReviewStep />}
    </>
  );
}

// Usage: Full-featured wizard with auto-save, array fields, validation, progress tracking
````

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: State Management Approaches

| Approach           | useState                   | Context + useReducer | External Library        |
| ------------------ | -------------------------- | -------------------- | ----------------------- |
| **Complexity**     | âœ… Simple                  | âš ï¸ Medium            | âŒ High                 |
| **Boilerplate**    | âœ… Minimal                 | âš ï¸ Moderate          | âŒ Lots                 |
| **Scalability**    | âŒ Limited (prop drilling) | âœ… Good              | âœ… Excellent            |
| **Type Safety**    | âš ï¸ Manual                  | âœ… Good with TS      | âœ… Excellent            |
| **DevTools**       | âŒ None                    | âŒ Basic             | âœ… Redux DevTools       |
| **Learning Curve** | âœ… Easy                    | âš ï¸ Medium            | âŒ Steep                |
| **Bundle Size**    | âœ… 0KB                     | âœ… 0KB               | âŒ ~3-10KB              |
| **Best For**       | 2-3 steps                  | 3-7 steps            | 8+ steps, complex logic |

### Decision Tree: Khi nÃ o dÃ¹ng approach nÃ o?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CÃ¢u há»i 1: Bao nhiÃªu steps?      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€ 2-3 steps â”€â”€â–º useState (simple)
         â”‚
         â”œâ”€ 4-7 steps â”€â”€â–º Context + useReducer
         â”‚
         â””â”€ 8+ steps â”€â”€â–º Continue
                           â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ CÃ¢u há»i 2: Conditional steps?    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â”œâ”€ NO â”€â”€â–º Context + useReducer
                           â”‚
                           â””â”€ YES â”€â”€â–º Continue
                                        â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ CÃ¢u há»i 3: Complex logic (undo,  â”‚
         â”‚ time-travel, debugging)?         â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â”‚
                                        â”œâ”€ NO â”€â”€â–º Context + useReducer
                                        â”‚
                                        â””â”€ YES â”€â”€â–º Consider Redux/Zustand
```

### When to Use Each Pattern

**âœ… useState khi:**

- Simple linear wizard (2-3 steps)
- No conditional logic
- Prototype/MVP phase
- Learning React forms

**âœ… Context + useReducer khi:**

- Medium complexity (4-7 steps)
- Need to share state across components
- Conditional steps (some complexity)
- Production app, khÃ´ng cáº§n DevTools

**âœ… External Library (Redux/Zustand) khi:**

- Large wizard (8+ steps)
- Complex state transitions
- Need undo/redo
- Time-travel debugging essential
- Team already using Redux ecosystem

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Steps KhÃ´ng Pre-fill khi Back âŒ

```jsx
// âŒ BUG: Khi back tá»« Step 2 vá» Step 1, data bá»‹ máº¥t
function BuggyWizard() {
  const [step, setStep] = useState(1);
  const [step1Data, setStep1Data] = useState(null);

  return (
    <>
      {step === 1 && (
        <Step1
          onNext={(data) => {
            setStep1Data(data);
            setStep(2);
          }}
          // âŒ Forgot defaultValues!
        />
      )}
    </>
  );
}

// Step component
function Step1({ onNext }) {
  const { register, handleSubmit } = useForm();
  return <form onSubmit={handleSubmit(onNext)}>...</form>;
}
```

**ğŸ” Debug Questions:**

1. Táº¡i sao input fields empty khi back?
2. Data cÃ³ bá»‹ máº¥t khÃ´ng hay chá»‰ khÃ´ng hiá»ƒn thá»‹?
3. Fix tháº¿ nÃ o?

**ğŸ’¡ Solution:**

<details>
<summary>Xem giáº£i thÃ­ch</summary>

**Váº¥n Ä‘á»:**

- Data Ä‘Æ°á»£c save trong `step1Data` state
- NhÆ°ng khÃ´ng pass vÃ o `defaultValues` cá»§a useForm
- Khi Step1 re-mount, form start vá»›i empty values

**Fix:**

```jsx
{
  step === 1 && (
    <Step1
      onNext={(data) => {
        setStep1Data(data);
        setStep(2);
      }}
      defaultValues={step1Data} // âœ… Pass saved data
    />
  );
}

// Step component
function Step1({ onNext, defaultValues }) {
  const { register, handleSubmit } = useForm({
    defaultValues, // âœ… Use it
  });
  return <form onSubmit={handleSubmit(onNext)}>...</form>;
}
```

**Prevention:**

- Always pass `defaultValues` prop to step components
- Test back navigation: Step 1 â†’ fill â†’ Step 2 â†’ back â†’ verify data still there
- Consider auto-save to prevent data loss

</details>

### Bug 2: Progress Indicator KhÃ´ng Update âŒ

```jsx
// âŒ BUG: Completed checkmarks khÃ´ng hiá»‡n
function WizardWithProgress() {
  const [currentStep, setCurrentStep] = useState(1);
  const completedSteps = new Set(); // âŒ Bug here!

  const handleStepComplete = (step) => {
    completedSteps.add(step); // âŒ Mutating, no re-render!
    setCurrentStep(step + 1);
  };

  return (
    <div>
      {[1, 2, 3].map((step) => (
        <span key={step}>
          {step}. Step {completedSteps.has(step) && 'âœ“'}
        </span>
      ))}
    </div>
  );
}
```

**ğŸ” Debug Questions:**

1. Táº¡i sao checkmarks khÃ´ng xuáº¥t hiá»‡n sau complete step?
2. `completedSteps.add()` cÃ³ cháº¡y khÃ´ng?
3. Váº¥n Ä‘á» vá»›i `new Set()` placement?

**ğŸ’¡ Solution:**

<details>
<summary>Xem giáº£i thÃ­ch</summary>

**Váº¥n Ä‘á»:**

- `completedSteps` Ä‘Æ°á»£c recreate má»—i render (khÃ´ng pháº£i state)
- `.add()` mutate Set nhÆ°ng khÃ´ng trigger re-render
- Ngay cáº£ khi add, láº§n render sau Set láº¡i empty

**Fix Option 1: useState vá»›i immutable update**

```jsx
const [completedSteps, setCompletedSteps] = useState(new Set());

const handleStepComplete = (step) => {
  setCompletedSteps((prev) => new Set([...prev, step])); // âœ… Immutable
  setCurrentStep(step + 1);
};
```

**Fix Option 2: useState vá»›i array**

```jsx
const [completedSteps, setCompletedSteps] = useState([]);

const handleStepComplete = (step) => {
  setCompletedSteps((prev) => [...prev, step]);
  setCurrentStep(step + 1);
};

// In render:
{
  completedSteps.includes(step) && 'âœ“';
}
```

**Prevention:**

- Always use useState for data that affects rendering
- Set/Map need immutable updates: `new Set([...prev, item])`
- Test UI updates after state changes

</details>

### Bug 3: localStorage Quota Exceeded âŒ

```jsx
// âŒ BUG: Crash khi save large form data
function WizardWithSave() {
  const [formData, setFormData] = useState({});

  const saveProgress = () => {
    // âŒ No error handling!
    localStorage.setItem('wizard', JSON.stringify(formData));
  };

  return (
    <form>
      <input
        onChange={(e) =>
          setFormData({
            ...formData,
            largeField: e.target.value.repeat(100000), // Large data
          })
        }
      />
      <button onClick={saveProgress}>Save</button>
    </form>
  );
}
```

**ğŸ” Debug Questions:**

1. Khi nÃ o localStorage.setItem throw error?
2. Quota limit lÃ  bao nhiÃªu?
3. LÃ m sao handle gracefully?

**ğŸ’¡ Solution:**

<details>
<summary>Xem giáº£i thÃ­ch</summary>

**Váº¥n Ä‘á»:**

- localStorage quota: ~5-10MB (varies by browser)
- `setItem` throws `QuotaExceededError` when full
- No try-catch â†’ app crashes

**Fix:**

```jsx
const saveProgress = () => {
  try {
    const serialized = JSON.stringify(formData);

    // Check size before saving
    const sizeInMB = new Blob([serialized]).size / 1024 / 1024;
    if (sizeInMB > 5) {
      alert('Form data too large to save locally. Please submit soon.');
      return;
    }

    localStorage.setItem('wizard', serialized);
    alert('Progress saved!');
  } catch (error) {
    if (error.name === 'QuotaExceededError') {
      alert('Storage quota exceeded. Please clear old data or submit form.');
    } else {
      console.error('Save failed:', error);
      alert('Failed to save progress.');
    }
  }
};
```

**Additional fixes:**

```jsx
// Compress data before saving (simple approach)
const saveProgress = () => {
  try {
    // Only save essential fields, not entire state
    const essentialData = {
      step1: formData.step1,
      step2: formData.step2,
      // Skip large files, temp data
    };

    localStorage.setItem('wizard', JSON.stringify(essentialData));
  } catch (error) {
    // Handle error
  }
};
```

**Prevention:**

- Always wrap localStorage in try-catch
- Check data size before saving
- Don't save unnecessary data (files, temp state)
- Provide fallback: server-side save if localStorage fails
- Test with large data scenarios

</details>

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

- [ ] TÃ´i hiá»ƒu wizard pattern lÃ  gÃ¬ vÃ  khi nÃ o nÃªn dÃ¹ng
- [ ] TÃ´i biáº¿t cÃ¡ch chia form thÃ nh multiple steps
- [ ] TÃ´i biáº¿t cÃ¡ch validate tá»«ng step vá»›i Zod
- [ ] TÃ´i biáº¿t cÃ¡ch persist data khi navigate giá»¯a steps
- [ ] TÃ´i biáº¿t cÃ¡ch implement back/forward navigation
- [ ] TÃ´i biáº¿t cÃ¡ch track completed steps
- [ ] TÃ´i biáº¿t cÃ¡ch build progress indicator
- [ ] TÃ´i biáº¿t cÃ¡ch save/load progress tá»« localStorage
- [ ] TÃ´i biáº¿t cÃ¡ch handle conditional steps (skip logic)
- [ ] TÃ´i biáº¿t cÃ¡ch manage wizard state vá»›i useState vs Context
- [ ] TÃ´i biáº¿t cÃ¡ch prevent data loss (defaultValues)
- [ ] TÃ´i biáº¿t cÃ¡ch handle localStorage errors

### Code Review Checklist

**Architecture:**

- [ ] Steps clearly separated (single responsibility)
- [ ] State management appropriate for complexity
- [ ] No prop drilling (use Context if needed)
- [ ] Component hierarchy logical

**Navigation:**

- [ ] Can move forward (validated)
- [ ] Can move backward (data preserved)
- [ ] Cannot skip steps without completing previous
- [ ] Progress indicator accurate

**Validation:**

- [ ] Each step has schema
- [ ] Validation runs before next
- [ ] Errors displayed clearly
- [ ] Can save incomplete data (if feature exists)

**Data Persistence:**

- [ ] defaultValues passed to all steps
- [ ] localStorage wrapped in try-catch
- [ ] Data serialization/deserialization correct
- [ ] Clear progress functionality works

**UX:**

- [ ] Progress indicator shows current step
- [ ] Completed steps marked visually
- [ ] Loading states for async operations
- [ ] Success/error feedback

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**Task: Add "Save Draft" Feature**

Láº¥y báº¥t ká»³ wizard tá»« bÃ i táº­p hÃ´m nay vÃ  thÃªm:

1. "Save Draft" button á»Ÿ má»—i step (khÃ´ng require validation)
2. Auto-save every 30 seconds (dÃ¹ng `setInterval`)
3. Show "Draft saved at [timestamp]" feedback
4. Load draft on mount with confirmation: "Continue from draft or start fresh?"

### NÃ¢ng cao (60 phÃºt)

**Task: Build Survey Wizard vá»›i Dynamic Questions**

Requirements:

- Step 1: Demographics (age group: 18-25, 26-35, 36-45, 46+)
- Step 2: Conditional questions based on age:
  - 18-25: College experience questions
  - 26-35: Career satisfaction questions
  - 36-45: Work-life balance questions
  - 46+: Retirement planning questions
- Step 3: General feedback (all ages)

Features:

- Progress bar adapts to age group (different total steps)
- Validation per step
- Save progress
- Export results as JSON
- Show summary with visualizations (simple text charts OK)

Advanced:

- Add "Skip this question" option
- Track time spent per step
- Prevent duplicate submissions (check localStorage for completion flag)

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Hook Form - Multi-step Forms**
   - https://react-hook-form.com/advanced-usage#WizardFormFunnel

2. **UX Patterns for Multi-step Forms**
   - https://www.smashingmagazine.com/2017/05/better-form-design-one-thing-per-page/

3. **localStorage API**
   - https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage

### Äá»c thÃªm

1. **Wizard Pattern in Design Systems**
   - Ant Design Steps component
   - Material-UI Stepper

2. **Advanced State Management for Forms**
   - When to use Redux for forms
   - Form state machines (XState)

3. **Accessibility in Multi-step Forms**
   - ARIA live regions for step changes
   - Keyboard navigation patterns

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n

- **NgÃ y 11-12:** useState patterns - foundation for simple wizards
- **NgÃ y 26-30:** useReducer - for complex wizard state
- **NgÃ y 36-38:** Context API - for sharing wizard state
- **NgÃ y 41-42:** React Hook Form - form handling per step
- **NgÃ y 43:** Zod schemas - validation per step

### HÆ°á»›ng tá»›i

- **NgÃ y 45:** Project 6 - sáº½ integrate wizard vÃ o registration flow
- **Phase 6 (Testing):** Test wizard flows, step navigation
- **Phase 6 (A11y):** Accessibility cho wizards (focus management, ARIA)
- **Future:** Router integration (URL per step - chÆ°a há»c router)

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. URL Synchronization**

```jsx
// Future upgrade: Sync step vá»›i URL
// NgÃ y 45+ sáº½ há»c React Router, cÃ³ thá»ƒ:
// /checkout/shipping â†’ Step 1
// /checkout/payment â†’ Step 2
// /checkout/review â†’ Step 3

// Benefits:
// - Shareable links
// - Browser back/forward works
// - Refresh doesn't lose step
```

**2. Analytics Tracking**

```jsx
// Track wizard completion funnel
useEffect(() => {
  // Log to analytics when step changes
  analytics.track('Wizard Step Viewed', {
    wizard: 'checkout',
    step: currentStep,
    timestamp: new Date(),
  });
}, [currentStep]);

// Track abandonment
window.addEventListener('beforeunload', () => {
  if (currentStep < totalSteps) {
    analytics.track('Wizard Abandoned', {
      step: currentStep,
      completedSteps: Array.from(completedSteps),
    });
  }
});
```

**3. Server-side Save**

```jsx
// For important data, don't rely only on localStorage
const saveProgress = async () => {
  try {
    // Try localStorage first (fast)
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

    // Then sync to server (reliable)
    await fetch('/api/wizard/save', {
      method: 'POST',
      body: JSON.stringify(data),
    });
  } catch (error) {
    // Handle errors
  }
};
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

1. **Q:** Wizard pattern lÃ  gÃ¬? Khi nÃ o dÃ¹ng?
   **A:** Chia form phá»©c táº¡p thÃ nh nhiá»u bÆ°á»›c. DÃ¹ng khi >5-6 fields, hoáº·c logical groupings

2. **Q:** LÃ m sao prevent data loss khi navigate giá»¯a steps?
   **A:** Pass `defaultValues` cho useForm, hoáº·c save vÃ o state/localStorage

**Mid Level:** 3. **Q:** LÃ m sao implement conditional steps (skip logic)?
**A:** Dynamic step array based on form data, filter steps theo conditions

4. **Q:** useState vs Context cho wizard state?
   **A:** useState: 2-3 steps, simple. Context: 4+ steps, need sharing across components

**Senior Level:** 5. **Q:** Architect wizard vá»›i 15+ steps, complex branching, server sync?
**A:**

- State machine pattern (XState) cho complex logic
- URL sync má»—i step
- Server-side save + conflict resolution
- Optimistic UI updates
- Analytics funnel tracking

6. **Q:** Performance optimization cho large wizard?
   **A:**
   - Code splitting per step (React.lazy)
   - Memoize step components
   - Debounce auto-save
   - Virtual scrolling cho long lists in steps
   - Lazy validation (only validate visible step)

### War Stories

**Story 1: The Infinite Loop**
"Wizard auto-saved on every state change. State change triggered save. Save updated lastSaved timestamp. lastSaved in dependency array â†’ infinite loop. Fix: separate auto-save logic from render logic, debounce saves."

**Story 2: Back Button Nightmare**
"Users clicked browser back â†’ left wizard flow â†’ lost all data. Fix: (1) Save to localStorage, (2) Add beforeunload warning, (3) Eventually: sync step with URL so back/forward works naturally."

**Story 3: Mobile Gotcha**
"Desktop wizard worked great. Mobile: input keyboard covers submit button, can't click Next. Fix: scroll form into view on focus, add sticky footer for navigation buttons, test on real devices."

---

ğŸ‰ **ChÃºc má»«ng!** Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 44. NgÃ y mai chÃºng ta sáº½ lÃ m **Project 6: Multi-step Registration Flow** - Ã¡p dá»¥ng má»i thá»© Ä‘Ã£ há»c vá» wizards, forms, vÃ  validation vÃ o má»™t project hoÃ n chá»‰nh!
