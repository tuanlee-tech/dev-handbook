# üìÖ NG√ÄY 40: Component Patterns - Part 2 (Legacy Patterns)

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

- [ ] Hi·ªÉu Render Props pattern v√† t·∫°i sao n√≥ t·ª´ng ph·ªï bi·∫øn
- [ ] Hi·ªÉu Higher-Order Components (HOCs) pattern v√† use cases
- [ ] So s√°nh ƒë∆∞·ª£c legacy patterns v·ªõi modern Hooks approach
- [ ] Bi·∫øt c√°ch migrate code t·ª´ Render Props/HOCs sang Hooks
- [ ] Nh·∫≠n bi·∫øt khi n√†o ƒë·ªçc code legacy v√† refactor an to√†n

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

1. **Custom Hooks** (Ng√†y 24): L√†m sao share logic gi·ªØa components b·∫±ng Hooks?
2. **Compound Components** (Ng√†y 39): L√†m sao share state implicit gi·ªØa parent/children?
3. **Context API** (Ng√†y 36-38): T·∫°i sao Context t·ªët h∆°n props drilling?

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø - L·ªãch S·ª≠ React Patterns

**Timeline React Patterns:**

```
2013-2015: Class Components + Mixins
‚îú‚îÄ Problem: Mixins cause name collisions
‚îú‚îÄ Solution needed: Better composition

2016-2018: Higher-Order Components (HOCs)
‚îú‚îÄ Pattern: Wrap components to add behavior
‚îú‚îÄ Problem: Wrapper hell, props collision
‚îú‚îÄ Still better than Mixins

2017-2018: Render Props
‚îú‚îÄ Pattern: Function as child
‚îú‚îÄ Problem: Callback hell, hard to read
‚îú‚îÄ Better flexibility than HOCs

2019-Present: Hooks üéâ
‚îú‚îÄ Pattern: Reusable stateful logic
‚îú‚îÄ Solution: Cleaner, more composable
‚îî‚îÄ Current standard
```

**T√¨nh hu·ªëng th·ª±c t·∫ø:**

```jsx
// B·∫°n join c√¥ng ty, ƒë·ªçc codebase c≈©:

// ‚ùå Code style 2017 - Render Props
<MouseTracker>
  {({ x, y }) => (
    <DataFetcher url='/api/users'>
      {({ data, loading }) => (
        <Theme>
          {({ theme }) => (
            <div>
              Mouse: {x}, {y}
              Data: {loading ? 'Loading...' : data}
              Theme: {theme}
            </div>
          )}
        </Theme>
      )}
    </DataFetcher>
  )}
</MouseTracker>;

// ‚ùå Code style 2018 - HOCs
const Enhanced = withMouse(withData(withTheme(Component)));

// ‚úÖ Code style 2024 - Hooks
function Component() {
  const { x, y } = useMouse();
  const { data, loading } = useFetch('/api/users');
  const { theme } = useTheme();

  return (
    <div>
      Mouse: {x}, {y}
      Data: {loading ? 'Loading...' : data}
      Theme: {theme}
    </div>
  );
}
```

**Mission c·ªßa b√†i h·ªçc h√¥m nay:**

- Hi·ªÉu legacy patterns ƒë·ªÉ ƒë·ªçc code c≈©
- Bi·∫øt refactor an to√†n sang Hooks
- Kh√¥ng bao gi·ªù d√πng trong code m·ªõi (tr·ª´ edge cases r·∫•t hi·∫øm)

### 1.2 Render Props Pattern

**ƒê·ªãnh nghƒ©a:** Component nh·∫≠n m·ªôt function (th∆∞·ªùng l√† children ho·∫∑c render prop) v√† g·ªçi function ƒë√≥ v·ªõi data.

**C·∫•u tr√∫c:**

```jsx
// Pattern c∆° b·∫£n
<Component>
  {(data) => <UI>{data}</UI>}
</Component>

// Ho·∫∑c
<Component render={(data) => <UI>{data}</UI>} />
```

**T·∫°i sao pattern n√†y t·ªìn t·∫°i?**

- Tr∆∞·ªõc Hooks, kh√¥ng c√≥ c√°ch n√†o share stateful logic
- C·∫ßn share state/behavior m√† kh√¥ng d√πng inheritance
- Flexible h∆°n HOCs (control render t·ª´ b√™n ngo√†i)

### 1.3 Higher-Order Components (HOCs)

**ƒê·ªãnh nghƒ©a:** Function nh·∫≠n component, return component m·ªõi v·ªõi enhanced behavior.

**C·∫•u tr√∫c:**

```jsx
// HOC l√† function
function withSomething(Component) {
  return function EnhancedComponent(props) {
    // Add behavior here
    return (
      <Component
        {...props}
        extraProp={value}
      />
    );
  };
}

// Usage
const Enhanced = withSomething(MyComponent);
```

**T·∫°i sao pattern n√†y t·ªìn t·∫°i?**

- Reuse component logic
- Add behaviors (logging, auth, data fetching)
- Composition (k·∫øt h·ª£p nhi·ªÅu HOCs)

### 1.4 Mental Model

```
EVOLUTION OF SHARING LOGIC IN REACT:

2013: Mixins
  class MyComponent extends React.Component {
    mixins: [MouseMixin, DataMixin]  ‚ùå Deprecated
  }

2016: HOCs
  const Enhanced = withMouse(withData(Component))
  ‚ö†Ô∏è Works, but wrapper hell

2017: Render Props
  <Mouse>
    {mouse => <Data>{data => <Component />}</Data>}
  </Mouse>
  ‚ö†Ô∏è Works, but callback hell

2019: Hooks
  function Component() {
    const mouse = useMouse();
    const data = useData();
  }
  ‚úÖ Clean, composable, modern

Analogy:
- Mixins = Chung n·ªìi (conflicts)
- HOCs = Matryoshka dolls (wrapper hell)
- Render Props = Nested callbacks (pyramid of doom)
- Hooks = Lego blocks (compose freely) ‚úÖ
```

### 1.5 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

‚ùå **"Render Props v√† HOCs ƒë√£ deprecated"**
‚Üí Kh√¥ng! Ch√∫ng v·∫´n ho·∫°t ƒë·ªông, nh∆∞ng Hooks l√† better approach.

‚ùå **"Kh√¥ng bao gi·ªù ƒë∆∞·ª£c d√πng Render Props/HOCs"**
‚Üí Kh√¥ng h·∫≥n. M·ªôt s·ªë edge cases v·∫´n OK (r·∫•t hi·∫øm), nh∆∞ng default l√† Hooks.

‚ùå **"HOCs gi·ªëng Hooks"**
‚Üí Kh√°c! HOCs wrap components, Hooks compose logic.

‚ùå **"Ph·∫£i refactor t·∫•t c·∫£ code c≈© ngay"**
‚Üí Kh√¥ng! Refactor t·ª´ t·ª´, ∆∞u ti√™n code hay thay ƒë·ªïi.

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Render Props Pattern ‚≠ê

**Mouse Tracker v·ªõi Render Props (Legacy way)**

<details>
<summary>üí° Code Example</summary>

```jsx
/**
 * Mouse Tracker - Render Props Pattern (LEGACY)
 *
 * ‚ö†Ô∏è ƒê√¢y l√† legacy pattern - KH√îNG khuy·∫øn kh√≠ch d√πng
 * M·ª•c ƒë√≠ch: Hi·ªÉu ƒë·ªÉ ƒë·ªçc code c≈©
 *
 * @example
 * <Mouse>
 *   {({ x, y }) => <div>Position: {x}, {y}</div>}
 * </Mouse>
 */

import { useState, useEffect } from 'react';

// ‚ùå LEGACY: Render Props Component
function Mouse({ children, render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);

  // Support c·∫£ 2 patterns: children function ho·∫∑c render prop
  return children ? children(position) : render(position);
}

// Usage - Callback hell khi combine nhi·ªÅu
function AppLegacy() {
  return (
    <div>
      <h2>Legacy: Render Props</h2>

      {/* Pattern 1: Children as function */}
      <Mouse>
        {({ x, y }) => (
          <div style={{ padding: '20px', border: '1px solid blue' }}>
            <h3>Mouse Position (Children)</h3>
            <p>
              X: {x}, Y: {y}
            </p>
          </div>
        )}
      </Mouse>

      {/* Pattern 2: Render prop */}
      <Mouse
        render={({ x, y }) => (
          <div style={{ padding: '20px', border: '1px solid green' }}>
            <h3>Mouse Position (Render Prop)</h3>
            <p>
              X: {x}, Y: {y}
            </p>
          </div>
        )}
      />

      {/* ‚ùå Problem: Callback hell khi nested */}
      <Mouse>
        {({ x, y }) => (
          <WindowSize>
            {({ width, height }) => (
              <div style={{ padding: '20px', border: '1px solid red' }}>
                <p>
                  Mouse: {x}, {y}
                </p>
                <p>
                  Window: {width}x{height}
                </p>
                {/* T∆∞·ªüng t∆∞·ª£ng 5-10 layers nh∆∞ n√†y! */}
              </div>
            )}
          </WindowSize>
        )}
      </Mouse>
    </div>
  );
}

// Helper component for demo
function WindowSize({ children }) {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({ width: window.innerWidth, height: window.innerHeight });
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return children(size);
}

// ‚úÖ MODERN: Hooks approach (so s√°nh)
function useMouse() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);

  return position;
}

function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setSize({ width: window.innerWidth, height: window.innerHeight });
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return size;
}

function AppModern() {
  const { x, y } = useMouse();
  const { width, height } = useWindowSize();

  return (
    <div>
      <h2>Modern: Hooks</h2>
      <div style={{ padding: '20px', border: '1px solid blue' }}>
        <p>
          Mouse: {x}, {y}
        </p>
        <p>
          Window: {width}x{height}
        </p>
        {/* ‚úÖ Flat, readable, no nesting! */}
      </div>
    </div>
  );
}

// Compare side by side
function App() {
  return (
    <div style={{ padding: '20px' }}>
      <AppLegacy />
      <hr style={{ margin: '40px 0' }} />
      <AppModern />
    </div>
  );
}

/*
So s√°nh:

Render Props:
‚ùå Callback hell khi combine nhi·ªÅu
‚ùå Kh√≥ ƒë·ªçc (nested deeply)
‚ùå Kh√≥ debug
‚ùå Performance issues (t·∫°o function m·ªõi m·ªói render)

Hooks:
‚úÖ Flat structure
‚úÖ D·ªÖ ƒë·ªçc
‚úÖ D·ªÖ compose
‚úÖ D·ªÖ test
‚úÖ Better performance
*/
```

</details>

---

### Demo 2: Higher-Order Components (HOCs) ‚≠ê‚≠ê

**withAuth HOC (Legacy pattern)**

<details>
<summary>üí° Code Example</summary>

```jsx
/**
 * Authentication HOC - Higher-Order Component Pattern (LEGACY)
 *
 * ‚ö†Ô∏è Legacy pattern - KH√îNG khuy·∫øn kh√≠ch d√πng
 * M·ª•c ƒë√≠ch: Hi·ªÉu ƒë·ªÉ ƒë·ªçc code c≈©
 *
 * @example
 * const ProtectedPage = withAuth(Dashboard);
 */

import { useState } from 'react';

// ‚ùå LEGACY: HOC Pattern
function withAuth(Component) {
  // Return new component
  return function AuthenticatedComponent(props) {
    const [isAuthenticated] = useState(false); // Gi·∫£ l·∫≠p auth state

    if (!isAuthenticated) {
      return (
        <div style={{ padding: '20px', border: '2px solid red' }}>
          <h3>Access Denied</h3>
          <p>Please login to view this page</p>
        </div>
      );
    }

    // Pass through all props
    return <Component {...props} />;
  };
}

// Another HOC for loading
function withLoading(Component) {
  return function LoadingComponent(props) {
    const [isLoading] = useState(false); // Gi·∫£ l·∫≠p loading

    if (isLoading) {
      return <div>Loading...</div>;
    }

    return <Component {...props} />;
  };
}

// Another HOC for logging
function withLogger(Component) {
  return function LoggedComponent(props) {
    console.log('Component rendered with props:', props);
    return <Component {...props} />;
  };
}

// Base component
function Dashboard({ title, user }) {
  return (
    <div style={{ padding: '20px', border: '1px solid green' }}>
      <h2>{title}</h2>
      <p>Welcome, {user}!</p>
    </div>
  );
}

// ‚ùå Problem: Wrapper hell
const EnhancedDashboard = withAuth(withLoading(withLogger(Dashboard)));

// ‚ùå Problem: Props collision
function withUser(Component) {
  return function UserComponent(props) {
    const user = { name: 'John from HOC' };
    // ‚ö†Ô∏è N·∫øu props c≈©ng c√≥ 'user', s·∫Ω b·ªã override!
    return (
      <Component
        {...props}
        user={user}
      />
    );
  };
}

// ‚ùå Problem: Static composition (kh√¥ng dynamic)
// Ph·∫£i decide HOCs khi define component, kh√¥ng th·ªÉ conditional

// Usage
function AppLegacy() {
  return (
    <div>
      <h2>Legacy: HOCs</h2>
      <EnhancedDashboard
        title='Dashboard'
        user='Alice'
      />
      {/* Component tree:
        withAuth(
          withLoading(
            withLogger(
              Dashboard
            )
          )
        )
        
        ‚Üí 3 wrapper components!
        ‚Üí Hard to debug in DevTools
      */}
    </div>
  );
}

// ‚úÖ MODERN: Hooks approach
function useAuth() {
  const [isAuthenticated] = useState(false);
  return { isAuthenticated };
}

function useLoading() {
  const [isLoading] = useState(false);
  return { isLoading };
}

function useLogger(componentName, props) {
  console.log(`${componentName} rendered with:`, props);
}

function DashboardModern({ title, user }) {
  const { isAuthenticated } = useAuth();
  const { isLoading } = useLoading();

  useLogger('Dashboard', { title, user });

  if (!isAuthenticated) {
    return (
      <div style={{ padding: '20px', border: '2px solid red' }}>
        <h3>Access Denied</h3>
        <p>Please login to view this page</p>
      </div>
    );
  }

  if (isLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div style={{ padding: '20px', border: '1px solid green' }}>
      <h2>{title}</h2>
      <p>Welcome, {user}!</p>
    </div>
  );
}

function AppModern() {
  return (
    <div>
      <h2>Modern: Hooks</h2>
      <DashboardModern
        title='Dashboard'
        user='Alice'
      />
      {/* Component tree: 
        Just DashboardModern
        
        ‚úÖ Flat structure
        ‚úÖ Easy to debug
        ‚úÖ No wrapper hell
      */}
    </div>
  );
}

// Compare
function App() {
  return (
    <div style={{ padding: '20px' }}>
      <AppLegacy />
      <hr style={{ margin: '40px 0' }} />
      <AppModern />
    </div>
  );
}

/*
So s√°nh:

HOCs:
‚ùå Wrapper hell (nhi·ªÅu layers)
‚ùå Props collision risk
‚ùå Hard to debug (DevTools shows wrappers)
‚ùå Static composition
‚ùå Naming conflicts

Hooks:
‚úÖ No wrappers
‚úÖ No props collision
‚úÖ Easy to debug
‚úÖ Dynamic composition
‚úÖ Clear dependencies
*/
```

</details>

---

### Demo 3: Migration Strategy ‚≠ê‚≠ê‚≠ê

**Refactor t·ª´ Legacy sang Hooks**

<details>
<summary>üí° Code Example</summary>

```jsx
/**
 * Migration Guide: Legacy Patterns ‚Üí Modern Hooks
 *
 * Step-by-step refactoring examples
 */

import { useState, useEffect } from 'react';

// =====================================
// EXAMPLE 1: Render Props ‚Üí Hook
// =====================================

// ‚ùå BEFORE: Render Props
function DataFetcherLegacy({ url, children }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, [url]);

  return children({ data, loading, error });
}

// Usage
function UserListLegacy() {
  return (
    <DataFetcherLegacy url='/api/users'>
      {({ data, loading, error }) => {
        if (loading) return <div>Loading...</div>;
        if (error) return <div>Error: {error.message}</div>;
        return <div>Data: {JSON.stringify(data)}</div>;
      }}
    </DataFetcherLegacy>
  );
}

// ‚úÖ AFTER: Custom Hook
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, [url]);

  return { data, loading, error };
}

// Usage - Much cleaner!
function UserListModern() {
  const { data, loading, error } = useFetch('/api/users');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>Data: {JSON.stringify(data)}</div>;
}

// =====================================
// EXAMPLE 2: HOC ‚Üí Hook
// =====================================

// ‚ùå BEFORE: HOC
function withTheme(Component) {
  return function ThemedComponent(props) {
    const [theme] = useState('dark');
    return (
      <Component
        {...props}
        theme={theme}
      />
    );
  };
}

function ButtonLegacy({ theme, children }) {
  return (
    <button
      style={{
        background: theme === 'dark' ? '#333' : '#fff',
        color: theme === 'dark' ? '#fff' : '#000',
      }}
    >
      {children}
    </button>
  );
}

const ThemedButton = withTheme(ButtonLegacy);

// ‚úÖ AFTER: Hook
function useTheme() {
  const [theme] = useState('dark');
  return { theme };
}

function ButtonModern({ children }) {
  const { theme } = useTheme();

  return (
    <button
      style={{
        background: theme === 'dark' ? '#333' : '#fff',
        color: theme === 'dark' ? '#fff' : '#000',
      }}
    >
      {children}
    </button>
  );
}

// =====================================
// EXAMPLE 3: Multiple HOCs ‚Üí Multiple Hooks
// =====================================

// ‚ùå BEFORE: Multiple HOCs
function withAuth(Component) {
  return function (props) {
    const isAuth = true;
    if (!isAuth) return <div>Not authenticated</div>;
    return (
      <Component
        {...props}
        isAuth={isAuth}
      />
    );
  };
}

function withUser(Component) {
  return function (props) {
    const user = { name: 'John' };
    return (
      <Component
        {...props}
        user={user}
      />
    );
  };
}

function withPermissions(Component) {
  return function (props) {
    const canEdit = true;
    return (
      <Component
        {...props}
        canEdit={canEdit}
      />
    );
  };
}

// Wrapper hell!
const ProfileLegacy = withAuth(
  withUser(
    withPermissions(function ({ user, canEdit }) {
      return (
        <div>
          <h2>{user.name}</h2>
          {canEdit && <button>Edit</button>}
        </div>
      );
    }),
  ),
);

// ‚úÖ AFTER: Compose Hooks
function useAuth() {
  const isAuth = true;
  return { isAuth };
}

function useUser() {
  const user = { name: 'John' };
  return { user };
}

function usePermissions() {
  const canEdit = true;
  return { canEdit };
}

function ProfileModern() {
  const { isAuth } = useAuth();
  const { user } = useUser();
  const { canEdit } = usePermissions();

  if (!isAuth) return <div>Not authenticated</div>;

  return (
    <div>
      <h2>{user.name}</h2>
      {canEdit && <button>Edit</button>}
    </div>
  );
}

// =====================================
// MIGRATION CHECKLIST
// =====================================

/*
STEP 1: Identify pattern
- Render Props? ‚Üí Extract to custom hook
- HOC? ‚Üí Extract to custom hook
- Multiple HOCs? ‚Üí Multiple hooks

STEP 2: Extract logic
- Move state management to hook
- Move effects to hook
- Return values needed by component

STEP 3: Update component
- Remove render prop callback
- Remove HOC wrapper
- Use hook directly

STEP 4: Test
- Same behavior?
- Same performance?
- Same props API (if public component)?

STEP 5: Clean up
- Remove old code
- Update tests
- Update documentation
*/

// Demo comparison
function App() {
  return (
    <div style={{ padding: '20px' }}>
      <h1>Migration Examples</h1>

      <section>
        <h2>Example 1: Data Fetching</h2>
        <h3>Legacy (Render Props):</h3>
        <UserListLegacy />

        <h3>Modern (Hooks):</h3>
        <UserListModern />
      </section>

      <hr style={{ margin: '40px 0' }} />

      <section>
        <h2>Example 2: Theme</h2>
        <h3>Legacy (HOC):</h3>
        <ThemedButton>Click me (Legacy)</ThemedButton>

        <h3>Modern (Hook):</h3>
        <ButtonModern>Click me (Modern)</ButtonModern>
      </section>

      <hr style={{ margin: '40px 0' }} />

      <section>
        <h2>Example 3: Multiple Concerns</h2>
        <h3>Legacy (Multiple HOCs):</h3>
        <ProfileLegacy />

        <h3>Modern (Multiple Hooks):</h3>
        <ProfileModern />
      </section>
    </div>
  );
}

/*
Key Takeaways:

1. Render Props ‚Üí Custom Hook
   - Extract logic to hook
   - Return values instead of calling children
   - No more callback nesting

2. HOC ‚Üí Custom Hook
   - Extract logic to hook
   - No more wrapper component
   - No props collision

3. Multiple HOCs ‚Üí Multiple Hooks
   - Each HOC becomes a hook
   - Compose hooks in component
   - Flat, readable structure

4. When NOT to migrate immediately:
   - Code is stable and not changing
   - Team unfamiliar with Hooks
   - Third-party library uses old pattern
   - Migration would break public API

5. When TO migrate:
   - Adding new features
   - Fixing bugs in that area
   - Code is hard to maintain
   - Team wants to modernize
*/
```

</details>

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê B√†i 1: Nh·∫≠n Bi·∫øt Pattern (15 ph√∫t)

**üéØ M·ª•c ti√™u:** Ph√¢n bi·ªát patterns v√† identify refactor opportunities

```jsx
/**
 * üéØ M·ª•c ti√™u: ƒê·ªçc code v√† nh·∫≠n bi·∫øt pattern ƒë∆∞·ª£c d√πng
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: Class components
 *
 * Requirements:
 * Cho m·ªói ƒëo·∫°n code sau:
 * 1. Identify pattern (Render Props / HOC / Hooks)
 * 2. List pros/cons
 * 3. N√™n refactor kh√¥ng? T·∫°i sao?
 */

// Code Snippet 1
function App() {
  return (
    <MouseTracker>
      {(position) => (
        <div>
          Mouse at: {position.x}, {position.y}
        </div>
      )}
    </MouseTracker>
  );
}

// Code Snippet 2
const EnhancedComponent = withLogging(withAuth(MyComponent));

// Code Snippet 3
function App() {
  const position = useMouse();
  const { user } = useAuth();

  return (
    <div>
      User: {user.name}, Mouse: {position.x}
    </div>
  );
}

// Code Snippet 4
function Toggle({ children }) {
  const [isOn, setIsOn] = useState(false);

  return (
    <>
      {children({
        isOn,
        toggle: () => setIsOn(!isOn),
      })}
    </>
  );
}

// üéØ NHI·ªÜM V·ª§: Ph√¢n t√≠ch t·ª´ng snippet
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Pattern Recognition & Analysis
 */

// =====================================
// SNIPPET 1: Render Props
// =====================================

/*
Pattern: Render Props (Children as function)

Pros:
- Flexible - control render t·ª´ outside
- Share state d·ªÖ d√†ng

Cons:
- Callback nesting
- Kh√≥ ƒë·ªçc khi nhi·ªÅu levels
- Performance (t·∫°o function m·ªõi m·ªói render)

Refactor?
‚úÖ YES - Should refactor to Hook

Reason:
- Single concern (mouse tracking)
- Easy to extract to useMouse()
- Better readability
- Better performance

Refactored:
```

```jsx
function useMouse() {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handler = (e) => setPosition({ x: e.clientX, y: e.clientY });
    window.addEventListener('mousemove', handler);
    return () => window.removeEventListener('mousemove', handler);
  }, []);

  return position;
}

function App() {
  const position = useMouse();
  return (
    <div>
      Mouse at: {position.x}, {position.y}
    </div>
  );
}
```

```jsx
*/

// =====================================
// SNIPPET 2: HOC (Higher-Order Component)
// =====================================

/*
Pattern: Multiple HOCs (Wrapper composition)

Pros:
- Reuse logic across components
- Separation of concerns

Cons:
- Wrapper hell (2 levels here)
- Props collision risk
- Hard to debug (DevTools shows wrappers)
- Static composition

Refactor?
‚úÖ YES - Definitely should refactor

Reason:
- Wrapper hell (multiple HOCs)
- Each HOC can be a hook
- Much cleaner with hooks

Refactored:
```

```jsx
function useLogging(componentName) {
  useEffect(() => {
    console.log(`${componentName} mounted`);
    return () => console.log(`${componentName} unmounted`);
  }, [componentName]);
}

function useAuth() {
  const [user, setUser] = useState(null);
  // auth logic
  return { user, isAuthenticated: !!user };
}

function MyComponent() {
  useLogging('MyComponent');
  const { user, isAuthenticated } = useAuth();

  if (!isAuthenticated) return <div>Please login</div>;

  return <div>Welcome, {user.name}</div>;
}
```

```jsx
*/

// =====================================
// SNIPPET 3: Hooks (Modern)
// =====================================

/*
Pattern: Custom Hooks

Pros:
‚úÖ Clean, flat structure
‚úÖ Easy to read
‚úÖ Easy to test
‚úÖ Composable
‚úÖ No wrappers

Cons:
(None - this is the modern way!)

Refactor?
‚ùå NO - Already modern pattern

Reason:
- Using hooks correctly
- Clean composition
- Best practice

Keep as is! ‚úÖ
*/

// =====================================
// SNIPPET 4: Render Props (Toggle)
// =====================================

/*
Pattern: Render Props

Pros:
- Flexible control
- Works (not broken)

Cons:
- Callback syntax
- Overkill for simple toggle

Refactor?
‚ö†Ô∏è MAYBE - Depends on context

Reason to refactor:
- If used in many places ‚Üí useToggle hook
- Cleaner syntax

Reason NOT to refactor:
- If only used once ‚Üí overhead of creating hook
- Team preference for render props
- Part of public API (breaking change)

Option 1: Keep as is (if rarely used)
Option 2: Refactor to hook (if common)
```

```jsx
function useToggle(initialValue = false) {
  const [isOn, setIsOn] = useState(initialValue);
  const toggle = useCallback(() => setIsOn((prev) => !prev), []);
  return [isOn, toggle];
}

// Usage
function App() {
  const [isOn, toggle] = useToggle();
  return (
    <div>
      <p>{isOn ? 'ON' : 'OFF'}</p>
      <button onClick={toggle}>Toggle</button>
    </div>
  );
}
```

```jsx

Option 3: Compound Components (if complex UI)
```

```jsx
<Toggle>
  <Toggle.Button />
  <Toggle.Content>Content here</Toggle.Content>
</Toggle>
```

```jsx
*/

/*
SUMMARY DECISION MATRIX:

Snippet 1: Render Props ‚Üí ‚úÖ Refactor to useMouse()
Snippet 2: Multiple HOCs ‚Üí ‚úÖ Refactor to hooks
Snippet 3: Hooks ‚Üí ‚ùå Keep (already modern)
Snippet 4: Render Props ‚Üí ‚ö†Ô∏è Maybe (depends on usage)

General Rules:
1. Single concern + stateful ‚Üí Custom Hook
2. Multiple HOCs ‚Üí Multiple Hooks
3. Render Props with nesting ‚Üí Hook
4. Render Props (simple, once) ‚Üí Maybe keep
5. Already Hooks ‚Üí Keep

Factors to consider:
- How often used? (1x vs 10x)
- Team familiarity?
- Breaking changes?
- Time available?
- Code churn risk?
*/
```

</details>

---

### ‚≠ê‚≠ê B√†i 2: Refactor Render Props (25 ph√∫t)

**üéØ M·ª•c ti√™u:** Th·ª±c h√†nh refactor t·ª´ Render Props sang Hook

```jsx
/**
 * üéØ M·ª•c ti√™u: Refactor component t·ª´ Render Props sang Hook
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Codebase c√≥ FormValidation component d√πng Render Props
 * Task: Refactor th√†nh useFormValidation hook
 *
 * Requirements:
 * 1. Extract logic v√†o custom hook
 * 2. Maintain same functionality
 * 3. Improve readability
 * 4. Keep backwards compatibility (bonus)
 */

// ‚ùå LEGACY: Render Props
function FormValidation({ initialValues, validate, children }) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const handleChange = (name, value) => {
    setValues((prev) => ({ ...prev, [name]: value }));

    // Validate on change
    const fieldErrors = validate({ ...values, [name]: value });
    setErrors(fieldErrors);
  };

  const handleBlur = (name) => {
    setTouched((prev) => ({ ...prev, [name]: true }));
  };

  const handleSubmit = (onSubmit) => (e) => {
    e.preventDefault();

    // Mark all as touched
    const allTouched = Object.keys(values).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allTouched);

    // Validate
    const formErrors = validate(values);
    setErrors(formErrors);

    // Submit if no errors
    if (Object.keys(formErrors).length === 0) {
      onSubmit(values);
    }
  };

  return children({
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
  });
}

// Usage (v√≠ d·ª•)
function LoginForm() {
  const validate = (values) => {
    const errors = {};
    if (!values.email) errors.email = 'Required';
    if (!values.password) errors.password = 'Required';
    return errors;
  };

  return (
    <FormValidation
      initialValues={{ email: '', password: '' }}
      validate={validate}
    >
      {({
        values,
        errors,
        touched,
        handleChange,
        handleBlur,
        handleSubmit,
      }) => (
        <form onSubmit={handleSubmit(() => console.log('Submitted!'))}>
          <input
            value={values.email}
            onChange={(e) => handleChange('email', e.target.value)}
            onBlur={() => handleBlur('email')}
          />
          {touched.email && errors.email && <span>{errors.email}</span>}

          <input
            type='password'
            value={values.password}
            onChange={(e) => handleChange('password', e.target.value)}
            onBlur={() => handleBlur('password')}
          />
          {touched.password && errors.password && (
            <span>{errors.password}</span>
          )}

          <button type='submit'>Login</button>
        </form>
      )}
    </FormValidation>
  );
}

// üéØ NHI·ªÜM V·ª§:
// 1. T·∫°o useFormValidation hook
// 2. Refactor LoginForm ƒë·ªÉ d√πng hook
// 3. (Bonus) Keep FormValidation component cho backwards compatibility
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Form Validation - Refactored from Render Props to Hook
 */

import { useState, useCallback } from 'react';

// ‚úÖ MODERN: Custom Hook
function useFormValidation({ initialValues, validate }) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const handleChange = useCallback(
    (name, value) => {
      setValues((prev) => {
        const newValues = { ...prev, [name]: value };

        // Validate on change
        const fieldErrors = validate(newValues);
        setErrors(fieldErrors);

        return newValues;
      });
    },
    [validate],
  );

  const handleBlur = useCallback((name) => {
    setTouched((prev) => ({ ...prev, [name]: true }));
  }, []);

  const handleSubmit = useCallback(
    (onSubmit) => {
      return (e) => {
        e.preventDefault();

        // Mark all as touched
        const allTouched = Object.keys(values).reduce((acc, key) => {
          acc[key] = true;
          return acc;
        }, {});
        setTouched(allTouched);

        // Validate
        const formErrors = validate(values);
        setErrors(formErrors);

        // Submit if no errors
        if (Object.keys(formErrors).length === 0) {
          onSubmit(values);
        }
      };
    },
    [values, validate],
  );

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  }, [initialValues]);

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
  };
}

// ‚úÖ Refactored LoginForm - Much cleaner!
function LoginFormModern() {
  const validate = useCallback((values) => {
    const errors = {};
    if (!values.email) errors.email = 'Email is required';
    if (!values.password) errors.password = 'Password is required';
    if (values.password && values.password.length < 6) {
      errors.password = 'Password must be at least 6 characters';
    }
    return errors;
  }, []);

  const {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
  } = useFormValidation({
    initialValues: { email: '', password: '' },
    validate,
  });

  const onSubmit = (values) => {
    console.log('Form submitted:', values);
    alert('Login successful!');
    reset();
  };

  return (
    <form
      onSubmit={handleSubmit(onSubmit)}
      style={{ maxWidth: '400px' }}
    >
      <div style={{ marginBottom: '16px' }}>
        <label
          htmlFor='email'
          style={{ display: 'block', marginBottom: '4px' }}
        >
          Email
        </label>
        <input
          id='email'
          type='email'
          value={values.email}
          onChange={(e) => handleChange('email', e.target.value)}
          onBlur={() => handleBlur('email')}
          style={{
            width: '100%',
            padding: '8px',
            border:
              touched.email && errors.email
                ? '2px solid red'
                : '1px solid #ccc',
            borderRadius: '4px',
          }}
        />
        {touched.email && errors.email && (
          <span style={{ color: 'red', fontSize: '14px' }}>{errors.email}</span>
        )}
      </div>

      <div style={{ marginBottom: '16px' }}>
        <label
          htmlFor='password'
          style={{ display: 'block', marginBottom: '4px' }}
        >
          Password
        </label>
        <input
          id='password'
          type='password'
          value={values.password}
          onChange={(e) => handleChange('password', e.target.value)}
          onBlur={() => handleBlur('password')}
          style={{
            width: '100%',
            padding: '8px',
            border:
              touched.password && errors.password
                ? '2px solid red'
                : '1px solid #ccc',
            borderRadius: '4px',
          }}
        />
        {touched.password && errors.password && (
          <span style={{ color: 'red', fontSize: '14px' }}>
            {errors.password}
          </span>
        )}
      </div>

      <button
        type='submit'
        style={{
          padding: '10px 20px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
        }}
      >
        Login
      </button>
    </form>
  );
}

// üéÅ BONUS: Backwards compatibility wrapper
// Keep old API working cho existing code
function FormValidation({ initialValues, validate, children }) {
  const formState = useFormValidation({ initialValues, validate });
  return children(formState);
}

// Old code v·∫´n ho·∫°t ƒë·ªông!
function LoginFormLegacy() {
  const validate = (values) => {
    const errors = {};
    if (!values.email) errors.email = 'Required';
    return errors;
  };

  return (
    <FormValidation
      initialValues={{ email: '', password: '' }}
      validate={validate}
    >
      {({ values, errors, handleChange, handleSubmit }) => (
        <form onSubmit={handleSubmit(() => console.log('Legacy submit'))}>
          <input
            value={values.email}
            onChange={(e) => handleChange('email', e.target.value)}
          />
          {errors.email && <span>{errors.email}</span>}
          <button>Submit</button>
        </form>
      )}
    </FormValidation>
  );
}

// Demo both versions
function App() {
  return (
    <div style={{ padding: '20px' }}>
      <h1>Form Validation Refactoring</h1>

      <section>
        <h2>Modern (Hook):</h2>
        <LoginFormModern />
      </section>

      <hr style={{ margin: '40px 0' }} />

      <section>
        <h2>Legacy (Render Props - Backwards Compatible):</h2>
        <LoginFormLegacy />
      </section>
    </div>
  );
}

/*
Migration Benefits:

Before (Render Props):
‚ùå Callback nesting
‚ùå Verbose syntax
‚ùå Hard to reuse logic

After (Hook):
‚úÖ Clean, flat code
‚úÖ Easy to compose with other hooks
‚úÖ Reusable across components
‚úÖ Better readability
‚úÖ Easier to test

Backwards Compatibility:
‚úÖ Old code still works
‚úÖ Gradual migration possible
‚úÖ No breaking changes
‚úÖ Can migrate component by component
*/
```

</details>

---

### ‚≠ê‚≠ê‚≠ê B√†i 3: Refactor Multiple HOCs (40 ph√∫t)

**üéØ M·ª•c ti√™u:** Gi·∫£i quy·∫øt wrapper hell

```jsx
/**
 * üéØ M·ª•c ti√™u: Refactor component c√≥ nhi·ªÅu HOCs
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† developer, t√¥i mu·ªën code d·ªÖ ƒë·ªçc v√† maintain h∆°n"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Refactor t·∫•t c·∫£ HOCs th√†nh hooks
 * - [ ] Maintain same functionality
 * - [ ] Improve readability
 * - [ ] Better performance (if possible)
 * - [ ] Easier to test
 *
 * üé® Technical Constraints:
 * - Must work exactly like before
 * - No breaking changes to component API
 * - Clean up wrapper components
 *
 * üö® Edge Cases:
 * - Props collision between HOCs
 * - Execution order matters
 * - Conditional logic in HOCs
 */

// ‚ùå LEGACY: Multiple HOCs

// HOC 1: Add analytics tracking
function withAnalytics(Component) {
  return function AnalyticsComponent(props) {
    useEffect(() => {
      console.log('Page view:', props.pageName);
    }, [props.pageName]);

    return <Component {...props} />;
  };
}

// HOC 2: Add authentication check
function withAuth(Component) {
  return function AuthComponent(props) {
    const [user] = useState({ name: 'John', role: 'admin' });
    const [isAuthenticated] = useState(true);

    if (!isAuthenticated) {
      return <div>Please login</div>;
    }

    return (
      <Component
        {...props}
        user={user}
        isAuthenticated={isAuthenticated}
      />
    );
  };
}

// HOC 3: Add loading state
function withLoading(Component) {
  return function LoadingComponent(props) {
    const [isLoading] = useState(false);

    if (isLoading) {
      return <div>Loading...</div>;
    }

    return <Component {...props} />;
  };
}

// HOC 4: Add error boundary
function withErrorBoundary(Component) {
  return function ErrorBoundaryComponent(props) {
    const [hasError] = useState(false);

    if (hasError) {
      return <div>Something went wrong</div>;
    }

    return <Component {...props} />;
  };
}

// Base component
function Dashboard({ pageName, user, isAuthenticated }) {
  return (
    <div>
      <h1>{pageName}</h1>
      <p>Welcome, {user?.name}</p>
      <p>Role: {user?.role}</p>
      <p>Authenticated: {isAuthenticated ? 'Yes' : 'No'}</p>
    </div>
  );
}

// ‚ùå Wrapper hell!
const EnhancedDashboard = withAnalytics(
  withAuth(withLoading(withErrorBoundary(Dashboard))),
);

function AppLegacy() {
  return <EnhancedDashboard pageName='Dashboard' />;
}

// üéØ NHI·ªÜM V·ª§:
// 1. T·∫°o hooks t∆∞∆°ng ·ª©ng cho m·ªói HOC
// 2. Refactor Dashboard ƒë·ªÉ d√πng hooks
// 3. Compare code tr∆∞·ªõc/sau
// 4. Document improvements
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Multiple HOCs ‚Üí Multiple Hooks Refactoring
 */

import { useState, useEffect, useCallback } from 'react';

// =====================================
// ‚úÖ STEP 1: Create Hooks
// =====================================

// Hook 1: Analytics
function useAnalytics(pageName) {
  useEffect(() => {
    console.log('Page view:', pageName);

    // Simulate analytics call
    // analytics.track('page_view', { page: pageName });

    return () => {
      console.log('Page leave:', pageName);
    };
  }, [pageName]);
}

// Hook 2: Authentication
function useAuth() {
  const [user] = useState({ name: 'John', role: 'admin' });
  const [isAuthenticated] = useState(true);

  // In real app: fetch from API, check token, etc.

  return {
    user,
    isAuthenticated,
    logout: useCallback(() => {
      console.log('Logging out...');
    }, []),
  };
}

// Hook 3: Loading
function useLoading(initialState = false) {
  const [isLoading, setIsLoading] = useState(initialState);

  const startLoading = useCallback(() => setIsLoading(true), []);
  const stopLoading = useCallback(() => setIsLoading(false), []);

  return {
    isLoading,
    startLoading,
    stopLoading,
  };
}

// Hook 4: Error handling
function useErrorHandler() {
  const [error, setError] = useState(null);

  const handleError = useCallback((err) => {
    console.error('Error caught:', err);
    setError(err);
  }, []);

  const clearError = useCallback(() => setError(null), []);

  return {
    error,
    hasError: !!error,
    handleError,
    clearError,
  };
}

// =====================================
// ‚úÖ STEP 2: Refactored Component
// =====================================

function DashboardModern({ pageName }) {
  // Compose all hooks - clean and flat!
  useAnalytics(pageName);

  const { user, isAuthenticated, logout } = useAuth();
  const { isLoading, startLoading, stopLoading } = useLoading();
  const { error, hasError, handleError, clearError } = useErrorHandler();

  // Simulate data fetching
  useEffect(() => {
    startLoading();

    setTimeout(() => {
      stopLoading();
    }, 1000);
  }, [startLoading, stopLoading]);

  // Early returns for different states
  if (!isAuthenticated) {
    return (
      <div style={{ padding: '20px', border: '2px solid red' }}>
        <h2>Access Denied</h2>
        <p>Please login to view this page</p>
      </div>
    );
  }

  if (hasError) {
    return (
      <div style={{ padding: '20px', border: '2px solid red' }}>
        <h2>Something went wrong</h2>
        <p>{error?.message || 'Unknown error'}</p>
        <button onClick={clearError}>Try Again</button>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div style={{ padding: '20px' }}>
        <h2>Loading...</h2>
        <p>Please wait...</p>
      </div>
    );
  }

  // Main content
  return (
    <div style={{ padding: '20px', border: '1px solid #ccc' }}>
      <h1>{pageName}</h1>
      <p>
        Welcome, <strong>{user?.name}</strong>
      </p>
      <p>Role: {user?.role}</p>
      <p>Authenticated: {isAuthenticated ? '‚úÖ Yes' : '‚ùå No'}</p>

      <div style={{ marginTop: '20px', display: 'flex', gap: '8px' }}>
        <button onClick={logout}>Logout</button>
        <button onClick={() => handleError(new Error('Test error'))}>
          Simulate Error
        </button>
        <button
          onClick={() => {
            startLoading();
            setTimeout(stopLoading, 2000);
          }}
        >
          Simulate Loading
        </button>
      </div>
    </div>
  );
}

// =====================================
// ‚úÖ STEP 3: Comparison
// =====================================

function App() {
  return (
    <div style={{ padding: '20px' }}>
      <h1>HOCs vs Hooks Refactoring</h1>

      <section style={{ marginBottom: '40px' }}>
        <h2>Legacy (Multiple HOCs):</h2>
        <pre
          style={{
            background: '#f5f5f5',
            padding: '16px',
            overflow: 'auto',
            fontSize: '14px',
          }}
        >
          {`// Wrapper hell!
const EnhancedDashboard = withAnalytics(
  withAuth(
    withLoading(
      withErrorBoundary(
        Dashboard
      )
    )
  )
);

// Component tree in DevTools:
AnalyticsComponent
  ‚îî‚îÄ AuthComponent
      ‚îî‚îÄ LoadingComponent
          ‚îî‚îÄ ErrorBoundaryComponent
              ‚îî‚îÄ Dashboard

Problems:
‚ùå 4 wrapper components
‚ùå Hard to debug
‚ùå Props collision risk
‚ùå Execution order unclear
‚ùå Can't easily conditional compose`}
        </pre>
      </section>

      <section style={{ marginBottom: '40px' }}>
        <h2>Modern (Hooks):</h2>
        <pre
          style={{
            background: '#e8f5e9',
            padding: '16px',
            overflow: 'auto',
            fontSize: '14px',
          }}
        >
          {`function DashboardModern({ pageName }) {
  useAnalytics(pageName);
  const { user, isAuthenticated } = useAuth();
  const { isLoading } = useLoading();
  const { error, hasError } = useErrorHandler();
  
  // Clean, flat, composable!
}

// Component tree in DevTools:
DashboardModern (just one!)

Benefits:
‚úÖ No wrappers
‚úÖ Easy to debug
‚úÖ No props collision
‚úÖ Clear execution order
‚úÖ Easy conditional logic`}
        </pre>
      </section>

      <section>
        <h2>Live Demo:</h2>
        <DashboardModern pageName='My Dashboard' />
      </section>

      <section style={{ marginTop: '40px' }}>
        <h3>üìä Metrics Comparison:</h3>
        <table
          style={{
            width: '100%',
            borderCollapse: 'collapse',
            marginTop: '16px',
          }}
        >
          <thead>
            <tr style={{ backgroundColor: '#f5f5f5' }}>
              <th
                style={{
                  padding: '12px',
                  border: '1px solid #ddd',
                  textAlign: 'left',
                }}
              >
                Metric
              </th>
              <th
                style={{
                  padding: '12px',
                  border: '1px solid #ddd',
                  textAlign: 'left',
                }}
              >
                HOCs
              </th>
              <th
                style={{
                  padding: '12px',
                  border: '1px solid #ddd',
                  textAlign: 'left',
                }}
              >
                Hooks
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                Wrapper Components
              </td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>4</td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>0</td>
            </tr>
            <tr>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                Lines of Code
              </td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>~80</td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>~50</td>
            </tr>
            <tr>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                Readability
              </td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                ‚≠ê‚≠ê
              </td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
              </td>
            </tr>
            <tr>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                Testability
              </td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                ‚≠ê‚≠ê
              </td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
              </td>
            </tr>
            <tr>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                DevTools Clarity
              </td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                ‚≠ê‚≠ê
              </td>
              <td style={{ padding: '12px', border: '1px solid #ddd' }}>
                ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
              </td>
            </tr>
          </tbody>
        </table>
      </section>
    </div>
  );
}

/*
Migration Steps Taken:

1. ‚úÖ Identified each HOC's concern
2. ‚úÖ Created equivalent hooks
3. ‚úÖ Composed hooks in component
4. ‚úÖ Maintained same functionality
5. ‚úÖ Improved readability
6. ‚úÖ Better performance (fewer components)
7. ‚úÖ Easier to test (hooks can be tested in isolation)

Key Improvements:

Performance:
- Before: 5 components in tree (4 HOCs + 1 actual)
- After: 1 component in tree
- Result: Faster rendering, less memory

Readability:
- Before: Nested function calls, hard to follow
- After: Linear hook calls, clear flow
- Result: Easier onboarding, faster debugging

Maintainability:
- Before: Change HOC = might break other uses
- After: Change hook = clear impact
- Result: Safer refactoring

Testability:
- Before: Must test with full HOC stack
- After: Can test hooks individually
- Result: Better test coverage, faster tests
*/
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh Chi Ti·∫øt

| Aspect              | Render Props      | HOCs                 | Hooks                 | Compound Components |
| ------------------- | ----------------- | -------------------- | --------------------- | ------------------- |
| **Year Introduced** | 2017              | 2016                 | 2019                  | 2018                |
| **Status**          | Legacy            | Legacy               | ‚úÖ Current            | ‚úÖ Current          |
| **Code Complexity** | ‚≠ê‚≠ê (callbacks)  | ‚≠ê‚≠ê (wrappers)      | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê            | ‚≠ê‚≠ê‚≠ê‚≠ê            |
| **Readability**     | ‚≠ê‚≠ê              | ‚≠ê‚≠ê‚≠ê               | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê            | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê          |
| **Composition**     | ‚≠ê‚≠ê (nested)     | ‚≠ê‚≠ê‚≠ê (static)      | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (flexible) | ‚≠ê‚≠ê‚≠ê‚≠ê            |
| **Performance**     | ‚≠ê‚≠ê‚≠ê            | ‚≠ê‚≠ê‚≠ê‚≠ê             | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê            | ‚≠ê‚≠ê‚≠ê‚≠ê            |
| **DevTools**        | ‚≠ê‚≠ê‚≠ê            | ‚≠ê‚≠ê (wrappers)      | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê            | ‚≠ê‚≠ê‚≠ê‚≠ê            |
| **Learning Curve**  | ‚≠ê‚≠ê‚≠ê            | ‚≠ê‚≠ê                 | ‚≠ê‚≠ê‚≠ê‚≠ê              | ‚≠ê‚≠ê‚≠ê‚≠ê            |
| **Use Case**        | Logic sharing     | Enhancing components | Logic sharing         | UI composition      |
| **When to Use**     | Never (use Hooks) | Never (use Hooks)    | ‚úÖ Always             | ‚úÖ Complex UI       |

### Decision Tree - When to Use What?

```
Need to share logic between components?
‚îÇ
‚îú‚îÄ Stateful logic? (useState, useEffect, etc.)
‚îÇ  ‚îî‚îÄ> ‚úÖ Custom Hook
‚îÇ     Example: useFetch, useAuth, useMouse
‚îÇ
‚îú‚îÄ UI composition? (flexible layout)
‚îÇ  ‚îî‚îÄ> ‚úÖ Compound Components
‚îÇ     Example: <Tabs>, <Menu>, <Modal>
‚îÇ
‚îú‚îÄ Simple prop transformation?
‚îÇ  ‚îî‚îÄ> ‚úÖ Regular component with props
‚îÇ     Example: <Button variant="primary" />
‚îÇ
‚îî‚îÄ Reading legacy code?
   ‚îú‚îÄ See render props?
   ‚îÇ  ‚îî‚îÄ> Understand pattern, consider refactoring to Hook
   ‚îÇ
   ‚îî‚îÄ See HOCs?
      ‚îî‚îÄ> Understand pattern, consider refactoring to Hook

NEVER start new code with:
‚ùå Render Props (use Hooks instead)
‚ùå HOCs (use Hooks instead)
‚ùå Mixins (deprecated!)
```

### Evolution Timeline

```
REACT PATTERNS EVOLUTION:

2013 ‚îÄ‚îÄ‚îÄ Mixins
         class MyComponent extends React.Component {
           mixins: [MouseMixin]
         }
         ‚ùå Deprecated in 2015

2016 ‚îÄ‚îÄ‚îÄ Higher-Order Components (HOCs)
         const Enhanced = withMouse(Component)
         ‚ö†Ô∏è Still works, but legacy
         Problems: Wrapper hell, props collision

2017 ‚îÄ‚îÄ‚îÄ Render Props
         <Mouse>{mouse => <UI />}</Mouse>
         ‚ö†Ô∏è Still works, but legacy
         Problems: Callback hell, hard to read

2018 ‚îÄ‚îÄ‚îÄ Compound Components
         <Tabs><Tabs.Tab /></Tabs>
         ‚úÖ Still good for UI composition
         Best for: Complex UI components

2019 ‚îÄ‚îÄ‚îÄ Hooks üéâ
         const mouse = useMouse()
         ‚úÖ Current standard
         Best for: Logic sharing, stateful logic

2020+ ‚îÄ‚îÄ Server Components (Next.js)
         async function Component() { ... }
         ‚úÖ Cutting edge
         Best for: Data fetching, SSR
         (Will learn in Next.js module)

Current Best Practices (2024):
1. Default: Hooks for logic
2. Compound Components for complex UI
3. Regular components for simple UI
4. Understand legacy patterns to read old code
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Props Collision in HOCs

```jsx
// ‚ùå Code c√≥ bug
function withUser(Component) {
  return function (props) {
    const user = { name: 'HOC User', id: 1 };
    return (
      <Component
        {...props}
        user={user}
      />
    );
  };
}

function withAuth(Component) {
  return function (props) {
    const user = { name: 'Auth User', id: 2, role: 'admin' };
    return (
      <Component
        {...props}
        user={user}
      />
    );
  };
}

const Enhanced = withUser(withAuth(MyComponent));

function MyComponent({ user }) {
  return <div>User: {user.name}</div>;
}
```

**‚ùì C√¢u h·ªèi:** User name hi·ªÉn th·ªã l√† g√¨? T·∫°i sao ƒë√¢y l√† v·∫•n ƒë·ªÅ?

<details>
<summary>üí° Gi·∫£i th√≠ch</summary>

**K·∫øt qu·∫£:** "HOC User" (from withUser)

**Nguy√™n nh√¢n:** Props collision - HOC b√™n ngo√†i override props t·ª´ HOC b√™n trong

```jsx
// Execution order:
1. withAuth wraps MyComponent
   ‚Üí Passes user = { name: 'Auth User', id: 2, role: 'admin' }

2. withUser wraps the result
   ‚Üí Passes user = { name: 'HOC User', id: 1 }
   ‚Üí OVERWRITES previous user!

Result: Only see 'HOC User', lose 'role' data!
```

**‚ùå This is a MAJOR problem with HOCs:**

- Props can collide
- Outer HOC wins
- Silent data loss
- Hard to debug

**‚úÖ Solutions:**

**Option 1: Namespace props**

```jsx
function withUser(Component) {
  return function (props) {
    const userData = { name: 'HOC User', id: 1 };
    return (
      <Component
        {...props}
        userData={userData}
      />
    );
  };
}

function withAuth(Component) {
  return function (props) {
    const authData = { name: 'Auth User', id: 2, role: 'admin' };
    return (
      <Component
        {...props}
        authData={authData}
      />
    );
  };
}

// No collision!
function MyComponent({ userData, authData }) {
  return (
    <div>
      <p>User: {userData.name}</p>
      <p>
        Auth: {authData.name}, Role: {authData.role}
      </p>
    </div>
  );
}
```

**Option 2: Merge props**

```jsx
function withUser(Component) {
  return function (props) {
    const user = { name: 'HOC User', id: 1 };
    // Merge instead of replace
    return (
      <Component
        {...props}
        user={{ ...props.user, ...user }}
      />
    );
  };
}
```

**Option 3: Use Hooks instead! (BEST)**

```jsx
function useUser() {
  return { name: 'Hook User', id: 1 };
}

function useAuth() {
  return { name: 'Auth User', id: 2, role: 'admin' };
}

function MyComponent() {
  const user = useUser();
  const auth = useAuth();

  // Clear, no collision!
  return (
    <div>
      <p>User: {user.name}</p>
      <p>
        Auth: {auth.name}, Role: {auth.role}
      </p>
    </div>
  );
}
```

**Lesson:** Props collision l√† l√Ω do ch√≠nh ƒë·ªÉ avoid HOCs. Hooks kh√¥ng c√≥ v·∫•n ƒë·ªÅ n√†y!

</details>

---

### Bug 2: Stale Closure in Render Props

```jsx
// ‚ùå Code c√≥ bug
function Counter({ children }) {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return children({ count, increment });
}

function App() {
  return (
    <Counter>
      {({ count, increment }) => (
        <div>
          <p>Count: {count}</p>
          <button
            onClick={() => {
              increment();
              increment();
              increment();
            }}
          >
            +3
          </button>
        </div>
      )}
    </Counter>
  );
}
```

**‚ùì C√¢u h·ªèi:** Click button, count tƒÉng bao nhi√™u? T·∫°i sao?

<details>
<summary>üí° Gi·∫£i th√≠ch</summary>

**K·∫øt qu·∫£:** Count ch·ªâ tƒÉng **+1** (not +3!)

**Nguy√™n nh√¢n:** Stale closure - `increment` function captures old `count` value

```jsx
// ‚ùå Problem
const increment = () => setCount(count + 1);
//                               ^^^^^ captured value!

// When button clicked:
increment(); // setCount(0 + 1) = 1
increment(); // setCount(0 + 1) = 1  (still using count = 0!)
increment(); // setCount(0 + 1) = 1
// Result: 1
```

**‚úÖ FIX 1: Functional update**

```jsx
function Counter({ children }) {
  const [count, setCount] = useState(0);

  // ‚úÖ Use previous value
  const increment = () => setCount((prev) => prev + 1);

  return children({ count, increment });
}

// Now:
increment(); // setCount(prev => 0 + 1) = 1
increment(); // setCount(prev => 1 + 1) = 2
increment(); // setCount(prev => 2 + 1) = 3
// Result: 3 ‚úÖ
```

**‚úÖ FIX 2: Use Hook instead**

```jsx
function useCounter() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => {
    setCount((prev) => prev + 1);
  }, []);

  return { count, increment };
}

function App() {
  const { count, increment } = useCounter();

  return (
    <div>
      <p>Count: {count}</p>
      <button
        onClick={() => {
          increment();
          increment();
          increment();
        }}
      >
        +3
      </button>
    </div>
  );
}
```

**Why Hooks are better here:**

- Clearer code
- useCallback memoization
- No callback syntax
- Easier to spot closure bugs

**Lesson:** Stale closures affect both Render Props and Hooks, but Hooks make it easier to see and fix!

</details>

---

### Bug 3: HOC Order Matters

```jsx
// ‚ùå Code c√≥ bug
function withLogger(Component) {
  return function LoggerComponent(props) {
    useEffect(() => {
      console.log('Component mounted with props:', props);
    }, [props]);

    return <Component {...props} />;
  };
}

function withAuth(Component) {
  return function AuthComponent(props) {
    const [isAuth] = useState(false);

    if (!isAuth) {
      return <div>Not authenticated</div>;
    }

    return <Component {...props} />;
  };
}

// Version A
const ComponentA = withLogger(withAuth(MyComponent));

// Version B
const ComponentB = withAuth(withLogger(MyComponent));
```

**‚ùì C√¢u h·ªèi:** Hai versions kh√°c nhau nh∆∞ th·∫ø n√†o? Version n√†o ƒë√∫ng?

<details>
<summary>üí° Gi·∫£i th√≠ch</summary>

**Behavior kh√°c nhau:**

**Version A: `withLogger(withAuth(MyComponent))`**

```jsx
Flow:
1. withAuth ki·ªÉm tra authentication
2. N·∫øu !isAuth ‚Üí return "Not authenticated"
3. Logger KH√îNG ch·∫°y v√¨ component kh√¥ng mount
4. MyComponent KH√îNG render

Console: (kh√¥ng c√≥ log n·∫øu not authenticated)
```

**Version B: `withAuth(withLogger(MyComponent))`**

```jsx
Flow:
1. Logger wraps MyComponent
2. withAuth ki·ªÉm tra authentication
3. N·∫øu !isAuth ‚Üí return "Not authenticated"
4. Logger V·∫™N ch·∫°y (v√¨ LoggerComponent mounted)
5. MyComponent KH√îNG render

Console: "Component mounted with props: ..."
         (log xu·∫•t hi·ªán d√π not authenticated!)
```

**V·∫•n ƒë·ªÅ:**

- HOC order matters!
- Kh√¥ng r√µ r√†ng t·ª´ code
- D·ªÖ sai khi refactor
- Hard to reason about

**Which is correct?**

- Depends on requirements!
- Usually A (don't log if not authenticated)
- But not obvious from code!

**‚úÖ With Hooks - Much clearer:**

```jsx
function MyComponent() {
  // Execution order is CLEAR!
  const { isAuth } = useAuth();

  useLogger('MyComponent'); // This runs regardless

  if (!isAuth) {
    return <div>Not authenticated</div>;
  }

  // Or:
  // Only log if authenticated
  if (isAuth) {
    useLogger('MyComponent');
  }

  return <div>Content</div>;
}
```

**Why Hooks are better:**

1. Execution order visible in code
2. Easy to change order
3. Can conditionally run hooks (with care)
4. No surprises

**Lesson:** HOC composition order affects behavior but isn't obvious from code. Hooks make execution flow explicit!

</details>

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

- [ ] T√¥i hi·ªÉu Render Props pattern v√† t·∫°i sao n√≥ legacy
- [ ] T√¥i hi·ªÉu HOCs pattern v√† v·∫•n ƒë·ªÅ c·ªßa n√≥
- [ ] T√¥i bi·∫øt refactor Render Props ‚Üí Hooks
- [ ] T√¥i bi·∫øt refactor HOCs ‚Üí Hooks
- [ ] T√¥i hi·ªÉu trade-offs gi·ªØa c√°c patterns
- [ ] T√¥i bi·∫øt khi n√†o n√™n refactor v√† khi n√†o n√™n gi·ªØ nguy√™n
- [ ] T√¥i nh·∫≠n bi·∫øt ƒë∆∞·ª£c c√°c patterns trong legacy code
- [ ] T√¥i hi·ªÉu t·∫°i sao Hooks l√† modern standard

### Code Review Checklist

Khi review legacy code:

**Identify Patterns:**

- [ ] Is this Render Props? (children as function)
- [ ] Is this HOC? (function returns component)
- [ ] Are there multiple HOCs? (wrapper hell)
- [ ] Is this causing bugs? (props collision, stale closures)

**Refactor Decision:**

- [ ] Is code actively being changed?
- [ ] Is it causing maintenance issues?
- [ ] Is team comfortable with Hooks?
- [ ] Is refactor worth the risk?

**If Refactoring:**

- [ ] Extract logic to custom hooks
- [ ] Maintain same API if possible
- [ ] Add tests before refactoring
- [ ] Refactor incrementally
- [ ] Test thoroughly after

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**Identify & Document Legacy Patterns**

Cho ƒëo·∫°n code sau, identify patterns v√† propose refactoring:

```jsx
// Legacy codebase
const EnhancedForm = withValidation(withSubmit(withReset(FormComponent)));

function App() {
  return (
    <DataProvider url='/api/data'>
      {({ data, loading }) => (
        <Theme>
          {({ theme }) => (
            <EnhancedForm
              data={data}
              loading={loading}
              theme={theme}
            />
          )}
        </Theme>
      )}
    </DataProvider>
  );
}
```

Tasks:

1. List all patterns used
2. Identify potential bugs
3. Write refactored version with Hooks
4. Document migration steps

### N√¢ng cao (60 ph√∫t)

**Build a Migration Guide**

T·∫°o document v·ªÅ migration strategy cho team:

1. **Assessment**: L√†m sao identify code c·∫ßn refactor?
2. **Priority**: Code n√†o refactor tr∆∞·ªõc?
3. **Process**: Step-by-step migration process
4. **Testing**: L√†m sao ƒë·∫£m b·∫£o kh√¥ng break?
5. **Rollback**: Plan B n·∫øu c√≥ v·∫•n ƒë·ªÅ
6. **Timeline**: Realistic estimates

Include:

- Code examples (before/after)
- Checklist templates
- Common pitfalls
- Success metrics

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - Render Props**
   https://legacy.reactjs.org/docs/render-props.html
   (Note: Legacy docs, nh∆∞ng explains pattern well)

2. **React Docs - Higher-Order Components**
   https://legacy.reactjs.org/docs/higher-order-components.html

3. **React Docs - Hooks Introduction**
   https://react.dev/learn#using-hooks
   (Shows why Hooks replace old patterns)

### ƒê·ªçc th√™m

1. **Michael Jackson - "Never Write Another HOC"**
   Classic talk explaining Render Props

2. **Dan Abramov - "Making Sense of React Hooks"**
   https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889

3. **Kent C. Dodds - "How to Use React Context Effectively"**
   Shows modern patterns vs legacy

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (c·∫ßn t·ª´ nh·ªØng ng√†y tr∆∞·ªõc)

- **Ng√†y 24:** Custom Hooks fundamentals
- **Ng√†y 32-34:** Performance patterns (memo, useCallback, useMemo)
- **Ng√†y 36-38:** Context API (thay th·∫ø props drilling)
- **Ng√†y 39:** Compound Components (modern pattern)

### H∆∞·ªõng t·ªõi (nh·ªØng ng√†y sau s·∫Ω d√πng)

- **Ng√†y 41-44:** Form libraries (modern approaches, not Render Props)
- **Ng√†y 53-57:** Testing patterns (easier v·ªõi Hooks)
- **Ng√†y 58-59:** TypeScript (better inference v·ªõi Hooks)
- **Projects:** T·∫•t c·∫£ code m·ªõi s·∫Ω d√πng Hooks

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**1. When to Refactor Legacy Code**

```
HIGH PRIORITY (refactor ngay):
‚úÖ Code causing bugs
‚úÖ Code being actively developed
‚úÖ Team wants to learn Hooks
‚úÖ Clear path to improvement

MEDIUM PRIORITY (refactor khi c√≥ th·ªùi gian):
‚ö†Ô∏è Code stable nh∆∞ng hard to maintain
‚ö†Ô∏è Multiple HOCs/Render Props nested
‚ö†Ô∏è Planning future features in area

LOW PRIORITY (c√≥ th·ªÉ ƒë·ªÉ nguy√™n):
‚ùå Code stable, not changing
‚ùå Would break public API
‚ùå Team unfamiliar with Hooks
‚ùå No resources for testing
```

**2. Migration Strategy**

```
INCREMENTAL APPROACH:

Week 1: Assessment
- Identify legacy patterns
- Measure code complexity
- Prioritize by impact

Week 2-3: Foundation
- Train team on Hooks
- Create migration guide
- Setup testing infrastructure

Week 4+: Migrate
- One component at a time
- Test thoroughly
- Monitor production
- Rollback plan ready

Don't:
‚ùå Refactor everything at once
‚ùå Mix old and new patterns in same component
‚ùå Skip tests
‚ùå Rush without measuring
```

**3. Team Considerations**

```
Communication:
- Explain WHY refactoring
- Show before/after examples
- Address concerns
- Get buy-in

Training:
- Hooks workshop
- Pair programming
- Code review focus
- Documentation

Metrics:
- Code complexity (before/after)
- Bug rate
- Development speed
- Team satisfaction
```

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior Level:**

Q: "Render Props l√† g√¨?"
A: Pattern where component nh·∫≠n function v√† g·ªçi n√≥ v·ªõi data. Legacy pattern, gi·ªù d√πng Hooks.

**Mid Level:**

Q: "T·∫°i sao Hooks t·ªët h∆°n HOCs?"
A:

- No wrapper hell
- No props collision
- Clearer code
- Better composition
- Easier to debug

Q: "Khi n√†o v·∫´n OK d√πng Render Props?"
A:

- Third-party library requirement
- Public API can't change
- Team consensus
- But default should be Hooks

**Senior Level:**

Q: "L√†m sao migrate large codebase t·ª´ HOCs sang Hooks?"
A:

1. Assess and prioritize
2. Create migration guide
3. Train team
4. Migrate incrementally
5. Test thoroughly
6. Monitor production
7. Maintain backwards compatibility initially

Q: "Trade-offs khi refactor legacy patterns?"
A:

- ‚úÖ Better maintainability
- ‚úÖ Modern patterns
- ‚úÖ Easier onboarding
- ‚ùå Risk of bugs
- ‚ùå Time investment
- ‚ùå Learning curve
- Decision: Depends on code churn, team capacity, business priority

### War Stories

**Story 1: The HOC Hell**

```
Context: Enterprise app with 50+ HOCs
Problem: withAuth(withTheme(withData(withLogger(...))))
Impact: 10+ wrapper components, 2s initial render
Solution: Migrated to Hooks over 3 months
Result: 1 component, 200ms render, 90% fewer bugs

Lesson: Don't let HOCs grow unchecked
```

**Story 2: Props Collision Bug**

```
Context: Payment form with withUser + withPayment HOCs
Problem: Both added "currency" prop
Impact: Used wrong currency, wrong charges!
Discovery: Customer complaint, hard to debug
Solution: Refactored to useUser() + usePayment()
Result: No more collisions, explicit dependencies

Lesson: Props collision can cause $$$ bugs
```

**Story 3: Migration Too Fast**

```
Context: Team refactored 100 components in 1 week
Problem: Introduced 20+ bugs, production down
Impact: Rollback, lost 1 week work
Solution: Slow down, 5 components/week with testing
Result: Clean migration over 3 months

Lesson: Slow and steady wins the race
```

---

## üéØ PREVIEW NG√ÄY 41

**Ng√†y mai:** React Hook Form - Basics

Ch√∫ng ta s·∫Ω h·ªçc:

- T·∫°i sao form trong React kh√≥?
- React Hook Form l√† g√¨?
- Performance benefits
- Basic form handling
- Validation strategies

Chu·∫©n b·ªã:

- Review controlled components (Ng√†y 13)
- Suy nghƒ©: Form n√†o b·∫°n t·ª´ng l√†m?
- Nh·ªØng v·∫•n ƒë·ªÅ g√¨ g·∫∑p v·ªõi forms?

**M·ª•c ti√™u:** Master form handling v·ªõi modern library

---

‚úÖ **Ch√∫c m·ª´ng b·∫°n ƒë√£ ho√†n th√†nh Ng√†y 40!**

B·∫°n ƒë√£ hi·ªÉu legacy patterns v√† bi·∫øt refactor sang modern approach. ƒê√¢y l√† k·ªπ nƒÉng quan tr·ªçng khi l√†m vi·ªác v·ªõi codebase th·ª±c t·∫ø! üöÄ
