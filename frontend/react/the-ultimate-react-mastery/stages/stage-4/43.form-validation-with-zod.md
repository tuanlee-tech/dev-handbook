# ğŸ“… NGÃ€Y 43: Form Validation Schemas vá»›i Zod

> **TÃ³m táº¯t:** HÃ´m nay chÃºng ta há»c cÃ¡ch sá»­ dá»¥ng Zod Ä‘á»ƒ Ä‘á»‹nh nghÄ©a validation schemas type-safe cho forms. Zod giÃºp tÃ¡ch biá»‡t validation logic khá»i UI, cung cáº¥p IntelliSense tá»± Ä‘á»™ng, vÃ  tÃ­ch há»£p hoÃ n háº£o vá»›i React Hook Form. ChÃºng ta sáº½ xÃ¢y dá»±ng schemas tá»« Ä‘Æ¡n giáº£n Ä‘áº¿n phá»©c táº¡p, custom error messages, vÃ  hiá»ƒu rÃµ khi nÃ o nÃªn dÃ¹ng schema-based validation thay vÃ¬ inline validation.

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] Hiá»ƒu Ä‘Æ°á»£c schema-based validation lÃ  gÃ¬ vÃ  táº¡i sao cáº§n thiáº¿t
- [ ] Viáº¿t Ä‘Æ°á»£c Zod schemas cho cÃ¡c use cases phá»• biáº¿n (string, number, email, nested objects, arrays)
- [ ] TÃ­ch há»£p Zod vá»›i React Hook Form sá»­ dá»¥ng zodResolver
- [ ] Custom error messages vÃ  localization
- [ ] So sÃ¡nh Ä‘Æ°á»£c trade-offs giá»¯a inline validation vs schema validation

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

1. **React Hook Form validation:** Trong NgÃ y 42, báº¡n Ä‘Ã£ há»c cÃ¡ch validate nhÆ° tháº¿ nÃ o? `register("email", { required: true, pattern: /.../ })` cÃ³ nhÆ°á»£c Ä‘iá»ƒm gÃ¬?

2. **Type safety:** Khi dÃ¹ng `watch()` hoáº·c `getValues()`, lÃ m sao TypeScript biáº¿t type cá»§a form data? CÃ³ cÃ¡ch nÃ o Ä‘á»ƒ cÃ³ auto-complete khÃ´ng?

3. **Reusability:** Náº¿u báº¡n cÃ³ 5 forms Ä‘á»u cáº§n validate email giá»‘ng nhau, báº¡n sáº½ lÃ m gÃ¬ Ä‘á»ƒ trÃ¡nh duplicate code?

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

Báº¡n Ä‘ang build má»™t á»©ng dá»¥ng e-commerce vá»›i nhiá»u forms: registration, checkout, profile settings, product reviews. Má»—i form Ä‘á»u cáº§n validate email, phone, address...

**Váº¥n Ä‘á» vá»›i inline validation:**

```jsx
// âŒ Registration form
<input {...register("email", {
  required: "Email is required",
  pattern: { value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i, message: "Invalid email" }
})} />

// âŒ Checkout form - duplicate validation logic
<input {...register("email", {
  required: "Email is required",
  pattern: { value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i, message: "Invalid email" }
})} />

// âŒ Profile form - again...
<input {...register("email", {
  required: "Email is required",
  pattern: { value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i, message: "Invalid email" }
})} />
```

**Nhá»¯ng váº¥n Ä‘á»:**

- âŒ Duplicate validation logic kháº¯p nÆ¡i
- âŒ KhÃ´ng cÃ³ type safety - TypeScript khÃ´ng biáº¿t shape cá»§a form data
- âŒ KhÃ³ maintain khi validation rules thay Ä‘á»•i
- âŒ KhÃ´ng cÃ³ auto-complete khi dÃ¹ng `watch()`, `getValues()`
- âŒ Validation logic láº«n lá»™n vá»›i UI code

### 1.2 Giáº£i PhÃ¡p: Schema-based Validation vá»›i Zod

**Zod** lÃ  má»™t TypeScript-first schema validation library cho phÃ©p báº¡n:

- âœ… Äá»‹nh nghÄ©a validation rules má»™t láº§n, dÃ¹ng nhiá»u nÆ¡i
- âœ… Tá»± Ä‘á»™ng infer TypeScript types tá»« schema
- âœ… TÃ¡ch biá»‡t validation logic khá»i UI
- âœ… Custom error messages dá»… dÃ ng
- âœ… Compose vÃ  reuse schemas

```jsx
// âœ… Define schema once
const userSchema = z.object({
  email: z.string().email("Invalid email address"),
  age: z.number().min(18, "Must be 18+"),
});

// Type Ä‘Æ°á»£c infer tá»± Ä‘á»™ng!
type UserFormData = z.infer<typeof userSchema>;
// { email: string; age: number; }

// Use everywhere vá»›i type safety
const { register, handleSubmit } = useForm<UserFormData>({
  resolver: zodResolver(userSchema)
});
```

### 1.3 Mental Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   ZOD SCHEMA FLOW                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. DEFINE SCHEMA (Single Source of Truth)
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ const schema = z.object({        â”‚
   â”‚   email: z.string().email(),     â”‚ â—„â”€â”€ Define once
   â”‚   age: z.number().min(18)        â”‚
   â”‚ })                               â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â”œâ”€â–º TypeScript Type (auto-inferred)
                  â”‚   type FormData = z.infer<typeof schema>
                  â”‚
                  â””â”€â–º Runtime Validation
                      schema.parse(data) â†’ valid or throw error

2. INTEGRATE WITH RHF
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ useForm({                        â”‚
   â”‚   resolver: zodResolver(schema)  â”‚ â—„â”€â”€ Bridge
   â”‚ })                               â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
   User Input â†’ Zod Validate â†’ RHF State â†’ Submit


3. REUSABILITY
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ emailSchema â”‚ â”€â”€â”¬â”€â–º Registration Form
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”œâ”€â–º Checkout Form
                     â””â”€â–º Profile Form
```

**Analogy:** Schema nhÆ° **blueprint cá»§a má»™t ngÃ´i nhÃ **

- Blueprint (schema) Ä‘á»‹nh nghÄ©a rules: phÃ²ng pháº£i rá»™ng Ã­t nháº¥t 10mÂ², cá»­a cao Ã­t nháº¥t 2m...
- Má»i ngÃ´i nhÃ  (form) xÃ¢y theo blueprint Ä‘á»u tuÃ¢n thá»§ rules
- Náº¿u thay Ä‘á»•i blueprint, má»i ngÃ´i nhÃ  má»›i Ä‘á»u follow rules má»›i
- Architect (TypeScript) biáº¿t chÃ­nh xÃ¡c structure tá»« blueprint

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

âŒ **"Schema validation chá»‰ cho backend, frontend dÃ¹ng inline validation lÃ  Ä‘á»§"**

- âœ… Schema validation giÃºp DRY (Don't Repeat Yourself), type safety, vÃ  dá»… maintain hÆ¡n nhiá»u

âŒ **"Zod lÃ m bundle size lá»›n hÆ¡n, khÃ´ng nÃªn dÃ¹ng"**

- âœ… Zod chá»‰ ~8KB gzipped, nhÆ°ng tiáº¿t kiá»‡m Ä‘Æ°á»£c hÃ ng trÄƒm dÃ²ng validation code duplicate

âŒ **"Schema phá»©c táº¡p, khÃ³ há»c"**

- âœ… Zod API ráº¥t intuitive: `z.string().email().min(5)` - Ä‘á»c nhÆ° tiáº¿ng Anh

âŒ **"DÃ¹ng schema thÃ¬ khÃ´ng custom Ä‘Æ°á»£c error messages"**

- âœ… Zod cho phÃ©p custom messages á»Ÿ má»i level: global, per-field, per-rule

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Zod Basics - Primitive Types â­

```jsx
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Demo: Basic Zod schema vá»›i primitive types
 */

// âŒ BEFORE: Inline validation (not reusable, no type safety)
function LoginFormBefore() {
  const { register, handleSubmit, formState: { errors } } = useForm();

  return (
    <form onSubmit={handleSubmit(data => console.log(data))}>
      <input
        {...register("email", {
          required: "Email required",
          pattern: {
            value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
            message: "Invalid email"
          }
        })}
      />
      {errors.email && <span>{errors.email.message}</span>}

      <input
        type="password"
        {...register("password", {
          required: "Password required",
          minLength: { value: 8, message: "Min 8 chars" }
        })}
      />
      {errors.password && <span>{errors.password.message}</span>}
    </form>
  );
}

// âœ… AFTER: Schema validation (reusable, type-safe)
const loginSchema = z.object({
  email: z.string()
    .min(1, "Email is required")
    .email("Invalid email address"),
  password: z.string()
    .min(8, "Password must be at least 8 characters")
});

// Type tá»± Ä‘á»™ng infer!
type LoginFormData = z.infer<typeof loginSchema>;
// { email: string; password: string; }

function LoginFormAfter() {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema)
  });

  const onSubmit = (data: LoginFormData) => {
    console.log(data); // TypeScript knows exact shape!
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input {...register("email")} placeholder="Email" />
        {errors.email && <span>{errors.email.message}</span>}
      </div>

      <div>
        <input
          type="password"
          {...register("password")}
          placeholder="Password"
        />
        {errors.password && <span>{errors.password.message}</span>}
      </div>

      <button type="submit">Login</button>
    </form>
  );
}

// ğŸ¯ BENEFITS:
// 1. Auto-complete khi gÃµ data.email, data.password
// 2. Schema cÃ³ thá»ƒ reuse cho API validation
// 3. Dá»… test: loginSchema.parse({ email: "test", password: "123" })
```

### Demo 2: Nested Objects & Arrays â­â­

```jsx
import { z } from 'zod';
import { useForm, useFieldArray } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Demo: Complex schema vá»›i nested objects vÃ  arrays
 * Use case: User profile vá»›i multiple addresses
 */

// Define reusable schemas
const addressSchema = z.object({
  street: z.string().min(1, "Street is required"),
  city: z.string().min(1, "City is required"),
  zipCode: z.string().regex(/^\d{5}$/, "Invalid ZIP code"),
  isDefault: z.boolean().default(false)
});

const profileSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email"),
  age: z.number()
    .min(18, "Must be 18 or older")
    .max(120, "Invalid age"),

  // Nested object
  preferences: z.object({
    newsletter: z.boolean(),
    notifications: z.boolean()
  }),

  // Array of objects
  addresses: z.array(addressSchema)
    .min(1, "At least one address required")
    .max(5, "Maximum 5 addresses allowed")
});

type ProfileFormData = z.infer<typeof profileSchema>;

function ProfileForm() {
  const {
    register,
    control,
    handleSubmit,
    formState: { errors }
  } = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      preferences: { newsletter: true, notifications: false },
      addresses: [{ street: '', city: '', zipCode: '', isDefault: true }]
    }
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: "addresses"
  });

  const onSubmit = (data: ProfileFormData) => {
    console.log('Valid data:', data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Basic fields */}
      <input {...register("name")} placeholder="Name" />
      {errors.name && <p>{errors.name.message}</p>}

      <input {...register("email")} placeholder="Email" />
      {errors.email && <p>{errors.email.message}</p>}

      <input
        type="number"
        {...register("age", { valueAsNumber: true })}
        placeholder="Age"
      />
      {errors.age && <p>{errors.age.message}</p>}

      {/* Nested object */}
      <fieldset>
        <legend>Preferences</legend>
        <label>
          <input type="checkbox" {...register("preferences.newsletter")} />
          Newsletter
        </label>
        <label>
          <input type="checkbox" {...register("preferences.notifications")} />
          Notifications
        </label>
      </fieldset>

      {/* Array */}
      <fieldset>
        <legend>Addresses</legend>
        {fields.map((field, index) => (
          <div key={field.id}>
            <h4>Address {index + 1}</h4>

            <input
              {...register(`addresses.${index}.street`)}
              placeholder="Street"
            />
            {errors.addresses?.[index]?.street && (
              <p>{errors.addresses[index].street.message}</p>
            )}

            <input
              {...register(`addresses.${index}.city`)}
              placeholder="City"
            />
            {errors.addresses?.[index]?.city && (
              <p>{errors.addresses[index].city.message}</p>
            )}

            <input
              {...register(`addresses.${index}.zipCode`)}
              placeholder="ZIP Code"
            />
            {errors.addresses?.[index]?.zipCode && (
              <p>{errors.addresses[index].zipCode.message}</p>
            )}

            <label>
              <input
                type="checkbox"
                {...register(`addresses.${index}.isDefault`)}
              />
              Default address
            </label>

            {fields.length > 1 && (
              <button type="button" onClick={() => remove(index)}>
                Remove
              </button>
            )}
          </div>
        ))}

        {errors.addresses?.root && (
          <p>{errors.addresses.root.message}</p>
        )}

        <button
          type="button"
          onClick={() => append({
            street: '',
            city: '',
            zipCode: '',
            isDefault: false
          })}
        >
          Add Address
        </button>
      </fieldset>

      <button type="submit">Save Profile</button>
    </form>
  );
}

// Result: Type-safe form vá»›i complex nested structure!
```

### Demo 3: Advanced Validation & Custom Rules â­â­â­

```jsx
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Demo: Advanced Zod features
 * - Conditional validation
 * - Custom validation functions
 * - Cross-field validation
 * - Transformations
 */

// âœ… Password confirmation validation
const registrationSchema = z.object({
  username: z.string()
    .min(3, "Username must be at least 3 characters")
    .max(20, "Username must be at most 20 characters")
    .regex(/^[a-zA-Z0-9_]+$/, "Only letters, numbers and underscore allowed"),

  email: z.string().email("Invalid email address"),

  password: z.string()
    .min(8, "Password must be at least 8 characters")
    .regex(/[A-Z]/, "Must contain at least one uppercase letter")
    .regex(/[a-z]/, "Must contain at least one lowercase letter")
    .regex(/[0-9]/, "Must contain at least one number"),

  confirmPassword: z.string(),

  age: z.string()
    .transform(val => parseInt(val, 10)) // Transform string to number
    .pipe(z.number().min(18, "Must be 18+").max(120, "Invalid age")),

  // Conditional validation
  hasPromoCode: z.boolean(),
  promoCode: z.string().optional(),

  // Custom validation
  termsAccepted: z.boolean()
    .refine(val => val === true, {
      message: "You must accept the terms and conditions"
    })
})
.refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"] // Error sáº½ hiá»‡n á»Ÿ confirmPassword field
})
.refine(
  data => {
    // If hasPromoCode is true, promoCode must be provided
    if (data.hasPromoCode) {
      return data.promoCode && data.promoCode.length > 0;
    }
    return true;
  },
  {
    message: "Promo code is required when checkbox is selected",
    path: ["promoCode"]
  }
);

type RegistrationFormData = z.infer<typeof registrationSchema>;

function RegistrationForm() {
  const {
    register,
    watch,
    handleSubmit,
    formState: { errors }
  } = useForm<RegistrationFormData>({
    resolver: zodResolver(registrationSchema)
  });

  const hasPromoCode = watch("hasPromoCode");

  const onSubmit = (data: RegistrationFormData) => {
    console.log('Registration data:', data);
    // data.age is number (transformed automatically!)
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input {...register("username")} placeholder="Username" />
        {errors.username && <p>{errors.username.message}</p>}
      </div>

      <div>
        <input {...register("email")} placeholder="Email" />
        {errors.email && <p>{errors.email.message}</p>}
      </div>

      <div>
        <input
          type="password"
          {...register("password")}
          placeholder="Password"
        />
        {errors.password && <p>{errors.password.message}</p>}
      </div>

      <div>
        <input
          type="password"
          {...register("confirmPassword")}
          placeholder="Confirm Password"
        />
        {errors.confirmPassword && <p>{errors.confirmPassword.message}</p>}
      </div>

      <div>
        <input {...register("age")} placeholder="Age" />
        {errors.age && <p>{errors.age.message}</p>}
      </div>

      <div>
        <label>
          <input type="checkbox" {...register("hasPromoCode")} />
          I have a promo code
        </label>
      </div>

      {hasPromoCode && (
        <div>
          <input {...register("promoCode")} placeholder="Promo Code" />
          {errors.promoCode && <p>{errors.promoCode.message}</p>}
        </div>
      )}

      <div>
        <label>
          <input type="checkbox" {...register("termsAccepted")} />
          I accept the terms and conditions
        </label>
        {errors.termsAccepted && <p>{errors.termsAccepted.message}</p>}
      </div>

      <button type="submit">Register</button>
    </form>
  );
}

// ğŸ¯ KEY FEATURES DEMONSTRATED:
// 1. Cross-field validation (password === confirmPassword)
// 2. Conditional validation (promoCode required if hasPromoCode)
// 3. Custom validation (termsAccepted must be true)
// 4. Transformations (age string â†’ number)
// 5. Complex regex patterns
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ BÃ i 1: Basic Schema Definition (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Táº¡o schema cÆ¡ báº£n cho contact form
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: Nested objects, arrays, custom validation
 *
 * Requirements:
 * 1. Name: required, min 2 chars
 * 2. Email: required, valid email format
 * 3. Phone: optional, but if provided must match format (XXX) XXX-XXXX
 * 4. Message: required, min 10 chars, max 500 chars
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - DÃ¹ng z.string().optional() cho optional fields
 * - DÃ¹ng z.string().regex() cho phone validation
 */

// âŒ CÃCH SAI: Inline validation khÃ´ng reusable
function ContactFormWrong() {
  const { register } = useForm();

  return (
    <form>
      <input
        {...register('name', {
          required: true,
          minLength: 2,
        })}
      />
      {/* Pháº£i copy/paste validation logic má»i nÆ¡i */}
    </form>
  );
}

// âœ… CÃCH ÄÃšNG: Schema-based validation
const contactSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  phone: z
    .string()
    .regex(/^\(\d{3}\) \d{3}-\d{4}$/, 'Phone must be (XXX) XXX-XXXX format')
    .optional()
    .or(z.literal('')), // Allow empty string
  message: z
    .string()
    .min(10, 'Message must be at least 10 characters')
    .max(500, 'Message must be at most 500 characters'),
});

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
// TODO: Implement ContactForm component using the schema above
// TODO: Show validation errors below each field
// TODO: Log submitted data to console
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Contact form vá»›i Zod schema validation
 * @returns {JSX.Element} Contact form component
 */
const contactSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  phone: z.string()
    .regex(/^\(\d{3}\) \d{3}-\d{4}$/, "Phone must be (XXX) XXX-XXXX format")
    .optional()
    .or(z.literal("")),
  message: z.string()
    .min(10, "Message must be at least 10 characters")
    .max(500, "Message must be at most 500 characters")
});

type ContactFormData = z.infer<typeof contactSchema>;

function ContactForm() {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm<ContactFormData>({
    resolver: zodResolver(contactSchema)
  });

  const onSubmit = (data: ContactFormData) => {
    console.log('Contact form data:', data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <label>Name *</label>
        <input {...register("name")} />
        {errors.name && <p style={{ color: 'red' }}>{errors.name.message}</p>}
      </div>

      <div>
        <label>Email *</label>
        <input {...register("email")} />
        {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
      </div>

      <div>
        <label>Phone (optional)</label>
        <input {...register("phone")} placeholder="(123) 456-7890" />
        {errors.phone && <p style={{ color: 'red' }}>{errors.phone.message}</p>}
      </div>

      <div>
        <label>Message *</label>
        <textarea {...register("message")} rows={5} />
        {errors.message && <p style={{ color: 'red' }}>{errors.message.message}</p>}
      </div>

      <button type="submit">Send Message</button>
    </form>
  );
}

// Example usage:
// Valid: { name: "John", email: "john@example.com", phone: "", message: "Hello world!" }
// Invalid: { name: "J", email: "invalid", phone: "123", message: "Short" }
```

</details>

### â­â­ BÃ i 2: Schema Composition (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Táº¡o reusable schemas vÃ  compose chÃºng
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: Báº¡n cÃ³ registration form vÃ  profile update form.
 * Cáº£ hai Ä‘á»u cáº§n email, name, nhÆ°ng registration cáº§n password,
 * cÃ²n profile update cáº§n bio.
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 * Approach A: Táº¡o 2 schemas riÃªng biá»‡t
 * Pros: ÄÆ¡n giáº£n, dá»… hiá»ƒu
 * Cons: Duplicate email & name validation
 *
 * Approach B: Táº¡o base schema, extend cho má»—i use case
 * Pros: DRY, dá»… maintain
 * Cons: Cáº§n hiá»ƒu schema composition
 *
 * ğŸ’­ Báº N CHá»ŒN GÃŒ VÃ€ Táº I SAO?
 *
 * Sau Ä‘Ã³ implement 2 forms:
 * 1. RegistrationForm: name, email, password, confirmPassword
 * 2. ProfileUpdateForm: name, email, bio (optional)
 */

// âŒ APPROACH A: Duplicate schemas
const registrationSchemaA = z.object({
  name: z.string().min(2),
  email: z.string().email(),
  password: z.string().min(8),
});

const profileSchemaA = z.object({
  name: z.string().min(2), // Duplicate!
  email: z.string().email(), // Duplicate!
  bio: z.string().optional(),
});

// âœ… APPROACH B: Composed schemas
const baseUserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
});

const registrationSchemaB = baseUserSchema
  .extend({
    password: z.string().min(8, 'Password must be at least 8 characters'),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ['confirmPassword'],
  });

const profileSchemaB = baseUserSchema.extend({
  bio: z.string().max(500, 'Bio must be at most 500 characters').optional(),
});

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
// TODO: Chá»n approach B vÃ  implement cáº£ 2 forms
// TODO: Document lÃ½ do chá»n approach B trong comment
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * APPROACH B: Schema composition
 *
 * LÃ½ do chá»n:
 * 1. DRY - khÃ´ng duplicate validation logic
 * 2. Maintainability - thay Ä‘á»•i email validation á»Ÿ 1 chá»— â†’ affect táº¥t cáº£
 * 3. Type safety - baseUserSchema cÃ³ thá»ƒ reuse cho API types
 * 4. Scalability - dá»… thÃªm fields vÃ o base schema sau nÃ y
 */

// Base schema - reusable
const baseUserSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address")
});

// Registration schema - extends base
const registrationSchema = baseUserSchema.extend({
  password: z.string().min(8, "Password must be at least 8 characters"),
  confirmPassword: z.string()
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"]
});

// Profile schema - extends base
const profileSchema = baseUserSchema.extend({
  bio: z.string().max(500, "Bio must be at most 500 characters").optional()
});

type RegistrationFormData = z.infer<typeof registrationSchema>;
type ProfileFormData = z.infer<typeof profileSchema>;

/**
 * Registration form component
 */
function RegistrationForm() {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm<RegistrationFormData>({
    resolver: zodResolver(registrationSchema)
  });

  const onSubmit = (data: RegistrationFormData) => {
    console.log('Registration:', data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Register</h2>

      <div>
        <input {...register("name")} placeholder="Name" />
        {errors.name && <p style={{ color: 'red' }}>{errors.name.message}</p>}
      </div>

      <div>
        <input {...register("email")} placeholder="Email" />
        {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
      </div>

      <div>
        <input type="password" {...register("password")} placeholder="Password" />
        {errors.password && <p style={{ color: 'red' }}>{errors.password.message}</p>}
      </div>

      <div>
        <input type="password" {...register("confirmPassword")} placeholder="Confirm Password" />
        {errors.confirmPassword && <p style={{ color: 'red' }}>{errors.confirmPassword.message}</p>}
      </div>

      <button type="submit">Register</button>
    </form>
  );
}

/**
 * Profile update form component
 */
function ProfileUpdateForm() {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      name: "John Doe",
      email: "john@example.com",
      bio: ""
    }
  });

  const onSubmit = (data: ProfileFormData) => {
    console.log('Profile update:', data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Update Profile</h2>

      <div>
        <input {...register("name")} placeholder="Name" />
        {errors.name && <p style={{ color: 'red' }}>{errors.name.message}</p>}
      </div>

      <div>
        <input {...register("email")} placeholder="Email" />
        {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
      </div>

      <div>
        <textarea {...register("bio")} placeholder="Bio (optional)" rows={4} />
        {errors.bio && <p style={{ color: 'red' }}>{errors.bio.message}</p>}
      </div>

      <button type="submit">Update Profile</button>
    </form>
  );
}

// Result:
// - baseUserSchema Ä‘Æ°á»£c reuse
// - Thay Ä‘á»•i email validation â†’ affect cáº£ 2 forms
// - Type-safe vá»›i auto-complete
```

</details>

### â­â­â­ BÃ i 3: Dynamic Form vá»›i Custom Validation (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build job application form vá»›i dynamic fields
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  recruiter, tÃ´i muá»‘n collect job applications vá»›i
 * flexible number of previous jobs vÃ  custom validation cho tá»«ng field"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Basic info: name, email, phone
 * - [ ] Current position & desired position
 * - [ ] Experience years: must match total years from previous jobs
 * - [ ] Previous jobs array: company, position, startDate, endDate
 * - [ ] Validate: endDate > startDate
 * - [ ] Validate: total experience = sum of all job durations
 * - [ ] Skills: comma-separated string, min 3 skills
 *
 * ğŸ¨ Technical Constraints:
 * - DÃ¹ng useFieldArray cho previous jobs
 * - Custom validation function cho experience matching
 * - Transform skills string â†’ array
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Empty previous jobs array
 * - Overlapping job dates
 * - Future end dates
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] Schema vá»›i nested validations
 * - [ ] Custom refine cho experience calculation
 * - [ ] Date validation
 * - [ ] Skills transformation
 * - [ ] Error messages clear & helpful
 */

// TODO: Implement schema and form
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { z } from 'zod';
import { useForm, useFieldArray } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * Job application form vá»›i complex validation
 * @returns {JSX.Element} Job application form
 */

// Helper: Calculate years between two dates
const calculateYears = (start: string, end: string): number => {
  const startDate = new Date(start);
  const endDate = new Date(end);
  const diff = endDate.getTime() - startDate.getTime();
  return Math.floor(diff / (1000 * 60 * 60 * 24 * 365));
};

const previousJobSchema = z.object({
  company: z.string().min(1, "Company is required"),
  position: z.string().min(1, "Position is required"),
  startDate: z.string().min(1, "Start date is required"),
  endDate: z.string().min(1, "End date is required")
}).refine(
  data => {
    const start = new Date(data.startDate);
    const end = new Date(data.endDate);
    return end > start;
  },
  {
    message: "End date must be after start date",
    path: ["endDate"]
  }
).refine(
  data => {
    const end = new Date(data.endDate);
    const today = new Date();
    return end <= today;
  },
  {
    message: "End date cannot be in the future",
    path: ["endDate"]
  }
);

const jobApplicationSchema = z.object({
  // Basic info
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Invalid email address"),
  phone: z.string().regex(/^\d{10}$/, "Phone must be 10 digits"),

  // Positions
  currentPosition: z.string().min(1, "Current position is required"),
  desiredPosition: z.string().min(1, "Desired position is required"),

  // Experience
  experienceYears: z.string()
    .transform(val => parseInt(val, 10))
    .pipe(z.number().min(0, "Experience must be 0 or more")),

  // Previous jobs
  previousJobs: z.array(previousJobSchema)
    .min(1, "At least one previous job required"),

  // Skills - transform comma-separated to array
  skills: z.string()
    .min(1, "Skills are required")
    .transform(val => val.split(',').map(s => s.trim()).filter(Boolean))
    .pipe(z.array(z.string()).min(3, "At least 3 skills required"))
}).refine(
  data => {
    // Calculate total experience from previous jobs
    const totalYears = data.previousJobs.reduce((sum, job) => {
      return sum + calculateYears(job.startDate, job.endDate);
    }, 0);

    return totalYears === data.experienceYears;
  },
  {
    message: "Total experience must match sum of previous job durations",
    path: ["experienceYears"]
  }
);

type JobApplicationData = z.infer<typeof jobApplicationSchema>;

function JobApplicationForm() {
  const {
    register,
    control,
    handleSubmit,
    formState: { errors }
  } = useForm<JobApplicationData>({
    resolver: zodResolver(jobApplicationSchema),
    defaultValues: {
      previousJobs: [
        { company: '', position: '', startDate: '', endDate: '' }
      ]
    }
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: "previousJobs"
  });

  const onSubmit = (data: JobApplicationData) => {
    console.log('Application data:', data);
    // Note: skills is now an array after transformation!
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h2>Job Application</h2>

      {/* Basic Info */}
      <fieldset>
        <legend>Basic Information</legend>

        <div>
          <input {...register("name")} placeholder="Full Name" />
          {errors.name && <p style={{ color: 'red' }}>{errors.name.message}</p>}
        </div>

        <div>
          <input {...register("email")} placeholder="Email" />
          {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
        </div>

        <div>
          <input {...register("phone")} placeholder="Phone (10 digits)" />
          {errors.phone && <p style={{ color: 'red' }}>{errors.phone.message}</p>}
        </div>
      </fieldset>

      {/* Positions */}
      <fieldset>
        <legend>Position Information</legend>

        <div>
          <input {...register("currentPosition")} placeholder="Current Position" />
          {errors.currentPosition && <p style={{ color: 'red' }}>{errors.currentPosition.message}</p>}
        </div>

        <div>
          <input {...register("desiredPosition")} placeholder="Desired Position" />
          {errors.desiredPosition && <p style={{ color: 'red' }}>{errors.desiredPosition.message}</p>}
        </div>

        <div>
          <input {...register("experienceYears")} placeholder="Total Experience (years)" />
          {errors.experienceYears && <p style={{ color: 'red' }}>{errors.experienceYears.message}</p>}
        </div>
      </fieldset>

      {/* Previous Jobs */}
      <fieldset>
        <legend>Previous Jobs</legend>

        {fields.map((field, index) => (
          <div key={field.id} style={{ border: '1px solid #ccc', padding: '10px', marginBottom: '10px' }}>
            <h4>Job {index + 1}</h4>

            <div>
              <input {...register(`previousJobs.${index}.company`)} placeholder="Company" />
              {errors.previousJobs?.[index]?.company && (
                <p style={{ color: 'red' }}>{errors.previousJobs[index].company.message}</p>
              )}
            </div>

            <div>
              <input {...register(`previousJobs.${index}.position`)} placeholder="Position" />
              {errors.previousJobs?.[index]?.position && (
                <p style={{ color: 'red' }}>{errors.previousJobs[index].position.message}</p>
              )}
            </div>

            <div>
              <input type="date" {...register(`previousJobs.${index}.startDate`)} />
              {errors.previousJobs?.[index]?.startDate && (
                <p style={{ color: 'red' }}>{errors.previousJobs[index].startDate.message}</p>
              )}
            </div>

            <div>
              <input type="date" {...register(`previousJobs.${index}.endDate`)} />
              {errors.previousJobs?.[index]?.endDate && (
                <p style={{ color: 'red' }}>{errors.previousJobs[index].endDate.message}</p>
              )}
            </div>

            {fields.length > 1 && (
              <button type="button" onClick={() => remove(index)}>Remove Job</button>
            )}
          </div>
        ))}

        {errors.previousJobs?.root && (
          <p style={{ color: 'red' }}>{errors.previousJobs.root.message}</p>
        )}

        <button
          type="button"
          onClick={() => append({ company: '', position: '', startDate: '', endDate: '' })}
        >
          Add Previous Job
        </button>
      </fieldset>

      {/* Skills */}
      <fieldset>
        <legend>Skills</legend>
        <div>
          <input
            {...register("skills")}
            placeholder="Enter skills separated by commas (e.g., JavaScript, React, Node.js)"
          />
          {errors.skills && <p style={{ color: 'red' }}>{errors.skills.message}</p>}
        </div>
      </fieldset>

      <button type="submit">Submit Application</button>
    </form>
  );
}

// Example valid data:
// {
//   name: "John Doe",
//   email: "john@example.com",
//   phone: "1234567890",
//   currentPosition: "Senior Developer",
//   desiredPosition: "Lead Developer",
//   experienceYears: 5,
//   previousJobs: [
//     { company: "Google", position: "Developer", startDate: "2019-01-01", endDate: "2024-01-01" }
//   ],
//   skills: "JavaScript, React, TypeScript, Node.js"
// }
// Result: skills becomes ["JavaScript", "React", "TypeScript", "Node.js"]
```

</details>

### â­â­â­â­ BÃ i 4: Schema-based Localization (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build multi-language form validation
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Nhiá»‡m vá»¥:
 * 1. So sÃ¡nh Ã­t nháº¥t 3 approaches:
 *    - A: Hard-code error messages cho má»—i language
 *    - B: DÃ¹ng i18n library (react-i18next)
 *    - C: Custom error map function vá»›i Zod
 * 2. Document pros/cons má»—i approach
 * 3. Chá»n approach C (custom error map - no external deps)
 * 4. Viáº¿t ADR
 *
 * ADR Template:
 * - Context: Multi-language form cáº§n dynamic error messages
 * - Decision: DÃ¹ng Zod setErrorMap vá»›i custom translation function
 * - Rationale: Lightweight, no deps, Zod native feature
 * - Consequences: Pháº£i maintain translation object manually
 * - Alternatives Considered: i18next (too heavy), hard-code (not scalable)
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 * Build checkout form vá»›i English/Vietnamese toggle
 * Fields: name, email, cardNumber, expiryDate, cvv
 *
 * ğŸ§ª PHASE 3: Testing (10 phÃºt)
 * - [ ] Switch language â†’ error messages update
 * - [ ] All validation rules work in both languages
 * - [ ] Type safety maintained
 */

// TODO: Implement ADR vÃ  solution
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { useState } from 'react';
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * ADR: Multi-language Form Validation
 *
 * Context:
 * Cáº§n build checkout form support English vÃ  Vietnamese.
 * Error messages pháº£i hiá»ƒn thá»‹ Ä‘Ãºng ngÃ´n ngá»¯ user chá»n.
 *
 * Decision:
 * DÃ¹ng Zod's setErrorMap Ä‘á»ƒ customize error messages theo language.
 *
 * Rationale:
 * - Zod native feature, khÃ´ng cáº§n external library
 * - Lightweight (no i18next bundle)
 * - Dá»… maintain translations trong 1 object
 * - Type-safe
 *
 * Consequences:
 * - Pháº£i maintain translation object manually
 * - Má»—i validation error cáº§n translate
 * - KhÃ´ng cÃ³ advanced i18n features (pluralization, date formatting)
 *
 * Alternatives Considered:
 * - A: Hard-code messages â†’ khÃ´ng scalable
 * - B: react-i18next â†’ overkill cho simple use case, large bundle
 */

type Language = 'en' | 'vi';

// Translation object
const translations = {
  en: {
    required: 'This field is required',
    invalidEmail: 'Invalid email address',
    invalidCard: 'Invalid card number',
    invalidExpiry: 'Invalid expiry date (MM/YY)',
    invalidCVV: 'CVV must be 3 digits',
    minLength: 'Must be at least {{min}} characters',
  },
  vi: {
    required: 'TrÆ°á»ng nÃ y lÃ  báº¯t buá»™c',
    invalidEmail: 'Äá»‹a chá»‰ email khÃ´ng há»£p lá»‡',
    invalidCard: 'Sá»‘ tháº» khÃ´ng há»£p lá»‡',
    invalidExpiry: 'NgÃ y háº¿t háº¡n khÃ´ng há»£p lá»‡ (MM/YY)',
    invalidCVV: 'CVV pháº£i lÃ  3 chá»¯ sá»‘',
    minLength: 'Pháº£i cÃ³ Ã­t nháº¥t {{min}} kÃ½ tá»±',
  }
};

// Custom error map factory
const createErrorMap = (lang: Language): z.ZodErrorMap => {
  return (issue, ctx) => {
    const t = translations[lang];

    switch (issue.code) {
      case z.ZodIssueCode.invalid_string:
        if (issue.validation === 'email') {
          return { message: t.invalidEmail };
        }
        break;
      case z.ZodIssueCode.too_small:
        if (issue.type === 'string') {
          return {
            message: t.minLength.replace('{{min}}', String(issue.minimum))
          };
        }
        break;
    }

    return { message: ctx.defaultError };
  };
};

// Schema factory - táº¡o schema vá»›i custom messages theo language
const createCheckoutSchema = (lang: Language) => {
  const t = translations[lang];

  return z.object({
    name: z.string().min(1, t.required).min(2, t.minLength.replace('{{min}}', '2')),
    email: z.string().min(1, t.required).email(t.invalidEmail),
    cardNumber: z.string()
      .min(1, t.required)
      .regex(/^\d{16}$/, t.invalidCard),
    expiryDate: z.string()
      .min(1, t.required)
      .regex(/^(0[1-9]|1[0-2])\/\d{2}$/, t.invalidExpiry),
    cvv: z.string()
      .min(1, t.required)
      .regex(/^\d{3}$/, t.invalidCVV)
  });
};

type CheckoutFormData = z.infer<ReturnType<typeof createCheckoutSchema>>;

/**
 * Checkout form vá»›i multi-language support
 */
function MultiLanguageCheckoutForm() {
  const [language, setLanguage] = useState<Language>('en');

  // Recreate schema when language changes
  const schema = createCheckoutSchema(language);

  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm<CheckoutFormData>({
    resolver: zodResolver(schema)
  });

  const onSubmit = (data: CheckoutFormData) => {
    console.log('Checkout data:', data);
  };

  const labels = {
    en: {
      title: 'Checkout',
      name: 'Full Name',
      email: 'Email',
      cardNumber: 'Card Number',
      expiryDate: 'Expiry Date (MM/YY)',
      cvv: 'CVV',
      submit: 'Complete Purchase',
      switchLang: 'Switch to Vietnamese'
    },
    vi: {
      title: 'Thanh toÃ¡n',
      name: 'Há» vÃ  tÃªn',
      email: 'Email',
      cardNumber: 'Sá»‘ tháº»',
      expiryDate: 'NgÃ y háº¿t háº¡n (MM/YY)',
      cvv: 'CVV',
      submit: 'HoÃ n táº¥t thanh toÃ¡n',
      switchLang: 'Switch to English'
    }
  };

  const t = labels[language];

  return (
    <div>
      <button
        type="button"
        onClick={() => setLanguage(lang => lang === 'en' ? 'vi' : 'en')}
      >
        {t.switchLang}
      </button>

      <form onSubmit={handleSubmit(onSubmit)}>
        <h2>{t.title}</h2>

        <div>
          <label>{t.name}</label>
          <input {...register("name")} />
          {errors.name && <p style={{ color: 'red' }}>{errors.name.message}</p>}
        </div>

        <div>
          <label>{t.email}</label>
          <input {...register("email")} />
          {errors.email && <p style={{ color: 'red' }}>{errors.email.message}</p>}
        </div>

        <div>
          <label>{t.cardNumber}</label>
          <input {...register("cardNumber")} placeholder="1234567890123456" />
          {errors.cardNumber && <p style={{ color: 'red' }}>{errors.cardNumber.message}</p>}
        </div>

        <div>
          <label>{t.expiryDate}</label>
          <input {...register("expiryDate")} placeholder="12/25" />
          {errors.expiryDate && <p style={{ color: 'red' }}>{errors.expiryDate.message}</p>}
        </div>

        <div>
          <label>{t.cvv}</label>
          <input {...register("cvv")} placeholder="123" maxLength={3} />
          {errors.cvv && <p style={{ color: 'red' }}>{errors.cvv.message}</p>}
        </div>

        <button type="submit">{t.submit}</button>
      </form>
    </div>
  );
}

// Usage example:
// Click "Switch to Vietnamese" â†’ All error messages display in Vietnamese
// Validation logic stays the same, only messages change
```

</details>

### â­â­â­â­â­ BÃ i 5: Production-grade E-commerce Checkout (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build production-ready checkout flow
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * Multi-step checkout: Shipping â†’ Payment â†’ Review
 * - Step 1: Shipping info (name, address, phone)
 * - Step 2: Payment (card number, expiry, cvv, billing address)
 * - Step 3: Review & confirm
 *
 * ğŸ—ï¸ Technical Design Doc:
 * 1. Component Architecture
 *    - CheckoutWizard (container)
 *    - ShippingStep, PaymentStep, ReviewStep (presentational)
 *    - useCheckoutForm (custom hook)
 *
 * 2. State Management Strategy
 *    - useState cho current step
 *    - React Hook Form cho form state
 *    - Context KHÃ”NG cáº§n (data flow Ä‘Æ¡n giáº£n)
 *
 * 3. Validation Strategy
 *    - Validate per step (partial validation)
 *    - Final validation on submit
 *    - Async validation cho billing address (simulate API call)
 *
 * 4. Performance Considerations
 *    - Memoize schemas (useMemo)
 *    - Debounce async validation
 *    - Code splitting per step (comment for future upgrade)
 *
 * 5. Error Handling Strategy
 *    - Field-level errors
 *    - Step-level errors
 *    - Submission errors
 *
 * âœ… Production Checklist:
 * - [ ] Type-safe vá»›i TypeScript
 * - [ ] Error handling Ä‘áº§y Ä‘á»§
 * - [ ] Loading states cho async validation
 * - [ ] Empty states
 * - [ ] Validation messages clear
 * - [ ] Accessibility (ARIA labels, keyboard nav)
 * - [ ] Mobile responsive (comment about CSS)
 * - [ ] Data persistence (comment for localStorage upgrade)
 *
 * ğŸ“ Documentation:
 * - Schema structure
 * - Component hierarchy
 * - Usage examples
 */

// TODO: Full implementation vá»›i production-grade quality
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { useState, useMemo } from 'react';
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * PRODUCTION-GRADE E-COMMERCE CHECKOUT
 *
 * Architecture:
 * - Multi-step wizard (Shipping â†’ Payment â†’ Review)
 * - Schema validation per step
 * - Type-safe data flow
 * - Async validation simulation
 *
 * Future upgrades:
 * - Add localStorage persistence (NgÃ y 24: useLocalStorage)
 * - Add API integration (Phase 6: Backend integration)
 * - Add code splitting (React.lazy - chÆ°a há»c)
 */

// ============================================
// SCHEMAS
// ============================================

const shippingSchema = z.object({
  fullName: z.string().min(2, "Full name must be at least 2 characters"),
  phone: z.string().regex(/^\d{10}$/, "Phone must be 10 digits"),
  address: z.string().min(10, "Address must be at least 10 characters"),
  city: z.string().min(1, "City is required"),
  zipCode: z.string().regex(/^\d{5}$/, "ZIP code must be 5 digits"),
  country: z.string().min(1, "Country is required")
});

const paymentSchema = z.object({
  cardNumber: z.string().regex(/^\d{16}$/, "Card number must be 16 digits"),
  cardHolder: z.string().min(2, "Card holder name required"),
  expiryDate: z.string().regex(/^(0[1-9]|1[0-2])\/\d{2}$/, "Format: MM/YY"),
  cvv: z.string().regex(/^\d{3}$/, "CVV must be 3 digits"),
  billingAddressSame: z.boolean(),
  billingAddress: z.string().optional()
}).refine(
  data => {
    if (!data.billingAddressSame) {
      return data.billingAddress && data.billingAddress.length >= 10;
    }
    return true;
  },
  {
    message: "Billing address must be at least 10 characters",
    path: ["billingAddress"]
  }
);

// Combined schema for final submission
const checkoutSchema = z.object({
  shipping: shippingSchema,
  payment: paymentSchema
});

type ShippingData = z.infer<typeof shippingSchema>;
type PaymentData = z.infer<typeof paymentSchema>;
type CheckoutData = z.infer<typeof checkoutSchema>;

// ============================================
// STEP 1: SHIPPING
// ============================================

/**
 * Shipping information step
 */
function ShippingStep({ onNext, defaultValues }: {
  onNext: (data: ShippingData) => void;
  defaultValues?: Partial<ShippingData>;
}) {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm<ShippingData>({
    resolver: zodResolver(shippingSchema),
    defaultValues
  });

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Shipping Information</h2>

      <div>
        <label htmlFor="fullName">Full Name *</label>
        <input id="fullName" {...register("fullName")} />
        {errors.fullName && <p style={{ color: 'red' }}>{errors.fullName.message}</p>}
      </div>

      <div>
        <label htmlFor="phone">Phone *</label>
        <input id="phone" {...register("phone")} placeholder="1234567890" />
        {errors.phone && <p style={{ color: 'red' }}>{errors.phone.message}</p>}
      </div>

      <div>
        <label htmlFor="address">Address *</label>
        <input id="address" {...register("address")} />
        {errors.address && <p style={{ color: 'red' }}>{errors.address.message}</p>}
      </div>

      <div>
        <label htmlFor="city">City *</label>
        <input id="city" {...register("city")} />
        {errors.city && <p style={{ color: 'red' }}>{errors.city.message}</p>}
      </div>

      <div>
        <label htmlFor="zipCode">ZIP Code *</label>
        <input id="zipCode" {...register("zipCode")} placeholder="12345" />
        {errors.zipCode && <p style={{ color: 'red' }}>{errors.zipCode.message}</p>}
      </div>

      <div>
        <label htmlFor="country">Country *</label>
        <select id="country" {...register("country")}>
          <option value="">Select country</option>
          <option value="US">United States</option>
          <option value="VN">Vietnam</option>
        </select>
        {errors.country && <p style={{ color: 'red' }}>{errors.country.message}</p>}
      </div>

      <button type="submit">Continue to Payment</button>
    </form>
  );
}

// ============================================
// STEP 2: PAYMENT
// ============================================

/**
 * Payment information step
 */
function PaymentStep({ onNext, onBack, defaultValues }: {
  onNext: (data: PaymentData) => void;
  onBack: () => void;
  defaultValues?: Partial<PaymentData>;
}) {
  const {
    register,
    watch,
    handleSubmit,
    formState: { errors }
  } = useForm<PaymentData>({
    resolver: zodResolver(paymentSchema),
    defaultValues: defaultValues || { billingAddressSame: true }
  });

  const billingAddressSame = watch("billingAddressSame");

  return (
    <form onSubmit={handleSubmit(onNext)}>
      <h2>Payment Information</h2>

      <div>
        <label htmlFor="cardNumber">Card Number *</label>
        <input id="cardNumber" {...register("cardNumber")} placeholder="1234567890123456" />
        {errors.cardNumber && <p style={{ color: 'red' }}>{errors.cardNumber.message}</p>}
      </div>

      <div>
        <label htmlFor="cardHolder">Card Holder *</label>
        <input id="cardHolder" {...register("cardHolder")} />
        {errors.cardHolder && <p style={{ color: 'red' }}>{errors.cardHolder.message}</p>}
      </div>

      <div>
        <label htmlFor="expiryDate">Expiry Date *</label>
        <input id="expiryDate" {...register("expiryDate")} placeholder="12/25" />
        {errors.expiryDate && <p style={{ color: 'red' }}>{errors.expiryDate.message}</p>}
      </div>

      <div>
        <label htmlFor="cvv">CVV *</label>
        <input id="cvv" {...register("cvv")} placeholder="123" maxLength={3} />
        {errors.cvv && <p style={{ color: 'red' }}>{errors.cvv.message}</p>}
      </div>

      <div>
        <label>
          <input type="checkbox" {...register("billingAddressSame")} />
          Billing address same as shipping
        </label>
      </div>

      {!billingAddressSame && (
        <div>
          <label htmlFor="billingAddress">Billing Address *</label>
          <input id="billingAddress" {...register("billingAddress")} />
          {errors.billingAddress && <p style={{ color: 'red' }}>{errors.billingAddress.message}</p>}
        </div>
      )}

      <div>
        <button type="button" onClick={onBack}>Back to Shipping</button>
        <button type="submit">Review Order</button>
      </div>
    </form>
  );
}

// ============================================
// STEP 3: REVIEW
// ============================================

/**
 * Review and confirm step
 */
function ReviewStep({ data, onBack, onSubmit }: {
  data: CheckoutData;
  onBack: () => void;
  onSubmit: () => void;
}) {
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleConfirm = async () => {
    setIsSubmitting(true);

    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1500));

    setIsSubmitting(false);
    onSubmit();
  };

  return (
    <div>
      <h2>Review Your Order</h2>

      <section>
        <h3>Shipping Information</h3>
        <p><strong>Name:</strong> {data.shipping.fullName}</p>
        <p><strong>Phone:</strong> {data.shipping.phone}</p>
        <p><strong>Address:</strong> {data.shipping.address}</p>
        <p><strong>City:</strong> {data.shipping.city}</p>
        <p><strong>ZIP:</strong> {data.shipping.zipCode}</p>
        <p><strong>Country:</strong> {data.shipping.country}</p>
      </section>

      <section>
        <h3>Payment Information</h3>
        <p><strong>Card:</strong> **** **** **** {data.payment.cardNumber.slice(-4)}</p>
        <p><strong>Holder:</strong> {data.payment.cardHolder}</p>
        <p><strong>Expiry:</strong> {data.payment.expiryDate}</p>
        <p>
          <strong>Billing Address:</strong>{' '}
          {data.payment.billingAddressSame
            ? 'Same as shipping'
            : data.payment.billingAddress
          }
        </p>
      </section>

      <div>
        <button type="button" onClick={onBack} disabled={isSubmitting}>
          Back to Payment
        </button>
        <button onClick={handleConfirm} disabled={isSubmitting}>
          {isSubmitting ? 'Processing...' : 'Confirm Order'}
        </button>
      </div>
    </div>
  );
}

// ============================================
// MAIN WIZARD
// ============================================

/**
 * Main checkout wizard component
 * Manages multi-step flow and data aggregation
 */
function CheckoutWizard() {
  const [step, setStep] = useState<1 | 2 | 3>(1);
  const [shippingData, setShippingData] = useState<ShippingData | null>(null);
  const [paymentData, setPaymentData] = useState<PaymentData | null>(null);

  // Memoize combined data
  const checkoutData = useMemo<CheckoutData | null>(() => {
    if (shippingData && paymentData) {
      return { shipping: shippingData, payment: paymentData };
    }
    return null;
  }, [shippingData, paymentData]);

  const handleShippingSubmit = (data: ShippingData) => {
    setShippingData(data);
    setStep(2);
  };

  const handlePaymentSubmit = (data: PaymentData) => {
    setPaymentData(data);
    setStep(3);
  };

  const handleFinalSubmit = () => {
    console.log('Order confirmed!', checkoutData);
    alert('Order placed successfully!');

    // Reset wizard
    setStep(1);
    setShippingData(null);
    setPaymentData(null);
  };

  return (
    <div>
      {/* Progress indicator */}
      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
        <span style={{ fontWeight: step >= 1 ? 'bold' : 'normal' }}>1. Shipping</span>
        <span style={{ fontWeight: step >= 2 ? 'bold' : 'normal' }}>2. Payment</span>
        <span style={{ fontWeight: step >= 3 ? 'bold' : 'normal' }}>3. Review</span>
      </div>

      {/* Step content */}
      {step === 1 && (
        <ShippingStep
          onNext={handleShippingSubmit}
          defaultValues={shippingData || undefined}
        />
      )}

      {step === 2 && (
        <PaymentStep
          onNext={handlePaymentSubmit}
          onBack={() => setStep(1)}
          defaultValues={paymentData || undefined}
        />
      )}

      {step === 3 && checkoutData && (
        <ReviewStep
          data={checkoutData}
          onBack={() => setStep(2)}
          onSubmit={handleFinalSubmit}
        />
      )}
    </div>
  );
}

// Example flow:
// 1. Fill shipping â†’ data saved, move to step 2
// 2. Fill payment â†’ data saved, move to step 3
// 3. Review â†’ submit â†’ success
// Can go back to edit previous steps without losing data
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Inline vs Schema Validation

| Aspect                 | Inline Validation               | Schema Validation (Zod)             |
| ---------------------- | ------------------------------- | ----------------------------------- |
| **Code Organization**  | âŒ Scattered across components  | âœ… Centralized in schema files      |
| **Type Safety**        | âŒ Manual TypeScript types      | âœ… Auto-inferred from schema        |
| **Reusability**        | âŒ Duplicate validation logic   | âœ… Share schemas across forms       |
| **Maintainability**    | âŒ Hard to update rules         | âœ… Change once, apply everywhere    |
| **Error Messages**     | âŒ Strings scattered in JSX     | âœ… Centralized, easy to localize    |
| **Testing**            | âŒ Must test through UI         | âœ… Can test schemas in isolation    |
| **Bundle Size**        | âœ… No extra library             | âš ï¸ +8KB (Zod)                       |
| **Learning Curve**     | âœ… Simple, straightforward      | âš ï¸ Need to learn Zod API            |
| **Complex Validation** | âŒ Hard to express dependencies | âœ… Refine, transform, compose       |
| **Runtime Validation** | âŒ Only on form submit          | âœ… Can validate anywhere (API, etc) |

### Decision Tree: Khi nÃ o dÃ¹ng Schema Validation?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CÃ¢u há»i 1: Form cÃ³ >3 fields?       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”œâ”€ NO â”€â”€â–º Inline validation OK
         â”‚
         â””â”€ YES â”€â”€â–º Tiáº¿p tá»¥c
                    â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ CÃ¢u há»i 2: Validation logic phá»©c    â”‚
      â”‚ táº¡p (cross-field, conditional)?     â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â”œâ”€ NO â”€â”€â–º CÃ¢n nháº¯c inline hoáº·c schema
                    â”‚
                    â””â”€ YES â”€â”€â–º DÃ¹ng Schema
                               â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ CÃ¢u há»i 3: Schema Ä‘Æ°á»£c reuse á»Ÿ      â”‚
         â”‚ nhiá»u nÆ¡i (API, multiple forms)?    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â”œâ”€ NO â”€â”€â–º Schema váº«n tá»‘t (maintainability)
                               â”‚
                               â””â”€ YES â”€â”€â–º DEFINITELY Schema
```

### When to Use Each Approach

**âœ… DÃ¹ng Inline Validation khi:**

- Simple form (1-3 fields)
- One-off form khÃ´ng reuse
- Prototype/POC nhanh
- Team khÃ´ng muá»‘n thÃªm dependencies

**âœ… DÃ¹ng Schema Validation (Zod) khi:**

- Production application
- Complex validation rules
- Multiple forms chia sáº» validation logic
- Cáº§n type safety máº¡nh
- Team sáºµn sÃ ng há»c thÃªm tool

**âœ… DÃ¹ng Zod + Alternatives:**

- **Yup**: Náº¿u team Ä‘Ã£ dÃ¹ng Yup (legacy project)
  - Pros: API tÆ°Æ¡ng tá»± Zod, mature ecosystem
  - Cons: Ãt type-safe hÆ¡n, bundle lá»›n hÆ¡n
- **Joi**: Backend validation (Node.js)
- **Vest**: Náº¿u muá»‘n validation library Ä‘á»™c láº­p vá»›i form library

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Schema KhÃ´ng Validate âŒ

```jsx
import { z } from 'zod';
import { useForm } from 'react-hook-form';

// âŒ BUG: Form submit luÃ´n pass, khÃ´ng validate
const schema = z.object({
  email: z.string().email('Invalid email'),
});

function BuggyForm() {
  const { register, handleSubmit } = useForm({
    // resolver: zodResolver(schema) // Forgot this line!
  });

  const onSubmit = (data) => {
    console.log(data); // Logs even with invalid email!
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email')} />
      <button type='submit'>Submit</button>
    </form>
  );
}
```

**ğŸ” Debug Questions:**

1. Táº¡i sao form váº«n submit vá»›i email invalid?
2. LÃ m sao kiá»ƒm tra Zod cÃ³ Ä‘Æ°á»£c apply khÃ´ng?
3. Fix nhÆ° tháº¿ nÃ o?

**ğŸ’¡ Solution:**

<details>
<summary>Xem giáº£i thÃ­ch</summary>

**Váº¥n Ä‘á»:**
Forgot to pass `zodResolver(schema)` to useForm's `resolver` option. React Hook Form khÃ´ng biáº¿t pháº£i validate vá»›i Zod schema.

**Fix:**

```jsx
import { zodResolver } from '@hookform/resolvers/zod';

const { register, handleSubmit } = useForm({
  resolver: zodResolver(schema), // âœ… Add this!
});
```

**CÃ¡ch kiá»ƒm tra:**

```jsx
const {
  formState: { errors },
} = useForm({
  resolver: zodResolver(schema),
});

console.log(errors); // Should show errors if validation fails
```

**Prevention:**

- LuÃ´n import `zodResolver` cÃ¹ng vá»›i `z` vÃ  `useForm`
- Check `formState.errors` trong DevTools
- Unit test schema: `schema.safeParse({ email: "invalid" })`

</details>

### Bug 2: Optional Field Validation Sai âŒ

```jsx
// âŒ BUG: Phone validation fail ngay cáº£ khi empty
const schema = z.object({
  phone: z
    .string()
    .regex(/^\d{10}$/, 'Phone must be 10 digits')
    .optional(),
});

function PhoneForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: zodResolver(schema),
  });

  return (
    <form onSubmit={handleSubmit((data) => console.log(data))}>
      <input
        {...register('phone')}
        placeholder='Optional phone'
      />
      {errors.phone && <p>{errors.phone.message}</p>}
      <button type='submit'>Submit</button>
    </form>
  );
}

// Submit vá»›i empty phone â†’ ERROR: "Phone must be 10 digits"
// Expected: Should allow empty
```

**ğŸ” Debug Questions:**

1. Táº¡i sao optional field váº«n validate khi empty?
2. `optional()` hoáº¡t Ä‘á»™ng tháº¿ nÃ o vá»›i `regex()`?
3. Fix tháº¿ nÃ o Ä‘á»ƒ allow empty OR valid format?

**ğŸ’¡ Solution:**

<details>
<summary>Xem giáº£i thÃ­ch</summary>

**Váº¥n Ä‘á»:**
Khi input empty, value lÃ  `""` (empty string), khÃ´ng pháº£i `undefined`.  
`.optional()` chá»‰ skip validation khi value lÃ  `undefined`, khÃ´ng pháº£i empty string.

**Fix Option 1: Allow empty string**

```jsx
const schema = z.object({
  phone: z
    .string()
    .regex(/^\d{10}$/, 'Phone must be 10 digits')
    .optional()
    .or(z.literal('')), // âœ… Allow empty string
});
```

**Fix Option 2: Transform empty to undefined**

```jsx
const schema = z.object({
  phone: z
    .string()
    .transform((val) => (val === '' ? undefined : val))
    .optional()
    .refine((val) => val === undefined || /^\d{10}$/.test(val), {
      message: 'Phone must be 10 digits',
    }),
});
```

**Fix Option 3: Use union type (cleanest)**

```jsx
const schema = z.object({
  phone: z.union([z.string().regex(/^\d{10}$/), z.literal('')]).optional(),
});
```

**Prevention:**

- Remember: HTML inputs default to `""`, not `undefined`
- Always test empty state: `schema.safeParse({ phone: "" })`
- Use `.or(z.literal(""))` pattern for optional fields

</details>

### Bug 3: Cross-field Validation Path Sai âŒ

```jsx
// âŒ BUG: Password mismatch error hiá»‡n sai chá»—
const schema = z
  .object({
    password: z.string().min(8),
    confirmPassword: z.string(),
  })
  .refine(
    (data) => data.password === data.confirmPassword,
    { message: "Passwords don't match" }, // Missing path!
  );

function PasswordForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm({
    resolver: zodResolver(schema),
  });

  return (
    <form onSubmit={handleSubmit((data) => console.log(data))}>
      <input
        type='password'
        {...register('password')}
      />
      {errors.password && <p>{errors.password.message}</p>}

      <input
        type='password'
        {...register('confirmPassword')}
      />
      {errors.confirmPassword && <p>{errors.confirmPassword.message}</p>}

      {/* âŒ Error hiá»‡n á»Ÿ Ä‘Ã¢y thay vÃ¬ confirmPassword field */}
      {errors.root && <p>{errors.root.message}</p>}

      <button type='submit'>Submit</button>
    </form>
  );
}
```

**ğŸ” Debug Questions:**

1. Error "Passwords don't match" hiá»‡n á»Ÿ Ä‘Ã¢u?
2. LÃ m sao chá»‰ Ä‘á»‹nh error hiá»‡n á»Ÿ confirmPassword field?
3. Táº¡i sao cáº§n `path` trong refine options?

**ğŸ’¡ Solution:**

<details>
<summary>Xem giáº£i thÃ­ch</summary>

**Váº¥n Ä‘á»:**
Khi `.refine()` khÃ´ng cÃ³ `path`, error Ä‘Æ°á»£c gÃ¡n vÃ o `errors.root` (form-level error), khÃ´ng pháº£i field-specific error.

**Fix:**

```jsx
const schema = z
  .object({
    password: z.string().min(8),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ['confirmPassword'], // âœ… Specify error path!
  });

// Now error shows under confirmPassword field:
{
  errors.confirmPassword && <p>{errors.confirmPassword.message}</p>;
}
```

**How `path` works:**

- `path: ["confirmPassword"]` â†’ `errors.confirmPassword.message`
- `path: ["password"]` â†’ `errors.password.message`
- No path â†’ `errors.root.message`

**Multiple paths (advanced):**

```jsx
.refine(data => ..., {
  message: "Error message",
  path: ["field1", "field2"] // Error on both fields
})
```

**Prevention:**

- Always specify `path` in cross-field validation
- Match path vá»›i field where error should display
- Test: Submit invalid data, check where error appears

</details>

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

- [ ] TÃ´i hiá»ƒu sá»± khÃ¡c biá»‡t giá»¯a inline validation vÃ  schema-based validation
- [ ] TÃ´i biáº¿t cÃ¡ch define Zod schema cho primitive types (string, number, boolean)
- [ ] TÃ´i biáº¿t cÃ¡ch validate email, regex patterns vá»›i Zod
- [ ] TÃ´i biáº¿t cÃ¡ch lÃ m nested objects vÃ  arrays trong schema
- [ ] TÃ´i biáº¿t cÃ¡ch integrate Zod vá»›i React Hook Form qua `zodResolver`
- [ ] TÃ´i biáº¿t cÃ¡ch infer TypeScript types tá»« schema vá»›i `z.infer`
- [ ] TÃ´i biáº¿t cÃ¡ch custom error messages trong Zod
- [ ] TÃ´i biáº¿t cÃ¡ch dÃ¹ng `.refine()` cho cross-field validation
- [ ] TÃ´i biáº¿t cÃ¡ch handle optional fields correctly (`.optional()` vÃ  `.or(z.literal(""))`)
- [ ] TÃ´i biáº¿t cÃ¡ch transform data vá»›i `.transform()`
- [ ] TÃ´i biáº¿t cÃ¡ch compose schemas vá»›i `.extend()`
- [ ] TÃ´i biáº¿t khi nÃ o nÃªn dÃ¹ng schema validation vs inline validation

### Code Review Checklist

Khi review code cÃ³ Zod schemas, check:

**Schema Design:**

- [ ] Schema cÃ³ clear, descriptive names
- [ ] Validation rules match business requirements
- [ ] Error messages user-friendly vÃ  actionable
- [ ] Optional fields handle empty strings correctly
- [ ] No duplicate validation logic

**Integration:**

- [ ] `zodResolver` Ä‘Æ°á»£c pass vÃ o `useForm`
- [ ] TypeScript types Ä‘Æ°á»£c infer tá»« schema (`z.infer`)
- [ ] KhÃ´ng manual type form data náº¿u cÃ³ schema
- [ ] Cross-field validation cÃ³ `path` chá»‰ Ä‘Ãºng field

**Error Handling:**

- [ ] Má»i field Ä‘á»u show errors khi invalid
- [ ] Error messages hiá»ƒn thá»‹ Ä‘Ãºng chá»—
- [ ] Loading states cho async validation (náº¿u cÃ³)
- [ ] Form khÃ´ng submit khi cÃ³ errors

**Performance:**

- [ ] Schemas Ä‘Æ°á»£c define ngoÃ i component (khÃ´ng recreate má»—i render)
- [ ] `useMemo` cho complex schema computations
- [ ] KhÃ´ng validate unnecessarily (debounce náº¿u cáº§n)

**Maintainability:**

- [ ] Base schemas Ä‘Æ°á»£c reuse
- [ ] Validation logic tÃ¡ch ra khá»i UI code
- [ ] Comments giáº£i thÃ­ch complex validation rules
- [ ] Schemas cÃ³ thá»ƒ test independently

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**Task: Refactor má»™t form hiá»‡n cÃ³ sang Zod**

Chá»n 1 form tá»« project cÅ© (hoáº·c tá»« bÃ i táº­p NgÃ y 41-42) vÃ  refactor:

1. Extract validation logic thÃ nh Zod schema
2. Replace inline validation vá»›i `zodResolver`
3. Add TypeScript types vá»›i `z.infer`
4. Improve error messages
5. Document: Before/After comparison

### NÃ¢ng cao (60 phÃºt)

**Task: Build Event Registration Form**

Requirements:

- Event details: name, date, location, capacity (number)
- Attendee info: name, email, phone, dietary restrictions (optional)
- Ticket selection: ticketType (enum: "vip" | "regular" | "student"), quantity
- Conditional validation:
  - VIP tickets: require company name
  - Student tickets: require student ID
  - Total attendees (quantity) khÃ´ng vÆ°á»£t quÃ¡ capacity
- Payment: amount auto-calculated based on ticket type
- Multi-language error messages (English + Vietnamese)

Advanced features:

- Schema composition (base attendee schema)
- Custom validation (capacity check)
- Transformations (calculate total price)
- Enums (ticket types)
- Conditional fields based on ticket type

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **Zod Official Documentation**
   - https://zod.dev
   - Focus: Basic types, Objects, Arrays, Refine

2. **React Hook Form - Zod Integration**
   - https://react-hook-form.com/get-started#SchemaValidation
   - https://github.com/react-hook-form/resolvers#zod

### Äá»c thÃªm

1. **Zod vs Yup Comparison**
   - https://zod.dev/?id=comparison
2. **TypeScript-first Schema Validation**
   - Táº¡i sao type safety quan trá»ng trong forms
   - https://colinhacks.com/essays/zod

3. **Advanced Zod Patterns**
   - Discriminated unions
   - Recursive schemas
   - Custom error maps

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n

- **NgÃ y 41:** React Hook Form basics - `useForm`, `register`, `handleSubmit`
- **NgÃ y 42:** React Hook Form advanced - field arrays, `watch`, custom validation
- **NgÃ y 13:** Forms vá»›i useState (Ä‘á»ƒ so sÃ¡nh complexity)
- **NgÃ y 1-2:** ES6+ (array methods, destructuring cho schema composition)

### HÆ°á»›ng tá»›i

- **NgÃ y 44:** Multi-step forms - sáº½ dÃ¹ng Zod cho validation tá»«ng step
- **NgÃ y 45:** Project 6 - Registration flow vá»›i complex Zod schemas
- **Phase 6 (Testing):** Test Zod schemas independently
- **Phase 6 (TypeScript):** Advanced type inference tá»« schemas

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. Bundle Size Optimization**

```jsx
// âŒ Import toÃ n bá»™ Zod
import { z } from 'zod';

// âœ… Tree-shakeable imports (náº¿u bundler support)
import { object, string, number } from 'zod';

// Note: Zod Ä‘Ã£ optimized tá»‘t, khÃ´ng cáº§n quÃ¡ lo
```

**2. Schema Versioning**

```jsx
// Khi API schema thay Ä‘á»•i, version schemas
const userSchemaV1 = z.object({ name: z.string() });
const userSchemaV2 = z.object({
  name: z.string(),
  email: z.string().email()
});

// Migration function
function migrateUser(data: unknown, version: 1 | 2) {
  if (version === 1) {
    return userSchemaV2.parse({
      ...userSchemaV1.parse(data),
      email: ''
    });
  }
  return userSchemaV2.parse(data);
}
```

**3. Async Validation vá»›i Debounce**

```jsx
// Future upgrade: Combine vá»›i async validation
const usernameSchema = z.string().min(3);
// Note: Zod khÃ´ng support async validation trá»±c tiáº¿p
// Cáº§n dÃ¹ng RHF's validate option cho async checks

// Example pattern (for future reference):
register('username', {
  validate: async (value) => {
    const result = await checkUsernameAvailable(value);
    return result.available || 'Username taken';
  },
});
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

1. **Q:** Zod lÃ  gÃ¬? Táº¡i sao dÃ¹ng Zod thay vÃ¬ inline validation?
   **A:** Schema validation library, type-safe, reusable, maintainable

2. **Q:** LÃ m sao integrate Zod vá»›i React Hook Form?
   **A:** DÃ¹ng `zodResolver` tá»« `@hookform/resolvers/zod`

**Mid Level:** 3. **Q:** Explain `.refine()` vÃ  khi nÃ o dÃ¹ng?
**A:** Custom validation logic, cross-field validation, complex business rules

4. **Q:** LÃ m sao handle optional fields cÃ³ validation conditional?
   **A:** `.optional().or(z.literal(""))` hoáº·c `.transform()` + `.refine()`

**Senior Level:** 5. **Q:** So sÃ¡nh Zod vs Yup, khi nÃ o chá»n cÃ¡i nÃ o?
**A:** Zod: TypeScript-first, better inference, smaller bundle. Yup: mature ecosystem, legacy support

6. **Q:** Architect schema structure cho large application vá»›i 50+ forms?
   **A:**
   - Base schemas trong `/schemas/base/`
   - Domain-specific schemas trong `/schemas/domains/`
   - Shared validation rules trong `/schemas/rules/`
   - Type exports tá»« schemas
   - Schema composition patterns

### War Stories

**Story 1: The Great Refactor**
"Team cÃ³ 30 forms vá»›i inline validation duplicate. Máº¥t 2 tuáº§n refactor sang Zod schemas. Káº¿t quáº£: giáº£m 40% validation code, zero regression bugs vÃ¬ tests schemas riÃªng. ThÃªm feature má»›i giá» chá»‰ máº¥t 1/3 thá»i gian."

**Story 2: i18n Nightmare**
"Hardcode English error messages kháº¯p nÆ¡i. Khi cáº§n support Vietnamese, pháº£i tÃ¬m vÃ  replace hÃ ng trÄƒm strings. Há»c Ä‘Æ°á»£c: dÃ¹ng Zod error maps + translation keys tá»« Ä‘áº§u. Migration Ä‘au Ä‘á»›n nhÆ°ng worth it."

**Story 3: Type Safety Saved Production**
"Backend thay Ä‘á»•i API response structure, frontend crash. Náº¿u dÃ¹ng Zod parse API responses, TypeScript bÃ¡o lá»—i compile-time. Lesson: validate data á»Ÿ má»i boundaries (forms, API, localStorage)."

---

ğŸ‰ **ChÃºc má»«ng!** Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 43. NgÃ y mai chÃºng ta sáº½ há»c **Multi-step Forms** - Ã¡p dá»¥ng táº¥t cáº£ knowledge vá» RHF vÃ  Zod vÃ o wizard pattern phá»©c táº¡p!
