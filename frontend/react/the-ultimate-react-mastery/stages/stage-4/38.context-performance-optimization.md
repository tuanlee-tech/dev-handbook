# üìÖ NG√ÄY 38: Context Performance Optimization

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

- [ ] Hi·ªÉu t·∫°i sao Context g√¢y performance issues
- [ ] Bi·∫øt c√°ch profile v√† detect re-render problems
- [ ] N·∫Øm v·ªØng useMemo/useCallback cho Context value
- [ ] Hi·ªÉu Context Splitting pattern (State + Dispatch)
- [ ] Bi·∫øt implement Selector pattern ƒë∆°n gi·∫£n
- [ ] Bi·∫øt khi n√†o N√äN v√† KH√îNG N√äN optimize

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

1. **Object reference equality l√† g√¨? `{} === {}` tr·∫£ v·ªÅ g√¨?**
2. **useMemo v√† useCallback kh√°c nhau nh∆∞ th·∫ø n√†o?**
3. **React.memo l√†m g√¨? Khi n√†o component re-render?**

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

Context r·∫•t ti·ªán, nh∆∞ng c√≥ performance cost:

```jsx
/**
 * ‚ùå PROBLEM: Context Performance Issue
 */

const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  const [notifications, setNotifications] = useState([]);

  // ‚ùå NEW OBJECT m·ªói render!
  const value = {
    user,
    setUser,
    theme,
    setTheme,
    notifications,
    setNotifications,
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

// Component ch·ªâ c·∫ßn user
function UserProfile() {
  const { user } = useContext(AppContext);

  console.log('UserProfile rendered!');

  return <div>{user?.name}</div>;
}

// Component ch·ªâ c·∫ßn theme
function ThemeToggle() {
  const { theme, setTheme } = useContext(AppContext);

  console.log('ThemeToggle rendered!');

  return (
    <button onClick={() => setTheme((t) => (t === 'light' ? 'dark' : 'light'))}>
      {theme}
    </button>
  );
}

// ‚ùå V·∫§N ƒê·ªÄ:
// - Change theme ‚Üí UserProfile re-render (KH√îNG c·∫ßn!)
// - Change user ‚Üí ThemeToggle re-render (KH√îNG c·∫ßn!)
// - M·ªói setState ‚Üí T·∫§T C·∫¢ consumers re-render
// - Value object m·ªõi m·ªói render ‚Üí Context change detection
```

**Root Causes:**

1. **Value Object Recreation:** `{}` m·ªõi m·ªói render ‚Üí Context "thay ƒë·ªïi"
2. **God Context:** T·∫•t c·∫£ state ·ªü 1 context ‚Üí M·ªçi change affect all
3. **No Memoization:** Functions t·∫°o m·ªõi m·ªói render

### 1.2 Gi·∫£i Ph√°p

**3 Optimization Strategies:**

```jsx
/**
 * ‚úÖ STRATEGY 1: Memoize Context Value
 */

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  // ‚úÖ Memoize value object
  const value = useMemo(
    () => ({ user, setUser, theme, setTheme }),
    [user, theme], // Ch·ªâ t·∫°o m·ªõi khi dependencies thay ƒë·ªïi
  );

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

/**
 * ‚úÖ STRATEGY 2: Context Splitting
 */

const UserContext = createContext();
const ThemeContext = createContext();

function UserProvider({ children }) {
  const [user, setUser] = useState(null);
  const value = useMemo(() => ({ user, setUser }), [user]);

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
}

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  const value = useMemo(() => ({ theme, setTheme }), [theme]);

  return (
    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>
  );
}

// ‚úÖ B√¢y gi·ªù: Change theme ‚Üí KH√îNG affect UserProfile!

/**
 * ‚úÖ STRATEGY 3: State + Dispatch Splitting
 */

const StateContext = createContext();
const DispatchContext = createContext();

function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, initialState);

  // State change nhi·ªÅu, dispatch KH√îNG bao gi·ªù change
  // ‚Üí Components ch·ªâ d√πng dispatch KH√îNG re-render khi state change!

  return (
    <StateContext.Provider value={state}>
      <DispatchContext.Provider value={dispatch}>
        {children}
      </DispatchContext.Provider>
    </StateContext.Provider>
  );
}

function useCartState() {
  return useContext(StateContext);
}

function useCartDispatch() {
  return useContext(DispatchContext);
}

// Component ch·ªâ dispatch (add to cart)
function AddToCartButton() {
  const dispatch = useCartDispatch(); // KH√îNG re-render khi cart items change!

  return <button onClick={() => dispatch({ type: 'ADD' })}>Add</button>;
}
```

### 1.3 Mental Model

```
CONTEXT PERFORMANCE:

Unoptimized:
Provider { value: NEW_OBJECT }  ‚Üê M·ªói render
    ‚Üì
Consumer A (d√πng user) ‚Üê Re-render
Consumer B (d√πng theme) ‚Üê Re-render
Consumer C (d√πng notifications) ‚Üê Re-render
‚Üí T·∫•t c·∫£ re-render khi B·∫§T K·ª≤ state n√†o change!

Optimized v·ªõi useMemo:
Provider { value: SAME_OBJECT }  ‚Üê N·∫øu dependencies kh√¥ng ƒë·ªïi
    ‚Üì
Consumer A, B, C ‚Üê KH√îNG re-render n·∫øu value kh√¥ng ƒë·ªïi

Optimized v·ªõi Splitting:
UserProvider
    ‚Üì
Consumer A (user) ‚Üê Re-render khi user change

ThemeProvider
    ‚Üì
Consumer B (theme) ‚Üê Re-render khi theme change

‚Üí Isolated re-renders!

T∆∞∆°ng t·ª± nh∆∞: RADIO CHANNELS
- Single Context = 1 channel broadcast t·∫•t c·∫£
  ‚Üí Ai nghe channel n√†y ƒë·ªÅu nh·∫≠n T·∫§T C·∫¢ updates
- Multiple Contexts = Nhi·ªÅu channels ri√™ng
  ‚Üí Ch·ªâ nghe channel c·∫ßn thi·∫øt, b·ªè qua c√°c channel kh√°c
```

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

‚ùå **"Lu√¥n lu√¥n optimize Context"**
‚Üí ‚úÖ Premature optimization is EVIL! Ch·ªâ optimize khi c√≥ performance issue TH·∫¨T

‚ùå **"useMemo gi·∫£i quy·∫øt m·ªçi v·∫•n ƒë·ªÅ"**
‚Üí ‚úÖ useMemo ch·ªâ gi·∫£i quy·∫øt object recreation. V·∫´n c·∫ßn split contexts cho best performance

‚ùå **"Context ch·∫≠m, kh√¥ng d√πng production"**
‚Üí ‚úÖ Context OK cho production! Ch·ªâ c·∫ßn optimize ƒë√∫ng c√°ch

‚ùå **"Optimization lu√¥n t·ªët h∆°n"**
‚Üí ‚úÖ Optimization c√≥ COST: Code ph·ª©c t·∫°p h∆°n, kh√≥ maintain. Trade-off!

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Profiling Performance Issues ‚≠ê

```jsx
/**
 * üéØ Detect performance issues v·ªõi React DevTools
 * - Highlight updates
 * - Profiler
 * - Unnecessary re-renders
 */

import { createContext, useContext, useState } from 'react';

// ‚ùå UNOPTIMIZED VERSION
const AppContext = createContext();

function AppProvider({ children }) {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // ‚ùå New object every render
  const value = {
    count,
    setCount,
    name,
    setName,
  };

  console.log('AppProvider rendered');

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

// Component ch·ªâ d√πng count
function Counter() {
  const { count, setCount } = useContext(AppContext);

  console.log('Counter rendered'); // Logs m·ªói khi name change!

  return (
    <div style={{ padding: '20px', border: '2px solid blue', margin: '10px' }}>
      <h3>Counter Component</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
    </div>
  );
}

// Component ch·ªâ d√πng name
function NameInput() {
  const { name, setName } = useContext(AppContext);

  console.log('NameInput rendered'); // Logs m·ªói khi count change!

  return (
    <div style={{ padding: '20px', border: '2px solid green', margin: '10px' }}>
      <h3>Name Input Component</h3>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder='Enter name'
        style={{ padding: '5px' }}
      />
      <p>Name: {name}</p>
    </div>
  );
}

// Component KH√îNG d√πng context
function StaticComponent() {
  console.log('StaticComponent rendered'); // V·∫´n re-render!

  return (
    <div style={{ padding: '20px', border: '2px solid red', margin: '10px' }}>
      <h3>Static Component</h3>
      <p>I don't use any context value!</p>
    </div>
  );
}

function App() {
  return (
    <AppProvider>
      <div style={{ maxWidth: '600px', margin: '20px auto' }}>
        <h1>Performance Issue Demo</h1>

        <div
          style={{
            padding: '10px',
            background: '#fff3cd',
            borderRadius: '4px',
            marginBottom: '20px',
          }}
        >
          <strong>üîç Open Console & React DevTools Profiler</strong>
          <ol>
            <li>Click Increment ‚Üí Counter, NameInput, Static ALL re-render</li>
            <li>Type in Name ‚Üí Counter, NameInput, Static ALL re-render</li>
            <li>Static component re-renders despite NOT using context!</li>
          </ol>
        </div>

        <Counter />
        <NameInput />
        <StaticComponent />
      </div>
    </AppProvider>
  );
}

/**
 * PROFILING STEPS:
 *
 * 1. Open React DevTools ‚Üí Profiler tab
 * 2. Click "Record"
 * 3. Increment counter 3 times
 * 4. Stop recording
 * 5. See flamegraph: Counter, NameInput, StaticComponent all rendered
 *
 * 6. Enable "Highlight updates" in React DevTools settings
 * 7. Type in name input
 * 8. See ALL components flash (re-render)
 *
 * CONCLUSION:
 * - Context change ‚Üí ALL children re-render (even if not using context)
 * - Need optimization!
 */
```

### Demo 2: Optimization v·ªõi useMemo ‚≠ê‚≠ê

```jsx
/**
 * üéØ Fix performance v·ªõi useMemo
 * - Memoize context value
 * - React.memo cho components
 */

import { createContext, useContext, useState, useMemo } from 'react';
import { memo } from 'react';

// ‚úÖ OPTIMIZED VERSION
const AppContext = createContext();

function AppProvider({ children }) {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');

  // ‚úÖ Memoize value object
  const value = useMemo(
    () => ({
      count,
      setCount,
      name,
      setName,
    }),
    [count, name], // Only recreate when these change
  );

  console.log('AppProvider rendered');

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

// ‚úÖ Wrap v·ªõi React.memo
const Counter = memo(function Counter() {
  const { count, setCount } = useContext(AppContext);

  console.log('Counter rendered');

  return (
    <div style={{ padding: '20px', border: '2px solid blue', margin: '10px' }}>
      <h3>Counter Component (Memoized)</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
    </div>
  );
});

const NameInput = memo(function NameInput() {
  const { name, setName } = useContext(AppContext);

  console.log('NameInput rendered');

  return (
    <div style={{ padding: '20px', border: '2px solid green', margin: '10px' }}>
      <h3>Name Input Component (Memoized)</h3>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder='Enter name'
        style={{ padding: '5px' }}
      />
      <p>Name: {name}</p>
    </div>
  );
});

// ‚úÖ Memo v√† KH√îNG d√πng context
const StaticComponent = memo(function StaticComponent() {
  console.log('StaticComponent rendered');

  return (
    <div style={{ padding: '20px', border: '2px solid red', margin: '10px' }}>
      <h3>Static Component (Memoized)</h3>
      <p>I don't use any context value!</p>
      <p>I should NOT re-render now!</p>
    </div>
  );
});

function App() {
  return (
    <AppProvider>
      <div style={{ maxWidth: '600px', margin: '20px auto' }}>
        <h1>Optimized with useMemo + React.memo</h1>

        <div
          style={{
            padding: '10px',
            background: '#d4edda',
            borderRadius: '4px',
            marginBottom: '20px',
          }}
        >
          <strong>‚úÖ Improvements:</strong>
          <ol>
            <li>Click Increment ‚Üí Only Counter re-renders</li>
            <li>Type in Name ‚Üí Only NameInput re-renders</li>
            <li>Static component NEVER re-renders</li>
          </ol>
        </div>

        <Counter />
        <NameInput />
        <StaticComponent />
      </div>
    </AppProvider>
  );
}

/**
 * WHY IT WORKS:
 *
 * useMemo:
 * - Value object ch·ªâ t·∫°o m·ªõi khi count ho·∫∑c name thay ƒë·ªïi
 * - Same object reference ‚Üí Context kh√¥ng "change"
 *
 * React.memo:
 * - Component ch·ªâ re-render khi props thay ƒë·ªïi
 * - Context value l√† "prop" hidden
 * - Value kh√¥ng ƒë·ªïi ‚Üí Component kh√¥ng re-render
 *
 * LIMITATION:
 * - V·∫´n c√≥ issue: Counter re-renders khi name changes (do context value change)
 * - NameInput re-renders khi count changes
 * - Need Context Splitting cho perfect optimization!
 */
```

### Demo 3: Context Splitting Pattern ‚≠ê‚≠ê‚≠ê

```jsx
/**
 * üéØ Perfect optimization: Split contexts
 * - CountContext
 * - NameContext
 * - Isolated re-renders
 */

import { createContext, useContext, useState, useMemo, memo } from 'react';

// ‚úÖ SPLIT CONTEXTS
const CountContext = createContext();
const NameContext = createContext();

function CountProvider({ children }) {
  const [count, setCount] = useState(0);

  const value = useMemo(() => ({ count, setCount }), [count]);

  console.log('CountProvider rendered');

  return (
    <CountContext.Provider value={value}>{children}</CountContext.Provider>
  );
}

function NameProvider({ children }) {
  const [name, setName] = useState('');

  const value = useMemo(() => ({ name, setName }), [name]);

  console.log('NameProvider rendered');

  return <NameContext.Provider value={value}>{children}</NameContext.Provider>;
}

// Custom hooks
function useCount() {
  const context = useContext(CountContext);
  if (!context) throw new Error('useCount must be used within CountProvider');
  return context;
}

function useName() {
  const context = useContext(NameContext);
  if (!context) throw new Error('useName must be used within NameProvider');
  return context;
}

// Components
const Counter = memo(function Counter() {
  const { count, setCount } = useCount();

  console.log('Counter rendered');

  return (
    <div style={{ padding: '20px', border: '2px solid blue', margin: '10px' }}>
      <h3>Counter Component</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <p style={{ fontSize: '12px', color: '#666' }}>
        ‚úÖ Only re-renders when count changes
      </p>
    </div>
  );
});

const NameInput = memo(function NameInput() {
  const { name, setName } = useName();

  console.log('NameInput rendered');

  return (
    <div style={{ padding: '20px', border: '2px solid green', margin: '10px' }}>
      <h3>Name Input Component</h3>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder='Enter name'
        style={{ padding: '5px' }}
      />
      <p>Name: {name}</p>
      <p style={{ fontSize: '12px', color: '#666' }}>
        ‚úÖ Only re-renders when name changes
      </p>
    </div>
  );
});

// Component d√πng C·∫¢ 2 contexts
const Summary = memo(function Summary() {
  const { count } = useCount();
  const { name } = useName();

  console.log('Summary rendered');

  return (
    <div
      style={{ padding: '20px', border: '2px solid purple', margin: '10px' }}
    >
      <h3>Summary Component</h3>
      <p>Count: {count}</p>
      <p>Name: {name || '(empty)'}</p>
      <p style={{ fontSize: '12px', color: '#666' }}>
        ‚ö†Ô∏è Re-renders when EITHER count or name changes
      </p>
    </div>
  );
});

const StaticComponent = memo(function StaticComponent() {
  console.log('StaticComponent rendered');

  return (
    <div style={{ padding: '20px', border: '2px solid red', margin: '10px' }}>
      <h3>Static Component</h3>
      <p>I don't use any context!</p>
      <p style={{ fontSize: '12px', color: '#666' }}>‚úÖ NEVER re-renders</p>
    </div>
  );
});

function App() {
  return (
    <CountProvider>
      <NameProvider>
        <div style={{ maxWidth: '600px', margin: '20px auto' }}>
          <h1>Perfect Optimization: Context Splitting</h1>

          <div
            style={{
              padding: '10px',
              background: '#d1ecf1',
              borderRadius: '4px',
              marginBottom: '20px',
            }}
          >
            <strong>üéØ Perfect Isolation:</strong>
            <ol>
              <li>Increment ‚Üí ONLY Counter + Summary re-render</li>
              <li>Type name ‚Üí ONLY NameInput + Summary re-render</li>
              <li>Static ‚Üí NEVER re-renders</li>
            </ol>
          </div>

          <Counter />
          <NameInput />
          <Summary />
          <StaticComponent />
        </div>
      </NameProvider>
    </CountProvider>
  );
}

/**
 * PERFECT OPTIMIZATION ACHIEVED:
 *
 * Before (Single Context):
 * - Change count ‚Üí Counter, NameInput, Summary, Static all re-render
 * - Change name ‚Üí Counter, NameInput, Summary, Static all re-render
 *
 * After (Split Contexts):
 * - Change count ‚Üí Counter, Summary re-render (ONLY!)
 * - Change name ‚Üí NameInput, Summary re-render (ONLY!)
 * - Static ‚Üí NEVER re-renders
 *
 * TRADE-OFFS:
 * ‚úÖ Perfect performance
 * ‚úÖ Isolated re-renders
 * ‚ùå More boilerplate (2 providers instead of 1)
 * ‚ùå Provider nesting
 *
 * WHEN TO USE:
 * - Large apps v·ªõi nhi·ªÅu independent state
 * - Performance-critical apps
 * - State thay ƒë·ªïi frequently
 */
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Level 1: useMemo Context Value (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Optimize context value v·ªõi useMemo
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: Context splitting (ch·ªâ useMemo)
 *
 * Requirements:
 * 1. TodoContext v·ªõi todos[], filter
 * 2. useMemo cho value object
 * 3. useCallback cho add/remove/toggle functions
 * 4. TodoList component v·ªõi React.memo
 * 5. FilterButtons component v·ªõi React.memo
 *
 * üí° G·ª£i √Ω:
 * - Dependencies c·ªßa useMemo: [todos, filter]
 * - useCallback dependencies: [] (d√πng functional updates)
 */

// ‚ùå C√°ch SAI:
// - Kh√¥ng d√πng useMemo cho value
// - Kh√¥ng d√πng useCallback cho functions
// - Kh√¥ng wrap components v·ªõi React.memo

// ‚úÖ C√°ch ƒê√öNG: Xem solution

// üéØ NHI·ªÜM V·ª§:
// TODO: Implement TodoProvider v·ªõi useMemo
// TODO: Implement addTodo, removeTodo v·ªõi useCallback
// TODO: TodoList v·ªõi React.memo
// TODO: FilterButtons v·ªõi React.memo
```

<details>
<summary>üí° Solution</summary>

```jsx
import {
  createContext,
  useContext,
  useState,
  useMemo,
  useCallback,
  memo,
} from 'react';

/**
 * Todo Context v·ªõi useMemo optimization
 */

const TodoContext = createContext();

function TodoProvider({ children }) {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all'); // 'all' | 'active' | 'completed'

  // ‚úÖ useCallback cho functions (dependencies [])
  const addTodo = useCallback((text) => {
    setTodos((prev) => [...prev, { id: Date.now(), text, completed: false }]);
  }, []); // Empty deps v√¨ d√πng functional update

  const removeTodo = useCallback((id) => {
    setTodos((prev) => prev.filter((todo) => todo.id !== id));
  }, []);

  const toggleTodo = useCallback((id) => {
    setTodos((prev) =>
      prev.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo,
      ),
    );
  }, []);

  // ‚úÖ useMemo cho value object
  const value = useMemo(
    () => ({
      todos,
      filter,
      setFilter,
      addTodo,
      removeTodo,
      toggleTodo,
    }),
    [todos, filter, addTodo, removeTodo, toggleTodo],
    // Note: addTodo, removeTodo, toggleTodo stable (useCallback)
  );

  console.log('TodoProvider rendered');

  return <TodoContext.Provider value={value}>{children}</TodoContext.Provider>;
}

function useTodos() {
  const context = useContext(TodoContext);
  if (!context) throw new Error('useTodos must be used within TodoProvider');
  return context;
}

// ‚úÖ React.memo components
const TodoInput = memo(function TodoInput() {
  const { addTodo } = useTodos();
  const [text, setText] = useState('');

  console.log('TodoInput rendered');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      addTodo(text);
      setText('');
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      style={{ marginBottom: '20px' }}
    >
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder='Add todo...'
        style={{ padding: '8px', width: '300px' }}
      />
      <button
        type='submit'
        style={{ marginLeft: '10px', padding: '8px' }}
      >
        Add
      </button>
    </form>
  );
});

const TodoItem = memo(function TodoItem({ todo, onToggle, onRemove }) {
  console.log(`TodoItem ${todo.id} rendered`);

  return (
    <div
      style={{
        display: 'flex',
        alignItems: 'center',
        padding: '8px',
        borderBottom: '1px solid #eee',
      }}
    >
      <input
        type='checkbox'
        checked={todo.completed}
        onChange={() => onToggle(todo.id)}
      />
      <span
        style={{
          flex: 1,
          marginLeft: '10px',
          textDecoration: todo.completed ? 'line-through' : 'none',
        }}
      >
        {todo.text}
      </span>
      <button onClick={() => onRemove(todo.id)}>Delete</button>
    </div>
  );
});

const TodoList = memo(function TodoList() {
  const { todos, filter, toggleTodo, removeTodo } = useTodos();

  console.log('TodoList rendered');

  const filteredTodos = todos.filter((todo) => {
    if (filter === 'active') return !todo.completed;
    if (filter === 'completed') return todo.completed;
    return true;
  });

  if (filteredTodos.length === 0) {
    return <p>No todos!</p>;
  }

  return (
    <div>
      {filteredTodos.map((todo) => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={toggleTodo}
          onRemove={removeTodo}
        />
      ))}
    </div>
  );
});

const FilterButtons = memo(function FilterButtons() {
  const { filter, setFilter } = useTodos();

  console.log('FilterButtons rendered');

  const filters = ['all', 'active', 'completed'];

  return (
    <div style={{ marginTop: '20px' }}>
      {filters.map((f) => (
        <button
          key={f}
          onClick={() => setFilter(f)}
          style={{
            marginRight: '10px',
            padding: '5px 15px',
            background: filter === f ? '#007bff' : '#fff',
            color: filter === f ? '#fff' : '#000',
            border: '1px solid #007bff',
            cursor: 'pointer',
          }}
        >
          {f.charAt(0).toUpperCase() + f.slice(1)}
        </button>
      ))}
    </div>
  );
});

function App() {
  return (
    <TodoProvider>
      <div style={{ maxWidth: '500px', margin: '20px auto' }}>
        <h1>Optimized Todo App</h1>

        <div
          style={{
            padding: '10px',
            background: '#e3f2fd',
            borderRadius: '4px',
            marginBottom: '20px',
            fontSize: '14px',
          }}
        >
          <strong>‚úÖ Optimizations:</strong>
          <ul>
            <li>useMemo for context value</li>
            <li>useCallback for functions</li>
            <li>React.memo for components</li>
            <li>Check console to see re-renders!</li>
          </ul>
        </div>

        <TodoInput />
        <TodoList />
        <FilterButtons />
      </div>
    </TodoProvider>
  );
}

/**
 * Result:
 * - Add todo ‚Üí TodoList re-renders, FilterButtons KH√îNG
 * - Change filter ‚Üí TodoList re-renders (filter), FilterButtons re-renders
 * - Toggle todo ‚Üí Ch·ªâ TodoItem ƒë√≥ re-render (n·∫øu optimize th√™m)
 */
```

</details>

### ‚≠ê‚≠ê Level 2: State + Dispatch Splitting (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Optimize v·ªõi State/Dispatch splitting
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Shopping Cart v·ªõi nhi·ªÅu operations
 * Problem: Add to cart button re-render m·ªói khi cart items change
 *
 * Solution: Split StateContext v√† DispatchContext
 *
 * Requirements:
 * 1. CartStateContext - ch·ª©a cart state
 * 2. CartDispatchContext - ch·ª©a dispatch function
 * 3. useCartState() v√† useCartDispatch() hooks
 * 4. AddToCartButton ch·ªâ d√πng dispatch
 * 5. CartSummary ch·ªâ d√πng state
 * 6. Verify: AddToCartButton KH√îNG re-render khi items change
 */
```

<details>
<summary>üí° Solution</summary>

```jsx
import { createContext, useContext, useReducer, memo } from 'react';

/**
 * Cart v·ªõi State/Dispatch Splitting
 * Dispatch NEVER changes ‚Üí Components d√πng dispatch KH√îNG re-render
 */

// 1. Separate Contexts
const CartStateContext = createContext();
const CartDispatchContext = createContext();

// 2. Reducer
const cartReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_ITEM': {
      const existing = state.items.find(
        (item) => item.id === action.payload.id,
      );

      if (existing) {
        return {
          ...state,
          items: state.items.map((item) =>
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item,
          ),
        };
      }

      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }],
      };
    }

    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter((item) => item.id !== action.payload),
      };

    case 'CLEAR':
      return { ...state, items: [] };

    default:
      return state;
  }
};

// 3. Provider
function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, { items: [] });

  // dispatch NEVER changes (stable reference)
  // state changes frequently

  return (
    <CartStateContext.Provider value={state}>
      <CartDispatchContext.Provider value={dispatch}>
        {children}
      </CartDispatchContext.Provider>
    </CartStateContext.Provider>
  );
}

// 4. Custom hooks
function useCartState() {
  const context = useContext(CartStateContext);
  if (!context)
    throw new Error('useCartState must be used within CartProvider');
  return context;
}

function useCartDispatch() {
  const context = useContext(CartDispatchContext);
  if (!context)
    throw new Error('useCartDispatch must be used within CartProvider');
  return context;
}

// 5. Components
const ProductCard = memo(function ProductCard({ product }) {
  // ‚úÖ Ch·ªâ d√πng dispatch ‚Üí KH√îNG re-render khi cart changes!
  const dispatch = useCartDispatch();

  console.log(`ProductCard ${product.id} rendered`);

  return (
    <div
      style={{
        border: '1px solid #ddd',
        padding: '15px',
        margin: '10px',
        borderRadius: '4px',
      }}
    >
      <h3>{product.name}</h3>
      <p>${product.price}</p>
      <button
        onClick={() => dispatch({ type: 'ADD_ITEM', payload: product })}
        style={{ padding: '8px 16px' }}
      >
        Add to Cart
      </button>
      <p style={{ fontSize: '12px', color: '#666' }}>
        ‚úÖ This button doesn't re-render when cart changes!
      </p>
    </div>
  );
});

const CartSummary = memo(function CartSummary() {
  // ‚úÖ Ch·ªâ d√πng state ‚Üí Re-render khi cart changes (expected!)
  const state = useCartState();
  const dispatch = useCartDispatch();

  console.log('CartSummary rendered');

  const totalItems = state.items.reduce((sum, item) => sum + item.quantity, 0);
  const totalPrice = state.items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0,
  );

  if (state.items.length === 0) {
    return (
      <div
        style={{ padding: '20px', background: '#f5f5f5', borderRadius: '4px' }}
      >
        <p>Cart is empty</p>
      </div>
    );
  }

  return (
    <div
      style={{ padding: '20px', background: '#f5f5f5', borderRadius: '4px' }}
    >
      <h3>Cart Summary</h3>

      {state.items.map((item) => (
        <div
          key={item.id}
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            padding: '5px 0',
            borderBottom: '1px solid #ddd',
          }}
        >
          <span>
            {item.name} x{item.quantity}
          </span>
          <span>${item.price * item.quantity}</span>
          <button
            onClick={() => dispatch({ type: 'REMOVE_ITEM', payload: item.id })}
            style={{ marginLeft: '10px' }}
          >
            Remove
          </button>
        </div>
      ))}

      <div style={{ marginTop: '15px', fontWeight: 'bold' }}>
        <div>Total Items: {totalItems}</div>
        <div>Total Price: ${totalPrice}</div>
      </div>

      <button
        onClick={() => dispatch({ type: 'CLEAR' })}
        style={{
          marginTop: '10px',
          padding: '8px 16px',
          background: '#f44336',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
        }}
      >
        Clear Cart
      </button>

      <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
        ‚ö†Ô∏è This component re-renders when cart changes (expected!)
      </p>
    </div>
  );
});

function App() {
  const products = [
    { id: 1, name: 'Laptop', price: 999 },
    { id: 2, name: 'Mouse', price: 29 },
    { id: 3, name: 'Keyboard', price: 79 },
  ];

  return (
    <CartProvider>
      <div style={{ maxWidth: '800px', margin: '20px auto' }}>
        <h1>State/Dispatch Splitting Pattern</h1>

        <div
          style={{
            padding: '15px',
            background: '#d1ecf1',
            borderRadius: '4px',
            marginBottom: '20px',
          }}
        >
          <strong>üéØ Optimization:</strong>
          <ul>
            <li>
              ProductCard buttons: Use dispatch only ‚Üí NO re-render on cart
              change
            </li>
            <li>
              CartSummary: Uses state ‚Üí Re-renders on cart change (expected)
            </li>
            <li>Open console to verify!</li>
          </ul>
        </div>

        <h2>Products</h2>
        <div style={{ display: 'flex', flexWrap: 'wrap' }}>
          {products.map((product) => (
            <ProductCard
              key={product.id}
              product={product}
            />
          ))}
        </div>

        <h2>Cart</h2>
        <CartSummary />
      </div>
    </CartProvider>
  );
}

/**
 * WHY IT WORKS:
 *
 * dispatch reference:
 * - Created once by useReducer
 * - NEVER changes
 * - Stable across re-renders
 *
 * Components using dispatch only:
 * - Get same dispatch reference every time
 * - No props change ‚Üí No re-render (v·ªõi React.memo)
 *
 * Components using state:
 * - State changes ‚Üí Context value changes ‚Üí Re-render
 * - This is EXPECTED and CORRECT!
 *
 * PATTERN:
 * - "Write-only" components ‚Üí useCartDispatch()
 * - "Read-only" components ‚Üí useCartState()
 * - "Read-write" components ‚Üí Both hooks
 */
```

</details>

### ‚≠ê‚≠ê‚≠ê Level 3: Simple Selector Pattern (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Implement selector pattern
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† developer, t√¥i mu·ªën components ch·ªâ subscribe
 *              v√†o ph·∫ßn state ch√∫ng c·∫ßn ƒë·ªÉ tr√°nh re-render kh√¥ng c·∫ßn thi·∫øt"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] useSelector(selector) hook
 * - [ ] Components ch·ªâ re-render khi selected value thay ƒë·ªïi
 * - [ ] Selector function: (state) => value
 * - [ ] Shallow comparison cho selected value
 * - [ ] Demo v·ªõi user state: { name, email, age, preferences }
 *
 * üé® Technical Constraints:
 * - KH√îNG d√πng external libraries
 * - T·ª± implement v·ªõi useRef v√† useEffect
 * - Simple shallow comparison (===)
 *
 * üìù Implementation Checklist:
 * - [ ] Context v·ªõi complex state
 * - [ ] useSelector hook implementation
 * - [ ] Components d√πng selectors
 * - [ ] Verify isolated re-renders
 */
```

<details>
<summary>üí° Solution</summary>

```jsx
import {
  createContext,
  useContext,
  useState,
  useRef,
  useEffect,
  useSyncExternalStore,
} from 'react';

/**
 * Simple Selector Pattern
 * Components subscribe to specific slices of state
 */

const UserContext = createContext();

function UserProvider({ children }) {
  const [state, setState] = useState({
    name: 'John Doe',
    email: 'john@example.com',
    age: 30,
    preferences: {
      theme: 'light',
      language: 'en',
      notifications: true,
    },
  });

  // Listeners for useSyncExternalStore
  const listenersRef = useRef(new Set());

  const subscribe = (callback) => {
    listenersRef.current.add(callback);
    return () => {
      listenersRef.current.delete(callback);
    };
  };

  const updateState = (updater) => {
    setState((prev) => {
      const next = typeof updater === 'function' ? updater(prev) : updater;

      // Notify listeners
      listenersRef.current.forEach((callback) => callback());

      return next;
    });
  };

  const value = {
    state,
    updateState,
    subscribe,
  };

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
}

// ‚úÖ useSelector implementation
function useUserSelector(selector) {
  const { state, subscribe } = useContext(UserContext);

  // Use React's built-in useSyncExternalStore for proper sync
  const selectedValue = useSyncExternalStore(
    subscribe,
    () => selector(state),
    () => selector(state),
  );

  return selectedValue;
}

function useUserUpdate() {
  const { updateState } = useContext(UserContext);
  return updateState;
}

// Components v·ªõi selectors
function NameDisplay() {
  // ‚úÖ Only subscribe to name
  const name = useUserSelector((state) => state.name);

  console.log('NameDisplay rendered');

  return (
    <div style={{ padding: '15px', border: '2px solid blue', margin: '10px' }}>
      <h3>Name Display</h3>
      <p>Name: {name}</p>
      <p style={{ fontSize: '12px', color: '#666' }}>
        ‚úÖ Only re-renders when name changes
      </p>
    </div>
  );
}

function EmailDisplay() {
  // ‚úÖ Only subscribe to email
  const email = useUserSelector((state) => state.email);

  console.log('EmailDisplay rendered');

  return (
    <div style={{ padding: '15px', border: '2px solid green', margin: '10px' }}>
      <h3>Email Display</h3>
      <p>Email: {email}</p>
      <p style={{ fontSize: '12px', color: '#666' }}>
        ‚úÖ Only re-renders when email changes
      </p>
    </div>
  );
}

function AgeDisplay() {
  // ‚úÖ Only subscribe to age
  const age = useUserSelector((state) => state.age);

  console.log('AgeDisplay rendered');

  return (
    <div
      style={{ padding: '15px', border: '2px solid orange', margin: '10px' }}
    >
      <h3>Age Display</h3>
      <p>Age: {age}</p>
      <p style={{ fontSize: '12px', color: '#666' }}>
        ‚úÖ Only re-renders when age changes
      </p>
    </div>
  );
}

function ThemeDisplay() {
  // ‚úÖ Only subscribe to theme (nested)
  const theme = useUserSelector((state) => state.preferences.theme);

  console.log('ThemeDisplay rendered');

  return (
    <div
      style={{ padding: '15px', border: '2px solid purple', margin: '10px' }}
    >
      <h3>Theme Display</h3>
      <p>Theme: {theme}</p>
      <p style={{ fontSize: '12px', color: '#666' }}>
        ‚úÖ Only re-renders when theme changes
      </p>
    </div>
  );
}

function Controls() {
  const updateState = useUserUpdate();

  console.log('Controls rendered');

  return (
    <div
      style={{
        padding: '20px',
        background: '#f5f5f5',
        borderRadius: '4px',
        marginBottom: '20px',
      }}
    >
      <h3>Controls</h3>

      <div style={{ marginBottom: '10px' }}>
        <button
          onClick={() =>
            updateState((prev) => ({
              ...prev,
              name: 'Jane Doe',
            }))
          }
          style={{ marginRight: '10px', padding: '5px 10px' }}
        >
          Change Name
        </button>

        <button
          onClick={() =>
            updateState((prev) => ({
              ...prev,
              email: 'jane@example.com',
            }))
          }
          style={{ marginRight: '10px', padding: '5px 10px' }}
        >
          Change Email
        </button>

        <button
          onClick={() =>
            updateState((prev) => ({
              ...prev,
              age: prev.age + 1,
            }))
          }
          style={{ marginRight: '10px', padding: '5px 10px' }}
        >
          Increment Age
        </button>

        <button
          onClick={() =>
            updateState((prev) => ({
              ...prev,
              preferences: {
                ...prev.preferences,
                theme: prev.preferences.theme === 'light' ? 'dark' : 'light',
              },
            }))
          }
          style={{ padding: '5px 10px' }}
        >
          Toggle Theme
        </button>
      </div>

      <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
        ‚ö†Ô∏è This component always re-renders (has buttons)
      </p>
    </div>
  );
}

function App() {
  return (
    <UserProvider>
      <div style={{ maxWidth: '800px', margin: '20px auto' }}>
        <h1>Selector Pattern Demo</h1>

        <div
          style={{
            padding: '15px',
            background: '#d4edda',
            borderRadius: '4px',
            marginBottom: '20px',
          }}
        >
          <strong>üéØ Perfect Isolation:</strong>
          <ul>
            <li>Change Name ‚Üí ONLY NameDisplay re-renders</li>
            <li>Change Email ‚Üí ONLY EmailDisplay re-renders</li>
            <li>Change Age ‚Üí ONLY AgeDisplay re-renders</li>
            <li>Toggle Theme ‚Üí ONLY ThemeDisplay re-renders</li>
            <li>Open console to verify!</li>
          </ul>
        </div>

        <Controls />

        <div
          style={{
            display: 'grid',
            gridTemplateColumns: '1fr 1fr',
            gap: '10px',
          }}
        >
          <NameDisplay />
          <EmailDisplay />
          <AgeDisplay />
          <ThemeDisplay />
        </div>
      </div>
    </UserProvider>
  );
}

/**
 * HOW IT WORKS:
 *
 * useSyncExternalStore:
 * - React 18 hook cho external stores
 * - subscribe: Function to subscribe to store
 * - getSnapshot: Function to get current value
 * - Automatically re-renders when snapshot changes
 *
 * useUserSelector:
 * - Takes selector function: (state) => value
 * - Returns selected value
 * - Only re-renders when selected value changes (shallow comparison)
 *
 * BENEFITS:
 * ‚úÖ Perfect isolation - components only re-render when needed
 * ‚úÖ Flexible selectors - can select any slice of state
 * ‚úÖ No library needed - uses React built-ins
 *
 * LIMITATIONS:
 * - Shallow comparison only (=== check)
 * - For deep comparison, need custom implementation
 * - More complex than simple Context
 */
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê Level 4: Optimized Todo App (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Apply t·∫•t c·∫£ optimization patterns
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Unoptimized Version (15 ph√∫t)
 * - Single TodoContext
 * - No memoization
 * - Measure performance issues
 *
 * üèóÔ∏è PHASE 2: Add Optimizations (30 ph√∫t)
 * - Split State/Dispatch contexts
 * - useMemo/useCallback
 * - React.memo components
 * - Selector pattern (optional)
 *
 * üß™ PHASE 3: Performance Comparison (15 ph√∫t)
 * - Profile both versions
 * - Document improvements
 * - Measure re-render count
 *
 * Requirements:
 * - 100+ todos ƒë·ªÉ test performance
 * - Filter, sort, search features
 * - Add, edit, delete, toggle operations
 * - Console logs ƒë·ªÉ track re-renders
 */
```

<details>
<summary>üí° Solution</summary>

```jsx
import {
  createContext,
  useContext,
  useReducer,
  useMemo,
  useCallback,
  memo,
} from 'react';

/**
 * OPTIMIZED TODO APP
 * Applies all optimization patterns learned
 */

// ========================================
// CONTEXTS (Split State/Dispatch)
// ========================================

const TodoStateContext = createContext();
const TodoDispatchContext = createContext();

// ========================================
// REDUCER
// ========================================

const todoReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now(),
            text: action.payload,
            completed: false,
            createdAt: new Date().toISOString(),
          },
        ],
      };

    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo,
        ),
      };

    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter((todo) => todo.id !== action.payload),
      };

    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload,
      };

    case 'SET_SEARCH':
      return {
        ...state,
        searchQuery: action.payload,
      };

    case 'BULK_ADD':
      return {
        ...state,
        todos: [...state.todos, ...action.payload],
      };

    default:
      return state;
  }
};

// ========================================
// PROVIDER
// ========================================

function TodoProvider({ children }) {
  const [state, dispatch] = useReducer(todoReducer, {
    todos: [],
    filter: 'all',
    searchQuery: '',
  });

  console.log('TodoProvider rendered');

  return (
    <TodoStateContext.Provider value={state}>
      <TodoDispatchContext.Provider value={dispatch}>
        {children}
      </TodoDispatchContext.Provider>
    </TodoStateContext.Provider>
  );
}

// ========================================
// HOOKS
// ========================================

function useTodoState() {
  const context = useContext(TodoStateContext);
  if (!context)
    throw new Error('useTodoState must be used within TodoProvider');
  return context;
}

function useTodoDispatch() {
  const context = useContext(TodoDispatchContext);
  if (!context)
    throw new Error('useTodoDispatch must be used within TodoProvider');
  return context;
}

// ‚úÖ Memoized selector hooks
function useFilteredTodos() {
  const { todos, filter, searchQuery } = useTodoState();

  return useMemo(() => {
    let filtered = todos;

    // Apply filter
    if (filter === 'active') {
      filtered = filtered.filter((t) => !t.completed);
    } else if (filter === 'completed') {
      filtered = filtered.filter((t) => t.completed);
    }

    // Apply search
    if (searchQuery) {
      filtered = filtered.filter((t) =>
        t.text.toLowerCase().includes(searchQuery.toLowerCase()),
      );
    }

    return filtered;
  }, [todos, filter, searchQuery]);
}

function useTodoStats() {
  const { todos } = useTodoState();

  return useMemo(
    () => ({
      total: todos.length,
      active: todos.filter((t) => !t.completed).length,
      completed: todos.filter((t) => t.completed).length,
    }),
    [todos],
  );
}

// ========================================
// COMPONENTS
// ========================================

// ‚úÖ Only uses dispatch - NEVER re-renders
const TodoInput = memo(function TodoInput() {
  const dispatch = useTodoDispatch();
  const [text, setText] = useState('');

  console.log('TodoInput rendered');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (text.trim()) {
      dispatch({ type: 'ADD_TODO', payload: text });
      setText('');
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      style={{ marginBottom: '20px' }}
    >
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder='Add todo...'
        style={{ padding: '10px', width: '400px', fontSize: '16px' }}
      />
      <button
        type='submit'
        style={{ marginLeft: '10px', padding: '10px 20px', fontSize: '16px' }}
      >
        Add
      </button>
      <p style={{ fontSize: '12px', color: '#666', marginTop: '5px' }}>
        ‚úÖ Never re-renders (uses dispatch only)
      </p>
    </form>
  );
});

const useState = require('react').useState;

// ‚úÖ Only uses dispatch - NEVER re-renders (except own state)
const SearchBar = memo(function SearchBar() {
  const dispatch = useTodoDispatch();
  const { searchQuery } = useTodoState();

  console.log('SearchBar rendered');

  return (
    <div style={{ marginBottom: '20px' }}>
      <input
        value={searchQuery}
        onChange={(e) =>
          dispatch({ type: 'SET_SEARCH', payload: e.target.value })
        }
        placeholder='Search todos...'
        style={{ padding: '10px', width: '400px', fontSize: '16px' }}
      />
      <p style={{ fontSize: '12px', color: '#666', marginTop: '5px' }}>
        ‚ö†Ô∏è Re-renders when search query changes
      </p>
    </div>
  );
});

// ‚úÖ Only uses dispatch - NEVER re-renders
const FilterButtons = memo(function FilterButtons() {
  const dispatch = useTodoDispatch();
  const { filter } = useTodoState();

  console.log('FilterButtons rendered');

  const filters = ['all', 'active', 'completed'];

  return (
    <div style={{ marginBottom: '20px' }}>
      {filters.map((f) => (
        <button
          key={f}
          onClick={() => dispatch({ type: 'SET_FILTER', payload: f })}
          style={{
            marginRight: '10px',
            padding: '8px 16px',
            background: filter === f ? '#007bff' : '#fff',
            color: filter === f ? '#fff' : '#000',
            border: '1px solid #007bff',
            cursor: 'pointer',
            fontSize: '14px',
          }}
        >
          {f.charAt(0).toUpperCase() + f.slice(1)}
        </button>
      ))}
      <p style={{ fontSize: '12px', color: '#666', marginTop: '5px' }}>
        ‚ö†Ô∏è Re-renders when filter changes
      </p>
    </div>
  );
});

// ‚úÖ Memoized, only re-renders when todo changes
const TodoItem = memo(
  function TodoItem({ todo }) {
    const dispatch = useTodoDispatch();

    console.log(`TodoItem ${todo.id} rendered`);

    return (
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          padding: '12px',
          borderBottom: '1px solid #eee',
          background: '#fff',
        }}
      >
        <input
          type='checkbox'
          checked={todo.completed}
          onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}
          style={{ marginRight: '10px' }}
        />
        <span
          style={{
            flex: 1,
            textDecoration: todo.completed ? 'line-through' : 'none',
            color: todo.completed ? '#999' : '#000',
          }}
        >
          {todo.text}
        </span>
        <button
          onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })}
          style={{
            padding: '5px 10px',
            background: '#f44336',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          Delete
        </button>
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Custom comparison - only re-render if todo actually changed
    return (
      prevProps.todo.id === nextProps.todo.id &&
      prevProps.todo.completed === nextProps.todo.completed &&
      prevProps.todo.text === nextProps.todo.text
    );
  },
);

// ‚úÖ Uses memoized filtered todos
const TodoList = memo(function TodoList() {
  const filteredTodos = useFilteredTodos();

  console.log('TodoList rendered');

  if (filteredTodos.length === 0) {
    return (
      <div style={{ padding: '40px', textAlign: 'center', color: '#999' }}>
        No todos found
      </div>
    );
  }

  return (
    <div
      style={{
        border: '1px solid #ddd',
        borderRadius: '4px',
        overflow: 'hidden',
      }}
    >
      {filteredTodos.map((todo) => (
        <TodoItem
          key={todo.id}
          todo={todo}
        />
      ))}
      <p
        style={{
          fontSize: '12px',
          color: '#666',
          padding: '10px',
          background: '#f5f5f5',
          margin: 0,
        }}
      >
        ‚ö†Ô∏è Re-renders when filtered todos change
      </p>
    </div>
  );
});

// ‚úÖ Uses memoized stats
const Stats = memo(function Stats() {
  const stats = useTodoStats();

  console.log('Stats rendered');

  return (
    <div
      style={{
        marginTop: '20px',
        padding: '15px',
        background: '#e3f2fd',
        borderRadius: '4px',
      }}
    >
      <strong>Statistics:</strong>
      <div style={{ marginTop: '10px' }}>
        <div>Total: {stats.total}</div>
        <div>Active: {stats.active}</div>
        <div>Completed: {stats.completed}</div>
      </div>
      <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
        ‚ö†Ô∏è Re-renders when todo count changes
      </p>
    </div>
  );
});

// Helper to bulk add todos for testing
const BulkAddButton = memo(function BulkAddButton() {
  const dispatch = useTodoDispatch();

  console.log('BulkAddButton rendered');

  const addBulk = () => {
    const newTodos = Array.from({ length: 100 }, (_, i) => ({
      id: Date.now() + i,
      text: `Todo ${i + 1}`,
      completed: Math.random() > 0.5,
      createdAt: new Date().toISOString(),
    }));

    dispatch({ type: 'BULK_ADD', payload: newTodos });
  };

  return (
    <button
      onClick={addBulk}
      style={{
        padding: '10px 20px',
        background: '#4caf50',
        color: 'white',
        border: 'none',
        borderRadius: '4px',
        cursor: 'pointer',
        fontSize: '14px',
      }}
    >
      Add 100 Random Todos (for testing)
    </button>
  );
});

function App() {
  return (
    <TodoProvider>
      <div style={{ maxWidth: '700px', margin: '40px auto', padding: '20px' }}>
        <h1>Optimized Todo App</h1>

        <div
          style={{
            padding: '20px',
            background: '#d4edda',
            borderRadius: '4px',
            marginBottom: '30px',
          }}
        >
          <strong>üéØ Optimizations Applied:</strong>
          <ul style={{ marginTop: '10px', marginBottom: 0 }}>
            <li>‚úÖ State/Dispatch context splitting</li>
            <li>‚úÖ useMemo for filtered todos & stats</li>
            <li>‚úÖ useCallback for event handlers</li>
            <li>‚úÖ React.memo for all components</li>
            <li>‚úÖ Custom comparison for TodoItem</li>
            <li>‚úÖ Dispatch-only components never re-render</li>
          </ul>
          <p style={{ marginTop: '15px', marginBottom: 0 }}>
            <strong>üìä Open console to see re-renders!</strong>
          </p>
        </div>

        <BulkAddButton />

        <div style={{ marginTop: '30px' }}>
          <TodoInput />
          <SearchBar />
          <FilterButtons />
          <TodoList />
          <Stats />
        </div>
      </div>
    </TodoProvider>
  );
}

/**
 * PERFORMANCE ANALYSIS:
 *
 * WITHOUT Optimizations:
 * - Add todo ‚Üí ALL components re-render
 * - Toggle todo ‚Üí ALL components re-render
 * - Change filter ‚Üí ALL components re-render
 * - Type in search ‚Üí ALL components re-render
 * - With 100 todos: VERY SLOW
 *
 * WITH Optimizations:
 * - Add todo ‚Üí TodoList, Stats re-render (expected)
 * - Toggle todo ‚Üí Only that TodoItem + Stats re-render
 * - Change filter ‚Üí FilterButtons, TodoList re-render (expected)
 * - Type in search ‚Üí SearchBar, TodoList re-render (expected)
 * - TodoInput, BulkAddButton NEVER re-render
 * - With 100 todos: SMOOTH
 *
 * KEY OPTIMIZATIONS:
 * 1. State/Dispatch split ‚Üí Dispatch-only components stable
 * 2. useMemo ‚Üí Expensive filtering only when needed
 * 3. React.memo ‚Üí Skip re-renders when props unchanged
 * 4. Custom comparison ‚Üí Fine-grained control
 */
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Level 5: Production Dashboard (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Production-ready optimized dashboard
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 * Real-time dashboard v·ªõi multiple data sources:
 * - User analytics (updates every 5s)
 * - Sales metrics (updates every 10s)
 * - System health (updates every 2s)
 * - Notifications (real-time)
 *
 * üèóÔ∏è Technical Design:
 * 1. 4 separate contexts (Analytics, Sales, Health, UI)
 * 2. State/Dispatch pattern for each
 * 3. Selector hooks cho derived data
 * 4. Memoized components
 * 5. Performance monitoring
 *
 * ‚úÖ Production Checklist:
 * - [ ] Separate contexts cho concerns
 * - [ ] State/Dispatch splitting
 * - [ ] useMemo/useCallback optimization
 * - [ ] React.memo cho components
 * - [ ] Performance profiling
 * - [ ] Re-render count < 5 per update
 * - [ ] Documentation
 */
```

<details>
<summary>üí° Solution</summary>

```jsx
import {
  createContext,
  useContext,
  useReducer,
  useMemo,
  useCallback,
  memo,
  useEffect,
  useState,
} from 'react';

/**
 * PRODUCTION DASHBOARD
 * Real-time data v·ªõi perfect performance optimization
 */

// ========================================
// ANALYTICS CONTEXT
// ========================================

const AnalyticsStateContext = createContext();
const AnalyticsDispatchContext = createContext();

const analyticsReducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_METRICS':
      return { ...state, ...action.payload };
    default:
      return state;
  }
};

function AnalyticsProvider({ children }) {
  const [state, dispatch] = useReducer(analyticsReducer, {
    visitors: 0,
    pageViews: 0,
    avgDuration: 0,
    bounceRate: 0,
  });

  // Simulate real-time updates
  useEffect(() => {
    const interval = setInterval(() => {
      dispatch({
        type: 'UPDATE_METRICS',
        payload: {
          visitors: Math.floor(Math.random() * 1000) + 500,
          pageViews: Math.floor(Math.random() * 5000) + 2000,
          avgDuration: Math.floor(Math.random() * 300) + 60,
          bounceRate: (Math.random() * 40 + 30).toFixed(1),
        },
      });
    }, 5000);

    return () => clearInterval(interval);
  }, []);

  return (
    <AnalyticsStateContext.Provider value={state}>
      <AnalyticsDispatchContext.Provider value={dispatch}>
        {children}
      </AnalyticsDispatchContext.Provider>
    </AnalyticsStateContext.Provider>
  );
}

function useAnalytics() {
  return useContext(AnalyticsStateContext);
}

// ========================================
// SALES CONTEXT
// ========================================

const SalesStateContext = createContext();
const SalesDispatchContext = createContext();

const salesReducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_SALES':
      return { ...state, ...action.payload };
    default:
      return state;
  }
};

function SalesProvider({ children }) {
  const [state, dispatch] = useReducer(salesReducer, {
    revenue: 0,
    orders: 0,
    avgOrderValue: 0,
  });

  useEffect(() => {
    const interval = setInterval(() => {
      dispatch({
        type: 'UPDATE_SALES',
        payload: {
          revenue: Math.floor(Math.random() * 50000) + 10000,
          orders: Math.floor(Math.random() * 200) + 50,
          avgOrderValue: (Math.random() * 100 + 50).toFixed(2),
        },
      });
    }, 10000);

    return () => clearInterval(interval);
  }, []);

  return (
    <SalesStateContext.Provider value={state}>
      <SalesDispatchContext.Provider value={dispatch}>
        {children}
      </SalesDispatchContext.Provider>
    </SalesStateContext.Provider>
  );
}

function useSales() {
  return useContext(SalesStateContext);
}

// ========================================
// HEALTH CONTEXT
// ========================================

const HealthStateContext = createContext();
const HealthDispatchContext = createContext();

const healthReducer = (state, action) => {
  switch (action.type) {
    case 'UPDATE_HEALTH':
      return { ...state, ...action.payload };
    default:
      return state;
  }
};

function HealthProvider({ children }) {
  const [state, dispatch] = useReducer(healthReducer, {
    cpu: 0,
    memory: 0,
    status: 'healthy',
  });

  useEffect(() => {
    const interval = setInterval(() => {
      const cpu = Math.floor(Math.random() * 100);
      const memory = Math.floor(Math.random() * 100);

      dispatch({
        type: 'UPDATE_HEALTH',
        payload: {
          cpu,
          memory,
          status: cpu > 80 || memory > 80 ? 'warning' : 'healthy',
        },
      });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  return (
    <HealthStateContext.Provider value={state}>
      <HealthDispatchContext.Provider value={dispatch}>
        {children}
      </HealthDispatchContext.Provider>
    </HealthStateContext.Provider>
  );
}

function useHealth() {
  return useContext(HealthStateContext);
}

// ========================================
// PERFORMANCE MONITOR
// ========================================

const RenderCounter = memo(function RenderCounter({ name }) {
  const [count, setCount] = useState(0);

  useEffect(() => {
    setCount((c) => c + 1);
  });

  return (
    <div
      style={{
        position: 'absolute',
        top: '5px',
        right: '5px',
        background: '#ff9800',
        color: 'white',
        padding: '2px 8px',
        borderRadius: '12px',
        fontSize: '11px',
        fontWeight: 'bold',
      }}
    >
      Renders: {count}
    </div>
  );
});

// ========================================
// COMPONENTS
// ========================================

const MetricCard = memo(function MetricCard({ title, value, unit, color }) {
  console.log(`MetricCard ${title} rendered`);

  return (
    <div
      style={{
        position: 'relative',
        background: 'white',
        padding: '20px',
        borderRadius: '8px',
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        borderLeft: `4px solid ${color}`,
      }}
    >
      <RenderCounter name={title} />
      <div style={{ fontSize: '14px', color: '#666', marginBottom: '8px' }}>
        {title}
      </div>
      <div style={{ fontSize: '32px', fontWeight: 'bold', color: '#333' }}>
        {value}
        {unit && (
          <span style={{ fontSize: '16px', marginLeft: '4px' }}>{unit}</span>
        )}
      </div>
    </div>
  );
});

const AnalyticsWidget = memo(function AnalyticsWidget() {
  const analytics = useAnalytics();

  console.log('AnalyticsWidget rendered');

  return (
    <div style={{ marginBottom: '20px' }}>
      <h2 style={{ marginBottom: '15px' }}>üìä Analytics</h2>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
          gap: '15px',
        }}
      >
        <MetricCard
          title='Visitors'
          value={analytics.visitors}
          color='#2196f3'
        />
        <MetricCard
          title='Page Views'
          value={analytics.pageViews}
          color='#4caf50'
        />
        <MetricCard
          title='Avg Duration'
          value={analytics.avgDuration}
          unit='s'
          color='#ff9800'
        />
        <MetricCard
          title='Bounce Rate'
          value={analytics.bounceRate}
          unit='%'
          color='#f44336'
        />
      </div>
      <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
        ‚ö†Ô∏è Updates every 5s - only this widget re-renders
      </p>
    </div>
  );
});

const SalesWidget = memo(function SalesWidget() {
  const sales = useSales();

  console.log('SalesWidget rendered');

  return (
    <div style={{ marginBottom: '20px' }}>
      <h2 style={{ marginBottom: '15px' }}>üí∞ Sales</h2>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
          gap: '15px',
        }}
      >
        <MetricCard
          title='Revenue'
          value={`$${sales.revenue.toLocaleString()}`}
          color='#4caf50'
        />
        <MetricCard
          title='Orders'
          value={sales.orders}
          color='#2196f3'
        />
        <MetricCard
          title='Avg Order Value'
          value={`$${sales.avgOrderValue}`}
          color='#9c27b0'
        />
      </div>
      <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
        ‚ö†Ô∏è Updates every 10s - only this widget re-renders
      </p>
    </div>
  );
});

const HealthWidget = memo(function HealthWidget() {
  const health = useHealth();

  console.log('HealthWidget rendered');

  const getStatusColor = (status) => {
    return status === 'healthy' ? '#4caf50' : '#ff9800';
  };

  return (
    <div style={{ marginBottom: '20px' }}>
      <h2 style={{ marginBottom: '15px' }}>üè• System Health</h2>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
          gap: '15px',
        }}
      >
        <MetricCard
          title='CPU Usage'
          value={health.cpu}
          unit='%'
          color={health.cpu > 80 ? '#f44336' : '#4caf50'}
        />
        <MetricCard
          title='Memory Usage'
          value={health.memory}
          unit='%'
          color={health.memory > 80 ? '#f44336' : '#4caf50'}
        />
        <div
          style={{
            position: 'relative',
            background: 'white',
            padding: '20px',
            borderRadius: '8px',
            boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
            borderLeft: `4px solid ${getStatusColor(health.status)}`,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
        >
          <RenderCounter name='Status' />
          <div style={{ textAlign: 'center' }}>
            <div
              style={{ fontSize: '14px', color: '#666', marginBottom: '8px' }}
            >
              Status
            </div>
            <div
              style={{
                fontSize: '24px',
                fontWeight: 'bold',
                color: getStatusColor(health.status),
              }}
            >
              {health.status.toUpperCase()}
            </div>
          </div>
        </div>
      </div>
      <p style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
        ‚ö†Ô∏è Updates every 2s - only this widget re-renders
      </p>
    </div>
  );
});

const StaticHeader = memo(function StaticHeader() {
  console.log('StaticHeader rendered');

  return (
    <header
      style={{
        background: 'white',
        padding: '20px',
        borderRadius: '8px',
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
        marginBottom: '30px',
        position: 'relative',
      }}
    >
      <RenderCounter name='Header' />
      <h1 style={{ margin: 0 }}>üìà Dashboard</h1>
      <p style={{ margin: '10px 0 0 0', color: '#666' }}>
        Real-time monitoring system
      </p>
      <p
        style={{
          fontSize: '12px',
          color: '#4caf50',
          marginTop: '10px',
          fontWeight: 'bold',
        }}
      >
        ‚úÖ This component NEVER re-renders
      </p>
    </header>
  );
});

function AppProviders({ children }) {
  return (
    <AnalyticsProvider>
      <SalesProvider>
        <HealthProvider>{children}</HealthProvider>
      </SalesProvider>
    </AnalyticsProvider>
  );
}

function App() {
  return (
    <AppProviders>
      <div
        style={{
          maxWidth: '1200px',
          margin: '40px auto',
          padding: '20px',
          background: '#f5f5f5',
          minHeight: '100vh',
        }}
      >
        <div
          style={{
            background: '#d1ecf1',
            padding: '20px',
            borderRadius: '8px',
            marginBottom: '20px',
          }}
        >
          <strong>üéØ Perfect Performance:</strong>
          <ul style={{ marginTop: '10px', marginBottom: 0 }}>
            <li>‚úÖ 4 separate contexts (Analytics, Sales, Health, UI)</li>
            <li>‚úÖ State/Dispatch pattern for each</li>
            <li>‚úÖ Widgets only re-render when THEIR data changes</li>
            <li>‚úÖ Header NEVER re-renders</li>
            <li>‚úÖ Render counters show optimization working</li>
          </ul>
          <p style={{ marginTop: '15px', marginBottom: 0, fontWeight: 'bold' }}>
            Watch the render counters - each widget isolated!
          </p>
        </div>

        <StaticHeader />
        <AnalyticsWidget />
        <SalesWidget />
        <HealthWidget />
      </div>
    </AppProviders>
  );
}

/**
 * PRODUCTION PERFORMANCE ANALYSIS:
 *
 * WITHOUT Optimization:
 * - ANY update ‚Üí ALL widgets + header re-render
 * - Health updates (2s) ‚Üí 13+ components re-render
 * - Total re-renders per minute: 200+
 * - UI stutters, laggy
 *
 * WITH Optimization:
 * - Health update (2s) ‚Üí ONLY HealthWidget (3 components)
 * - Analytics update (5s) ‚Üí ONLY AnalyticsWidget (4 components)
 * - Sales update (10s) ‚Üí ONLY SalesWidget (3 components)
 * - Header NEVER re-renders
 * - Total re-renders per minute: 60
 * - Smooth, responsive UI
 *
 * PERFORMANCE GAIN: 70% reduction in re-renders!
 *
 * KEY TECHNIQUES:
 * 1. ‚úÖ Context splitting by concern
 * 2. ‚úÖ State/Dispatch separation
 * 3. ‚úÖ React.memo on all components
 * 4. ‚úÖ Render counter for visibility
 * 5. ‚úÖ Perfect isolation
 *
 * PRODUCTION READY:
 * - Scales to 100+ metrics
 * - Handles frequent updates
 * - Minimal re-renders
 * - Great UX
 */
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh: Optimization Strategies

| Strategy                 | Complexity         | Performance Gain     | Use Case                       |
| ------------------------ | ------------------ | -------------------- | ------------------------------ |
| **useMemo value**        | ‚≠ê Low             | ‚≠ê‚≠ê Medium          | Simple contexts, few consumers |
| **React.memo**           | ‚≠ê Low             | ‚≠ê‚≠ê Medium          | Components v·ªõi stable props    |
| **Context Splitting**    | ‚≠ê‚≠ê‚≠ê High        | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | Multiple independent state     |
| **State/Dispatch Split** | ‚≠ê‚≠ê Medium        | ‚≠ê‚≠ê‚≠ê‚≠ê High        | useReducer-based contexts      |
| **Selector Pattern**     | ‚≠ê‚≠ê‚≠ê‚≠ê Very High | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent | Complex state, many consumers  |

### B·∫£ng So S√°nh: Trade-offs

| Aspect              | Single Context | Multiple Contexts |
| ------------------- | -------------- | ----------------- |
| **Setup Time**      | ‚úÖ Fast        | ‚ùå Slow           |
| **Boilerplate**     | ‚úÖ Minimal     | ‚ùå Much           |
| **Performance**     | ‚ùå Poor        | ‚úÖ Excellent      |
| **Maintainability** | ‚ö†Ô∏è Medium      | ‚úÖ High           |
| **Testing**         | ‚ùå Hard        | ‚úÖ Easy           |
| **Debugging**       | ‚ùå Hard        | ‚úÖ Easy           |

### Decision Tree

```
PERFORMANCE ISSUE?
‚îú‚îÄ NO ‚Üí Don't optimize (premature optimization!)
‚îî‚îÄ YES ‚Üí Profile first!
    ‚îú‚îÄ Few re-renders (<10/sec) ‚Üí useMemo + React.memo
    ‚îî‚îÄ Many re-renders (>10/sec) ‚Üí Need deeper optimization
        ‚îú‚îÄ Single concern ‚Üí State/Dispatch split
        ‚îî‚îÄ Multiple concerns ‚Üí Context splitting
            ‚îú‚îÄ Independent states ‚Üí Separate contexts
            ‚îî‚îÄ Complex state ‚Üí Selector pattern

WHEN TO OPTIMIZE:
‚îú‚îÄ Profiler shows slow renders (>16ms)
‚îú‚îÄ UI feels laggy
‚îú‚îÄ User complaints
‚îî‚îÄ NEVER: "Just in case" or "Best practice"

OPTIMIZATION ORDER:
1. Measure (React DevTools Profiler)
2. Identify bottleneck
3. Apply SIMPLEST solution
4. Measure again
5. Iterate if needed
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: useMemo v·ªõi Wrong Dependencies ‚ö†Ô∏è

```jsx
/**
 * üêõ BUG: useMemo kh√¥ng work nh∆∞ expected
 *
 * üéØ CHALLENGE: T√¨m l·ªói
 */

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');

  // ‚ùå Missing dependencies!
  const value = useMemo(
    () => ({ user, setUser, theme, setTheme }),
    [], // Empty array!
  );

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

// Change user ‚Üí Consumers kh√¥ng nh·∫≠n updated value!

// ‚ùì QUESTIONS:
// 1. T·∫°i sao consumers kh√¥ng update?
// 2. Dependencies n√†o c·∫ßn th√™m?
// 3. C√≥ th·ªÉ d√πng [] kh√¥ng?
```

**üí° Gi·∫£i th√≠ch:**

```jsx
// NGUY√äN NH√ÇN:
// - useMemo with [] ‚Üí Ch·ªâ t·∫°o value 1 l·∫ßn
// - user, theme thay ƒë·ªïi ‚Üí value V·∫™N gi·ªØ gi√° tr·ªã c≈©
// - Consumers nh·∫≠n stale value

// ‚úÖ FIX: ƒê√∫ng dependencies
const value = useMemo(
  () => ({ user, setUser, theme, setTheme }),
  [user, theme], // Add user and theme!
);

// setUser, setTheme l√† stable (t·ª´ useState)
// Kh√¥ng c·∫ßn trong deps

// RULE:
// - useMemo deps PH·∫¢I include t·∫•t c·∫£ values d√πng trong computation
// - ESLint rule: exhaustive-deps
```

### Bug 2: React.memo kh√¥ng Work v·ªõi Objects ‚ö†Ô∏è

```jsx
/**
 * üêõ BUG: React.memo component v·∫´n re-render
 *
 * üéØ CHALLENGE: T√¨m l·ªói
 */

const UserCard = memo(function UserCard({ user }) {
  console.log('UserCard rendered');
  return <div>{user.name}</div>;
});

function App() {
  const [count, setCount] = useState(0);

  // ‚ùå New object every render!
  const user = { name: 'John', age: 30 };

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Count: {count}</button>
      <UserCard user={user} />
      {/* UserCard re-renders m·ªói l·∫ßn count thay ƒë·ªïi! */}
    </div>
  );
}

// ‚ùì QUESTIONS:
// 1. T·∫°i sao UserCard re-render?
// 2. Object comparison l√† g√¨?
// 3. L√†m sao fix?
```

**üí° Gi·∫£i th√≠ch:**

```jsx
// NGUY√äN NH√ÇN:
// - { name: 'John' } t·∫°o NEW object m·ªói render
// - React.memo so s√°nh: prevUser === nextUser
// - prevUser !== nextUser (different references)
// - ‚Üí Re-render!

// ‚úÖ FIX 1: useMemo cho object
function App() {
  const [count, setCount] = useState(0);

  const user = useMemo(
    () => ({ name: 'John', age: 30 }),
    [], // Static object
  );

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Count: {count}</button>
      <UserCard user={user} />
      {/* UserCard KH√îNG re-render! */}
    </div>
  );
}

// ‚úÖ FIX 2: Move object outside component
const user = { name: 'John', age: 30 }; // Outside!

function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Count: {count}</button>
      <UserCard user={user} />
    </div>
  );
}

// RULE:
// - React.memo ch·ªâ work v·ªõi stable references
// - Objects/arrays trong render ‚Üí ALWAYS new
// - useMemo ho·∫∑c move outside component
```

### Bug 3: Context Splitting Missing Provider ‚ö†Ô∏è

```jsx
/**
 * üêõ BUG: Context error khi split
 *
 * üéØ CHALLENGE: T√¨m l·ªói
 */

const StateContext = createContext();
const DispatchContext = createContext();

function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, initialState);

  // ‚ùå Forgot DispatchContext.Provider!
  return (
    <StateContext.Provider value={state}>{children}</StateContext.Provider>
  );
}

function AddToCartButton() {
  const dispatch = useContext(DispatchContext); // undefined!

  return <button onClick={() => dispatch({ type: 'ADD' })}>Add</button>;
  // Error: dispatch is not a function
}

// ‚ùì QUESTIONS:
// 1. T·∫°i sao dispatch l√† undefined?
// 2. Qu√™n g√¨?
// 3. L√†m sao prevent?
```

**üí° Gi·∫£i th√≠ch:**

```jsx
// NGUY√äN NH√ÇN:
// - T·∫°o DispatchContext nh∆∞ng KH√îNG c√≥ Provider
// - useContext(DispatchContext) ‚Üí undefined (default value)
// - dispatch() ‚Üí Error

// ‚úÖ FIX: Wrap c·∫£ 2 Providers
function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, initialState);

  return (
    <StateContext.Provider value={state}>
      <DispatchContext.Provider value={dispatch}>
        {children}
      </DispatchContext.Provider>
    </StateContext.Provider>
  );
}

// ‚úÖ Better: Custom hooks v·ªõi error check
function useCartDispatch() {
  const context = useContext(DispatchContext);

  if (context === undefined) {
    throw new Error('useCartDispatch must be used within CartProvider');
  }

  return context;
}

// PREVENTION:
// - ALWAYS create custom hooks
// - Check for undefined
// - Throw clear error message
```

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

- [ ] T√¥i hi·ªÉu t·∫°i sao Context g√¢y performance issues
- [ ] T√¥i bi·∫øt c√°ch profile performance v·ªõi React DevTools
- [ ] T√¥i bi·∫øt c√°ch d√πng useMemo cho context value
- [ ] T√¥i bi·∫øt c√°ch d√πng useCallback cho context functions
- [ ] T√¥i hi·ªÉu State/Dispatch splitting pattern
- [ ] T√¥i bi·∫øt khi n√†o split contexts
- [ ] T√¥i bi·∫øt implement selector pattern c∆° b·∫£n
- [ ] T√¥i hi·ªÉu trade-offs c·ªßa m·ªói optimization
- [ ] T√¥i bi·∫øt KHI N√ÄO optimize (measure first!)
- [ ] T√¥i bi·∫øt KH√îNG optimize s·ªõm

### Code Review Checklist

**Optimization:**

- [ ] Profile TR∆Ø·ªöC KHI optimize
- [ ] useMemo cho context value objects
- [ ] useCallback cho context functions
- [ ] Dependencies ƒë√∫ng v√† ƒë·∫ßy ƒë·ªß
- [ ] React.memo cho expensive components

**Context Architecture:**

- [ ] Split contexts theo concerns
- [ ] State/Dispatch separation khi d√πng useReducer
- [ ] Custom hooks cho m·ªói context
- [ ] Error checks trong custom hooks

**Performance:**

- [ ] Render count < 5 per update
- [ ] Render time < 16ms (60fps)
- [ ] No unnecessary re-renders
- [ ] Profiler flamegraph clean

**Documentation:**

- [ ] Document optimization decisions
- [ ] Explain trade-offs
- [ ] Performance benchmarks

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**Profile v√† Optimize Existing App**

L·∫•y b√†i t·∫≠p Shopping Cart t·ª´ Ng√†y 37:

Tasks:

1. Profile performance (React DevTools)
2. Document issues found
3. Apply optimizations:
   - useMemo for context value
   - React.memo for components
   - State/Dispatch split
4. Profile l·∫°i v√† compare
5. Document improvements

Deliverable:

- Before/After screenshots
- Re-render count comparison
- Code v·ªõi comments gi·∫£i th√≠ch optimizations

### N√¢ng cao (60 ph√∫t)

**Build Optimized Real-time Chat**

Requirements:

- MessageContext v·ªõi 1000+ messages
- UserContext v·ªõi online users
- TypingContext cho typing indicators
- Messages update real-time (simulate)

Optimization Requirements:

- Split contexts
- State/Dispatch pattern
- Selector hooks
- Message virtualization (display 50 at a time)
- Profile v√† document

Constraints:

- Render time < 16ms
- Smooth scrolling
- < 10 re-renders per message

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - useMemo:**
   https://react.dev/reference/react/useMemo

2. **React Docs - React.memo:**
   https://react.dev/reference/react/memo

3. **React Docs - useSyncExternalStore:**
   https://react.dev/reference/react/useSyncExternalStore

### ƒê·ªçc th√™m

1. **Before You memo():**
   https://overreacted.io/before-you-memo/

2. **React Context Performance:**
   https://github.com/facebook/react/issues/15156

3. **Optimizing Context Value:**
   https://kentcdodds.com/blog/how-to-optimize-your-context-value

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (c·∫ßn bi·∫øt)

- **Ng√†y 32:** React.memo fundamentals
- **Ng√†y 33:** useMemo patterns
- **Ng√†y 34:** useCallback patterns
- **Ng√†y 36-37:** Context basics v√† advanced patterns

### H∆∞·ªõng t·ªõi (s·∫Ω d√πng)

- **Ng√†y 41-43:** Forms performance v·ªõi Context
- **Ng√†y 46-50:** Concurrent features + Context
- **Ng√†y 61-75:** Capstone project architecture

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**When NOT to Optimize:**

```jsx
// ‚ùå Premature Optimization
// App nh·ªè, kh√¥ng c√≥ performance issue
// ‚Üí Ch·∫•p nh·∫≠n simple code > optimized code

// ‚úÖ Optimize When:
// - Profiler shows slow renders (>16ms)
// - Users complain about lag
// - Measurable performance degradation
```

**Optimization Cost:**

```jsx
// Simple Code (No optimization):
const value = { user, setUser };

// Optimized Code:
const value = useMemo(() => ({ user, setUser }), [user]); // +3 lines, +mental overhead

// TRADE-OFF:
// - Simple: D·ªÖ ƒë·ªçc, d·ªÖ maintain
// - Optimized: Performance t·ªët, ph·ª©c t·∫°p h∆°n

// RULE: Optimize ch·ªâ khi benefit > cost!
```

**Context Splitting Decision:**

```
START: Single Context

IF (>20 consumers) AND (frequent updates)
  ‚Üí Profile performance

IF (re-renders >10/sec) AND (UI laggy)
  ‚Üí Consider splitting

IF (independent state groups)
  ‚Üí Split by concern

ELSE
  ‚Üí Keep simple!
```

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior:**

1. T·∫°i sao Context g√¢y re-render issues?
2. useMemo gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ g√¨?
3. React.memo l√†m g√¨?

**Mid:**

1. So s√°nh optimization strategies (useMemo, split, selector)
2. State/Dispatch splitting ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o?
3. Khi n√†o N√äN optimize Context?

**Senior:**

1. Design optimization strategy cho large app (100+ contexts)
2. Implement custom selector pattern
3. Debug re-render issues methodology
4. Measure performance improvements quantitatively

### War Stories

**Story 1: The Premature Optimization**

```
Junior dev optimize M·ªåI context:
- useMemo everywhere
- Split 50 contexts
- Selector hooks for everything

K·∫øt qu·∫£:
- 5x code complexity
- Hard to debug
- Performance improvement: 0ms (kh√¥ng c√≥ issue!)

Lesson: MEASURE FIRST!
```

**Story 2: The Performance Win**

```
Production app laggy:
- Single Context v·ªõi 200 consumers
- Every update ‚Üí 200 re-renders
- UI stutters

Solution:
- Split into 5 contexts
- State/Dispatch pattern
- React.memo strategically

Result:
- 80% re-render reduction
- Smooth UI
- Happy users
```

---

## üéØ PREVIEW NG√ÄY 39

**Component Patterns - Part 1**

Ng√†y mai ch√∫ng ta s·∫Ω h·ªçc:

- Compound Components pattern
- Flexible component APIs
- Implicit state sharing
- Real-world examples (Select, Tabs, Accordion)

Teaser:

```jsx
// Compound Components pattern
<Select
  value={value}
  onChange={onChange}
>
  <Select.Trigger />
  <Select.Options>
    <Select.Option value='1'>One</Select.Option>
    <Select.Option value='2'>Two</Select.Option>
  </Select.Options>
</Select>

// State ƒë∆∞·ª£c share implicitly gi·ªØa components!
```

**Chu·∫©n b·ªã:**

- Hi·ªÉu Context patterns (Ng√†y 36-38)
- Suy nghƒ©: L√†m sao share state gi·ªØa sibling components?
- Review children prop v√† component composition

---

‚úÖ **Ho√†n th√†nh Ng√†y 38!**

B·∫°n ƒë√£ bi·∫øt:

- T·∫°i sao Context c√≥ performance issues
- Profile v√† detect re-render problems
- useMemo/useCallback optimization
- Context Splitting patterns
- State/Dispatch separation
- Selector pattern basics
- **KHI N√ÄO optimize (measure first!)**

Ti·∫øp theo: Advanced Component Patterns! üöÄ
