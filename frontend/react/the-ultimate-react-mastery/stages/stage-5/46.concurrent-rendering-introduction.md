# üìÖ NG√ÄY 46: Concurrent Rendering - N·ªÅn T·∫£ng Hi·ªán ƒê·∫°i

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

- [ ] Hi·ªÉu ƒë∆∞·ª£c Concurrent Rendering l√† g√¨ v√† t·∫°i sao c·∫ßn thi·∫øt
- [ ] Ph√¢n bi·ªát r√µ Synchronous vs Concurrent rendering
- [ ] N·∫Øm v·ªØng Automatic Batching trong React 18
- [ ] Bi·∫øt c√°ch measure v√† visualize render performance
- [ ] Nh·∫≠n di·ªán use cases ph√π h·ª£p v·ªõi Concurrent features

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

**C√¢u 1:** State update trong React trigger re-render nh∆∞ th·∫ø n√†o? C√≥ ƒë·ªìng b·ªô hay b·∫•t ƒë·ªìng b·ªô?

**C√¢u 2:** Khi b·∫°n g·ªçi `setState` nhi·ªÅu l·∫ßn li√™n ti·∫øp, React x·ª≠ l√Ω nh∆∞ th·∫ø n√†o?

**C√¢u 3:** Trong app c√≥ danh s√°ch 10,000 items, user typing v√†o search box b·ªã lag. T·∫°i sao v√† b·∫°n x·ª≠ l√Ω th·∫ø n√†o?

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

T∆∞·ªüng t∆∞·ª£ng b·∫°n ƒëang build m·ªôt search interface:

```jsx
function SearchPage() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);

    // Heavy computation - filter 10,000 items
    const filtered = heavyFilter(allItems, value);
    setResults(filtered);
  };

  return (
    <>
      <input
        value={query}
        onChange={handleChange}
      />
      <ResultsList results={results} /> {/* Renders 10,000 items */}
    </>
  );
}
```

**V·∫•n ƒë·ªÅ:** M·ªói keystroke ‚Üí UI freezes v√†i trƒÉm ms ‚Üí Tr·∫£i nghi·ªám t·ªá!

**T·∫°i sao?** React 17 render **ƒë·ªìng b·ªô (synchronous)**:

1. User types "a"
2. React b·∫Øt ƒë·∫ßu render t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi
3. PH·∫¢I ho√†n th√†nh 100% tr∆∞·ªõc khi handle input ti·∫øp theo
4. N·∫øu render takes 200ms ‚Üí Input b·ªã block 200ms

### 1.2 Gi·∫£i Ph√°p: Concurrent Rendering

React 18 gi·ªõi thi·ªáu **Concurrent Rendering** - kh·∫£ nƒÉng:

- **Interruptible rendering**: T·∫°m d·ª´ng render ƒë·ªÉ x·ª≠ l√Ω urgent updates
- **Prioritized updates**: Updates c√≥ ƒë·ªô ∆∞u ti√™n kh√°c nhau
- **Automatic batching**: Batch nhi·ªÅu state updates th√†nh 1 render

**Mental Model:**

```
REACT 17 (Synchronous):
User Input ‚Üí [==========RENDER==========] ‚Üí UI Update
              (blocked, kh√¥ng th·ªÉ interrupt)

REACT 18 (Concurrent):
User Input ‚Üí [==RENDER==] ‚Üê New Input!
              (pause render, handle input first)
             ‚Üí [==RENDER URGENT==] ‚Üí UI Update (fast!)
             ‚Üí [==RESUME RENDER==] ‚Üí Background Update
```

### 1.3 Mental Model

H√£y nghƒ© v·ªÅ Concurrent Rendering nh∆∞ **multitasking tr√™n computer**:

**Synchronous (React 17):**

```
Task A [=============================] Task B
       Must finish A before start B
```

**Concurrent (React 18):**

```
Task A [====]     [====]     [====]
Task B      [====]     [====]     [====]
       Switch between tasks, prioritize urgent ones
```

**Analogy:**

- **Synchronous:** Nh∆∞ ƒë·ªçc s√°ch t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi, kh√¥ng ƒë∆∞·ª£c d·ª´ng
- **Concurrent:** Nh∆∞ ƒë·ªçc s√°ch nh∆∞ng c√≥ th·ªÉ bookmark, x·ª≠ l√Ω ƒëi·ªán tho·∫°i, r·ªìi quay l·∫°i ƒë·ªçc ti·∫øp

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

‚ùå **Hi·ªÉu l·∫ßm 1:** "Concurrent = Parallel (ƒëa lu·ªìng)"

- ‚úÖ **S·ª± th·∫≠t:** V·∫´n single-threaded! Ch·ªâ l√† **time-slicing** th√¥ng minh

‚ùå **Hi·ªÉu l·∫ßm 2:** "React 18 t·ª± ƒë·ªông l√†m m·ªçi th·ª© nhanh h∆°n"

- ‚úÖ **S·ª± th·∫≠t:** C·∫ßn **opt-in** v√†o concurrent features (useTransition, useDeferredValue)

‚ùå **Hi·ªÉu l·∫ßm 3:** "Ph·∫£i rewrite to√†n b·ªô app ƒë·ªÉ d√πng React 18"

- ‚úÖ **S·ª± th·∫≠t:** Backward compatible 100%! Ch·ªâ c·∫ßn upgrade version

‚ùå **Hi·ªÉu l·∫ßm 4:** "Automatic batching l√†m app ch·∫≠m h∆°n"

- ‚úÖ **S·ª± th·∫≠t:** Ng∆∞·ª£c l·∫°i - √≠t render h∆°n = nhanh h∆°n!

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Automatic Batching - Before vs After ‚≠ê

**React 17 (No Batching ngo√†i event handlers):**

```jsx
/**
 * Demo: React 17 batching behavior
 * Batching CH·ªà ho·∫°t ƒë·ªông trong event handlers
 */
function Counter17() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  console.log('Render'); // Log ƒë·ªÉ ƒë·∫øm s·ªë l·∫ßn render

  // ‚úÖ Event handler: Batched (1 render)
  const handleClick = () => {
    setCount((c) => c + 1);
    setFlag((f) => !f);
    // React 17: Batches these ‚Üí 1 render
  };

  // ‚ùå setTimeout: NOT batched (2 renders)
  const handleAsync = () => {
    setTimeout(() => {
      setCount((c) => c + 1); // Render 1
      setFlag((f) => !f); // Render 2
      // React 17: NO batching ‚Üí 2 renders!
    }, 1000);
  };

  // ‚ùå fetch: NOT batched (2 renders)
  const handleFetch = () => {
    fetch('/api/data').then(() => {
      setCount((c) => c + 1); // Render 1
      setFlag((f) => !f); // Render 2
      // React 17: NO batching ‚Üí 2 renders!
    });
  };

  return (
    <div>
      <p>
        Count: {count}, Flag: {flag.toString()}
      </p>
      <button onClick={handleClick}>Sync Update (1 render)</button>
      <button onClick={handleAsync}>Async Update (2 renders)</button>
      <button onClick={handleFetch}>Fetch Update (2 renders)</button>
    </div>
  );
}

// Console output khi click "Async Update":
// Render
// Render
// ‚Üí 2 renders! Performance issue!
```

**React 18 (Automatic Batching everywhere):**

```jsx
/**
 * Demo: React 18 automatic batching
 * Batching ho·∫°t ƒë·ªông ·ªü M·ªåI N∆†I
 */
function Counter18() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  console.log('Render');

  // ‚úÖ Event handler: Batched
  const handleClick = () => {
    setCount((c) => c + 1);
    setFlag((f) => !f);
    // React 18: Batched ‚Üí 1 render
  };

  // ‚úÖ setTimeout: Batched! (NEW in React 18)
  const handleAsync = () => {
    setTimeout(() => {
      setCount((c) => c + 1);
      setFlag((f) => !f);
      // React 18: Batched ‚Üí 1 render ‚ú®
    }, 1000);
  };

  // ‚úÖ fetch: Batched! (NEW in React 18)
  const handleFetch = async () => {
    const data = await fetch('/api/data');
    setCount((c) => c + 1);
    setFlag((f) => !f);
    // React 18: Batched ‚Üí 1 render ‚ú®
  };

  return (
    <div>
      <p>
        Count: {count}, Flag: {flag.toString()}
      </p>
      <button onClick={handleClick}>Sync Update (1 render)</button>
      <button onClick={handleAsync}>Async Update (1 render!)</button>
      <button onClick={handleFetch}>Fetch Update (1 render!)</button>
    </div>
  );
}

// Console output khi click "Async Update":
// Render
// ‚Üí Ch·ªâ 1 render! Performance improved! ‚ú®
```

**‚ö†Ô∏è Opt-out n·∫øu c·∫ßn:**

```jsx
import { flushSync } from 'react-dom';

function OptOut() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);

  const handleClick = () => {
    flushSync(() => {
      setCount((c) => c + 1); // Render immediately
    });

    flushSync(() => {
      setFlag((f) => !f); // Render immediately
    });
    // Total: 2 renders (opted out of batching)
  };

  return <button onClick={handleClick}>Force 2 Renders</button>;
}
```

### Demo 2: Visualizing Concurrent Rendering ‚≠ê‚≠ê

```jsx
/**
 * Demo: Measure render performance v·ªõi profiler
 * So s√°nh sync vs concurrent rendering impact
 */
import { Profiler } from 'react';

function PerformanceDemo() {
  const [items, setItems] = useState(generateItems(5000));
  const [query, setQuery] = useState('');

  // Callback ƒë·ªÉ measure render time
  const onRenderCallback = (
    id,
    phase, // "mount" ho·∫∑c "update"
    actualDuration, // Time spent rendering
    baseDuration, // Estimated time without memoization
    startTime,
    commitTime,
    interactions,
  ) => {
    console.log(`${id} ${phase} phase:`);
    console.log(`  Actual time: ${actualDuration.toFixed(2)}ms`);
    console.log(`  Base time: ${baseDuration.toFixed(2)}ms`);
  };

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);

    // Heavy filtering
    const filtered = items.filter((item) =>
      item.name.toLowerCase().includes(value.toLowerCase()),
    );
    setItems(filtered);
  };

  return (
    <Profiler
      id='SearchDemo'
      onRender={onRenderCallback}
    >
      <div>
        <input
          type='text'
          value={query}
          onChange={handleChange}
          placeholder='Search...'
        />

        <div>
          {items.map((item) => (
            <div key={item.id}>{item.name}</div>
          ))}
        </div>
      </div>
    </Profiler>
  );
}

function generateItems(count) {
  return Array.from({ length: count }, (_, i) => ({
    id: i,
    name: `Item ${i}`,
  }));
}

// Console output:
// SearchDemo update phase:
//   Actual time: 245.30ms  ‚Üê Blocking UI!
//   Base time: 245.30ms
```

### Demo 3: React DevTools Profiler ‚≠ê‚≠ê‚≠ê

```jsx
/**
 * Demo: S·ª≠ d·ª•ng React DevTools ƒë·ªÉ identify performance issues
 *
 * C√°ch d√πng:
 * 1. M·ªü React DevTools
 * 2. Tab "Profiler"
 * 3. Click record (‚è∫Ô∏è)
 * 4. Interact v·ªõi app
 * 5. Stop recording
 * 6. Analyze flame graph
 */
function ProfilerExample() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');

  // Heavy component - intentionally slow
  const HeavyComponent = () => {
    const startTime = performance.now();
    while (performance.now() - startTime < 50) {
      // Simulate heavy computation
    }
    return <div>Heavy Component rendered</div>;
  };

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>

      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder='Type here...'
      />

      {/* This will show up red in profiler */}
      <HeavyComponent />

      {/* Render nhi·ªÅu components ƒë·ªÉ d·ªÖ visualize */}
      {Array.from({ length: 100 }).map((_, i) => (
        <div key={i}>Item {i}</div>
      ))}
    </div>
  );
}

/**
 * Flame Graph Analysis:
 *
 * üî¥ Red/Orange: Took long time (>12ms)
 * üü° Yellow: Moderate time (4-12ms)
 * üü¢ Green: Fast (<4ms)
 *
 * Ranked Chart: Shows components by render time
 * - Focus on top items first
 * - Optimize red/orange components
 */
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Level 1: Ki·ªÉm Tra Automatic Batching (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Verify automatic batching trong React 18
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: useTransition, useDeferredValue
 *
 * Requirements:
 * 1. T·∫°o component v·ªõi 3 state variables
 * 2. Update c·∫£ 3 states trong setTimeout
 * 3. Log render count ƒë·ªÉ verify ch·ªâ 1 render
 * 4. So s√°nh behavior n·∫øu d√πng React 17
 *
 * üí° G·ª£i √Ω: D√πng useRef ƒë·ªÉ track render count
 */

// ‚ùå C√°ch SAI (kh√¥ng track ƒë∆∞·ª£c renders):
function BadExample() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  const [c, setC] = useState(0);

  // Kh√¥ng c√≥ c√°ch n√†o bi·∫øt bao nhi√™u renders!

  return <div>{a + b + c}</div>;
}

// ‚úÖ C√°ch ƒê√öNG (track renders properly):
function GoodExample() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);
  const [c, setC] = useState(0);

  const renderCount = useRef(0);

  useEffect(() => {
    renderCount.current += 1;
    console.log(`Render #${renderCount.current}`);
  });

  return (
    <div>
      <p>Sum: {a + b + c}</p>
      <p>Render count: {renderCount.current}</p>
    </div>
  );
}

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
function BatchingTest() {
  // TODO: Implement state variables

  // TODO: Implement render counter

  const handleAsync = () => {
    setTimeout(() => {
      // TODO: Update all 3 states here
      // Expected: Ch·ªâ 1 render trong React 18
    }, 100);
  };

  const handlePromise = () => {
    Promise.resolve().then(() => {
      // TODO: Update all 3 states here
      // Expected: Ch·ªâ 1 render trong React 18
    });
  };

  return (
    <div>
      {/* TODO: Display states v√† render count */}
      {/* TODO: Add buttons ƒë·ªÉ trigger updates */}
    </div>
  );
}
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Automatic Batching Test Component
 * Verifies React 18 batches updates trong async contexts
 */
function BatchingTest() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);
  const [text, setText] = useState('');

  const renderCount = useRef(0);

  useEffect(() => {
    renderCount.current += 1;
    console.log(`Render #${renderCount.current}`);
  });

  const handleAsync = () => {
    console.log('--- Async update started ---');
    setTimeout(() => {
      setCount((c) => c + 1);
      setFlag((f) => !f);
      setText('Updated via setTimeout');
      // React 18: 1 render
      // React 17: 3 renders
    }, 100);
  };

  const handlePromise = () => {
    console.log('--- Promise update started ---');
    Promise.resolve().then(() => {
      setCount((c) => c + 1);
      setFlag((f) => !f);
      setText('Updated via Promise');
      // React 18: 1 render
      // React 17: 3 renders
    });
  };

  const handleFetch = async () => {
    console.log('--- Fetch update started ---');
    // Simulate fetch
    await new Promise((resolve) => setTimeout(resolve, 100));

    setCount((c) => c + 1);
    setFlag((f) => !f);
    setText('Updated via fetch');
    // React 18: 1 render
    // React 17: 3 renders
  };

  return (
    <div>
      <h3>Automatic Batching Test</h3>
      <div>
        <p>Count: {count}</p>
        <p>Flag: {flag.toString()}</p>
        <p>Text: {text}</p>
        <p>
          <strong>Total Renders: {renderCount.current}</strong>
        </p>
      </div>

      <button onClick={handleAsync}>Update via setTimeout</button>
      <button onClick={handlePromise}>Update via Promise</button>
      <button onClick={handleFetch}>Update via Fetch</button>
    </div>
  );
}

/**
 * Expected results (React 18):
 * - Click "Update via setTimeout" ‚Üí Render count +1
 * - Click "Update via Promise" ‚Üí Render count +1
 * - Click "Update via Fetch" ‚Üí Render count +1
 *
 * In React 17:
 * - Each click would increase render count by +3
 */
```

</details>

### ‚≠ê‚≠ê Level 2: Performance Profiling (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Measure v√† visualize render performance
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Build m·ªôt search interface v·ªõi large dataset
 *
 * ü§î PH√ÇN T√çCH:
 * Approach A: Filter inline trong render
 * Pros: Simple, straightforward
 * Cons: Recalculates every render
 *
 * Approach B: Filter trong event handler
 * Pros: Better performance
 * Cons: Multiple state updates
 *
 * Approach C: useMemo ƒë·ªÉ cache filtered results
 * Pros: Optimal performance
 * Cons: More complex
 *
 * üí≠ B·∫†N CH·ªåN G√å V√Ä T·∫†I SAO?
 *
 * Requirements:
 * 1. Generate 10,000 items
 * 2. Implement search v·ªõi c·∫£ 3 approaches
 * 3. D√πng Profiler component ƒë·ªÉ measure
 * 4. Log render times
 * 5. So s√°nh performance
 */

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
function SearchPerformance() {
  const allItems = useMemo(
    () =>
      Array.from({ length: 10000 }, (_, i) => ({
        id: i,
        name: `Item ${i}`,
        category: ['A', 'B', 'C'][i % 3],
      })),
    [],
  );

  // TODO: Implement 3 approaches
  // TODO: Add Profiler to measure each
  // TODO: Display render times

  return <div>{/* Your implementation */}</div>;
}
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Search Performance Comparison
 * Compares different filtering approaches
 */
function SearchPerformance() {
  const allItems = useMemo(
    () =>
      Array.from({ length: 10000 }, (_, i) => ({
        id: i,
        name: `Item ${i}`,
        category: ['Electronics', 'Clothing', 'Food'][i % 3],
      })),
    [],
  );

  const [approach, setApproach] = useState('A');
  const [times, setTimes] = useState({ A: [], B: [], C: [] });

  const onRender = useCallback((id, phase, actualDuration) => {
    if (phase === 'update') {
      setTimes((prev) => ({
        ...prev,
        [id]: [...prev[id].slice(-4), actualDuration],
      }));
    }
  }, []);

  const avgTime = (arr) =>
    arr.length
      ? (arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(2)
      : '0.00';

  return (
    <div>
      <h3>Performance Comparison</h3>

      <div style={{ marginBottom: 20 }}>
        <button onClick={() => setApproach('A')}>Approach A</button>
        <button onClick={() => setApproach('B')}>Approach B</button>
        <button onClick={() => setApproach('C')}>Approach C</button>
      </div>

      <div style={{ marginBottom: 20 }}>
        <p>Approach A avg: {avgTime(times.A)}ms (Filter inline)</p>
        <p>Approach B avg: {avgTime(times.B)}ms (Filter in handler)</p>
        <p>Approach C avg: {avgTime(times.C)}ms (useMemo)</p>
      </div>

      {approach === 'A' && (
        <Profiler
          id='A'
          onRender={onRender}
        >
          <ApproachA items={allItems} />
        </Profiler>
      )}

      {approach === 'B' && (
        <Profiler
          id='B'
          onRender={onRender}
        >
          <ApproachB items={allItems} />
        </Profiler>
      )}

      {approach === 'C' && (
        <Profiler
          id='C'
          onRender={onRender}
        >
          <ApproachC items={allItems} />
        </Profiler>
      )}
    </div>
  );
}

/**
 * Approach A: Filter inline (WORST)
 * Re-filters on EVERY render, even unrelated updates
 */
function ApproachA({ items }) {
  const [query, setQuery] = useState('');
  const [count, setCount] = useState(0); // Unrelated state

  // ‚ùå Filters on every render!
  const filtered = items.filter((item) =>
    item.name.toLowerCase().includes(query.toLowerCase()),
  );

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search...'
      />
      <button onClick={() => setCount((c) => c + 1)}>
        Unrelated update: {count}
      </button>
      <p>Found: {filtered.length} items</p>
    </div>
  );
}

/**
 * Approach B: Filter in handler (BETTER)
 * Only filters when query changes
 */
function ApproachB({ items }) {
  const [query, setQuery] = useState('');
  const [filtered, setFiltered] = useState(items);
  const [count, setCount] = useState(0);

  const handleSearch = (e) => {
    const value = e.target.value;
    setQuery(value);

    // Filter and update state
    const results = items.filter((item) =>
      item.name.toLowerCase().includes(value.toLowerCase()),
    );
    setFiltered(results);
  };

  return (
    <div>
      <input
        value={query}
        onChange={handleSearch}
        placeholder='Search...'
      />
      <button onClick={() => setCount((c) => c + 1)}>
        Unrelated update: {count}
      </button>
      <p>Found: {filtered.length} items</p>
    </div>
  );
}

/**
 * Approach C: useMemo (BEST)
 * Only recalculates when dependencies change
 */
function ApproachC({ items }) {
  const [query, setQuery] = useState('');
  const [count, setCount] = useState(0);

  // ‚úÖ Only recalculates when query or items change
  const filtered = useMemo(() => {
    console.log('Filtering...'); // Log ƒë·ªÉ verify
    return items.filter((item) =>
      item.name.toLowerCase().includes(query.toLowerCase()),
    );
  }, [items, query]);

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search...'
      />
      <button onClick={() => setCount((c) => c + 1)}>
        Unrelated update: {count}
      </button>
      <p>Found: {filtered.length} items</p>
    </div>
  );
}

/**
 * Performance results (typical):
 * Approach A: 15-20ms per render (includes filtering)
 * Approach B: 2-3ms per render (no filtering on unrelated updates)
 * Approach C: 2-3ms per render (memoized)
 *
 * Key insight: Approach B and C similar, but C is cleaner code
 */
```

</details>

### ‚≠ê‚≠ê‚≠ê Level 3: React DevTools Profiler Analysis (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Identify v√† fix performance bottlenecks
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën type trong search box m∆∞·ª£t m√†
 * kh√¥ng b·ªã lag, ngay c·∫£ khi c√≥ nhi·ªÅu k·∫øt qu·∫£"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Search kh√¥ng lag khi typing nhanh
 * - [ ] Unrelated updates kh√¥ng re-render search results
 * - [ ] Profiler shows minimal wasted renders
 *
 * üé® Technical Constraints:
 * - Dataset: 5000 items
 * - Target: <16ms per render (60fps)
 * - Must show loading indicator
 *
 * üö® Edge Cases c·∫ßn handle:
 * - Empty search (show all)
 * - No results found
 * - Rapid typing (debounce?)
 *
 * üìù Implementation Checklist:
 * - [ ] Implement buggy version first
 * - [ ] Use Profiler to identify issues
 * - [ ] Apply optimizations
 * - [ ] Measure before/after
 */

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
function ProductSearch() {
  // TODO: Implement search v·ªõi intentional performance issues
  // TODO: Add Profiler
  // TODO: Identify bottlenecks
  // TODO: Fix issues
  // TODO: Document findings
}
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Product Search - Performance Optimization Exercise
 * Step-by-step optimization v·ªõi profiling
 */

// Step 1: Buggy version v·ªõi multiple issues
function ProductSearchBuggy() {
  const [query, setQuery] = useState('');
  const [category, setCategory] = useState('all');
  const [sortBy, setSortBy] = useState('name');

  // ‚ùå Issue 1: Generate data on every render!
  const allProducts = Array.from({ length: 5000 }, (_, i) => ({
    id: i,
    name: `Product ${i}`,
    category: ['Electronics', 'Clothing', 'Food'][i % 3],
    price: Math.floor(Math.random() * 1000),
  }));

  // ‚ùå Issue 2: No memoization
  const filtered = allProducts.filter((p) => {
    const matchQuery = p.name.toLowerCase().includes(query.toLowerCase());
    const matchCategory = category === 'all' || p.category === category;
    return matchQuery && matchCategory;
  });

  // ‚ùå Issue 3: Sorting on every render
  const sorted = [...filtered].sort((a, b) => {
    if (sortBy === 'name') return a.name.localeCompare(b.name);
    return a.price - b.price;
  });

  return (
    <div>
      <h3>‚ùå Buggy Version (measure this!)</h3>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search products...'
      />

      <select
        value={category}
        onChange={(e) => setCategory(e.target.value)}
      >
        <option value='all'>All Categories</option>
        <option value='Electronics'>Electronics</option>
        <option value='Clothing'>Clothing</option>
        <option value='Food'>Food</option>
      </select>

      <select
        value={sortBy}
        onChange={(e) => setSortBy(e.target.value)}
      >
        <option value='name'>Sort by Name</option>
        <option value='price'>Sort by Price</option>
      </select>

      <p>Found: {sorted.length} products</p>

      {/* ‚ùå Issue 4: No memo, re-renders always */}
      {sorted.slice(0, 100).map((product) => (
        <ProductCard
          key={product.id}
          product={product}
        />
      ))}
    </div>
  );
}

// Heavy component without memo
function ProductCard({ product }) {
  // Simulate heavy render
  const startTime = performance.now();
  while (performance.now() - startTime < 1) {
    // Busy wait 1ms
  }

  return (
    <div style={{ padding: 8, border: '1px solid #ddd', margin: 4 }}>
      <strong>{product.name}</strong> - ${product.price}
    </div>
  );
}

// Step 2: Optimized version
function ProductSearchOptimized() {
  const [query, setQuery] = useState('');
  const [category, setCategory] = useState('all');
  const [sortBy, setSortBy] = useState('name');
  const [renderTime, setRenderTime] = useState(0);

  // ‚úÖ Fix 1: useMemo for data generation
  const allProducts = useMemo(
    () =>
      Array.from({ length: 5000 }, (_, i) => ({
        id: i,
        name: `Product ${i}`,
        category: ['Electronics', 'Clothing', 'Food'][i % 3],
        price: Math.floor(Math.random() * 1000),
      })),
    [],
  );

  // ‚úÖ Fix 2: useMemo for filtering
  const filtered = useMemo(() => {
    console.log('Filtering...');
    return allProducts.filter((p) => {
      const matchQuery = p.name.toLowerCase().includes(query.toLowerCase());
      const matchCategory = category === 'all' || p.category === category;
      return matchQuery && matchCategory;
    });
  }, [allProducts, query, category]);

  // ‚úÖ Fix 3: useMemo for sorting
  const sorted = useMemo(() => {
    console.log('Sorting...');
    return [...filtered].sort((a, b) => {
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      return a.price - b.price;
    });
  }, [filtered, sortBy]);

  const onRender = useCallback((id, phase, actualDuration) => {
    if (phase === 'update') {
      setRenderTime(actualDuration);
    }
  }, []);

  return (
    <Profiler
      id='ProductSearch'
      onRender={onRender}
    >
      <div>
        <h3>‚úÖ Optimized Version</h3>
        <p>Last render: {renderTime.toFixed(2)}ms</p>

        <input
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder='Search products...'
        />

        <select
          value={category}
          onChange={(e) => setCategory(e.target.value)}
        >
          <option value='all'>All Categories</option>
          <option value='Electronics'>Electronics</option>
          <option value='Clothing'>Clothing</option>
          <option value='Food'>Food</option>
        </select>

        <select
          value={sortBy}
          onChange={(e) => setSortBy(e.target.value)}
        >
          <option value='name'>Sort by Name</option>
          <option value='price'>Sort by Price</option>
        </select>

        <p>Found: {sorted.length} products</p>

        {/* ‚úÖ Fix 4: Memo'd component */}
        {sorted.slice(0, 100).map((product) => (
          <ProductCardMemo
            key={product.id}
            product={product}
          />
        ))}
      </div>
    </Profiler>
  );
}

// ‚úÖ Memoized component
const ProductCardMemo = React.memo(function ProductCard({ product }) {
  const startTime = performance.now();
  while (performance.now() - startTime < 1) {
    // Busy wait 1ms
  }

  return (
    <div style={{ padding: 8, border: '1px solid #ddd', margin: 4 }}>
      <strong>{product.name}</strong> - ${product.price}
    </div>
  );
});

/**
 * Performance comparison:
 *
 * Buggy version:
 * - Initial render: ~600ms (regenerates data + sorts)
 * - Typing in search: ~300ms per keystroke
 * - Changing category: ~300ms
 * - Total wasted renders: High
 *
 * Optimized version:
 * - Initial render: ~150ms (memoized data)
 * - Typing in search: ~50ms per keystroke
 * - Changing category: ~30ms
 * - Total wasted renders: Minimal
 *
 * Improvement: ~6x faster! ‚ú®
 */
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê Level 4: Custom Performance Monitor (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Build reusable performance monitoring tool
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Nhi·ªám v·ª•:
 * 1. Design API cho usePerformance hook
 * 2. Decide metrics c·∫ßn track
 * 3. Visualization strategy
 *
 * ADR Template:
 * - Context: Need to monitor render performance across app
 * - Decision: Custom hook + visual indicator
 * - Rationale: Reusable, non-invasive, informative
 * - Consequences: Small overhead, dev-only
 * - Alternatives: React DevTools (manual), console.log (poor UX)
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 * [Implement solution]
 *
 * üß™ PHASE 3: Testing (10 ph√∫t)
 * - [ ] Test v·ªõi fast component (<5ms)
 * - [ ] Test v·ªõi slow component (>50ms)
 * - [ ] Verify kh√¥ng ·∫£nh h∆∞·ªüng production
 */

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
function usePerformance(componentName) {
  // TODO: Track render count
  // TODO: Track render time
  // TODO: Track average time
  // TODO: Detect slow renders (>16ms)
  // TODO: Return metrics v√† controls
}

function PerformanceMonitor({ children }) {
  // TODO: Visual indicator component
  // TODO: Show metrics overlay
  // TODO: Warning for slow renders
}
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Custom Performance Monitor Hook & Component
 * Tracks v√† visualizes component performance
 */

/**
 * usePerformance - Track component render metrics
 * @param {string} componentName - T√™n component ƒë·ªÉ identify
 * @returns {Object} Metrics v√† helper functions
 */
function usePerformance(componentName) {
  const renderCount = useRef(0);
  const renderTimes = useRef([]);
  const slowRenders = useRef([]);
  const [metrics, setMetrics] = useState({
    count: 0,
    avgTime: 0,
    lastTime: 0,
    slowCount: 0,
  });

  useEffect(() => {
    const startTime = performance.now();

    return () => {
      const endTime = performance.now();
      const renderTime = endTime - startTime;

      // Update counts
      renderCount.current += 1;
      renderTimes.current.push(renderTime);

      // Keep last 100 renders
      if (renderTimes.current.length > 100) {
        renderTimes.current.shift();
      }

      // Track slow renders (>16ms = 60fps threshold)
      if (renderTime > 16) {
        slowRenders.current.push({
          count: renderCount.current,
          time: renderTime,
          timestamp: Date.now(),
        });

        console.warn(
          `[Performance] Slow render in ${componentName}: ${renderTime.toFixed(2)}ms`,
        );
      }

      // Calculate metrics
      const avgTime =
        renderTimes.current.reduce((a, b) => a + b, 0) /
        renderTimes.current.length;

      setMetrics({
        count: renderCount.current,
        avgTime,
        lastTime: renderTime,
        slowCount: slowRenders.current.length,
      });
    };
  });

  const reset = useCallback(() => {
    renderCount.current = 0;
    renderTimes.current = [];
    slowRenders.current = [];
    setMetrics({ count: 0, avgTime: 0, lastTime: 0, slowCount: 0 });
  }, []);

  const getSlowRenders = useCallback(() => {
    return slowRenders.current;
  }, []);

  return {
    metrics,
    reset,
    getSlowRenders,
  };
}

/**
 * PerformanceMonitor - Visual performance indicator
 * Shows performance metrics in overlay
 */
function PerformanceMonitor({
  componentName,
  children,
  threshold = 16, // ms - 60fps threshold
}) {
  const { metrics, reset, getSlowRenders } = usePerformance(componentName);
  const [showDetails, setShowDetails] = useState(false);

  const status = metrics.avgTime > threshold ? 'slow' : 'fast';
  const color = status === 'slow' ? '#ef4444' : '#10b981';

  return (
    <div style={{ position: 'relative' }}>
      {/* Performance badge */}
      <div
        onClick={() => setShowDetails(!showDetails)}
        style={{
          position: 'absolute',
          top: 0,
          right: 0,
          backgroundColor: color,
          color: 'white',
          padding: '4px 8px',
          borderRadius: 4,
          fontSize: 12,
          cursor: 'pointer',
          zIndex: 1000,
          userSelect: 'none',
        }}
      >
        {metrics.lastTime.toFixed(1)}ms
      </div>

      {/* Detailed metrics panel */}
      {showDetails && (
        <div
          style={{
            position: 'absolute',
            top: 30,
            right: 0,
            backgroundColor: 'white',
            border: '1px solid #ccc',
            borderRadius: 4,
            padding: 12,
            fontSize: 12,
            zIndex: 1001,
            minWidth: 200,
            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
          }}
        >
          <h4 style={{ margin: '0 0 8px 0' }}>{componentName}</h4>

          <div style={{ marginBottom: 8 }}>
            <strong>Renders:</strong> {metrics.count}
          </div>

          <div style={{ marginBottom: 8 }}>
            <strong>Avg time:</strong> {metrics.avgTime.toFixed(2)}ms
          </div>

          <div style={{ marginBottom: 8 }}>
            <strong>Last render:</strong> {metrics.lastTime.toFixed(2)}ms
          </div>

          <div style={{ marginBottom: 8 }}>
            <strong>Slow renders:</strong> {metrics.slowCount}
          </div>

          {metrics.slowCount > 0 && (
            <div
              style={{
                marginTop: 8,
                padding: 8,
                backgroundColor: '#fef2f2',
                borderRadius: 4,
              }}
            >
              <strong>‚ö†Ô∏è Optimization needed!</strong>
              <div style={{ marginTop: 4, fontSize: 11 }}>
                {getSlowRenders()
                  .slice(-3)
                  .map((render, i) => (
                    <div key={i}>
                      Render #{render.count}: {render.time.toFixed(2)}ms
                    </div>
                  ))}
              </div>
            </div>
          )}

          <button
            onClick={reset}
            style={{
              marginTop: 8,
              width: '100%',
              padding: '4px 8px',
              fontSize: 12,
              cursor: 'pointer',
            }}
          >
            Reset Metrics
          </button>
        </div>
      )}

      {children}
    </div>
  );
}

// Example usage:
function DemoApp() {
  const [count, setCount] = useState(0);
  const [items, setItems] = useState(Array.from({ length: 1000 }, (_, i) => i));

  return (
    <div>
      <h2>Performance Monitor Demo</h2>

      {/* Fast component */}
      <PerformanceMonitor componentName='FastComponent'>
        <FastComponent count={count} />
      </PerformanceMonitor>

      {/* Slow component */}
      <PerformanceMonitor
        componentName='SlowComponent'
        threshold={10}
      >
        <SlowComponent items={items} />
      </PerformanceMonitor>

      <button onClick={() => setCount((c) => c + 1)}>Increment Count</button>

      <button onClick={() => setItems((items) => [...items, items.length])}>
        Add Item
      </button>
    </div>
  );
}

function FastComponent({ count }) {
  return <div>Fast component: {count}</div>;
}

function SlowComponent({ items }) {
  // Intentionally slow
  const startTime = performance.now();
  while (performance.now() - startTime < 20) {
    // Busy wait
  }

  return (
    <div>
      <p>Slow component with {items.length} items</p>
      {items.slice(0, 10).map((i) => (
        <div key={i}>Item {i}</div>
      ))}
    </div>
  );
}

/**
 * Key features:
 * 1. Visual badge showing last render time
 * 2. Color-coded (green = fast, red = slow)
 * 3. Click to show detailed metrics
 * 4. Tracks slow renders with warnings
 * 5. Reset functionality
 * 6. Configurable threshold
 *
 * Usage tips:
 * - Wrap components you want to monitor
 * - Check for red badges (slow renders)
 * - Click badge to see detailed metrics
 * - Use in development only (add process.env.NODE_ENV check)
 */
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Level 5: Performance Dashboard (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Build comprehensive performance monitoring dashboard
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 * Build a developer tool ƒë·ªÉ monitor to√†n b·ªô app performance
 * - Real-time render metrics
 * - Component hierarchy visualization
 * - Slow render alerts
 * - Export metrics
 *
 * üèóÔ∏è Technical Design Doc:
 * 1. Component Architecture
 *    - PerformanceProvider (context)
 *    - usePerformanceMonitor hook
 *    - PerformanceDashboard UI
 *    - MetricsChart visualization
 *
 * 2. State Management Strategy
 *    - Context cho global metrics
 *    - Local state cho UI controls
 *
 * 3. Performance Considerations
 *    - Minimal overhead (<1ms)
 *    - Debounced updates
 *    - Memory limits (max 1000 data points)
 *
 * 4. Error Handling Strategy
 *    - Graceful degradation n·∫øu kh√¥ng support
 *    - Try-catch cho measurement APIs
 *
 * ‚úÖ Production Checklist:
 * - [ ] DEV-only (check NODE_ENV)
 * - [ ] No production bundle impact
 * - [ ] Keyboard shortcut (Cmd/Ctrl + Shift + P)
 * - [ ] Draggable window
 * - [ ] Local storage persistence
 * - [ ] Export CSV functionality
 * - [ ] Clear metrics function
 */

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
// Implement full performance monitoring solution
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Production-ready Performance Dashboard
 * Comprehensive monitoring tool cho React apps
 */

// Context for global performance tracking
const PerformanceContext = React.createContext(null);

/**
 * PerformanceProvider - Wrap app ƒë·ªÉ track metrics
 */
function PerformanceProvider({ children }) {
  const [components, setComponents] = useState(new Map());
  const [showDashboard, setShowDashboard] = useState(false);

  // Keyboard shortcut: Cmd/Ctrl + Shift + P
  useEffect(() => {
    const handleKeyPress = (e) => {
      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'P') {
        e.preventDefault();
        setShowDashboard((prev) => !prev);
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, []);

  const registerComponent = useCallback((name, metrics) => {
    setComponents((prev) => {
      const newMap = new Map(prev);
      newMap.set(name, {
        ...metrics,
        timestamp: Date.now(),
      });
      return newMap;
    });
  }, []);

  const clearMetrics = useCallback(() => {
    setComponents(new Map());
  }, []);

  const exportMetrics = useCallback(() => {
    const data = Array.from(components.entries()).map(([name, metrics]) => ({
      component: name,
      ...metrics,
    }));

    const csv = [
      'Component,Renders,AvgTime,LastTime,SlowRenders',
      ...data.map(
        (d) =>
          `${d.component},${d.count},${d.avgTime.toFixed(2)},${d.lastTime.toFixed(2)},${d.slowCount}`,
      ),
    ].join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `performance-${Date.now()}.csv`;
    a.click();
  }, [components]);

  const value = {
    components,
    registerComponent,
    clearMetrics,
    exportMetrics,
  };

  return (
    <PerformanceContext.Provider value={value}>
      {children}
      {showDashboard && (
        <PerformanceDashboard onClose={() => setShowDashboard(false)} />
      )}
    </PerformanceContext.Provider>
  );
}

/**
 * useComponentPerformance - Hook ƒë·ªÉ track individual component
 */
function useComponentPerformance(componentName) {
  const context = React.useContext(PerformanceContext);
  const renderCount = useRef(0);
  const renderTimes = useRef([]);
  const slowRenders = useRef(0);

  useEffect(() => {
    const startTime = performance.now();

    return () => {
      const renderTime = performance.now() - startTime;
      renderCount.current += 1;
      renderTimes.current.push(renderTime);

      // Keep last 100
      if (renderTimes.current.length > 100) {
        renderTimes.current.shift();
      }

      if (renderTime > 16) {
        slowRenders.current += 1;
      }

      const avgTime =
        renderTimes.current.reduce((a, b) => a + b, 0) /
        renderTimes.current.length;

      context?.registerComponent(componentName, {
        count: renderCount.current,
        avgTime,
        lastTime: renderTime,
        slowCount: slowRenders.current,
      });
    };
  });
}

/**
 * PerformanceDashboard - Main dashboard UI
 */
function PerformanceDashboard({ onClose }) {
  const { components, clearMetrics, exportMetrics } =
    React.useContext(PerformanceContext);
  const [position, setPosition] = useState({ x: 20, y: 20 });
  const [isDragging, setIsDragging] = useState(false);
  const dragStart = useRef({ x: 0, y: 0 });

  const componentsArray = Array.from(components.entries())
    .map(([name, metrics]) => ({ name, ...metrics }))
    .sort((a, b) => b.avgTime - a.avgTime);

  const totalRenders = componentsArray.reduce((sum, c) => sum + c.count, 0);
  const slowComponents = componentsArray.filter((c) => c.avgTime > 16).length;

  // Dragging logic
  const handleMouseDown = (e) => {
    if (e.target.closest('.dashboard-header')) {
      setIsDragging(true);
      dragStart.current = {
        x: e.clientX - position.x,
        y: e.clientY - position.y,
      };
    }
  };

  useEffect(() => {
    if (!isDragging) return;

    const handleMouseMove = (e) => {
      setPosition({
        x: e.clientX - dragStart.current.x,
        y: e.clientY - dragStart.current.y,
      });
    };

    const handleMouseUp = () => setIsDragging(false);

    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);

    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging]);

  return (
    <div
      style={{
        position: 'fixed',
        left: position.x,
        top: position.y,
        width: 600,
        maxHeight: '80vh',
        backgroundColor: 'white',
        border: '1px solid #ccc',
        borderRadius: 8,
        boxShadow: '0 4px 20px rgba(0,0,0,0.2)',
        zIndex: 10000,
        overflow: 'hidden',
        fontFamily: 'monospace',
        fontSize: 12,
        cursor: isDragging ? 'grabbing' : 'default',
      }}
      onMouseDown={handleMouseDown}
    >
      {/* Header */}
      <div
        className='dashboard-header'
        style={{
          padding: 12,
          backgroundColor: '#3b82f6',
          color: 'white',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          cursor: 'grab',
        }}
      >
        <h3 style={{ margin: 0 }}>‚ö° Performance Dashboard</h3>
        <button
          onClick={onClose}
          style={{
            background: 'none',
            border: 'none',
            color: 'white',
            cursor: 'pointer',
            fontSize: 18,
          }}
        >
          √ó
        </button>
      </div>

      {/* Summary */}
      <div style={{ padding: 12, borderBottom: '1px solid #e5e7eb' }}>
        <div
          style={{
            display: 'grid',
            gridTemplateColumns: '1fr 1fr 1fr',
            gap: 12,
          }}
        >
          <div>
            <div style={{ color: '#6b7280' }}>Components</div>
            <div style={{ fontSize: 20, fontWeight: 'bold' }}>
              {components.size}
            </div>
          </div>
          <div>
            <div style={{ color: '#6b7280' }}>Total Renders</div>
            <div style={{ fontSize: 20, fontWeight: 'bold' }}>
              {totalRenders}
            </div>
          </div>
          <div>
            <div style={{ color: '#6b7280' }}>Slow Components</div>
            <div
              style={{
                fontSize: 20,
                fontWeight: 'bold',
                color: slowComponents > 0 ? '#ef4444' : '#10b981',
              }}
            >
              {slowComponents}
            </div>
          </div>
        </div>
      </div>

      {/* Actions */}
      <div
        style={{
          padding: 12,
          borderBottom: '1px solid #e5e7eb',
          display: 'flex',
          gap: 8,
        }}
      >
        <button
          onClick={clearMetrics}
          style={{ flex: 1, padding: 6 }}
        >
          Clear Metrics
        </button>
        <button
          onClick={exportMetrics}
          style={{ flex: 1, padding: 6 }}
        >
          Export CSV
        </button>
      </div>

      {/* Component list */}
      <div
        style={{
          maxHeight: 400,
          overflowY: 'auto',
          padding: 12,
        }}
      >
        {componentsArray.length === 0 ? (
          <div style={{ textAlign: 'center', padding: 20, color: '#6b7280' }}>
            No components tracked yet
          </div>
        ) : (
          componentsArray.map(
            ({ name, count, avgTime, lastTime, slowCount }) => (
              <div
                key={name}
                style={{
                  padding: 8,
                  marginBottom: 8,
                  backgroundColor: avgTime > 16 ? '#fef2f2' : '#f9fafb',
                  borderLeft: `3px solid ${avgTime > 16 ? '#ef4444' : '#10b981'}`,
                  borderRadius: 4,
                }}
              >
                <div
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    marginBottom: 4,
                  }}
                >
                  <strong>{name}</strong>
                  <span
                    style={{
                      color: avgTime > 16 ? '#ef4444' : '#10b981',
                      fontWeight: 'bold',
                    }}
                  >
                    {avgTime.toFixed(2)}ms avg
                  </span>
                </div>
                <div
                  style={{
                    display: 'flex',
                    gap: 16,
                    color: '#6b7280',
                    fontSize: 11,
                  }}
                >
                  <span>Renders: {count}</span>
                  <span>Last: {lastTime.toFixed(2)}ms</span>
                  {slowCount > 0 && (
                    <span style={{ color: '#ef4444' }}>Slow: {slowCount}</span>
                  )}
                </div>
              </div>
            ),
          )
        )}
      </div>

      {/* Footer */}
      <div
        style={{
          padding: 8,
          borderTop: '1px solid #e5e7eb',
          backgroundColor: '#f9fafb',
          fontSize: 10,
          color: '#6b7280',
          textAlign: 'center',
        }}
      >
        Press Cmd/Ctrl + Shift + P to toggle ‚Ä¢ Drag to move
      </div>
    </div>
  );
}

// Example: Wrap your app
function App() {
  return (
    <PerformanceProvider>
      <MyApp />
    </PerformanceProvider>
  );
}

// Example: Track a component
function MyComponent() {
  useComponentPerformance('MyComponent');

  return <div>My Component</div>;
}

/**
 * Features implemented:
 * ‚úÖ Global performance tracking via Context
 * ‚úÖ Keyboard shortcut (Cmd/Ctrl + Shift + P)
 * ‚úÖ Draggable window
 * ‚úÖ Real-time metrics
 * ‚úÖ Color-coded slow components
 * ‚úÖ Export to CSV
 * ‚úÖ Clear metrics
 * ‚úÖ Summary statistics
 * ‚úÖ Sorted by avg time
 *
 * Production considerations:
 * - Wrap with process.env.NODE_ENV === 'development' check
 * - Tree-shake in production build
 * - Add memory limits (max components tracked)
 * - Debounce updates for better performance
 */
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh: React 17 vs React 18

| Feature       | React 17                  | React 18                    | Impact                       |
| ------------- | ------------------------- | --------------------------- | ---------------------------- |
| **Batching**  | Ch·ªâ trong event handlers  | M·ªçi n∆°i (automatic)         | ‚¨ÜÔ∏è Performance               |
| **Rendering** | Synchronous               | Concurrent (opt-in)         | ‚¨ÜÔ∏è Responsiveness            |
| **APIs**      | Legacy                    | Modern (useTransition, etc) | ‚¨ÜÔ∏è Developer Experience      |
| **SSR**       | Client hydration blocking | Streaming SSR               | ‚¨ÜÔ∏è TTI (Time to Interactive) |
| **Suspense**  | Limited                   | Full support                | ‚¨ÜÔ∏è Loading UX                |

### Trade-offs Matrix

| Approach     | Pros                                                                                            | Cons                                                                         | When to Use                                                |
| ------------ | ----------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | ---------------------------------------------------------- |
| **React 17** | ‚úÖ Stable<br>‚úÖ Well-tested<br>‚úÖ Simple model                                                  | ‚ùå No automatic batching<br>‚ùå Blocking renders<br>‚ùå No concurrent features | Legacy apps<br>Simple UIs<br>Low interactivity             |
| **React 18** | ‚úÖ Better performance<br>‚úÖ Concurrent rendering<br>‚úÖ Automatic batching<br>‚úÖ Modern features | ‚ùå Learning curve<br>‚ùå Migration effort<br>‚ùå Some breaking changes         | New projects<br>High interactivity<br>Performance-critical |

### Decision Tree: Upgrade to React 18?

```
START: Should I upgrade to React 18?
‚îÇ
‚îú‚îÄ App c·∫ßn Concurrent features? (useTransition, Suspense)
‚îÇ  ‚îú‚îÄ YES ‚Üí ‚úÖ Upgrade
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue
‚îÇ
‚îú‚îÄ Performance issues v·ªõi frequent state updates?
‚îÇ  ‚îú‚îÄ YES ‚Üí ‚úÖ Upgrade (automatic batching helps)
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue
‚îÇ
‚îú‚îÄ Using Suspense for data fetching?
‚îÇ  ‚îú‚îÄ YES ‚Üí ‚úÖ Upgrade (better support)
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue
‚îÇ
‚îú‚îÄ App is stable, no issues?
‚îÇ  ‚îú‚îÄ YES ‚Üí ‚ö†Ô∏è Optional (low risk, minor benefits)
‚îÇ  ‚îî‚îÄ NO ‚Üí Continue
‚îÇ
‚îî‚îÄ Legacy codebase, high risk?
   ‚îî‚îÄ NO ‚Üí ‚ö†Ô∏è Test thoroughly before upgrade
```

### Batching Comparison

```jsx
// SCENARIO: Multiple state updates trong async callback

// ‚ùå React 17
setTimeout(() => {
  setA(1); // Render 1
  setB(2); // Render 2
  setC(3); // Render 3
}, 100);
// Total: 3 renders ‚Üí Performance issue!

// ‚úÖ React 18
setTimeout(() => {
  setA(1);
  setB(2);
  setC(3);
}, 100);
// Total: 1 render ‚Üí Optimized! ‚ú®

// WHEN TO OPT-OUT (rare cases):
import { flushSync } from 'react-dom';

setTimeout(() => {
  flushSync(() => setA(1)); // Render immediately
  flushSync(() => setB(2)); // Render immediately
  setC(3); // Batched with next update
}, 100);
// Use case: Need immediate DOM update for measurements
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Expecting Automatic Performance Improvements

```jsx
/**
 * ‚ùå BUG: Upgraded to React 18 nh∆∞ng v·∫´n ch·∫≠m
 *
 * Symptom: UI v·∫´n lag khi typing, kh√¥ng c√≥ improvement
 * Root cause: Concurrent features are OPT-IN, kh√¥ng t·ª± ƒë·ªông
 */
function SlowSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const handleSearch = (e) => {
    const value = e.target.value;
    setQuery(value);

    // ‚ùå Heavy sync operation v·∫´n block UI
    const filtered = heavyFilter(allData, value);
    setResults(filtered);
  };

  return (
    <input
      value={query}
      onChange={handleSearch}
    />
  );
}

// ‚ùì C√ÇU H·ªéI:
// 1. T·∫°i sao React 18 kh√¥ng t·ª± ƒë·ªông l√†m nhanh h∆°n?
// 2. Solution l√† g√¨?
// 3. Khi n√†o d√πng useTransition? (s·∫Ω h·ªçc ng√†y sau)
```

**üí° Gi·∫£i th√≠ch:**

1. **T·∫°i sao kh√¥ng t·ª± ƒë·ªông nhanh h∆°n?**
   - Concurrent rendering l√† OPT-IN
   - C·∫ßn d√πng `useTransition` ho·∫∑c `useDeferredValue`
   - Heavy computation v·∫´n c·∫ßn optimize (memoization, code splitting)

2. **Solutions:**

   ```jsx
   // Solution 1: useMemo ƒë·ªÉ tr√°nh re-compute
   const filtered = useMemo(() => heavyFilter(allData, query), [query]);

   // Solution 2: useTransition (s·∫Ω h·ªçc Ng√†y 47)
   // const [isPending, startTransition] = useTransition();
   // startTransition(() => setResults(filtered));

   // Solution 3: Web Worker (advanced)
   // Offload to background thread
   ```

3. **Khi n√†o d√πng useTransition:**
   - Update kh√¥ng urgent (search results, filtering)
   - User c·∫ßn feedback ngay (input field)
   - Heavy computation c√≥ th·ªÉ defer

### Bug 2: Infinite Renders sau Upgrade

```jsx
/**
 * ‚ùå BUG: Component re-render v√¥ h·∫°n sau upgrade React 18
 *
 * Symptom: Browser freeze, console ƒë·∫ßy "Render"
 * Root cause: useEffect dependency issue amplified b·ªüi automatic batching
 */
function BuggyComponent() {
  const [data, setData] = useState([]);
  const [filter, setFilter] = useState('all');

  console.log('Render');

  useEffect(() => {
    // ‚ùå Creates new array reference every time
    const filtered = data.filter(
      (item) => filter === 'all' || item.type === filter,
    );
    setData(filtered); // This triggers re-render!
  }, [data, filter]); // data changes ‚Üí effect runs ‚Üí setData ‚Üí data changes...

  return <div>{data.length} items</div>;
}

// ‚ùì C√ÇU H·ªéI:
// 1. T·∫°i sao infinite loop x·∫£y ra?
// 2. React 17 c√≥ bug n√†y kh√¥ng? T·∫°i sao React 18 amplify?
// 3. Fix nh∆∞ th·∫ø n√†o?
```

**üí° Gi·∫£i th√≠ch:**

1. **T·∫°i sao infinite loop:**
   - `useEffect` depends on `data`
   - Effect runs ‚Üí `setData(filtered)` ‚Üí `data` changes
   - `data` changes ‚Üí effect runs again ‚Üí infinite loop!

2. **React 17 vs 18:**
   - React 17: Bug v·∫´n c√≥ nh∆∞ng c√≥ th·ªÉ √≠t obvious h∆°n
   - React 18: Automatic batching l√†m loop nhanh h∆°n ‚Üí d·ªÖ ph√°t hi·ªán

3. **Fix:**

   ```jsx
   // ‚úÖ Fix 1: Remove data t·ª´ dependencies
   useEffect(() => {
     setData((prev) =>
       prev.filter((item) => filter === 'all' || item.type === filter),
     );
   }, [filter]); // Ch·ªâ depend on filter

   // ‚úÖ Fix 2: useMemo thay v√¨ useEffect
   const filteredData = useMemo(
     () =>
       originalData.filter((item) => filter === 'all' || item.type === filter),
     [filter],
   );

   // ‚úÖ Fix 3: Separate filtered state
   const [rawData, setRawData] = useState([]);
   const [filteredData, setFilteredData] = useState([]);

   useEffect(() => {
     setFilteredData(
       rawData.filter((item) => filter === 'all' || item.type === filter),
     );
   }, [rawData, filter]); // Safe - rawData kh√¥ng update trong effect
   ```

### Bug 3: flushSync Misuse

```jsx
/**
 * ‚ùå BUG: Overusing flushSync causing performance regression
 *
 * Symptom: React 18 ch·∫≠m h∆°n React 17!
 * Root cause: Opt-out kh·ªèi batching unnecessarily
 */
import { flushSync } from 'react-dom';

function OverFlushSync() {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);

  const handleLoad = async () => {
    // ‚ùå Unnecessary flushSync
    flushSync(() => {
      setLoading(true);
    });

    const data = await fetchData();

    // ‚ùå Another unnecessary flushSync
    flushSync(() => {
      setItems(data);
    });

    // ‚ùå And another!
    flushSync(() => {
      setLoading(false);
    });
  };

  return (
    <button onClick={handleLoad}>{loading ? 'Loading...' : 'Load Data'}</button>
  );
}

// ‚ùì C√ÇU H·ªéI:
// 1. T·∫°i sao code n√†y slow?
// 2. Khi n√†o N√äN d√πng flushSync?
// 3. Fix nh∆∞ th·∫ø n√†o?
```

**üí° Gi·∫£i th√≠ch:**

1. **T·∫°i sao slow:**
   - `flushSync` force synchronous render
   - M·ªói `flushSync` call = 1 render ngay l·∫≠p t·ª©c
   - Total: 3 synchronous renders thay v√¨ 1 batched render
   - M·∫•t ƒëi benefit c·ªßa automatic batching!

2. **Khi N√äN d√πng flushSync:**

   ```jsx
   // ‚úÖ Use case 1: C·∫ßn DOM measurement ngay
   flushSync(() => {
     setHeight(100);
   });
   const actualHeight = ref.current.offsetHeight; // Accurate!

   // ‚úÖ Use case 2: Third-party lib c·∫ßn sync DOM
   flushSync(() => {
     setOpen(true);
   });
   thirdPartyLib.focus(ref.current); // DOM ƒë√£ update!

   // ‚úÖ Use case 3: Scroll position restore
   flushSync(() => {
     setItems(newItems);
   });
   scrollToPosition(savedPosition);
   ```

3. **Fix:**

   ```jsx
   // ‚úÖ Let React batch automatically
   const handleLoad = async () => {
     setLoading(true);
     const data = await fetchData();

     // React 18 t·ª± ƒë·ªông batch c·∫£ 2 updates n√†y!
     setItems(data);
     setLoading(false);
     // Total: 1 render ‚ú®
   };

   // Ho·∫∑c n·∫øu mu·ªën explicit:
   const handleLoad = async () => {
     setLoading(true);
     const data = await fetchData();

     // Batched update
     React.startTransition(() => {
       setItems(data);
       setLoading(false);
     });
   };
   ```

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

- [ ] T√¥i hi·ªÉu s·ª± kh√°c bi·ªát gi·ªØa Synchronous v√† Concurrent rendering
- [ ] T√¥i bi·∫øt Automatic Batching ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o trong React 18
- [ ] T√¥i c√≥ th·ªÉ d√πng Profiler component ƒë·ªÉ measure performance
- [ ] T√¥i hi·ªÉu khi n√†o n√™n upgrade l√™n React 18
- [ ] T√¥i bi·∫øt khi n√†o d√πng `flushSync` v√† khi n√†o KH√îNG n√™n d√πng
- [ ] T√¥i c√≥ th·ªÉ identify performance bottlenecks b·∫±ng React DevTools
- [ ] T√¥i hi·ªÉu Concurrent features l√† opt-in, kh√¥ng automatic

### Code Review Checklist

**React 18 Migration:**

- [ ] ƒê√£ test automatic batching trong async callbacks
- [ ] Verify kh√¥ng c√≥ breaking changes trong codebase
- [ ] useEffect dependencies v·∫´n correct sau upgrade
- [ ] Performance kh√¥ng regression (measure before/after)

**Performance Monitoring:**

- [ ] Profiler component ƒë∆∞·ª£c d√πng ƒë√∫ng c√°ch
- [ ] Metrics tracking kh√¥ng ·∫£nh h∆∞·ªüng production
- [ ] React DevTools ƒë∆∞·ª£c d√πng ƒë·ªÉ identify bottlenecks
- [ ] Slow renders ƒë∆∞·ª£c document v√† track

**Best Practices:**

- [ ] Kh√¥ng overuse `flushSync`
- [ ] useMemo/useCallback ƒë∆∞·ª£c d√πng khi c·∫ßn
- [ ] Component kh√¥ng re-render unnecessarily
- [ ] Performance monitoring ch·ªâ trong development

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**1. Batching Verification Lab:**

- T·∫°o component test automatic batching
- So s√°nh behavior trong different contexts:
  - Event handlers
  - setTimeout
  - Promises
  - fetch callbacks
- Document findings v·ªõi screenshots

**2. Profiler Integration:**

- Add Profiler component v√†o 1 existing project
- Identify top 3 slowest components
- Document render times v√† potential optimizations

### N√¢ng cao (60 ph√∫t)

**1. Migration Guide:**

- Document step-by-step guide ƒë·ªÉ upgrade project t·ª´ React 17 ‚Üí 18
- Include:
  - Breaking changes checklist
  - Testing strategy
  - Rollback plan
  - Performance comparison

**2. Performance Audit:**

- Ch·ªçn 1 component trong project
- Measure v·ªõi React DevTools Profiler
- Identify performance issues
- Implement optimizations
- Document before/after metrics

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React 18 Release Notes**
   - https://react.dev/blog/2022/03/29/react-v18
   - Focus: Automatic Batching, Concurrent Features

2. **New in React 18**
   - https://react.dev/blog/2022/03/08/react-18-upgrade-guide
   - Migration guide v√† breaking changes

### ƒê·ªçc th√™m

1. **Concurrent Rendering Deep Dive**
   - https://github.com/reactwg/react-18/discussions

2. **Performance Profiling Guide**
   - https://react.dev/learn/react-developer-tools

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (c·∫ßn bi·∫øt)

- **Ng√†y 11-14:** useState v√† state updates
- **Ng√†y 16-20:** useEffect v√† side effects
- **Ng√†y 31-34:** Performance optimization (memo, useMemo, useCallback)
- **Profiler API:** ƒê√£ bi·∫øt t·ª´ demo tr∆∞·ªõc

### H∆∞·ªõng t·ªõi (s·∫Ω d√πng)

- **Ng√†y 47:** useTransition - Non-urgent updates
- **Ng√†y 48:** useDeferredValue - Deferred values
- **Ng√†y 49:** Suspense for Data Fetching
- **Ng√†y 50:** Error Boundaries
- **Ng√†y 51:** React Server Components

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**1. Migration Strategy:**

```
PHASED APPROACH:
Week 1: Upgrade dependencies, test builds
Week 2: Test critical paths, fix breaking changes
Week 3: Performance monitoring
Week 4: Gradual rollout (10% ‚Üí 50% ‚Üí 100% users)
```

**2. Monitoring:**

- Track render times before/after upgrade
- Watch for performance regressions
- Monitor error rates
- Set up alerts cho slow renders

**3. Rollback Plan:**

- Keep React 17 build ready
- Feature flags ƒë·ªÉ toggle concurrent features
- Incremental adoption strategy

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior Level:**

- Q: React 18 c√≥ g√¨ m·ªõi so v·ªõi React 17?
- A: Automatic batching everywhere, concurrent rendering opt-in, new APIs (useTransition, useDeferredValue), Suspense improvements

**Mid Level:**

- Q: Gi·∫£i th√≠ch Automatic Batching v√† t·∫°i sao n√≥ improve performance?
- A: React 18 batches multiple state updates th√†nh 1 render, ngay c·∫£ trong async callbacks (setTimeout, promises). √çt renders h∆°n = better performance. React 17 ch·ªâ batch trong event handlers.

**Senior Level:**

- Q: Khi n√†o n√™n migrate l√™n React 18? Trade-offs l√† g√¨?
- A:
  - Migrate khi: C·∫ßn concurrent features, performance issues v·ªõi frequent updates, modern SSR
  - Trade-offs: Learning curve, migration effort, potential breaking changes
  - Strategy: Test thoroughly, gradual rollout, monitor metrics, rollback plan ready

**Architect Level:**

- Q: Design strategy ƒë·ªÉ migrate large legacy app l√™n React 18 without downtime
- A:
  1. Audit codebase (breaking changes, third-party deps)
  2. Phased migration (dev ‚Üí staging ‚Üí prod)
  3. Feature flags ƒë·ªÉ toggle concurrent features
  4. Comprehensive testing (unit, integration, E2E, perf)
  5. Monitoring setup (render times, error rates)
  6. Gradual rollout (percentage-based)
  7. Rollback plan (React 17 build ready)
  8. Post-migration optimization (adopt new patterns)

### War Stories

**Story 1: "Automatic Batching Surprise"**

```
Scenario: Upgraded to React 18, performance ƒë·ªôt nhi√™n WORSE!

Root cause: Code rely on synchronous renders ƒë·ªÉ trigger effects
useEffect(() => {
  // Expects setA to trigger render before setB
}, [a]);

setA(1);  // React 17: Render now
setB(2);  // React 17: Render now

setA(1);  // React 18: Batched
setB(2);  // React 18: Batched ‚Üí 1 render ‚Üí effect timing changed!

Fix: Review useEffect dependencies, use flushSync n·∫øu c·∫ßn sync behavior
```

**Story 2: "The flushSync Trap"**

```
Scenario: Developer ƒë·ªçc v·ªÅ flushSync, nghƒ© n√≥ "optimize" performance

Reality: Wrapped m·ªçi setState trong flushSync
‚Üí Opt-out kh·ªèi batching completely
‚Üí React 18 ch·∫≠m h∆°n React 17!

Lesson: flushSync l√† escape hatch cho edge cases, kh√¥ng ph·∫£i default
```

**Story 3: "Profiler in Production"**

```
Mistake: Ship Profiler component to production

Impact:
- Bundle size increase
- Runtime overhead (callbacks firing constantly)
- Memory leaks (storing metrics)

Fix:
if (process.env.NODE_ENV === 'development') {
  return <Profiler onRender={callback}>{children}</Profiler>;
}
return children;
```

---

## üéØ PREVIEW NG√ÄY MAI

**Ng√†y 47: useTransition - Non-urgent Updates**

Tomorrow s·∫Ω h·ªçc:

- useTransition hook ƒë·ªÉ mark non-urgent updates
- isPending state ƒë·ªÉ show feedback
- Pattern: Keep UI responsive during heavy updates
- Use case: Search, filtering, sorting large datasets

Prepare:

- Review concurrent rendering concepts h√¥m nay
- Nghƒ© v·ªÅ scenarios trong app c·ªßa b·∫°n c·∫ßn "urgent vs non-urgent" updates
- C√†i ƒë·∫∑t React DevTools m·ªõi nh·∫•t

See you tomorrow! üöÄ
