# ğŸ“… NGÃ€Y 51: React Server Components (RSC) - Overview

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] Hiá»ƒu React Server Components concept á»Ÿ high-level
- [ ] PhÃ¢n biá»‡t Server Components vs Client Components
- [ ] Náº¯m Ä‘Æ°á»£c benefits vÃ  trade-offs cá»§a RSC
- [ ] Biáº¿t khi nÃ o nÃªn dÃ¹ng Server vs Client Components
- [ ] Hiá»ƒu RSC architecture vÃ  rendering flow (conceptual)
- [ ] Chuáº©n bá»‹ foundation cho Next.js module

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

1. **Suspense boundaries hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o vá»›i async data?**
2. **Error Boundaries catch errors á»Ÿ Ä‘Ã¢u trong component tree?**
3. **SSR (Server-Side Rendering) khÃ¡c CSR (Client-Side Rendering) nhÆ° tháº¿ nÃ o?**

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

**Traditional React = Má»i thá»© cháº¡y trÃªn client**

```jsx
// âŒ Traditional React - ALL code runs on client browser
function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);
  const [reviews, setReviews] = useState([]);
  const [recommendations, setRecommendations] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Client fetches everything
    Promise.all([
      fetch(`/api/products/${productId}`).then((r) => r.json()),
      fetch(`/api/reviews/${productId}`).then((r) => r.json()),
      fetch(`/api/recommendations/${productId}`).then((r) => r.json()),
    ]).then(([productData, reviewsData, recsData]) => {
      setProduct(productData);
      setReviews(reviewsData);
      setRecommendations(recsData);
      setLoading(false);
    });
  }, [productId]);

  if (loading) return <LoadingSpinner />;

  return (
    <div>
      <ProductInfo product={product} />
      <ReviewsList reviews={reviews} />
      <Recommendations items={recommendations} />
    </div>
  );
}

// Váº¥n Ä‘á»:
// 1. ğŸ“¦ Large JavaScript bundle - Cáº£ app code gá»­i Ä‘áº¿n browser
// 2. â±ï¸ Waterfall requests - Component mount â†’ fetch â†’ render
// 3. ğŸ”„ Loading states everywhere - Poor UX
// 4. ğŸ” SEO challenges - Content khÃ´ng cÃ³ trong initial HTML
// 5. ğŸ” Security risks - API keys cÃ³ thá»ƒ leak ra client
// 6. ğŸ’¾ Duplicate code - Logic validation á»Ÿ cáº£ server & client
// 7. ğŸŒ Network overhead - Multiple round trips
```

**Real-world Impact:**

```
Typical E-commerce Page Load:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Server sends empty HTML (1KB)      â”‚ â†’ 50ms
â”‚ 2. Client downloads React bundle      â”‚ â†’ 500ms
â”‚ 3. Client downloads app code          â”‚ â†’ 800ms
â”‚ 4. React hydrates                     â”‚ â†’ 200ms
â”‚ 5. useEffect runs                     â”‚ â†’ 10ms
â”‚ 6. Fetch product data                 â”‚ â†’ 300ms
â”‚ 7. Fetch reviews                      â”‚ â†’ 250ms
â”‚ 8. Fetch recommendations              â”‚ â†’ 200ms
â”‚ 9. Final render                       â”‚ â†’ 50ms
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Total: ~2.3 seconds before user sees content!

Bundle sizes:
- React: 40KB (gzipped)
- App code: 200KB (gzipped)
- Heavy libraries (charts, markdown): 100KB
â†’ Total: 340KB just for JavaScript
```

### 1.2 Giáº£i PhÃ¡p: React Server Components

**RSC = Components render trÃªn server, gá»­i káº¿t quáº£ Ä‘áº¿n client**

```jsx
// âœ… Server Component - Runs on SERVER only
// âš ï¸ CONCEPTUAL CODE - Chá»‰ cháº¡y trong Next.js App Router
async function ProductPage({ productId }) {
  // NO useState! NO useEffect! NO loading states!
  // Direct data access on server
  const product = await db.products.findById(productId);
  const reviews = await db.reviews.findMany({ productId });
  const recommendations = await getRecommendations(productId);

  return (
    <div>
      <ProductInfo product={product} />
      <ReviewsList reviews={reviews} />
      <Recommendations items={recommendations} />
    </div>
  );
}

// Benefits:
// âœ… Zero JavaScript for this component
// âœ… Direct database/API access - No intermediate API layer
// âœ… Parallel data fetching - All await at once
// âœ… No loading states - Data ready when component renders
// âœ… Perfect SEO - HTML contains full content
// âœ… Smaller bundle - No data fetching code sent to client
// âœ… Better security - Secrets stay on server
```

**Flow Comparison:**

```
âŒ TRADITIONAL REACT (Client-Side):
1. Browser requests page
2. Server sends minimal HTML + JS bundles
3. Browser downloads & parses JavaScript
4. React renders (loading state)
5. useEffect triggers API calls
6. Wait for responses
7. Re-render with data
â†’ Time to Interactive: 2-3 seconds

âœ… REACT SERVER COMPONENTS:
1. Browser requests page
2. Server runs React components
3. Server fetches all data in parallel
4. Server renders components to RSC payload
5. Server streams HTML to browser
6. Browser shows content immediately
7. Hydrate only interactive parts
â†’ Time to Interactive: 0.5-1 second
```

### 1.3 Mental Model

**RSC Architecture:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SERVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                      â”‚
â”‚  Server Components (.server.js)     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ async function BlogPost()      â”‚ â”‚
â”‚  â”‚   const post = await db.get()  â”‚ â”‚
â”‚  â”‚   return <Article {...post} /> â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚            â”‚                         â”‚
â”‚            â†“ Serialize                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  RSC Payload (JSON-like)       â”‚ â”‚
â”‚  â”‚  {                             â”‚ â”‚
â”‚  â”‚    type: 'article',            â”‚ â”‚
â”‚  â”‚    props: { title: '...' }     â”‚ â”‚
â”‚  â”‚  }                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Stream over network
               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CLIENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                      â”‚
â”‚  Client Components (.client.js)     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ 'use client'                   â”‚ â”‚
â”‚  â”‚                                â”‚ â”‚
â”‚  â”‚ function LikeButton()          â”‚ â”‚
â”‚  â”‚   const [liked, setLiked] =    â”‚ â”‚
â”‚  â”‚     useState(false)             â”‚ â”‚
â”‚  â”‚   return <button onClick=...>  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚            â”‚                         â”‚
â”‚            â†“ Interactive              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Hydrated React Tree           â”‚ â”‚
â”‚  â”‚  (Only interactive parts)      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Component Tree Example:**

```jsx
// Server Component (default)
async function BlogPage() {
  const posts = await db.posts.getAll(); // Server-only

  return (
    <div>
      <Header /> {/* Server Component */}
      <Sidebar posts={posts} /> {/* Server Component */}
      {posts.map((post) => (
        // Client Component - needs interactivity
        <LikeButton
          key={post.id}
          postId={post.id}
        />
      ))}
    </div>
  );
}

// Client Component - has 'use client' directive
('use client');
function LikeButton({ postId }) {
  const [liked, setLiked] = useState(false);

  return (
    <button onClick={() => setLiked(!liked)}>{liked ? 'â¤ï¸' : 'ğŸ¤'}</button>
  );
}
```

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

**âŒ Hiá»ƒu láº§m 1: "RSC = Server-Side Rendering (SSR)"**

```jsx
// SSR (Old approach - Next.js Pages Router):
export async function getServerSideProps() {
  const data = await fetch('...');
  return { props: { data } };
}

function Page({ data }) {
  // Component still runs on client
  // Full React bundle sent to browser
  return <div>{data.title}</div>;
}

// RSC (New approach - Next.js App Router):
async function Page() {
  const data = await fetch('...');

  // Component ONLY runs on server
  // NO JavaScript sent to client for this component
  return <div>{data.title}</div>;
}

// Differences:
// SSR: Component code sent to client + hydrated
// RSC: Component code NEVER sent to client
```

**Comparison:**

| Feature             | SSR                                | RSC                            |
| ------------------- | ---------------------------------- | ------------------------------ |
| Where code runs     | Server + Client                    | Server only                    |
| JavaScript sent     | Full component code                | Zero (for server components)   |
| Can use useState    | âœ… Yes                             | âŒ No                          |
| Can use useEffect   | âœ… Yes                             | âŒ No                          |
| Can access database | âŒ No (only in getServerSideProps) | âœ… Yes (directly)              |
| Bundle size impact  | Large (all code)                   | Small (only client components) |

**âŒ Hiá»ƒu láº§m 2: "Má»i component pháº£i lÃ  Server Component"**

```jsx
// âŒ WRONG: Cannot use hooks in Server Component
async function ProductPage() {
  const [count, setCount] = useState(0); // âŒ Error!

  return <button onClick={() => setCount((c) => c + 1)}>Count</button>;
}

// âœ… RIGHT: Use Client Component cho interactivity
('use client');
function Counter() {
  const [count, setCount] = useState(0);

  return <button onClick={() => setCount((c) => c + 1)}>Count: {count}</button>;
}

// Server Component can render Client Component
async function ProductPage() {
  const product = await db.products.get();

  return (
    <div>
      <h1>{product.name}</h1>
      <Counter /> {/* Client Component inside Server Component */}
    </div>
  );
}
```

**âŒ Hiá»ƒu láº§m 3: "Client Components khÃ´ng thá»ƒ nháº­n Server Component props"**

```jsx
// âŒ WRONG: Cannot pass Server Component as children
'use client';
function ClientWrapper({ children }) {
  const [show, setShow] = useState(true);

  return show ? children : null;
}

async function Page() {
  const data = await db.get();

  return (
    <ClientWrapper>
      {/* âŒ Server Component as children won't work */}
      <ServerComponent data={data} />
    </ClientWrapper>
  );
}

// âœ… RIGHT: Pass data as props, not components
('use client');
function ClientWrapper({ data, children }) {
  const [show, setShow] = useState(true);

  return show ? <div>{data.title}</div> : null;
}

async function Page() {
  const data = await db.get();

  return <ClientWrapper data={data} />;
}
```

---

## ğŸ’» PHáº¦N 2: CONCEPTUAL EXAMPLES (45 phÃºt)

### Demo 1: Server vs Client Components â­

```jsx
/**
 * Demo: Understanding Server vs Client Components
 *
 * âš ï¸ CONCEPTUAL CODE - KhÃ´ng cháº¡y Ä‘Æ°á»£c trong React thuáº§n
 * Chá»‰ cháº¡y trong Next.js 13+ App Router
 *
 * Má»¥c Ä‘Ã­ch: Hiá»ƒu difference vÃ  khi nÃ o dÃ¹ng cÃ¡i nÃ o
 */

// ============= SERVER COMPONENT (Default) =============
// File: app/blog/page.js
// NO 'use client' directive = Server Component

async function BlogPage() {
  // âœ… CAN: Direct database access
  const posts = await prisma.post.findMany({
    include: { author: true, comments: true },
  });

  // âœ… CAN: Use server-only libraries
  const fs = require('fs');
  const markdown = require('marked');

  // âœ… CAN: Access environment variables safely
  const apiKey = process.env.SECRET_API_KEY;

  // âœ… CAN: Complex data transformations (zero cost to client)
  const processedPosts = posts.map((post) => ({
    ...post,
    content: markdown.parse(post.content),
    readingTime: calculateReadingTime(post.content),
  }));

  // âŒ CANNOT: Use hooks
  // const [count, setCount] = useState(0); // Error!

  // âŒ CANNOT: Use browser APIs
  // window.localStorage.getItem('key'); // Error!

  // âŒ CANNOT: Add event handlers
  // <button onClick={...}> // Error!

  return (
    <div>
      <h1>Blog Posts</h1>
      {processedPosts.map((post) => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>By {post.author.name}</p>
          <div dangerouslySetInnerHTML={{ __html: post.content }} />

          {/* Client Component for interactivity */}
          <LikeButton
            postId={post.id}
            initialLikes={post.likes}
          />
        </article>
      ))}
    </div>
  );
}

// ============= CLIENT COMPONENT =============
// File: app/components/LikeButton.js
('use client'); // â† This directive makes it a Client Component

import { useState } from 'react';

function LikeButton({ postId, initialLikes }) {
  // âœ… CAN: Use all React hooks
  const [likes, setLikes] = useState(initialLikes);
  const [isLiked, setIsLiked] = useState(false);

  // âœ… CAN: Use browser APIs
  const handleLike = () => {
    setIsLiked(!isLiked);
    setLikes(isLiked ? likes - 1 : likes + 1);

    // Save to localStorage
    localStorage.setItem(`liked-${postId}`, !isLiked);

    // Call API
    fetch(`/api/posts/${postId}/like`, { method: 'POST' });
  };

  // âœ… CAN: Use event handlers
  return (
    <button
      onClick={handleLike}
      className={isLiked ? 'liked' : ''}
    >
      {isLiked ? 'â¤ï¸' : 'ğŸ¤'} {likes}
    </button>
  );
}

// ============= DECISION MATRIX =============

/*
USE SERVER COMPONENT when:
âœ… Fetching data
âœ… Accessing backend resources (database, filesystem)
âœ… Keeping sensitive information on server (API keys)
âœ… Reducing client bundle size
âœ… Heavy computations (markdown parsing, image processing)

USE CLIENT COMPONENT when:
âœ… Need interactivity (onClick, onChange)
âœ… Use React hooks (useState, useEffect, useContext)
âœ… Use browser-only APIs (localStorage, window)
âœ… Use React features (Error Boundaries with hooks - future)
âœ… Need lifecycle methods
*/

// Káº¿t quáº£:
// - Server Component: Cháº¡y server, zero JS to client
// - Client Component: Cháº¡y client, full JS sent
// - Mix and match based on needs
```

### Demo 2: Data Fetching Patterns â­â­

```jsx
/**
 * Demo: Data Fetching - Traditional vs RSC
 *
 * So sÃ¡nh cÃ¡ch fetch data
 */

// ============= TRADITIONAL REACT (Client-Side) =============

function TraditionalProductPage({ productId }) {
  const [product, setProduct] = useState(null);
  const [reviews, setReviews] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Waterfall: One after another
    async function fetchData() {
      try {
        setLoading(true);

        // Request 1
        const productRes = await fetch(`/api/products/${productId}`);
        const productData = await productRes.json();
        setProduct(productData);

        // Request 2 (depends on product)
        const reviewsRes = await fetch(`/api/reviews/${productId}`);
        const reviewsData = await reviewsRes.json();
        setReviews(reviewsData);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, [productId]);

  if (loading) return <Spinner />;
  if (error) return <Error message={error.message} />;

  return (
    <div>
      <h1>{product.name}</h1>
      <p>${product.price}</p>
      <ReviewsList reviews={reviews} />
    </div>
  );
}

// Problems:
// 1. Waterfall: product â†’ reviews (sequential)
// 2. Loading states management
// 3. Error handling boilerplate
// 4. JavaScript bundle includes all fetch logic
// 5. API layer needed (/api/products, /api/reviews)

// ============= RSC APPROACH =============

// âš ï¸ CONCEPTUAL - Only works in Next.js App Router
async function RSCProductPage({ productId }) {
  // Parallel fetching - both at once!
  const [product, reviews] = await Promise.all([
    db.products.findById(productId),
    db.reviews.findMany({ where: { productId } }),
  ]);

  // Direct database access - no API layer needed
  // No loading states - data ready before render
  // No useState/useEffect - simpler code

  return (
    <div>
      <h1>{product.name}</h1>
      <p>${product.price}</p>
      <ReviewsList reviews={reviews} />
    </div>
  );
}

// Benefits:
// âœ… Parallel fetching (faster)
// âœ… No loading states (simpler)
// âœ… Direct DB access (no API layer)
// âœ… Zero fetch code sent to client
// âœ… Better error handling (Error Boundaries)

// ============= STREAMING PATTERN =============

// Traditional: Wait for ALL data before showing anything
async function TraditionalDashboard() {
  const [user, analytics, notifications] = await Promise.all([
    fetchUser(),
    fetchAnalytics(), // Takes 2 seconds
    fetchNotifications(),
  ]);

  // User waits 2 seconds before seeing ANYTHING
  return (
    <div>
      <UserWidget user={user} />
      <AnalyticsWidget data={analytics} />
      <NotificationsWidget data={notifications} />
    </div>
  );
}

// RSC: Stream components as data arrives
async function StreamingDashboard() {
  const userPromise = fetchUser();
  const analyticsPromise = fetchAnalytics();
  const notificationsPromise = fetchNotifications();

  return (
    <div>
      {/* Show immediately */}
      <Suspense fallback={<UserSkeleton />}>
        <UserWidget promise={userPromise} />
      </Suspense>

      {/* Show when ready (2s) */}
      <Suspense fallback={<AnalyticsSkeleton />}>
        <AnalyticsWidget promise={analyticsPromise} />
      </Suspense>

      {/* Show when ready */}
      <Suspense fallback={<NotificationsSkeleton />}>
        <NotificationsWidget promise={notificationsPromise} />
      </Suspense>
    </div>
  );
}

// Flow:
// 0ms: User sees UserSkeleton + AnalyticsSkeleton + NotificationsSkeleton
// 100ms: UserWidget shows (user data ready)
// 150ms: NotificationsWidget shows
// 2000ms: AnalyticsWidget shows
// â†’ Better perceived performance!

// Káº¿t quáº£:
// Traditional: Waterfall, slow, complex
// RSC: Parallel, fast, simple
// Streaming: Progressive rendering, best UX
```

### Demo 3: Composition Patterns â­â­â­

```jsx
/**
 * Demo: Server & Client Component Composition
 *
 * Rules:
 * 1. Server Component can import Client Component âœ…
 * 2. Server Component can import Server Component âœ…
 * 3. Client Component can import Client Component âœ…
 * 4. Client Component CANNOT import Server Component âŒ
 *    (but can receive as children prop)
 */

// ============= PATTERN 1: Server â†’ Client âœ… =============

// Server Component
async function ProductPage({ productId }) {
  const product = await db.products.get(productId);

  return (
    <div>
      <h1>{product.name}</h1>

      {/* âœ… Server Component can use Client Component */}
      <AddToCartButton product={product} />
    </div>
  );
}

// Client Component
('use client');
function AddToCartButton({ product }) {
  const [isAdding, setIsAdding] = useState(false);

  const handleAdd = async () => {
    setIsAdding(true);
    await addToCart(product.id);
    setIsAdding(false);
  };

  return (
    <button
      onClick={handleAdd}
      disabled={isAdding}
    >
      {isAdding ? 'Adding...' : 'Add to Cart'}
    </button>
  );
}

// ============= PATTERN 2: Server â†’ Server âœ… =============

// Parent Server Component
async function BlogPage() {
  const posts = await db.posts.getAll();

  return (
    <div>
      {posts.map((post) => (
        // âœ… Server Component can use Server Component
        <BlogPostCard
          key={post.id}
          post={post}
        />
      ))}
    </div>
  );
}

// Child Server Component
async function BlogPostCard({ post }) {
  const author = await db.users.get(post.authorId);

  return (
    <article>
      <h2>{post.title}</h2>
      <p>By {author.name}</p>
    </article>
  );
}

// ============= PATTERN 3: Client â†’ Client âœ… =============

// Parent Client Component
('use client');
function ShoppingCart() {
  const [items, setItems] = useState([]);

  return (
    <div>
      {items.map((item) => (
        // âœ… Client Component can use Client Component
        <CartItem
          key={item.id}
          item={item}
          onRemove={() => removeItem(item.id)}
        />
      ))}
    </div>
  );
}

// Child Client Component
('use client');
function CartItem({ item, onRemove }) {
  return (
    <div>
      <span>{item.name}</span>
      <button onClick={onRemove}>Remove</button>
    </div>
  );
}

// ============= PATTERN 4: Client â†’ Server âŒ (Direct Import) =============

// âŒ WRONG: Client Component cannot import Server Component
('use client');
import ServerComponent from './ServerComponent'; // âŒ Error!

function ClientWrapper() {
  return <ServerComponent />; // Won't work
}

// ============= PATTERN 5: Client â†’ Server âœ… (via children) =============

// âœ… RIGHT: Pass Server Component as children
('use client');
function ClientWrapper({ children }) {
  const [show, setShow] = useState(true);

  return (
    <div>
      <button onClick={() => setShow(!show)}>Toggle</button>
      {show && children}
    </div>
  );
}

// Server Component can pass Server Component as children
async function Page() {
  const data = await db.get();

  return (
    <ClientWrapper>
      {/* âœ… Server Component passed as children */}
      <ServerDataDisplay data={data} />
    </ClientWrapper>
  );
}

async function ServerDataDisplay({ data }) {
  return <div>{data.title}</div>;
}

// ============= BEST PRACTICE: Leaf Client Components =============

// âŒ BAD: Entire tree becomes Client Component
('use client');
function Layout({ children }) {
  const [theme, setTheme] = useState('light');

  return (
    <div className={theme}>
      <Header /> {/* Now a Client Component */}
      <Sidebar /> {/* Now a Client Component */}
      <main>{children}</main> {/* All children are Client Components */}
      <Footer /> {/* Now a Client Component */}
    </div>
  );
}

// âœ… GOOD: Keep Client Components at the leaves
function Layout({ children }) {
  // Server Component (default)
  return (
    <div>
      <Header /> {/* Server Component */}
      <Sidebar /> {/* Server Component */}
      <main>
        {children} {/* Can be Server or Client */}
        {/* Only interactive part is Client */}
        <ThemeToggle /> {/* Client Component */}
      </main>
      <Footer /> {/* Server Component */}
    </div>
  );
}

('use client');
function ThemeToggle() {
  const [theme, setTheme] = useState('light');
  return (
    <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      Toggle Theme
    </button>
  );
}

// Káº¿t quáº£:
// âœ… Most of tree = Server Components (zero JS)
// âœ… Only leaves = Client Components (minimal JS)
// âœ… Better performance, smaller bundle
```

---

## ğŸ”¨ PHáº¦N 3: CONCEPTUAL EXERCISES (60 phÃºt)

### â­ Level 1: Identify Server vs Client (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Nháº­n biáº¿t khi nÃ o dÃ¹ng Server vs Client Component
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG code: Chá»‰ phÃ¢n tÃ­ch vÃ  quyáº¿t Ä‘á»‹nh
 *
 * Requirements:
 * 1. Äá»c tá»«ng component
 * 2. Quyáº¿t Ä‘á»‹nh: Server hay Client?
 * 3. Giáº£i thÃ­ch lÃ½ do
 */

// Component 1
function UserProfile({ userId }) {
  const user = await db.users.findById(userId);

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
// â“ Server hay Client? Táº¡i sao?

// Component 2
function LikeButton({ postId }) {
  const [liked, setLiked] = useState(false);

  return (
    <button onClick={() => setLiked(!liked)}>
      {liked ? 'â¤ï¸' : 'ğŸ¤'}
    </button>
  );
}
// â“ Server hay Client? Táº¡i sao?

// Component 3
function ProductList({ category }) {
  const products = await fetch(`/api/products?category=${category}`);

  return (
    <div>
      {products.map(p => <ProductCard key={p.id} product={p} />)}
    </div>
  );
}
// â“ Server hay Client? Táº¡i sao?

// Component 4
function SearchBox() {
  const [query, setQuery] = useState('');
  const router = useRouter();

  const handleSearch = () => {
    router.push(`/search?q=${query}`);
  };

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
    />
  );
}
// â“ Server hay Client? Táº¡i sao?

// Component 5
function BlogPost({ slug }) {
  const post = await db.posts.findOne({ slug });
  const html = await markdownToHtml(post.content);

  return <article dangerouslySetInnerHTML={{ __html: html }} />;
}
// â“ Server hay Client? Táº¡i sao?
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * PhÃ¢n tÃ­ch tá»«ng component
 */

// Component 1: SERVER COMPONENT âœ…
// LÃ½ do:
// - Fetches data (await db.users)
// - No interactivity
// - No hooks needed
// - Direct database access
// Benefits: Zero JS to client, fast data access

// Component 2: CLIENT COMPONENT âœ…
// LÃ½ do:
// - Uses useState hook
// - Needs interactivity (onClick)
// - Manages local state
// Must add: 'use client' directive

// Component 3: SERVER COMPONENT âœ…
// LÃ½ do:
// - Fetches data (await fetch)
// - No interactivity
// - Pure rendering based on data
// Benefits: Data fetched on server, smaller bundle

// Component 4: CLIENT COMPONENT âœ…
// LÃ½ do:
// - Uses useState
// - Uses useRouter (browser API)
// - Event handlers (onChange, onKeyPress)
// - Form interactivity
// Must add: 'use client' directive

// Component 5: SERVER COMPONENT âœ…
// LÃ½ do:
// - Fetches from database
// - Heavy computation (markdownToHtml) better on server
// - No interactivity
// - Static content rendering
// Benefits: Markdown processing zero cost to client

// ğŸ’¡ RULE OF THUMB:
// Server: Data fetching, heavy computation, static content
// Client: Interactivity, hooks, browser APIs, state management
```

</details>

---

### â­â­ Level 2: Convert Traditional to RSC (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Convert traditional React sang RSC architecture
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: Dashboard vá»›i user info, stats, vÃ  notifications
 *
 * Task:
 * 1. Identify parts that should be Server Components
 * 2. Identify parts that should be Client Components
 * 3. Rewrite vá»›i RSC patterns
 * 4. Document reasoning
 */

// âŒ TRADITIONAL REACT
function Dashboard() {
  const [user, setUser] = useState(null);
  const [stats, setStats] = useState(null);
  const [notifications, setNotifications] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    Promise.all([
      fetch('/api/user').then((r) => r.json()),
      fetch('/api/stats').then((r) => r.json()),
      fetch('/api/notifications').then((r) => r.json()),
    ]).then(([userData, statsData, notifData]) => {
      setUser(userData);
      setStats(statsData);
      setNotifications(notifData);
      setLoading(false);
    });
  }, []);

  if (loading) return <Spinner />;

  return (
    <div>
      <UserInfo user={user} />
      <Stats data={stats} />
      <NotificationsList notifications={notifications} />
    </div>
  );
}

function NotificationsList({ notifications }) {
  const [filter, setFilter] = useState('all');

  const filtered = notifications.filter(
    (n) => filter === 'all' || n.type === filter,
  );

  return (
    <div>
      <select
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
      >
        <option value='all'>All</option>
        <option value='alert'>Alerts</option>
        <option value='message'>Messages</option>
      </select>
      {filtered.map((n) => (
        <div key={n.id}>{n.message}</div>
      ))}
    </div>
  );
}

// TODO: Rewrite vá»›i RSC architecture
// TODO: Document which parts are Server vs Client
// TODO: Explain benefits of new architecture
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * RSC Architecture - Converted
 */

// ============= SERVER COMPONENTS =============

// Main Dashboard - Server Component
async function Dashboard() {
  // Parallel data fetching on server
  const [user, stats, notifications] = await Promise.all([
    db.users.getCurrent(),
    db.stats.getOverview(),
    db.notifications.getRecent(),
  ]);

  return (
    <div>
      {/* Server Component - static display */}
      <UserInfo user={user} />

      {/* Server Component - static display */}
      <Stats data={stats} />

      {/* Client Component - needs interactivity for filtering */}
      <NotificationsList initialNotifications={notifications} />
    </div>
  );
}

// Server Component - No hooks needed
function UserInfo({ user }) {
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}

// Server Component - No hooks needed
function Stats({ data }) {
  return (
    <div>
      <div>Total Users: {data.totalUsers}</div>
      <div>Active: {data.activeUsers}</div>
    </div>
  );
}

// ============= CLIENT COMPONENT =============

// Client Component - needs state for filtering
('use client');
import { useState } from 'react';

function NotificationsList({ initialNotifications }) {
  const [filter, setFilter] = useState('all');

  const filtered = initialNotifications.filter(
    (n) => filter === 'all' || n.type === filter,
  );

  return (
    <div>
      <select
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
      >
        <option value='all'>All</option>
        <option value='alert'>Alerts</option>
        <option value='message'>Messages</option>
      </select>
      {filtered.map((n) => (
        <div key={n.id}>{n.message}</div>
      ))}
    </div>
  );
}

// ============= ARCHITECTURE DECISIONS =============

/*
BREAKDOWN:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Dashboard (SERVER)                          â”‚
â”‚ - Fetches all data in parallel             â”‚
â”‚ - No useState/useEffect needed             â”‚
â”‚ - Direct database access                   â”‚
â”‚                                             â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ UserInfo (SERVER)                       â”‚ â”‚
â”‚ â”‚ - Pure display                          â”‚ â”‚
â”‚ â”‚ - Zero JS to client                     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                             â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Stats (SERVER)                          â”‚ â”‚
â”‚ â”‚ - Pure display                          â”‚ â”‚
â”‚ â”‚ - Zero JS to client                     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                             â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ NotificationsList (CLIENT)              â”‚ â”‚
â”‚ â”‚ - Needs useState for filter             â”‚ â”‚
â”‚ â”‚ - Interactive dropdown                  â”‚ â”‚
â”‚ â”‚ - Only this sends JS to client          â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

BENEFITS:
âœ… Faster initial load (parallel fetching on server)
âœ… No loading states needed
âœ… Smaller bundle (only NotificationsList is client JS)
âœ… Better SEO (all content in HTML)
âœ… Direct database access (no API layer)

BUNDLE SIZE COMPARISON:
Traditional:
- Dashboard code: 5KB
- UserInfo code: 2KB
- Stats code: 2KB
- NotificationsList code: 3KB
- Data fetching logic: 4KB
- React hooks overhead: 2KB
Total: 18KB

RSC:
- NotificationsList code: 3KB
- Data already in HTML: 0KB
Total: 3KB (83% reduction!)
*/
```

</details>

---

### â­â­â­ Level 3: Design RSC Architecture (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Design complete RSC architecture
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Scenario: E-commerce Product Page
 *
 * Requirements:
 * - Product details (name, price, description, images)
 * - Reviews list (rating, comment, author)
 * - Recommendations (related products)
 * - Add to cart button (interactive)
 * - Quantity selector (interactive)
 * - Review form (interactive)
 * - Breadcrumbs (navigation)
 *
 * Tasks:
 * 1. Design component tree (which are Server, which are Client)
 * 2. Document data fetching strategy
 * 3. Identify benefits vs traditional approach
 * 4. List potential issues and solutions
 */

// TODO: Design component architecture
// TODO: Specify Server vs Client for each component
// TODO: Document data flow
// TODO: Compare bundle sizes (traditional vs RSC)
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * E-commerce Product Page - RSC Architecture Design
 */

// ============= COMPONENT TREE =============

/*
ProductPage (SERVER)
â”œâ”€â”€ Breadcrumbs (SERVER)
â”œâ”€â”€ ProductDetails (SERVER)
â”‚   â”œâ”€â”€ ImageGallery (SERVER)
â”‚   â”œâ”€â”€ ProductInfo (SERVER)
â”‚   â””â”€â”€ PurchaseSection (CLIENT) â† Interactive
â”‚       â”œâ”€â”€ QuantitySelector (CLIENT)
â”‚       â””â”€â”€ AddToCartButton (CLIENT)
â”œâ”€â”€ ReviewsSection (MIXED)
â”‚   â”œâ”€â”€ ReviewsSummary (SERVER)
â”‚   â”œâ”€â”€ ReviewsList (SERVER)
â”‚   â””â”€â”€ ReviewForm (CLIENT) â† Interactive
â””â”€â”€ Recommendations (SERVER)
    â””â”€â”€ ProductCard (SERVER)
        â””â”€â”€ QuickAddButton (CLIENT) â† Interactive
*/

// ============= IMPLEMENTATION =============

// â”€â”€â”€â”€â”€â”€â”€ SERVER COMPONENT (Main Page) â”€â”€â”€â”€â”€â”€â”€
async function ProductPage({ productId }) {
  // Parallel data fetching
  const [product, reviews, recommendations] = await Promise.all([
    db.products.findById(productId),
    db.reviews.findMany({ productId }),
    db.products.findRelated(productId),
  ]);

  return (
    <div>
      <Breadcrumbs
        category={product.category}
        productName={product.name}
      />

      <ProductDetails
        product={product}
        averageRating={calculateAverage(reviews)}
      />

      <ReviewsSection
        reviews={reviews}
        productId={productId}
      />

      <Recommendations products={recommendations} />
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ SERVER COMPONENT â”€â”€â”€â”€â”€â”€â”€
function Breadcrumbs({ category, productName }) {
  return (
    <nav>
      Home / {category} / {productName}
    </nav>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ SERVER COMPONENT â”€â”€â”€â”€â”€â”€â”€
function ProductDetails({ product, averageRating }) {
  return (
    <div>
      <ImageGallery images={product.images} />

      <div>
        <h1>{product.name}</h1>
        <div>
          â­ {averageRating} ({product.reviewCount} reviews)
        </div>
        <p>{product.description}</p>
        <div>${product.price}</div>

        {/* Client Component for interactivity */}
        <PurchaseSection
          productId={product.id}
          price={product.price}
          inStock={product.inStock}
        />
      </div>
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ SERVER COMPONENT â”€â”€â”€â”€â”€â”€â”€
function ImageGallery({ images }) {
  return (
    <div>
      {images.map((img, idx) => (
        <img
          key={idx}
          src={img.url}
          alt={img.alt}
        />
      ))}
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ CLIENT COMPONENT â”€â”€â”€â”€â”€â”€â”€
('use client');
function PurchaseSection({ productId, price, inStock }) {
  const [quantity, setQuantity] = useState(1);
  const [isAdding, setIsAdding] = useState(false);

  const handleAddToCart = async () => {
    setIsAdding(true);
    await addToCart(productId, quantity);
    setIsAdding(false);
  };

  return (
    <div>
      <QuantitySelector
        value={quantity}
        onChange={setQuantity}
        max={inStock}
      />

      <button
        onClick={handleAddToCart}
        disabled={!inStock || isAdding}
      >
        {isAdding ? 'Adding...' : `Add to Cart - $${price * quantity}`}
      </button>

      <p>{inStock} in stock</p>
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ CLIENT COMPONENT â”€â”€â”€â”€â”€â”€â”€
('use client');
function QuantitySelector({ value, onChange, max }) {
  return (
    <div>
      <button onClick={() => onChange(Math.max(1, value - 1))}>-</button>
      <span>{value}</span>
      <button onClick={() => onChange(Math.min(max, value + 1))}>+</button>
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ SERVER COMPONENT â”€â”€â”€â”€â”€â”€â”€
function ReviewsSection({ reviews, productId }) {
  const stats = calculateReviewStats(reviews);

  return (
    <div>
      <ReviewsSummary stats={stats} />
      <ReviewsList reviews={reviews} />
      <ReviewForm productId={productId} />
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ SERVER COMPONENT â”€â”€â”€â”€â”€â”€â”€
function ReviewsSummary({ stats }) {
  return (
    <div>
      <h3>Customer Reviews</h3>
      <div>Average: {stats.average}â­</div>
      <div>
        5â˜…: {stats.fiveStar} | 4â˜…: {stats.fourStar} ...
      </div>
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ SERVER COMPONENT â”€â”€â”€â”€â”€â”€â”€
function ReviewsList({ reviews }) {
  return (
    <div>
      {reviews.map((review) => (
        <div key={review.id}>
          <div>{'â­'.repeat(review.rating)}</div>
          <p>{review.comment}</p>
          <span>
            By {review.author} on {review.date}
          </span>
        </div>
      ))}
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ CLIENT COMPONENT â”€â”€â”€â”€â”€â”€â”€
('use client');
function ReviewForm({ productId }) {
  const [rating, setRating] = useState(5);
  const [comment, setComment] = useState('');
  const [submitting, setSubmitting] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setSubmitting(true);
    await submitReview(productId, { rating, comment });
    setSubmitting(false);
    setComment('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <select
        value={rating}
        onChange={(e) => setRating(+e.target.value)}
      >
        <option value={5}>5 Stars</option>
        <option value={4}>4 Stars</option>
        <option value={3}>3 Stars</option>
        <option value={2}>2 Stars</option>
        <option value={1}>1 Star</option>
      </select>

      <textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
        placeholder='Write your review...'
      />

      <button
        type='submit'
        disabled={submitting}
      >
        {submitting ? 'Submitting...' : 'Submit Review'}
      </button>
    </form>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ SERVER COMPONENT â”€â”€â”€â”€â”€â”€â”€
function Recommendations({ products }) {
  return (
    <div>
      <h3>You Might Also Like</h3>
      <div>
        {products.map((product) => (
          <ProductCard
            key={product.id}
            product={product}
          />
        ))}
      </div>
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ SERVER COMPONENT â”€â”€â”€â”€â”€â”€â”€
function ProductCard({ product }) {
  return (
    <div>
      <img
        src={product.image}
        alt={product.name}
      />
      <h4>{product.name}</h4>
      <p>${product.price}</p>
      <QuickAddButton productId={product.id} />
    </div>
  );
}

// â”€â”€â”€â”€â”€â”€â”€ CLIENT COMPONENT â”€â”€â”€â”€â”€â”€â”€
('use client');
function QuickAddButton({ productId }) {
  const [isAdding, setIsAdding] = useState(false);

  const handleQuickAdd = async () => {
    setIsAdding(true);
    await addToCart(productId, 1);
    setIsAdding(false);
  };

  return (
    <button
      onClick={handleQuickAdd}
      disabled={isAdding}
    >
      {isAdding ? '...' : 'Quick Add'}
    </button>
  );
}

// ============= BENEFITS ANALYSIS =============

/*
BUNDLE SIZE COMPARISON:

Traditional React (Client-Side):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Component                    | Size
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ProductPage                  | 8KB
Breadcrumbs                  | 2KB
ProductDetails               | 6KB
ImageGallery                 | 4KB
PurchaseSection              | 5KB
QuantitySelector             | 2KB
ReviewsSection               | 8KB
ReviewsList                  | 4KB
ReviewForm                   | 6KB
Recommendations              | 5KB
ProductCard                  | 3KB
QuickAddButton               | 2KB
Data fetching logic          | 10KB
State management             | 8KB
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
TOTAL                        | 73KB
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

RSC Architecture:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Component                    | Size
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ProductPage (Server)         | 0KB âœ…
Breadcrumbs (Server)         | 0KB âœ…
ProductDetails (Server)      | 0KB âœ…
ImageGallery (Server)        | 0KB âœ…
PurchaseSection (Client)     | 5KB
QuantitySelector (Client)    | 2KB
ReviewsSection (Server)      | 0KB âœ…
ReviewsSummary (Server)      | 0KB âœ…
ReviewsList (Server)         | 0KB âœ…
ReviewForm (Client)          | 6KB
Recommendations (Server)     | 0KB âœ…
ProductCard (Server)         | 0KB âœ…
QuickAddButton (Client)      | 2KB
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
TOTAL                        | 15KB
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SAVINGS: 73KB â†’ 15KB (79% reduction!)

PERFORMANCE METRICS:

Traditional:
- Time to Interactive: ~3.2s
- First Contentful Paint: ~1.8s
- Largest Contentful Paint: ~2.5s
- Total Blocking Time: ~800ms

RSC:
- Time to Interactive: ~0.8s âœ… (75% faster)
- First Contentful Paint: ~0.4s âœ… (78% faster)
- Largest Contentful Paint: ~0.6s âœ… (76% faster)
- Total Blocking Time: ~200ms âœ… (75% less)

SEO:
Traditional:
- Initial HTML: Empty (JavaScript required)
- Search engines: Must run JS to see content
- Crawl budget: Wasted on JS execution

RSC:
- Initial HTML: Full content
- Search engines: Immediate content access
- Crawl budget: Efficient

DEVELOPER EXPERIENCE:

Traditional:
- âŒ Complex state management
- âŒ Loading states everywhere
- âŒ Error handling boilerplate
- âŒ API layer needed
- âŒ Waterfall requests

RSC:
- âœ… Simple async/await
- âœ… No loading states
- âœ… Error boundaries handle errors
- âœ… Direct database access
- âœ… Parallel requests
*/

// ============= POTENTIAL ISSUES & SOLUTIONS =============

/*
ISSUE 1: Cannot use hooks in Server Components
Solution: Move interactive parts to Client Components

ISSUE 2: Cannot import Server Components in Client Components
Solution: Pass Server Components as children props

ISSUE 3: Large initial HTML payload
Solution: Use Streaming + Suspense for progressive loading

ISSUE 4: Serialization limits (functions, classes)
Solution: Only pass serializable data as props

ISSUE 5: Learning curve
Solution: Start with small features, gradually adopt
*/
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh Trade-offs

| Aspect                  | Traditional React (CSR) | SSR (Next.js Pages)           | RSC (Next.js App Router)           |
| ----------------------- | ----------------------- | ----------------------------- | ---------------------------------- |
| **Rendering Location**  | Client only             | Server + Client               | Server (default) + Client (opt-in) |
| **JavaScript Bundle**   | Large (all code)        | Large (all code)              | Small (only Client Components)     |
| **Data Fetching**       | Client (useEffect)      | getServerSideProps            | Direct in component (async)        |
| **SEO**                 | Poor (needs JS)         | Good (HTML ready)             | Excellent (HTML + streaming)       |
| **Time to Interactive** | Slow (2-3s)             | Medium (1-2s)                 | Fast (0.5-1s)                      |
| **Can use hooks**       | âœ… Yes                  | âœ… Yes                        | âš ï¸ Only in Client Components       |
| **Direct DB access**    | âŒ No                   | âš ï¸ Only in getServerSideProps | âœ… Yes (in Server Components)      |
| **Bundle size**         | ~300-500KB              | ~300-500KB                    | ~50-100KB                          |
| **Loading states**      | Required                | Required                      | Optional (use Suspense)            |
| **Complexity**          | Medium                  | High                          | Medium-High (new concepts)         |
| **Performance**         | Poor                    | Good                          | Excellent                          |
| **When to use**         | Simple SPAs             | SEO-critical pages            | Modern apps, best performance      |

### Decision Tree

```
START: Building a React feature?
    |
    â”œâ”€ Need interactivity (onClick, useState, forms)?
    â”‚   |
    â”‚   â”œâ”€ Yes â†’ CLIENT COMPONENT ('use client')
    â”‚   â”‚   Examples:
    â”‚   â”‚   - Buttons with click handlers
    â”‚   â”‚   - Forms with controlled inputs
    â”‚   â”‚   - Interactive widgets (dropdowns, modals)
    â”‚   â”‚   - Browser API usage (localStorage, geolocation)
    â”‚   â”‚
    â”‚   â””â”€ No â†’ Continue to next question
    â”‚
    â”œâ”€ Need to fetch data?
    â”‚   |
    â”‚   â”œâ”€ Yes â†’ SERVER COMPONENT (default)
    â”‚   â”‚   Examples:
    â”‚   â”‚   - Blog post content
    â”‚   â”‚   - Product details
    â”‚   â”‚   - User profiles
    â”‚   â”‚   - Dashboard data
    â”‚   â”‚
    â”‚   â””â”€ No â†’ Continue to next question
    â”‚
    â”œâ”€ Heavy computation (markdown, image processing)?
    â”‚   |
    â”‚   â”œâ”€ Yes â†’ SERVER COMPONENT
    â”‚   â”‚   Benefits:
    â”‚   â”‚   - Computation happens on server
    â”‚   â”‚   - Zero cost to client bundle
    â”‚   â”‚   - Faster page loads
    â”‚   â”‚
    â”‚   â””â”€ No â†’ Continue to next question
    â”‚
    â”œâ”€ Static content display only?
    â”‚   |
    â”‚   â”œâ”€ Yes â†’ SERVER COMPONENT (default)
    â”‚   â”‚   Examples:
    â”‚   â”‚   - Headers, footers
    â”‚   â”‚   - Static text blocks
    â”‚   â”‚   - Non-interactive cards
    â”‚   â”‚
    â”‚   â””â”€ No â†’ Analyze specific needs
    â”‚
    â””â”€ MIXED: Use Server Component as wrapper,
       Client Components for interactive parts
```

**Composition Patterns:**

```
Pattern 1: Server wraps Client
âœ… GOOD
async function Page() {
  const data = await fetchData();
  return (
    <>
      <ServerHeader data={data} />
      <ClientInteractive data={data} />
      <ServerFooter />
    </>
  );
}

Pattern 2: Client wraps Server (via children)
âœ… GOOD (when necessary)
'use client';
function ClientWrapper({ children }) {
  return <div className={useTheme()}>{children}</div>;
}

// Usage
<ClientWrapper>
  <ServerContent />
</ClientWrapper>

Pattern 3: Client imports Server
âŒ BAD - Will cause error
'use client';
import ServerComponent from './server';

function Client() {
  return <ServerComponent />; // Error!
}

Pattern 4: Server imports Client
âœ… GOOD - Recommended
async function Server() {
  const data = await fetchData();
  return <ClientButton data={data} />;
}
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Using Hooks in Server Component

```jsx
/**
 * ğŸ› BUG: Cannot use hooks in Server Component
 */

// File: app/posts/page.js
async function PostsPage() {
  const [filter, setFilter] = useState('all'); // âŒ Error!

  const posts = await db.posts.findMany();

  return (
    <div>
      <select
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
      >
        <option>All</option>
        <option>Published</option>
      </select>
      {posts.map((post) => (
        <Post
          key={post.id}
          post={post}
        />
      ))}
    </div>
  );
}

// â“ Táº I SAO: Error "useState is not defined"?
// â“ LÃ€M SAO FIX?
```

<details>
<summary>ğŸ’¡ Giáº£i thÃ­ch & Fix</summary>

```jsx
/**
 * GIáº¢I THÃCH:
 * Server Components khÃ´ng support hooks (useState, useEffect, etc.)
 * Server Components chá»‰ cháº¡y trÃªn server, khÃ´ng cÃ³ client-side lifecycle
 *
 * LÃ DO:
 * - Server Components render má»™t láº§n trÃªn server
 * - KhÃ´ng cÃ³ re-renders
 * - KhÃ´ng cÃ³ interactivity
 * - Hooks require client-side React runtime
 */

// âœ… FIX: Extract interactive part to Client Component

// File: app/posts/page.js (Server Component)
async function PostsPage() {
  const posts = await db.posts.findMany();

  return <PostsListWithFilter initialPosts={posts} />;
}

// File: app/components/PostsListWithFilter.js (Client Component)
('use client');
import { useState } from 'react';

function PostsListWithFilter({ initialPosts }) {
  const [filter, setFilter] = useState('all');

  const filtered = initialPosts.filter(
    (post) => filter === 'all' || post.status === filter,
  );

  return (
    <div>
      <select
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
      >
        <option value='all'>All</option>
        <option value='published'>Published</option>
        <option value='draft'>Draft</option>
      </select>

      {filtered.map((post) => (
        <Post
          key={post.id}
          post={post}
        />
      ))}
    </div>
  );
}

// ğŸ’¡ PATTERN:
// Server Component: Fetch data
// Client Component: Handle interactivity
// Pass data from Server to Client via props
```

</details>

---

### Bug 2: Importing Server Component in Client Component

```jsx
/**
 * ğŸ› BUG: Cannot import Server Component trong Client Component
 */

// File: app/components/ServerUserCard.js (Server Component)
async function ServerUserCard({ userId }) {
  const user = await db.users.findById(userId);

  return (
    <div>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
}

// File: app/components/UserModal.js (Client Component)
('use client');
import { useState } from 'react';
import ServerUserCard from './ServerUserCard'; // âŒ Error!

function UserModal({ userId }) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <button onClick={() => setIsOpen(true)}>View User</button>

      {isOpen && (
        <div>
          <ServerUserCard userId={userId} /> {/* âŒ Won't work */}
        </div>
      )}
    </>
  );
}

// â“ Váº¤N Äá»€: "You're importing a component that needs server-side..."
// â“ FIX?
```

<details>
<summary>ğŸ’¡ Giáº£i thÃ­ch & Fix</summary>

```jsx
/**
 * GIáº¢I THÃCH:
 * Client Components cannot import Server Components directly
 * Server Components can only be rendered on server
 * Client Components render on client
 *
 * Rule: Client â†’ Server imports are not allowed
 * Exception: Can pass Server Components as children
 */

// âœ… FIX 1: Pass Server Component as children prop

// File: app/page.js (Server Component)
async function Page({ userId }) {
  return (
    <UserModal>
      {/* Server Component passed as children */}
      <ServerUserCard userId={userId} />
    </UserModal>
  );
}

// File: app/components/UserModal.js (Client Component)
('use client');
import { useState } from 'react';

function UserModal({ children }) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <button onClick={() => setIsOpen(true)}>View User</button>

      {isOpen && (
        <div className='modal'>
          {children} {/* Renders Server Component */}
        </div>
      )}
    </>
  );
}

// âœ… FIX 2: Fetch data on server, pass to Client Component

// Server Component
async function Page({ userId }) {
  const user = await db.users.findById(userId);

  return <UserModal user={user} />;
}

// Client Component
('use client');
function UserModal({ user }) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <button onClick={() => setIsOpen(true)}>View User</button>

      {isOpen && (
        <div className='modal'>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      )}
    </>
  );
}

// ğŸ’¡ KEY INSIGHT:
// Data flows: Server â†’ Client âœ…
// Components flow: Server â†’ Client âœ… (as children)
// Direct imports: Server â†’ Client âŒ (not allowed)
```

</details>

---

### Bug 3: Non-serializable Props

```jsx
/**
 * ğŸ› BUG: Cannot pass functions/class instances as props
 */

// Server Component
async function Page() {
  const user = await db.users.findById('123');

  const handleClick = () => {
    console.log('Clicked!');
  };

  return (
    <ClientButton
      user={user} // âœ… OK - plain object
      onClick={handleClick} // âŒ Error! Cannot serialize function
      date={new Date()} // âŒ Error! Cannot serialize Date
    />
  );
}

// â“ Váº¤N Äá»€: "Only plain objects can be passed to Client Components"
// â“ FIX?
```

<details>
<summary>ğŸ’¡ Giáº£i thÃ­ch & Fix</summary>

```jsx
/**
 * GIáº¢I THÃCH:
 * Props tá»« Server â†’ Client pháº£i serializable (JSON.stringify compatible)
 *
 * âœ… SERIALIZABLE:
 * - Strings, numbers, booleans
 * - Plain objects, arrays
 * - null, undefined
 *
 * âŒ NOT SERIALIZABLE:
 * - Functions
 * - Class instances (Date, Map, Set, etc.)
 * - Symbols
 * - undefined (in objects)
 */

// âœ… FIX: Convert non-serializable to serializable

// Server Component
async function Page() {
  const user = await db.users.findById('123');

  // Convert Date to string
  const createdAt = user.createdAt.toISOString();

  return (
    <ClientButton
      user={user}
      createdAt={createdAt} // âœ… String is serializable
    />
  );
}

// Client Component
('use client');
function ClientButton({ user, createdAt }) {
  // Define handler in Client Component
  const handleClick = () => {
    console.log('Clicked!', user);
  };

  // Convert string back to Date if needed
  const date = new Date(createdAt);

  return (
    <button onClick={handleClick}>Created: {date.toLocaleDateString()}</button>
  );
}

// ğŸ’¡ BEST PRACTICE:
// Server Component: Prepare data (fetch, transform)
// Client Component: Handle interactions (events, state)
// Props: Only serializable data
```

</details>

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

- [ ] TÃ´i hiá»ƒu RSC lÃ  gÃ¬ vÃ  khÃ¡c SSR nhÆ° tháº¿ nÃ o
- [ ] TÃ´i biáº¿t phÃ¢n biá»‡t Server vs Client Components
- [ ] TÃ´i hiá»ƒu khi nÃ o dÃ¹ng Server Component
- [ ] TÃ´i hiá»ƒu khi nÃ o dÃ¹ng Client Component
- [ ] TÃ´i biáº¿t Server Component KHÃ”NG dÃ¹ng Ä‘Æ°á»£c hooks
- [ ] TÃ´i biáº¿t Client Component KHÃ”NG import Ä‘Æ°á»£c Server Component
- [ ] TÃ´i hiá»ƒu composition patterns (Server â†’ Client)
- [ ] TÃ´i biáº¿t benefits cá»§a RSC (bundle size, performance)
- [ ] TÃ´i hiá»ƒu trade-offs cá»§a RSC
- [ ] TÃ´i sáºµn sÃ ng cho Next.js module Ä‘á»ƒ thá»±c hÃ nh

### Conceptual Understanding Check

**Scenario 1:**

```jsx
function Component() {
  const data = await fetch('/api/data');
  return <div>{data.title}</div>;
}
```

â“ Server hay Client? â†’ **Server** (async, fetch data)

**Scenario 2:**

```jsx
function Component() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount((c) => c + 1)}>{count}</button>;
}
```

â“ Server hay Client? â†’ **Client** (useState, onClick)

**Scenario 3:**

```jsx
async function Component() {
  const posts = await db.posts.getAll();
  return posts.map((p) => (
    <ClientCard
      key={p.id}
      post={p}
    />
  ));
}
```

â“ Server hay Client? â†’ **Server** (async, db access)

**Scenario 4:**

```jsx
function Component({ children }) {
  const theme = useTheme();
  return <div className={theme}>{children}</div>;
}
```

â“ Server hay Client? â†’ **Client** (useTheme hook)

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

Analyze vÃ  redesign má»™t trang blog:

- Identify táº¥t cáº£ components
- Classify: Server vs Client
- Document reasoning cho má»—i decision
- Estimate bundle size savings
- List potential issues

### NÃ¢ng cao (60 phÃºt)

Design RSC architecture cho complex app:

- Multi-tenant SaaS dashboard
- Multiple user roles
- Real-time notifications
- Complex data visualizations
- Document complete component tree
- Identify Server/Client boundaries
- Design data fetching strategy
- Plan error handling approach

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. [React Server Components RFC](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md)
2. [Next.js App Router Documentation](https://nextjs.org/docs/app)

### Äá»c thÃªm

3. [Server Components - Deep Dive (Dan Abramov)](https://www.youtube.com/watch?v=TQQPAU21ZUw)
4. [React Server Components in Next.js 13](https://nextjs.org/docs/getting-started/react-essentials)

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n

- **NgÃ y 49**: Suspense - RSC dÃ¹ng Suspense for streaming
- **NgÃ y 50**: Error Boundaries - RSC dÃ¹ng Error Boundaries
- **NgÃ y 1-45**: Táº¥t cáº£ React fundamentals - Foundation cho RSC

### HÆ°á»›ng tá»›i

- **NgÃ y 52**: Project 7 - Tá»•ng há»£p Modern React features
- **Next.js Module**: Thá»±c hÃ nh RSC trong Next.js 13+ App Router
- **Testing Module**: Testing Server Components

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. Migration Strategy:**

```
Phase 1: New features only
- DÃ¹ng RSC cho new features
- Keep existing code unchanged

Phase 2: High-traffic pages
- Convert product pages, blog posts
- Measure performance impact

Phase 3: Gradual rollout
- Convert dashboard, user pages
- Monitor errors, rollback if needed

Phase 4: Complete migration
- Convert remaining pages
- Remove old patterns
```

**2. Performance Monitoring:**

```jsx
// Track RSC performance
export async function ProductPage({ params }) {
  const startTime = Date.now();

  const product = await db.products.get(params.id);

  const fetchTime = Date.now() - startTime;
  await analytics.track('rsc_fetch_time', { fetchTime });

  return <ProductDetails product={product} />;
}
```

**3. SEO Benefits:**

```
Traditional React:
- Google sees empty HTML
- Must execute JavaScript
- Slower indexing

RSC:
- Google sees full HTML
- Instant content access
- Faster indexing
- Better rankings
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior:**

1. RSC lÃ  gÃ¬?
2. Server Component khÃ¡c Client Component nhÆ° tháº¿ nÃ o?
3. Khi nÃ o dÃ¹ng Server Component?

**Mid:**

1. Explain RSC architecture vÃ  rendering flow
2. So sÃ¡nh RSC vs SSR vs CSR
3. Composition patterns trong RSC

**Senior:**

1. Design RSC architecture cho large-scale app
2. Migration strategy tá»« traditional React sang RSC
3. Performance optimization vá»›i RSC
4. Trade-offs vÃ  khi nÃ o KHÃ”NG nÃªn dÃ¹ng RSC

### War Stories

**Story: The Bundle Size Miracle**

"E-commerce app cÃ³ bundle size 450KB. Users complain slow loads.

Migrated sang RSC:

- Product pages: 450KB â†’ 80KB
- Category pages: 380KB â†’ 60KB
- Homepage: 420KB â†’ 90KB

Result:

- Load time: 3.2s â†’ 0.8s
- Conversion rate: +25%
- Bounce rate: -40%

Lesson: RSC dramatically reduces bundle size â†’ Better UX â†’ More money."

---

## ğŸ¯ PREVIEW NGÃ€Y 52

NgÃ y mai lÃ  **Project 7 - Modern React App**!

ChÃºng ta sáº½:

- Tá»•ng há»£p táº¥t cáº£ React 18 features
- Combine Suspense + Error Boundaries
- Use Concurrent features
- Build production-ready modern app
- Apply best practices Ä‘Ã£ há»c

ÄÃ¢y lÃ  project cuá»‘i cÃ¹ng trÆ°á»›c Testing phase! ğŸ‰

---

**ğŸ‰ CHÃšC Má»ªNG! Báº¡n Ä‘Ã£ hiá»ƒu React Server Components!**

Báº¡n Ä‘Ã£ há»c Ä‘Æ°á»£c:
âœ… RSC concept vÃ  architecture
âœ… Server vs Client Components
âœ… Benefits vÃ  trade-offs
âœ… Composition patterns
âœ… When to use RSC

âš ï¸ **LÆ¯U Ã:** RSC chá»‰ cÃ³ trong Next.js 13+ App Router. ChÃºng ta sáº½ thá»±c hÃ nh trong Next.js module!

Sáºµn sÃ ng cho project cuá»‘i Modern React phase! ğŸš€
