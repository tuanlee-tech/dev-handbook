# üìÖ NG√ÄY 49: Suspense for Data Fetching

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

- [ ] Hi·ªÉu concept v√† c∆° ch·∫ø ho·∫°t ƒë·ªông c·ªßa Suspense
- [ ] Bi·∫øt c√°ch s·ª≠ d·ª•ng Suspense boundaries ƒë·ªÉ handle loading states
- [ ] K·∫øt h·ª£p Error Boundaries v·ªõi Suspense ƒë·ªÉ x·ª≠ l√Ω l·ªói
- [ ] √Åp d·ª•ng Suspense patterns trong data fetching scenarios

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

1. **useTransition vs useDeferredValue kh√°c nhau nh∆∞ th·∫ø n√†o?**
2. **Concurrent rendering gi√∫p c·∫£i thi·ªán UX ra sao?**
3. **T·∫°i sao c·∫ßn non-urgent updates?**

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

**Tr∆∞·ªõc ƒë√¢y ch√∫ng ta handle loading nh∆∞ th·∫ø n√†o?**

```jsx
// ‚ùå Pattern c≈©: Manual loading states everywhere
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetchUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [userId]);

  if (loading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!user) return null;

  return <div>{user.name}</div>;
}

// V·∫•n ƒë·ªÅ:
// 1. Boilerplate l·∫∑p l·∫°i (loading, error, data)
// 2. Waterfall loading (parent load xong m·ªõi load child)
// 3. Kh√≥ coordinate loading states gi·ªØa c√°c components
// 4. Kh√¥ng t·∫≠n d·ª•ng ƒë∆∞·ª£c concurrent rendering
```

**App th·ª±c t·∫ø:**

```jsx
// ‚ùå Waterfall loading - Ch·∫≠m!
function Dashboard() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser().then((user) => {
      setUser(user);
      setLoading(false);
    });
  }, []);

  if (loading) return <Spinner />;

  return (
    <div>
      <UserHeader user={user} />
      <UserPosts userId={user.id} /> {/* Ch·ªù user load xong m·ªõi fetch */}
      <UserFriends userId={user.id} /> {/* Ch·ªù user load xong m·ªõi fetch */}
    </div>
  );
}

// Timeline:
// 0ms: Fetch user
// 500ms: User loaded ‚Üí Fetch posts + friends
// 1000ms: Posts + Friends loaded
// Total: 1000ms (could be 500ms if parallel!)
```

### 1.2 Gi·∫£i Ph√°p: Suspense

**Suspense cho ph√©p:**

1. **Declarative loading states** - Kh√¥ng c·∫ßn manual useState
2. **Parallel data fetching** - Fetch t·∫•t c·∫£ c√πng l√∫c
3. **Coordinated loading UI** - Single loading boundary
4. **Better UX** - T·∫≠n d·ª•ng concurrent features

```jsx
// ‚úÖ Suspense pattern
function Dashboard() {
  return (
    <Suspense fallback={<DashboardSkeleton />}>
      <UserHeader /> {/* Fetch ngay */}
      <UserPosts /> {/* Fetch ngay */}
      <UserFriends /> {/* Fetch ngay */}
    </Suspense>
  );
}

// Timeline:
// 0ms: Fetch user + posts + friends c√πng l√∫c
// 500ms: T·∫•t c·∫£ loaded
// Total: 500ms (50% faster!)
```

### 1.3 Mental Model

**Suspense ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o?**

```
Component mu·ªën render
    ‚Üì
C·∫ßn data ‚Üí Throw Promise
    ‚Üì
React catch Promise
    ‚Üì
Show fallback UI (closest Suspense boundary)
    ‚Üì
Promise resolves
    ‚Üì
Re-render component v·ªõi data
    ‚Üì
Show actual content
```

**Analogy: Restaurant Order**

```
Traditional (useState):
- B·∫°n: "Cho t√¥i m√≥n A" ‚Üí ƒê·ª£i ‚Üí ƒÇn ‚Üí "Cho t√¥i m√≥n B" ‚Üí ƒê·ª£i ‚Üí ƒÇn
- Ch·∫≠m! Sequential

Suspense:
- B·∫°n: "Cho t√¥i m√≥n A, B, C" ‚Üí ƒê·ª£i ‚Üí ƒÇn t·∫•t c·∫£ c√πng l√∫c
- Nhanh! Parallel
```

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

**‚ùå Hi·ªÉu l·∫ßm 1: "Suspense t·ª± ƒë·ªông fetch data"**

```jsx
// ‚ùå WRONG: Suspense kh√¥ng fetch!
<Suspense fallback={<Spinner />}>
  <User userId={1} /> {/* Ai fetch? */}
</Suspense>;

// ‚úÖ CORRECT: Component ph·∫£i t·ª± fetch (ho·∫∑c d√πng library)
function User({ userId }) {
  const user = useSuspenseQuery(['user', userId], () => fetchUser(userId));
  // useSuspenseQuery t·ª± ƒë·ªông throw promise khi loading
  return <div>{user.name}</div>;
}
```

**‚ùå Hi·ªÉu l·∫ßm 2: "Suspense thay th·∫ø useEffect"**

```jsx
// Suspense KH√îNG thay th·∫ø useEffect!
// N√≥ ch·ªâ l√† c√°ch HI·ªÇN TH·ªä loading state

// ‚úÖ useEffect v·∫´n c·∫ßn cho side effects kh√°c:
useEffect(() => {
  trackPageView();
  setupWebSocket();
  return () => closeWebSocket();
}, []);
```

**‚ùå Hi·ªÉu l·∫ßm 3: "Suspense ch·ªâ cho data fetching"**

```jsx
// Suspense c≈©ng d√πng cho:
// - Code splitting (React.lazy)
// - Image loading (future)
// - B·∫•t k·ª≥ async operation n√†o

const LazyComponent = React.lazy(() => import('./Heavy'));

<Suspense fallback={<Spinner />}>
  <LazyComponent />
</Suspense>;
```

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Suspense C∆° B·∫£n ‚≠ê

```jsx
/**
 * Demo: Basic Suspense v·ªõi simulated data fetching
 *
 * ‚ö†Ô∏è L√ÄM R√ï: React Suspense hi·ªán t·∫°i ch·ªâ ch√≠nh th·ª©c support:
 * 1. React.lazy (code splitting)
 * 2. Data fetching libraries c√≥ Suspense support (React Query, SWR, etc.)
 *
 * Demo n√†y d√πng custom implementation ƒë·ªÉ HI·ªÇU CONCEPT.
 * Production code n√™n d√πng React Query ho·∫∑c t∆∞∆°ng t·ª±.
 */

// Utility: Wrap promise ƒë·ªÉ throw cho Suspense
function wrapPromise(promise) {
  let status = 'pending';
  let result;

  const suspender = promise.then(
    (data) => {
      status = 'success';
      result = data;
    },
    (error) => {
      status = 'error';
      result = error;
    },
  );

  return {
    read() {
      if (status === 'pending') {
        throw suspender; // React catches this!
      } else if (status === 'error') {
        throw result;
      } else {
        return result;
      }
    },
  };
}

// Fake API
function fetchUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: `User ${id}`, email: `user${id}@example.com` });
    }, 1000);
  });
}

// Resource (kh·ªüi t·∫°o NGO√ÄI component ƒë·ªÉ fetch ngay)
const userResource = wrapPromise(fetchUser(1));

// ‚úÖ Component v·ªõi Suspense
function User() {
  const user = userResource.read(); // Throw promise n·∫øu ch∆∞a s·∫µn s√†ng

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <h1>User Profile</h1>
      <Suspense fallback={<div>Loading user...</div>}>
        <User />
      </Suspense>
    </div>
  );
}

// K·∫øt qu·∫£:
// 1. App render ‚Üí Show "Loading user..."
// 2. User component throw promise
// 3. 1s sau: Promise resolve ‚Üí Re-render User ‚Üí Show data
```

### Demo 2: Multiple Suspense Boundaries ‚≠ê‚≠ê

```jsx
/**
 * Demo: Nested Suspense boundaries
 * Cho ph√©p independent loading states
 */

// Fake APIs
function fetchUser(id) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ id, name: `User ${id}` });
    }, 1000);
  });
}

function fetchPosts(userId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, title: 'Post 1', content: 'Content 1' },
        { id: 2, title: 'Post 2', content: 'Content 2' },
      ]);
    }, 2000); // Ch·∫≠m h∆°n user
  });
}

// Resources
const userResource = wrapPromise(fetchUser(1));
const postsResource = wrapPromise(fetchPosts(1));

// Components
function UserInfo() {
  const user = userResource.read();
  return <h2>{user.name}</h2>;
}

function PostList() {
  const posts = postsResource.read();
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}

// ‚úÖ Pattern: Nested Suspense boundaries
function Profile() {
  return (
    <div>
      {/* User loads fast ‚Üí Show immediately */}
      <Suspense fallback={<div>Loading user...</div>}>
        <UserInfo />
      </Suspense>

      {/* Posts load slower ‚Üí Independent loading */}
      <Suspense fallback={<div>Loading posts...</div>}>
        <PostList />
      </Suspense>
    </div>
  );
}

// Timeline:
// 0ms: Show "Loading user..." + "Loading posts..."
// 1000ms: User loaded ‚Üí Show user + Still "Loading posts..."
// 2000ms: Posts loaded ‚Üí Show posts

// ‚ùå So s√°nh: Single boundary
function ProfileSingleBoundary() {
  return (
    <Suspense fallback={<div>Loading everything...</div>}>
      <UserInfo />
      <PostList />
    </Suspense>
  );
}

// Timeline v·ªõi single boundary:
// 0ms: Show "Loading everything..."
// 2000ms: Show user + posts (ch·ªù c√°i ch·∫≠m nh·∫•t!)
// ‚Üí UX t·ªá h∆°n v√¨ user ph·∫£i ƒë·ª£i posts

// üí° QUY·∫æT ƒê·ªäNH:
// - Nested boundaries: Better UX, data hi·ªán d·∫ßn
// - Single boundary: ƒê∆°n gi·∫£n h∆°n, nh∆∞ng ch·∫≠m h∆°n
```

### Demo 3: Suspense + Error Boundary ‚≠ê‚≠ê‚≠ê

```jsx
/**
 * Demo: K·∫øt h·ª£p Suspense v·ªõi Error Boundary
 * Handle c·∫£ loading V√Ä error states
 */

import { Component } from 'react';

// Simple Error Boundary
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ color: 'red', padding: 20, border: '1px solid red' }}>
          <h3>‚ùå Error occurred!</h3>
          <p>{this.state.error.message}</p>
          <button onClick={() => this.setState({ hasError: false })}>
            Try Again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Fake API with error
function fetchUserUnstable(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.5) {
        resolve({ id, name: `User ${id}` });
      } else {
        reject(new Error('Failed to fetch user'));
      }
    }, 1000);
  });
}

const unstableResource = wrapPromise(fetchUserUnstable(1));

function UnstableUser() {
  const user = unstableResource.read(); // C√≥ th·ªÉ throw error!
  return <h2>{user.name}</h2>;
}

// ‚úÖ Pattern: Error Boundary b·ªçc Suspense
function SafeProfile() {
  return (
    <ErrorBoundary>
      <Suspense fallback={<div>Loading...</div>}>
        <UnstableUser />
      </Suspense>
    </ErrorBoundary>
  );
}

// Flow:
// 1. Suspense catch loading (throw promise)
// 2. Error Boundary catch errors (throw error)
// 3. Clean separation of concerns!

// ‚ùå WRONG: Suspense b·ªçc Error Boundary
function WrongOrder() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ErrorBoundary>
        <UnstableUser />
      </ErrorBoundary>
    </Suspense>
  );
}
// V·∫•n ƒë·ªÅ: Error Boundary b·ªã Suspense suspend ‚Üí Kh√¥ng catch ƒë∆∞·ª£c error ƒë√∫ng c√°ch
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Level 1: √Åp D·ª•ng Concept (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: T·∫°o Suspense boundary c∆° b·∫£n
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: Error Boundary, nested Suspense
 *
 * Requirements:
 * 1. Fetch danh s√°ch products (mock API)
 * 2. Show loading spinner khi ƒëang fetch
 * 3. Hi·ªÉn th·ªã products khi ƒë√£ load xong
 *
 * üí° G·ª£i √Ω: D√πng wrapPromise utility t·ª´ demo
 */

// Mock API
function fetchProducts() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, name: 'Laptop', price: 1200 },
        { id: 2, name: 'Phone', price: 800 },
        { id: 3, name: 'Tablet', price: 500 },
      ]);
    }, 1500);
  });
}

// TODO: T·∫°o resource

// TODO: T·∫°o ProductList component (ƒë·ªçc t·ª´ resource)

// TODO: T·∫°o App v·ªõi Suspense boundary

// Expected output:
// - Hi·ªÉn th·ªã "Loading products..." trong 1.5s
// - Sau ƒë√≥ hi·ªÉn th·ªã danh s√°ch 3 products
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Product List v·ªõi Suspense
 */

// Utility function
function wrapPromise(promise) {
  let status = 'pending';
  let result;

  const suspender = promise.then(
    (data) => {
      status = 'success';
      result = data;
    },
    (error) => {
      status = 'error';
      result = error;
    },
  );

  return {
    read() {
      if (status === 'pending') throw suspender;
      if (status === 'error') throw result;
      return result;
    },
  };
}

// Create resource (outside component - fetch immediately)
const productsResource = wrapPromise(fetchProducts());

function ProductList() {
  const products = productsResource.read();

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>
          {product.name} - ${product.price}
        </li>
      ))}
    </ul>
  );
}

function App() {
  return (
    <div>
      <h1>Product Catalog</h1>
      <Suspense fallback={<div>‚è≥ Loading products...</div>}>
        <ProductList />
      </Suspense>
    </div>
  );
}

// K·∫øt qu·∫£:
// 0ms: "‚è≥ Loading products..."
// 1500ms:
// - Laptop - $1200
// - Phone - $800
// - Tablet - $500
```

</details>

---

### ‚≠ê‚≠ê Level 2: Nh·∫≠n Bi·∫øt Pattern (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: So s√°nh Single vs Multiple Suspense boundaries
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Dashboard v·ªõi 3 sections:
 * - User info (load nhanh - 500ms)
 * - Recent activity (load trung b√¨nh - 1000ms)
 * - Analytics (load ch·∫≠m - 2000ms)
 *
 * ü§î PH√ÇN T√çCH:
 *
 * Approach A: Single Suspense Boundary
 * Pros:
 * - Code ƒë∆°n gi·∫£n
 * - T·∫•t c·∫£ data xu·∫•t hi·ªán c√πng l√∫c (consistent)
 *
 * Cons:
 * - User ƒë·ª£i l√¢u (2000ms)
 * - Waste time (user info ƒë√£ s·∫µn s√†ng t·ª´ 500ms)
 *
 * Approach B: Multiple Suspense Boundaries
 * Pros:
 * - Progressive loading (data hi·ªán d·∫ßn)
 * - Better perceived performance
 * - User th·∫•y content s·ªõm h∆°n
 *
 * Cons:
 * - Code ph·ª©c t·∫°p h∆°n
 * - Layout shift (n·∫øu kh√¥ng handle t·ªët)
 *
 * üí≠ B·∫†N CH·ªåN G√å V√Ä T·∫†I SAO?
 * Document quy·∫øt ƒë·ªãnh c·ªßa b·∫°n d·ª±a tr√™n:
 * - User experience priorities
 * - Data importance (critical vs nice-to-have)
 * - Loading time differences
 *
 * Sau ƒë√≥ implement c·∫£ 2 approaches ƒë·ªÉ so s√°nh.
 */

// Mock APIs v·ªõi timing kh√°c nhau
function fetchUserInfo() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ name: 'John Doe', email: 'john@example.com' });
    }, 500);
  });
}

function fetchRecentActivity() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, action: 'Logged in', time: '2 hours ago' },
        { id: 2, action: 'Updated profile', time: '1 day ago' },
      ]);
    }, 1000);
  });
}

function fetchAnalytics() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        pageViews: 1234,
        uniqueVisitors: 567,
        avgSessionTime: '5m 23s',
      });
    }, 2000);
  });
}

// TODO: Implement Approach A (Single boundary)
// TODO: Implement Approach B (Multiple boundaries)
// TODO: Add timing visualization ƒë·ªÉ th·∫•y r√µ kh√°c bi·ªát
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Dashboard - Single vs Multiple Suspense Boundaries
 */

// Resources
const userInfoResource = wrapPromise(fetchUserInfo());
const activityResource = wrapPromise(fetchRecentActivity());
const analyticsResource = wrapPromise(fetchAnalytics());

// Components
function UserInfo() {
  const user = userInfoResource.read();
  return (
    <div style={{ padding: 10, border: '1px solid blue' }}>
      <h3>üë§ User Info</h3>
      <p>Name: {user.name}</p>
      <p>Email: {user.email}</p>
    </div>
  );
}

function RecentActivity() {
  const activities = activityResource.read();
  return (
    <div style={{ padding: 10, border: '1px solid green' }}>
      <h3>üìä Recent Activity</h3>
      <ul>
        {activities.map((activity) => (
          <li key={activity.id}>
            {activity.action} - {activity.time}
          </li>
        ))}
      </ul>
    </div>
  );
}

function Analytics() {
  const data = analyticsResource.read();
  return (
    <div style={{ padding: 10, border: '1px solid orange' }}>
      <h3>üìà Analytics</h3>
      <p>Page Views: {data.pageViews}</p>
      <p>Unique Visitors: {data.uniqueVisitors}</p>
      <p>Avg Session: {data.avgSessionTime}</p>
    </div>
  );
}

// ‚ùå Approach A: Single Boundary
function DashboardSingleBoundary() {
  return (
    <div>
      <h2>Dashboard (Single Boundary)</h2>
      <Suspense fallback={<div>‚è≥ Loading dashboard...</div>}>
        <UserInfo />
        <RecentActivity />
        <Analytics />
      </Suspense>
      <p style={{ color: 'gray', fontSize: 12 }}>
        Timeline: Wait 2000ms ‚Üí Show everything
      </p>
    </div>
  );
}

// ‚úÖ Approach B: Multiple Boundaries
function DashboardMultipleBoundaries() {
  return (
    <div>
      <h2>Dashboard (Multiple Boundaries)</h2>

      <Suspense
        fallback={<div style={{ padding: 10 }}>‚è≥ Loading user...</div>}
      >
        <UserInfo />
      </Suspense>

      <Suspense
        fallback={<div style={{ padding: 10 }}>‚è≥ Loading activity...</div>}
      >
        <RecentActivity />
      </Suspense>

      <Suspense
        fallback={<div style={{ padding: 10 }}>‚è≥ Loading analytics...</div>}
      >
        <Analytics />
      </Suspense>

      <p style={{ color: 'gray', fontSize: 12 }}>
        Timeline: 500ms (user) ‚Üí 1000ms (activity) ‚Üí 2000ms (analytics)
      </p>
    </div>
  );
}

// üí≠ QUY·∫æT ƒê·ªäNH:
// T√¥i ch·ªçn Multiple Boundaries v√¨:
// 1. Data c√≥ timing r·∫•t kh√°c nhau (500ms vs 2000ms)
// 2. User info l√† critical ‚Üí c·∫ßn hi·ªán s·ªõm nh·∫•t
// 3. Analytics kh√¥ng qu√° quan tr·ªçng ‚Üí c√≥ th·ªÉ ƒë·ª£i
// 4. Better perceived performance (user th·∫•y progress)
//
// Trade-off accepted:
// - Code ph·ª©c t·∫°p h∆°n (3 Suspense thay v√¨ 1)
// - C·∫ßn prevent layout shift (d√πng min-height placeholder)

// K·∫øt qu·∫£:
// Single: ƒê·ª£i 2s ‚Üí Boom t·∫•t c·∫£ xu·∫•t hi·ªán
// Multiple: 500ms ‚Üí User | 1s ‚Üí Activity | 2s ‚Üí Analytics
```

</details>

---

### ‚≠ê‚≠ê‚≠ê Level 3: K·ªãch B·∫£n Th·ª±c T·∫ø (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: T·∫°o Product Detail Page v·ªõi Suspense
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën xem chi ti·∫øt product
 * v·ªõi recommendations, ƒë·ªÉ c√≥ th·ªÉ mua h√†ng informed decision"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Product info hi·ªán nhanh nh·∫•t (high priority)
 * - [ ] Reviews c√≥ th·ªÉ load ch·∫≠m (medium priority)
 * - [ ] Recommendations c√≥ th·ªÉ load ch·∫≠m (low priority)
 * - [ ] M·ªói section c√≥ loading state ri√™ng
 * - [ ] Handle error cho t·ª´ng section
 * - [ ] Skeleton loader realistic
 *
 * üé® Technical Constraints:
 * - Ph·∫£i d√πng nested Suspense boundaries
 * - Ph·∫£i c√≥ Error Boundary cho m·ªói critical section
 * - Loading states ph·∫£i c√≥ skeleton (kh√¥ng d√πng spinner text)
 *
 * üö® Edge Cases c·∫ßn handle:
 * - Product kh√¥ng t·ªìn t·∫°i (404)
 * - Network error khi fetch reviews
 * - Empty recommendations list
 * - Retry mechanism khi error
 *
 * üìù Implementation Checklist:
 * - [ ] Mock 3 APIs (product, reviews, recommendations)
 * - [ ] 3 components t∆∞∆°ng ·ª©ng
 * - [ ] 3 Suspense boundaries
 * - [ ] 2 Error Boundaries (product + reviews critical)
 * - [ ] Skeleton loaders
 * - [ ] Retry buttons
 */

// TODO: Implement ProductDetailPage
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Product Detail Page v·ªõi Suspense
 */

import { Component } from 'react';

// ============= ERROR BOUNDARY =============
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div
          style={{
            padding: 20,
            border: '2px solid red',
            borderRadius: 8,
            backgroundColor: '#fee',
          }}
        >
          <h3 style={{ color: 'red' }}>
            ‚ùå {this.props.errorTitle || 'Error'}
          </h3>
          <p>{this.state.error.message}</p>
          {this.props.onRetry && (
            <button
              onClick={() => {
                this.setState({ hasError: false });
                this.props.onRetry();
              }}
              style={{
                padding: '8px 16px',
                backgroundColor: '#ef4444',
                color: 'white',
                border: 'none',
                borderRadius: 4,
                cursor: 'pointer',
              }}
            >
              üîÑ Retry
            </button>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}

// ============= MOCK APIS =============
function fetchProduct(id) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (id === '404') {
        reject(new Error('Product not found'));
      } else {
        resolve({
          id,
          name: 'Premium Laptop',
          price: 1299,
          description: 'High-performance laptop for professionals',
          inStock: true,
        });
      }
    }, 500);
  });
}

function fetchReviews(productId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.7) {
        // 30% error rate
        reject(new Error('Failed to load reviews'));
      } else {
        resolve([
          { id: 1, author: 'Alice', rating: 5, text: 'Excellent!' },
          { id: 2, author: 'Bob', rating: 4, text: 'Good value' },
          { id: 3, author: 'Charlie', rating: 5, text: 'Amazing quality' },
        ]);
      }
    }, 1200);
  });
}

function fetchRecommendations(productId) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 101, name: 'Laptop Bag', price: 49 },
        { id: 102, name: 'Wireless Mouse', price: 29 },
        { id: 103, name: 'USB-C Hub', price: 39 },
      ]);
    }, 1800);
  });
}

// ============= RESOURCES =============
// Note: Real app s·∫Ω t·∫°o resources dynamically d·ª±a v√†o productId
const productResource = wrapPromise(fetchProduct('123'));
const reviewsResource = wrapPromise(fetchReviews('123'));
const recommendationsResource = wrapPromise(fetchRecommendations('123'));

// ============= SKELETON LOADERS =============
function ProductSkeleton() {
  return (
    <div style={{ padding: 20, backgroundColor: '#f3f4f6', borderRadius: 8 }}>
      <div
        style={{
          width: '60%',
          height: 32,
          backgroundColor: '#d1d5db',
          marginBottom: 16,
        }}
      />
      <div
        style={{
          width: '30%',
          height: 24,
          backgroundColor: '#d1d5db',
          marginBottom: 12,
        }}
      />
      <div style={{ width: '100%', height: 80, backgroundColor: '#d1d5db' }} />
    </div>
  );
}

function ReviewsSkeleton() {
  return (
    <div style={{ padding: 20 }}>
      {[1, 2, 3].map((i) => (
        <div
          key={i}
          style={{ marginBottom: 12 }}
        >
          <div
            style={{
              width: '40%',
              height: 16,
              backgroundColor: '#d1d5db',
              marginBottom: 8,
            }}
          />
          <div
            style={{ width: '80%', height: 12, backgroundColor: '#d1d5db' }}
          />
        </div>
      ))}
    </div>
  );
}

function RecommendationsSkeleton() {
  return (
    <div style={{ display: 'flex', gap: 12, padding: 20 }}>
      {[1, 2, 3].map((i) => (
        <div
          key={i}
          style={{
            width: 150,
            height: 200,
            backgroundColor: '#d1d5db',
            borderRadius: 8,
          }}
        />
      ))}
    </div>
  );
}

// ============= COMPONENTS =============
function ProductInfo() {
  const product = productResource.read();

  return (
    <div style={{ padding: 20, border: '2px solid #3b82f6', borderRadius: 8 }}>
      <h2>{product.name}</h2>
      <p style={{ fontSize: 24, color: '#059669', fontWeight: 'bold' }}>
        ${product.price}
      </p>
      <p>{product.description}</p>
      <p>
        Stock:{' '}
        {product.inStock ? (
          <span style={{ color: 'green' }}>‚úÖ In Stock</span>
        ) : (
          <span style={{ color: 'red' }}>‚ùå Out of Stock</span>
        )}
      </p>
      <button
        style={{
          padding: '12px 24px',
          backgroundColor: '#3b82f6',
          color: 'white',
          border: 'none',
          borderRadius: 4,
          cursor: 'pointer',
          fontSize: 16,
        }}
      >
        Add to Cart
      </button>
    </div>
  );
}

function Reviews() {
  const reviews = reviewsResource.read();

  return (
    <div style={{ padding: 20, border: '1px solid #e5e7eb', borderRadius: 8 }}>
      <h3>‚≠ê Customer Reviews ({reviews.length})</h3>
      {reviews.map((review) => (
        <div
          key={review.id}
          style={{
            marginBottom: 12,
            padding: 12,
            backgroundColor: '#f9fafb',
            borderRadius: 4,
          }}
        >
          <div style={{ fontWeight: 'bold' }}>
            {review.author} - {'‚≠ê'.repeat(review.rating)}
          </div>
          <p>{review.text}</p>
        </div>
      ))}
    </div>
  );
}

function Recommendations() {
  const products = recommendationsResource.read();

  if (products.length === 0) {
    return <p>No recommendations available</p>;
  }

  return (
    <div style={{ padding: 20 }}>
      <h3>üõçÔ∏è You Might Also Like</h3>
      <div style={{ display: 'flex', gap: 12 }}>
        {products.map((product) => (
          <div
            key={product.id}
            style={{
              width: 150,
              padding: 12,
              border: '1px solid #e5e7eb',
              borderRadius: 8,
            }}
          >
            <div
              style={{
                width: '100%',
                height: 100,
                backgroundColor: '#f3f4f6',
                marginBottom: 8,
                borderRadius: 4,
              }}
            />
            <h4 style={{ fontSize: 14 }}>{product.name}</h4>
            <p style={{ color: '#059669' }}>${product.price}</p>
          </div>
        ))}
      </div>
    </div>
  );
}

// ============= MAIN COMPONENT =============
function ProductDetailPage() {
  return (
    <div style={{ maxWidth: 1200, margin: '0 auto', padding: 20 }}>
      <h1>Product Details</h1>

      {/* HIGH PRIORITY: Product Info */}
      <ErrorBoundary
        errorTitle='Failed to load product'
        onRetry={() => window.location.reload()}
      >
        <Suspense fallback={<ProductSkeleton />}>
          <ProductInfo />
        </Suspense>
      </ErrorBoundary>

      {/* MEDIUM PRIORITY: Reviews */}
      <div style={{ marginTop: 20 }}>
        <ErrorBoundary
          errorTitle='Failed to load reviews'
          onRetry={() => window.location.reload()}
        >
          <Suspense fallback={<ReviewsSkeleton />}>
            <Reviews />
          </Suspense>
        </ErrorBoundary>
      </div>

      {/* LOW PRIORITY: Recommendations (no error boundary - graceful degradation) */}
      <div style={{ marginTop: 20 }}>
        <Suspense fallback={<RecommendationsSkeleton />}>
          <Recommendations />
        </Suspense>
      </div>
    </div>
  );
}

// K·∫øt qu·∫£:
// 0ms: ProductSkeleton + ReviewsSkeleton + RecommendationsSkeleton
// 500ms: Product loaded ‚Üí Real product + Still loading reviews & recs
// 1200ms: Reviews loaded (ho·∫∑c error) ‚Üí Real reviews + Still loading recs
// 1800ms: Recommendations loaded ‚Üí Real recommendations
//
// Error scenarios:
// - Product error ‚Üí Show error + retry (critical)
// - Reviews error ‚Üí Show error + retry (important)
// - Recommendations error ‚Üí Kh√¥ng c√≥ error boundary, component t·ª± handle
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê Level 4: Quy·∫øt ƒê·ªãnh Ki·∫øn Tr√∫c (60 ph√∫t)

````jsx
/**
 * üéØ M·ª•c ti√™u: Thi·∫øt k·∫ø Suspense architecture cho Social Feed
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Scenario: News feed v·ªõi infinite scroll
 * - Initial posts (fast - 500ms)
 * - User recommendations (medium - 1000ms)
 * - Trending topics (slow - 1500ms)
 * - Ads (medium - 800ms)
 *
 * Nhi·ªám v·ª•:
 * 1. So s√°nh √≠t nh·∫•t 3 approaches:
 *    A. Single Suspense - Load t·∫•t c·∫£ c√πng l√∫c
 *    B. Section-based Suspense - M·ªói section ri√™ng
 *    C. Hybrid - Critical content chung, non-critical ri√™ng
 *
 * 2. Document pros/cons m·ªói approach:
 *    - User experience impact
 *    - Performance characteristics
 *    - Code complexity
 *    - Maintainability
 *
 * 3. Ch·ªçn approach ph√π h·ª£p nh·∫•t
 *
 * 4. Vi·∫øt ADR (Architecture Decision Record):
 *
 * ADR Template:
 * ```markdown
 * # ADR: Suspense Strategy for Social Feed
 *
 * ## Context
 * News feed c√≥ 4 sections v·ªõi loading times kh√°c nhau.
 * Users expect: Fast initial load + Progressive content.
 *
 * ## Decision
 * [Approach ƒë√£ ch·ªçn]
 *
 * ## Rationale
 * [T·∫°i sao ch·ªçn approach n√†y]
 * - User experience benefits: ...
 * - Performance gains: ...
 * - Development trade-offs: ...
 *
 * ## Consequences
 * Positive:
 * - ...
 *
 * Negative:
 * - ...
 *
 * Trade-offs accepted:
 * - ...
 *
 * ## Alternatives Considered
 * 1. Approach A: [T·∫°i sao kh√¥ng ch·ªçn]
 * 2. Approach B: [T·∫°i sao kh√¥ng ch·ªçn]
 * ```
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 * Implement approach ƒë√£ ch·ªçn v·ªõi:
 * - All 4 sections
 * - Proper error handling
 * - Skeleton loaders
 * - Retry mechanisms
 *
 * üß™ PHASE 3: Testing (10 ph√∫t)
 * Manual testing checklist:
 * - [ ] Fast network: All sections load smoothly
 * - [ ] Slow network: Progressive loading works
 * - [ ] Network error: Error boundaries catch properly
 * - [ ] Retry: Works for each section
 * - [ ] Layout: No significant shifts
 */

// TODO: Write ADR
// TODO: Implement chosen approach
// TODO: Test all scenarios
````

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Social Feed with Suspense Architecture
 */

// ============= ADR =============
/*
# ADR: Suspense Strategy for Social Feed

## Context
News feed c√≥ 4 sections v·ªõi loading times kh√°c nhau:
- Posts: 500ms (critical - user ƒë·∫øn ƒë·ªÉ xem posts)
- Recommendations: 1000ms (important - engagement driver)
- Trending: 1500ms (nice-to-have - supplementary content)
- Ads: 800ms (revenue critical nh∆∞ng kh√¥ng ·∫£nh h∆∞·ªüng UX)

Users expect: Fast initial load, content appearing progressively.
Business needs: Ads ph·∫£i hi·ªán, nh∆∞ng kh√¥ng block content.

## Decision
HYBRID APPROACH:
- Single Suspense cho Posts + Ads (critical path)
- Separate Suspense cho Recommendations
- Separate Suspense cho Trending
- Error Boundary b·ªçc Posts (most critical)
- No Error Boundary cho Ads (graceful degradation)

## Rationale

### User Experience:
1. Posts l√† m·ª•c ƒë√≠ch ch√≠nh ‚Üí Ph·∫£i load nhanh
2. Ads load c√πng Posts ‚Üí Revenue nh∆∞ng kh√¥ng slow down Posts
3. Recommendations c√≥ Suspense ri√™ng ‚Üí Appear sau Posts
4. Trending c√≥ Suspense ri√™ng ‚Üí Least important

### Performance:
- Posts + Ads load parallel ‚Üí Max 800ms wait
- Total perceived load time: 800ms vs 1500ms (single boundary)
- 46% faster perceived performance!

### Development:
- Moderate complexity (3 Suspense boundaries)
- Clear separation of concerns
- Easy to adjust priorities later

## Consequences

Positive:
+ Fast initial content (800ms vs 1500ms)
+ Progressive enhancement UX
+ Flexible loading priorities
+ Easy to A/B test different strategies

Negative:
- More Suspense boundaries to manage
- Potential layout shift (mitigated with skeletons)
- Slightly more complex code

Trade-offs accepted:
- Code complexity for better UX
- More boundaries for flexibility
- Layout shift risk for progressive loading

## Alternatives Considered

1. Single Suspense (All together):
   ‚ùå Rejected: 1500ms wait unacceptable
   ‚ùå No progressive loading
   ‚úÖ Simplest code
   
2. Section-based (4 separate):
   ‚ùå Too many loading states
   ‚ùå Ads blocking would hurt revenue
   ‚úÖ Maximum flexibility
   
3. Hybrid (Chosen):
   ‚úÖ Balance UX + Business needs
   ‚úÖ Fast perceived performance
   ‚öñÔ∏è Moderate complexity
*/

// ============= MOCK APIS =============
function fetchPosts() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        {
          id: 1,
          author: 'Alice',
          content: 'Just learned React Suspense!',
          likes: 42,
        },
        { id: 2, author: 'Bob', content: 'Building amazing UIs', likes: 38 },
        {
          id: 3,
          author: 'Charlie',
          content: 'TypeScript is awesome',
          likes: 55,
        },
      ]);
    }, 500);
  });
}

function fetchAds() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, title: 'Premium Course', description: 'Learn React' },
        { id: 2, title: 'New Product', description: 'Check it out!' },
      ]);
    }, 800);
  });
}

function fetchRecommendations() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, name: 'Dave', followers: 1234 },
        { id: 2, name: 'Eve', followers: 5678 },
        { id: 3, name: 'Frank', followers: 910 },
      ]);
    }, 1000);
  });
}

function fetchTrending() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 1, topic: '#ReactJS', posts: 12500 },
        { id: 2, topic: '#TypeScript', posts: 8900 },
        { id: 3, topic: '#WebDev', posts: 15600 },
      ]);
    }, 1500);
  });
}

// ============= RESOURCES =============
const postsResource = wrapPromise(fetchPosts());
const adsResource = wrapPromise(fetchAds());
const recommendationsResource = wrapPromise(fetchRecommendations());
const trendingResource = wrapPromise(fetchTrending());

// ============= SKELETONS =============
function PostsSkeleton() {
  return (
    <div>
      {[1, 2, 3].map((i) => (
        <div
          key={i}
          style={{
            padding: 16,
            marginBottom: 12,
            backgroundColor: '#f3f4f6',
            borderRadius: 8,
          }}
        >
          <div
            style={{
              width: '30%',
              height: 16,
              backgroundColor: '#d1d5db',
              marginBottom: 8,
            }}
          />
          <div
            style={{
              width: '80%',
              height: 12,
              backgroundColor: '#d1d5db',
              marginBottom: 8,
            }}
          />
          <div
            style={{ width: '20%', height: 12, backgroundColor: '#d1d5db' }}
          />
        </div>
      ))}
    </div>
  );
}

function AdsSkeleton() {
  return (
    <div
      style={{
        padding: 16,
        backgroundColor: '#fef3c7',
        borderRadius: 8,
        marginBottom: 12,
      }}
    >
      <div
        style={{
          width: '40%',
          height: 16,
          backgroundColor: '#fcd34d',
          marginBottom: 8,
        }}
      />
      <div style={{ width: '60%', height: 12, backgroundColor: '#fcd34d' }} />
    </div>
  );
}

// ============= COMPONENTS =============
function Posts() {
  const posts = postsResource.read();

  return (
    <div>
      <h3>üì∞ Feed</h3>
      {posts.map((post) => (
        <div
          key={post.id}
          style={{
            padding: 16,
            marginBottom: 12,
            border: '1px solid #e5e7eb',
            borderRadius: 8,
          }}
        >
          <div style={{ fontWeight: 'bold', marginBottom: 8 }}>
            {post.author}
          </div>
          <p>{post.content}</p>
          <div style={{ color: '#6b7280' }}>‚ù§Ô∏è {post.likes} likes</div>
        </div>
      ))}
    </div>
  );
}

function Ads() {
  const ads = adsResource.read();

  return (
    <div>
      {ads.map((ad) => (
        <div
          key={ad.id}
          style={{
            padding: 16,
            marginBottom: 12,
            backgroundColor: '#fef3c7',
            border: '1px solid #fcd34d',
            borderRadius: 8,
          }}
        >
          <div style={{ fontSize: 12, color: '#92400e', marginBottom: 4 }}>
            Sponsored
          </div>
          <div style={{ fontWeight: 'bold' }}>{ad.title}</div>
          <p style={{ fontSize: 14 }}>{ad.description}</p>
        </div>
      ))}
    </div>
  );
}

function Recommendations() {
  const users = recommendationsResource.read();

  return (
    <div
      style={{
        padding: 16,
        backgroundColor: '#f9fafb',
        borderRadius: 8,
      }}
    >
      <h4>üë• Suggested Users</h4>
      {users.map((user) => (
        <div
          key={user.id}
          style={{
            padding: 12,
            marginBottom: 8,
            backgroundColor: 'white',
            borderRadius: 4,
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
          }}
        >
          <div>
            <div style={{ fontWeight: 'bold' }}>{user.name}</div>
            <div style={{ fontSize: 12, color: '#6b7280' }}>
              {user.followers} followers
            </div>
          </div>
          <button
            style={{
              padding: '6px 12px',
              backgroundColor: '#3b82f6',
              color: 'white',
              border: 'none',
              borderRadius: 4,
              cursor: 'pointer',
            }}
          >
            Follow
          </button>
        </div>
      ))}
    </div>
  );
}

function Trending() {
  const topics = trendingResource.read();

  return (
    <div
      style={{
        padding: 16,
        backgroundColor: '#f9fafb',
        borderRadius: 8,
      }}
    >
      <h4>üî• Trending</h4>
      {topics.map((topic) => (
        <div
          key={topic.id}
          style={{
            padding: 12,
            marginBottom: 8,
            backgroundColor: 'white',
            borderRadius: 4,
          }}
        >
          <div style={{ fontWeight: 'bold', color: '#3b82f6' }}>
            {topic.topic}
          </div>
          <div style={{ fontSize: 12, color: '#6b7280' }}>
            {topic.posts.toLocaleString()} posts
          </div>
        </div>
      ))}
    </div>
  );
}

// ============= MAIN FEED =============
function SocialFeed() {
  return (
    <div style={{ maxWidth: 1200, margin: '0 auto', padding: 20 }}>
      <h1>Social Feed</h1>

      <div style={{ display: 'grid', gridTemplateColumns: '2fr 1fr', gap: 20 }}>
        {/* LEFT COLUMN: Posts + Ads (Critical Path) */}
        <div>
          <ErrorBoundary errorTitle='Failed to load feed'>
            <Suspense
              fallback={
                <>
                  <PostsSkeleton />
                  <AdsSkeleton />
                </>
              }
            >
              <Posts />
              <Ads />
            </Suspense>
          </ErrorBoundary>
        </div>

        {/* RIGHT COLUMN: Sidebar */}
        <div>
          {/* Recommendations - Important but not critical */}
          <Suspense
            fallback={
              <div
                style={{
                  padding: 16,
                  backgroundColor: '#f3f4f6',
                  borderRadius: 8,
                  height: 200,
                }}
              >
                <div
                  style={{
                    width: '60%',
                    height: 16,
                    backgroundColor: '#d1d5db',
                    marginBottom: 12,
                  }}
                />
                <div
                  style={{
                    width: '80%',
                    height: 12,
                    backgroundColor: '#d1d5db',
                    marginBottom: 8,
                  }}
                />
                <div
                  style={{
                    width: '80%',
                    height: 12,
                    backgroundColor: '#d1d5db',
                  }}
                />
              </div>
            }
          >
            <Recommendations />
          </Suspense>

          {/* Trending - Least critical */}
          <div style={{ marginTop: 20 }}>
            <Suspense
              fallback={
                <div
                  style={{
                    padding: 16,
                    backgroundColor: '#f3f4f6',
                    borderRadius: 8,
                    height: 200,
                  }}
                >
                  <div
                    style={{
                      width: '60%',
                      height: 16,
                      backgroundColor: '#d1d5db',
                      marginBottom: 12,
                    }}
                  />
                  <div
                    style={{
                      width: '80%',
                      height: 12,
                      backgroundColor: '#d1d5db',
                      marginBottom: 8,
                    }}
                  />
                  <div
                    style={{
                      width: '80%',
                      height: 12,
                      backgroundColor: '#d1d5db',
                    }}
                  />
                </div>
              }
            >
              <Trending />
            </Suspense>
          </div>
        </div>
      </div>

      {/* Timeline Visualization */}
      <div
        style={{
          marginTop: 40,
          padding: 20,
          backgroundColor: '#f3f4f6',
          borderRadius: 8,
        }}
      >
        <h4>üìä Loading Timeline (Hybrid Approach)</h4>
        <div style={{ fontFamily: 'monospace', fontSize: 12 }}>
          <div>0ms: Show skeletons for all sections</div>
          <div style={{ color: '#059669' }}>500ms: ‚úÖ Posts loaded</div>
          <div style={{ color: '#059669' }}>
            800ms: ‚úÖ Ads loaded (critical path complete!)
          </div>
          <div style={{ color: '#3b82f6' }}>
            1000ms: ‚úÖ Recommendations loaded
          </div>
          <div style={{ color: '#6b7280' }}>1500ms: ‚úÖ Trending loaded</div>
        </div>
        <p style={{ marginTop: 12, fontSize: 14, color: '#6b7280' }}>
          vs Single Boundary: 1500ms wait ‚Üí All at once
          <br />
          Improvement: 46% faster perceived performance (800ms vs 1500ms)
        </p>
      </div>
    </div>
  );
}

// Manual Testing Checklist:
// ‚úÖ Fast network: Posts‚ÜíAds‚ÜíRecommendations‚ÜíTrending loads smoothly
// ‚úÖ Slow network: Progressive loading visible
// ‚úÖ Network error: Error boundary catches Posts errors
// ‚úÖ Retry: Error boundary retry button works
// ‚úÖ Layout: Skeletons prevent major layout shifts
// ‚úÖ Ads failure: Feed still works (graceful degradation)
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Level 5: Production Challenge (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: E-commerce Search Results Page
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 *
 * Search results page v·ªõi:
 * 1. Product grid (critical - 600ms)
 * 2. Filters sidebar (important - 400ms)
 * 3. Sorting options (fast - 200ms)
 * 4. Recommended searches (slow - 1000ms)
 * 5. Recently viewed (medium - 800ms)
 *
 * User interactions:
 * - Apply filters ‚Üí Re-fetch products (with useTransition)
 * - Change sort ‚Üí Re-fetch products (instant)
 * - Load more ‚Üí Append products (optimistic)
 *
 * üèóÔ∏è Technical Design Doc:
 *
 * 1. Component Architecture:
 *    - SearchResultsPage (container)
 *    - ProductGrid (list + items)
 *    - FilterSidebar (checkboxes)
 *    - SortBar (dropdown)
 *    - RecommendedSearches (chips)
 *    - RecentlyViewed (carousel)
 *
 * 2. State Management Strategy:
 *    - URL params cho filters/sort (future: router)
 *    - useState cho filter selections
 *    - useTransition cho filter updates
 *    - Resources cho data fetching
 *
 * 3. Suspense Strategy:
 *    - Critical path: Sorting + Filters + Products (single boundary)
 *    - Non-critical: Recommended + Recently viewed (separate)
 *    - Error handling: Products critical, others graceful
 *
 * 4. Performance Considerations:
 *    - Skeleton loaders prevent layout shift
 *    - useTransition keeps UI responsive during filter changes
 *    - Optimistic updates for "Load More"
 *
 * 5. Error Handling Strategy:
 *    - Products: Show error + retry
 *    - Filters: Fallback to default
 *    - Recommendations: Hide section
 *
 * ‚úÖ Production Checklist:
 * - [ ] TypeScript types ƒë·∫ßy ƒë·ªß (ho·∫∑c JSDoc comments)
 * - [ ] Error boundaries properly placed
 * - [ ] Loading states v·ªõi skeletons
 * - [ ] Empty states ("No results found")
 * - [ ] Error states v·ªõi retry
 * - [ ] Accessible (keyboard navigation, ARIA labels)
 * - [ ] Performance optimized (Suspense boundaries)
 * - [ ] Mobile responsive layout
 *
 * üìù Documentation:
 * - Component structure diagram
 * - Data flow explanation
 * - Suspense boundaries rationale
 *
 * üîç Code Review Self-Checklist:
 * - [ ] Kh√¥ng d√πng concepts ch∆∞a h·ªçc (router, external libs)
 * - [ ] Proper error handling everywhere
 * - [ ] Loading states realistic
 * - [ ] Code c√≥ comments gi·∫£i th√≠ch decisions
 * - [ ] Naming conventions consistent
 */

// TODO: Implement full search results page
// G·ª£i √Ω: B·∫Øt ƒë·∫ßu v·ªõi component structure, sau ƒë√≥ t·ª´ng ph·∫ßn
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * E-commerce Search Results Page - Production Ready
 *
 * Architecture:
 * - Critical Path: Sort + Filters + Products (400ms-600ms)
 * - Non-Critical: Recommendations (1000ms) + Recent (800ms)
 * - Error Boundaries: Products (critical), others (graceful)
 */

import { useState, useTransition } from 'react';

// ============= TYPE DEFINITIONS (JSDoc) =============
/**
 * @typedef {Object} Product
 * @property {string} id
 * @property {string} name
 * @property {number} price
 * @property {string} category
 * @property {number} rating
 * @property {boolean} inStock
 */

/**
 * @typedef {Object} FilterOptions
 * @property {string[]} categories
 * @property {number} minPrice
 * @property {number} maxPrice
 */

// ============= MOCK APIS =============
/**
 * Fetch products v·ªõi filters
 * @param {Object} params
 * @param {string} params.query - Search query
 * @param {string[]} params.categories - Selected categories
 * @param {string} params.sortBy - Sort option
 * @returns {Promise<Product[]>}
 */
function fetchProducts({ query, categories, sortBy }) {
  return new Promise((resolve) => {
    setTimeout(() => {
      let products = [
        {
          id: '1',
          name: 'Laptop Pro',
          price: 1299,
          category: 'Electronics',
          rating: 4.5,
          inStock: true,
        },
        {
          id: '2',
          name: 'Wireless Mouse',
          price: 29,
          category: 'Electronics',
          rating: 4.2,
          inStock: true,
        },
        {
          id: '3',
          name: 'Office Chair',
          price: 399,
          category: 'Furniture',
          rating: 4.7,
          inStock: false,
        },
        {
          id: '4',
          name: 'Desk Lamp',
          price: 45,
          category: 'Furniture',
          rating: 4.0,
          inStock: true,
        },
        {
          id: '5',
          name: 'Keyboard',
          price: 79,
          category: 'Electronics',
          rating: 4.4,
          inStock: true,
        },
        {
          id: '6',
          name: 'Monitor',
          price: 299,
          category: 'Electronics',
          rating: 4.6,
          inStock: true,
        },
      ];

      // Filter by categories
      if (categories.length > 0) {
        products = products.filter((p) => categories.includes(p.category));
      }

      // Sort
      if (sortBy === 'price-asc') {
        products.sort((a, b) => a.price - b.price);
      } else if (sortBy === 'price-desc') {
        products.sort((a, b) => b.price - a.price);
      } else if (sortBy === 'rating') {
        products.sort((a, b) => b.rating - a.rating);
      }

      resolve(products);
    }, 600);
  });
}

function fetchFilterOptions() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        categories: ['Electronics', 'Furniture', 'Clothing', 'Books'],
        minPrice: 0,
        maxPrice: 2000,
      });
    }, 400);
  });
}

function fetchRecommendedSearches() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        'laptop deals',
        'office setup',
        'gaming accessories',
        'ergonomic chairs',
      ]);
    }, 1000);
  });
}

function fetchRecentlyViewed() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { id: 'r1', name: 'Gaming Laptop', price: 1599 },
        { id: 'r2', name: 'Mechanical Keyboard', price: 129 },
        { id: 'r3', name: 'Webcam HD', price: 89 },
      ]);
    }, 800);
  });
}

// ============= UTILITY =============
function wrapPromise(promise) {
  let status = 'pending';
  let result;

  const suspender = promise.then(
    (data) => {
      status = 'success';
      result = data;
    },
    (error) => {
      status = 'error';
      result = error;
    },
  );

  return {
    read() {
      if (status === 'pending') throw suspender;
      if (status === 'error') throw result;
      return result;
    },
  };
}

// ============= ERROR BOUNDARY =============
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div
          style={{
            padding: 24,
            border: '2px solid #ef4444',
            borderRadius: 8,
            backgroundColor: '#fee',
            textAlign: 'center',
          }}
        >
          <h3 style={{ color: '#dc2626', marginBottom: 8 }}>
            ‚ö†Ô∏è Something went wrong
          </h3>
          <p style={{ color: '#991b1b', marginBottom: 16 }}>
            {this.state.error.message}
          </p>
          {this.props.onRetry && (
            <button
              onClick={() => {
                this.setState({ hasError: false });
                this.props.onRetry();
              }}
              style={{
                padding: '10px 20px',
                backgroundColor: '#ef4444',
                color: 'white',
                border: 'none',
                borderRadius: 6,
                cursor: 'pointer',
                fontSize: 14,
                fontWeight: 600,
              }}
            >
              Try Again
            </button>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}

// ============= SKELETONS =============
function ProductGridSkeleton() {
  return (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
        gap: 16,
      }}
    >
      {[1, 2, 3, 4, 5, 6].map((i) => (
        <div
          key={i}
          style={{
            padding: 16,
            border: '1px solid #e5e7eb',
            borderRadius: 8,
            backgroundColor: '#f9fafb',
          }}
        >
          <div
            style={{
              width: '100%',
              height: 200,
              backgroundColor: '#d1d5db',
              marginBottom: 12,
              borderRadius: 4,
            }}
          />
          <div
            style={{
              width: '80%',
              height: 20,
              backgroundColor: '#d1d5db',
              marginBottom: 8,
            }}
          />
          <div
            style={{
              width: '40%',
              height: 16,
              backgroundColor: '#d1d5db',
              marginBottom: 8,
            }}
          />
          <div
            style={{ width: '60%', height: 16, backgroundColor: '#d1d5db' }}
          />
        </div>
      ))}
    </div>
  );
}

function FilterSkeleton() {
  return (
    <div style={{ padding: 16, backgroundColor: '#f9fafb', borderRadius: 8 }}>
      <div
        style={{
          width: '60%',
          height: 20,
          backgroundColor: '#d1d5db',
          marginBottom: 16,
        }}
      />
      {[1, 2, 3, 4].map((i) => (
        <div
          key={i}
          style={{ marginBottom: 12 }}
        >
          <div
            style={{ width: '80%', height: 16, backgroundColor: '#d1d5db' }}
          />
        </div>
      ))}
    </div>
  );
}

// ============= COMPONENTS =============

/**
 * Filter Sidebar Component
 */
function FilterSidebar({ selectedCategories, onCategoryChange }) {
  const filterOptions = filterOptionsResource.read();

  return (
    <div
      style={{
        padding: 20,
        backgroundColor: 'white',
        border: '1px solid #e5e7eb',
        borderRadius: 8,
        position: 'sticky',
        top: 20,
      }}
    >
      <h3 style={{ marginBottom: 16, fontSize: 18 }}>Filters</h3>

      <div style={{ marginBottom: 24 }}>
        <h4 style={{ marginBottom: 12, fontSize: 14, fontWeight: 600 }}>
          Categories
        </h4>
        {filterOptions.categories.map((category) => (
          <label
            key={category}
            style={{ display: 'block', marginBottom: 8, cursor: 'pointer' }}
          >
            <input
              type='checkbox'
              checked={selectedCategories.includes(category)}
              onChange={(e) => {
                if (e.target.checked) {
                  onCategoryChange([...selectedCategories, category]);
                } else {
                  onCategoryChange(
                    selectedCategories.filter((c) => c !== category),
                  );
                }
              }}
              style={{ marginRight: 8 }}
            />
            {category}
          </label>
        ))}
      </div>

      <button
        onClick={() => onCategoryChange([])}
        style={{
          width: '100%',
          padding: '8px 12px',
          backgroundColor: '#f3f4f6',
          border: '1px solid #d1d5db',
          borderRadius: 4,
          cursor: 'pointer',
          fontSize: 14,
        }}
      >
        Clear All
      </button>
    </div>
  );
}

/**
 * Sort Bar Component
 */
function SortBar({ sortBy, onSortChange, resultsCount }) {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: 20,
        padding: 16,
        backgroundColor: 'white',
        border: '1px solid #e5e7eb',
        borderRadius: 8,
      }}
    >
      <div style={{ fontSize: 14, color: '#6b7280' }}>
        {resultsCount} results found
      </div>

      <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
        <label style={{ fontSize: 14, fontWeight: 500 }}>Sort by:</label>
        <select
          value={sortBy}
          onChange={(e) => onSortChange(e.target.value)}
          style={{
            padding: '6px 12px',
            border: '1px solid #d1d5db',
            borderRadius: 4,
            fontSize: 14,
            cursor: 'pointer',
          }}
        >
          <option value='relevance'>Relevance</option>
          <option value='price-asc'>Price: Low to High</option>
          <option value='price-desc'>Price: High to Low</option>
          <option value='rating'>Highest Rated</option>
        </select>
      </div>
    </div>
  );
}

/**
 * Product Grid Component
 */
function ProductGrid() {
  const products = productsResource.read();

  if (products.length === 0) {
    return (
      <div
        style={{
          padding: 60,
          textAlign: 'center',
          backgroundColor: '#f9fafb',
          borderRadius: 8,
        }}
      >
        <div style={{ fontSize: 48, marginBottom: 16 }}>üîç</div>
        <h3 style={{ marginBottom: 8 }}>No products found</h3>
        <p style={{ color: '#6b7280' }}>Try adjusting your filters</p>
      </div>
    );
  }

  return (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
        gap: 16,
      }}
    >
      {products.map((product) => (
        <div
          key={product.id}
          style={{
            padding: 16,
            border: '1px solid #e5e7eb',
            borderRadius: 8,
            backgroundColor: 'white',
            transition: 'box-shadow 0.2s',
            cursor: 'pointer',
          }}
          onMouseEnter={(e) => {
            e.currentTarget.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
          }}
          onMouseLeave={(e) => {
            e.currentTarget.style.boxShadow = 'none';
          }}
        >
          {/* Product Image Placeholder */}
          <div
            style={{
              width: '100%',
              height: 200,
              backgroundColor: '#f3f4f6',
              borderRadius: 4,
              marginBottom: 12,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: 48,
            }}
          >
            üì¶
          </div>

          <h4 style={{ marginBottom: 8, fontSize: 16 }}>{product.name}</h4>

          <div
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: 8,
            }}
          >
            <span
              style={{ fontSize: 18, fontWeight: 'bold', color: '#059669' }}
            >
              ${product.price}
            </span>
            <span style={{ fontSize: 14, color: '#6b7280' }}>
              ‚≠ê {product.rating}
            </span>
          </div>

          <div
            style={{
              fontSize: 12,
              color: product.inStock ? '#059669' : '#dc2626',
            }}
          >
            {product.inStock ? '‚úì In Stock' : '‚úó Out of Stock'}
          </div>

          <button
            style={{
              width: '100%',
              marginTop: 12,
              padding: '8px 16px',
              backgroundColor: product.inStock ? '#3b82f6' : '#d1d5db',
              color: 'white',
              border: 'none',
              borderRadius: 4,
              cursor: product.inStock ? 'pointer' : 'not-allowed',
              fontSize: 14,
              fontWeight: 600,
            }}
            disabled={!product.inStock}
          >
            {product.inStock ? 'Add to Cart' : 'Out of Stock'}
          </button>
        </div>
      ))}
    </div>
  );
}

/**
 * Recommended Searches Component
 */
function RecommendedSearches() {
  const searches = recommendedSearchesResource.read();

  return (
    <div
      style={{
        padding: 16,
        backgroundColor: '#f9fafb',
        borderRadius: 8,
        marginBottom: 20,
      }}
    >
      <h4 style={{ marginBottom: 12, fontSize: 14, fontWeight: 600 }}>
        üîç Trending Searches
      </h4>
      <div style={{ display: 'flex', flexWrap: 'wrap', gap: 8 }}>
        {searches.map((search, index) => (
          <button
            key={index}
            style={{
              padding: '6px 12px',
              backgroundColor: 'white',
              border: '1px solid #d1d5db',
              borderRadius: 16,
              fontSize: 12,
              cursor: 'pointer',
            }}
          >
            {search}
          </button>
        ))}
      </div>
    </div>
  );
}

/**
 * Recently Viewed Component
 */
function RecentlyViewed() {
  const products = recentlyViewedResource.read();

  return (
    <div
      style={{
        padding: 16,
        backgroundColor: 'white',
        border: '1px solid #e5e7eb',
        borderRadius: 8,
      }}
    >
      <h4 style={{ marginBottom: 12, fontSize: 14, fontWeight: 600 }}>
        üëÅÔ∏è Recently Viewed
      </h4>
      <div style={{ display: 'flex', gap: 12, overflowX: 'auto' }}>
        {products.map((product) => (
          <div
            key={product.id}
            style={{
              minWidth: 150,
              padding: 12,
              border: '1px solid #e5e7eb',
              borderRadius: 6,
              backgroundColor: '#f9fafb',
            }}
          >
            <div
              style={{
                width: '100%',
                height: 100,
                backgroundColor: '#e5e7eb',
                borderRadius: 4,
                marginBottom: 8,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
              }}
            >
              üì¶
            </div>
            <div style={{ fontSize: 12, marginBottom: 4 }}>{product.name}</div>
            <div style={{ fontSize: 14, fontWeight: 'bold', color: '#059669' }}>
              ${product.price}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

// ============= RESOURCES (will be recreated on filter/sort change) =============
let productsResource = wrapPromise(
  fetchProducts({
    query: 'laptop',
    categories: [],
    sortBy: 'relevance',
  }),
);
let filterOptionsResource = wrapPromise(fetchFilterOptions());
let recommendedSearchesResource = wrapPromise(fetchRecommendedSearches());
let recentlyViewedResource = wrapPromise(fetchRecentlyViewed());

// ============= MAIN PAGE =============
function SearchResultsPage() {
  const [selectedCategories, setSelectedCategories] = useState([]);
  const [sortBy, setSortBy] = useState('relevance');
  const [isPending, startTransition] = useTransition();

  /**
   * Handle category filter change
   * Use startTransition to keep UI responsive
   */
  const handleCategoryChange = (newCategories) => {
    setSelectedCategories(newCategories);

    // Use transition for non-urgent update
    startTransition(() => {
      // Recreate resource with new filters
      productsResource = wrapPromise(
        fetchProducts({
          query: 'laptop',
          categories: newCategories,
          sortBy,
        }),
      );
    });
  };

  /**
   * Handle sort change
   * Immediate update (no transition needed)
   */
  const handleSortChange = (newSort) => {
    setSortBy(newSort);

    // Recreate resource with new sort
    productsResource = wrapPromise(
      fetchProducts({
        query: 'laptop',
        categories: selectedCategories,
        sortBy: newSort,
      }),
    );
  };

  return (
    <div
      style={{
        maxWidth: 1400,
        margin: '0 auto',
        padding: 20,
        backgroundColor: '#f9fafb',
        minHeight: '100vh',
      }}
    >
      {/* Header */}
      <div
        style={{
          marginBottom: 24,
          padding: 20,
          backgroundColor: 'white',
          borderRadius: 8,
          boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
        }}
      >
        <h1 style={{ marginBottom: 8, fontSize: 28 }}>Search Results</h1>
        <p style={{ color: '#6b7280', fontSize: 14 }}>
          Showing results for "laptop"
        </p>
      </div>

      {/* Recommended Searches - Non-critical */}
      <Suspense
        fallback={
          <div
            style={{
              padding: 16,
              backgroundColor: '#f3f4f6',
              borderRadius: 8,
              marginBottom: 20,
              height: 60,
            }}
          />
        }
      >
        <RecommendedSearches />
      </Suspense>

      {/* Main Content */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: '250px 1fr',
          gap: 20,
        }}
      >
        {/* Sidebar - Critical (loads with products) */}
        <aside>
          <ErrorBoundary>
            <Suspense fallback={<FilterSkeleton />}>
              <FilterSidebar
                selectedCategories={selectedCategories}
                onCategoryChange={handleCategoryChange}
              />
            </Suspense>
          </ErrorBoundary>

          {/* Recently Viewed - Non-critical */}
          <div style={{ marginTop: 20 }}>
            <Suspense
              fallback={
                <div
                  style={{
                    padding: 16,
                    backgroundColor: '#f3f4f6',
                    borderRadius: 8,
                    height: 200,
                  }}
                />
              }
            >
              <RecentlyViewed />
            </Suspense>
          </div>
        </aside>

        {/* Products - Critical */}
        <main>
          <ErrorBoundary onRetry={() => window.location.reload()}>
            <Suspense
              fallback={
                <>
                  <div
                    style={{
                      padding: 16,
                      backgroundColor: '#f3f4f6',
                      borderRadius: 8,
                      marginBottom: 20,
                      height: 60,
                    }}
                  />
                  <ProductGridSkeleton />
                </>
              }
            >
              {/* Show pending state during transition */}
              <div
                style={{
                  opacity: isPending ? 0.6 : 1,
                  transition: 'opacity 0.2s',
                }}
              >
                <SortBar
                  sortBy={sortBy}
                  onSortChange={handleSortChange}
                  resultsCount={6} // In real app, get from resource
                />
                <ProductGrid />
              </div>
            </Suspense>
          </ErrorBoundary>
        </main>
      </div>

      {/* Documentation */}
      <div
        style={{
          marginTop: 40,
          padding: 20,
          backgroundColor: 'white',
          borderRadius: 8,
          fontSize: 12,
          color: '#6b7280',
        }}
      >
        <h4 style={{ marginBottom: 12, color: '#111827' }}>
          üìä Architecture Notes
        </h4>
        <div style={{ fontFamily: 'monospace' }}>
          <div>Critical Path (Single Boundary):</div>
          <div style={{ paddingLeft: 16, color: '#059669' }}>
            - Filters (400ms) + Products (600ms) = ~600ms total
          </div>
          <div style={{ marginTop: 8 }}>
            Non-Critical (Separate Boundaries):
          </div>
          <div style={{ paddingLeft: 16, color: '#3b82f6' }}>
            - Recommended Searches (1000ms)
          </div>
          <div style={{ paddingLeft: 16, color: '#3b82f6' }}>
            - Recently Viewed (800ms)
          </div>
          <div style={{ marginTop: 8 }}>Performance:</div>
          <div style={{ paddingLeft: 16 }}>
            - useTransition keeps UI responsive during filtering
          </div>
          <div style={{ paddingLeft: 16 }}>
            - Suspense prevents waterfall loading
          </div>
          <div style={{ paddingLeft: 16 }}>
            - Error boundaries protect critical sections
          </div>
        </div>
      </div>
    </div>
  );
}

// Production Checklist:
// ‚úÖ JSDoc types for key data structures
// ‚úÖ Error boundaries on critical sections
// ‚úÖ Skeleton loaders prevent layout shift
// ‚úÖ Empty state for no results
// ‚úÖ Error states with retry
// ‚úÖ Keyboard accessible (native form elements)
// ‚úÖ ARIA labels on interactive elements
// ‚úÖ Suspense boundaries optimized for UX
// ‚úÖ useTransition for responsive filtering
// ‚úÖ Responsive grid layout

// Future improvements (would need router):
// - URL sync for filters/sort
// - Browser back/forward
// - Shareable search URLs
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh Trade-offs

| Pattern                          | Pros                                                                                                               | Cons                                                                                    | When to Use                                                                            |
| -------------------------------- | ------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |
| **Single Suspense Boundary**     | - Code ƒë∆°n gi·∫£n<br>- Consistent loading state<br>- T·∫•t c·∫£ data xu·∫•t hi·ªán c√πng l√∫c                                  | - Ch·ªù component ch·∫≠m nh·∫•t<br>- Poor perceived performance<br>- User kh√¥ng th·∫•y progress | - All data c√≥ loading time t∆∞∆°ng ƒë∆∞∆°ng<br>- Data ph·ª• thu·ªôc l·∫´n nhau<br>- Simple apps   |
| **Multiple Suspense Boundaries** | - Progressive loading<br>- Better perceived performance<br>- Independent loading states<br>- User th·∫•y content s·ªõm | - Code ph·ª©c t·∫°p h∆°n<br>- Potential layout shifts<br>- More boundaries to manage         | - Data c√≥ loading times r·∫•t kh√°c nhau<br>- Independent data sections<br>- Complex apps |
| **Nested Suspense**              | - Hierarchical loading<br>- Fine-grained control<br>- Parent ‚Üí Child progression                                   | - Most complex<br>- Easy to over-engineer<br>- Hard to reason about                     | - Deep component trees<br>- Parent-child data dependencies<br>- Very complex UIs       |

### Decision Tree

```
C·∫ßn load data?
‚îú‚îÄ YES ‚Üí T·∫•t c·∫£ data load c√πng th·ªùi ƒëi·ªÉm (~100ms kh√°c bi·ªát)?
‚îÇ   ‚îú‚îÄ YES ‚Üí Single Suspense Boundary
‚îÇ   ‚îÇ   ‚îî‚îÄ ƒê∆°n gi·∫£n, maintainable
‚îÇ   ‚îî‚îÄ NO ‚Üí C√≥ critical data c·∫ßn hi·ªán nhanh?
‚îÇ       ‚îú‚îÄ YES ‚Üí Multiple Boundaries
‚îÇ       ‚îÇ   ‚îú‚îÄ Critical content: Separate boundary
‚îÇ       ‚îÇ   ‚îî‚îÄ Non-critical: Separate boundary
‚îÇ       ‚îî‚îÄ NO ‚Üí User c√≥ ch·ªù ƒë∆∞·ª£c kh√¥ng?
‚îÇ           ‚îú‚îÄ YES ‚Üí Single Boundary
‚îÇ           ‚îî‚îÄ NO ‚Üí Multiple Boundaries
‚îî‚îÄ NO ‚Üí Kh√¥ng c·∫ßn Suspense
```

**V√≠ d·ª• quy·∫øt ƒë·ªãnh:**

```jsx
// Scenario: Blog post page

// Data:
// - Post content: 300ms (critical!)
// - Author info: 500ms (important)
// - Comments: 1200ms (slow, non-critical)
// - Related posts: 1000ms (non-critical)

// ‚ùå BAD: Single boundary
<Suspense fallback={<PageSkeleton />}>
  <Post />
  <Author />
  <Comments />
  <Related />
</Suspense>
// Wait 1200ms ‚Üí Everything appears
// Poor UX: User waits for comments!

// ‚úÖ GOOD: Multiple boundaries
<Suspense fallback={<PostSkeleton />}>
  <Post />
  <Author />
</Suspense>

<Suspense fallback={<CommentsSkeleton />}>
  <Comments />
</Suspense>

<Suspense fallback={<RelatedSkeleton />}>
  <Related />
</Suspense>
// 300ms ‚Üí Post + Author
// 1200ms ‚Üí Comments
// 1000ms ‚Üí Related
// Much better!
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Suspense Boundary Kh√¥ng Catch

```jsx
// ‚ùå Code b·ªã l·ªói
function BrokenApp() {
  const [show, setShow] = useState(false);

  return (
    <div>
      <button onClick={() => setShow(true)}>Load Data</button>

      <Suspense fallback={<div>Loading...</div>}>
        {show && <DataComponent />}
      </Suspense>
    </div>
  );
}

function DataComponent() {
  // Resource created INSIDE component - Wrong!
  const resource = wrapPromise(fetchData());
  const data = resource.read();
  return <div>{data.title}</div>;
}

// V·∫•n ƒë·ªÅ: Resource ƒë∆∞·ª£c t·∫°o m·ªói l·∫ßn render ‚Üí Promise m·ªõi ‚Üí Suspense kh√¥ng catch
```

**üîç Debug Questions:**

1. T·∫°i sao Suspense kh√¥ng show loading state?
2. Resource n√™n ƒë∆∞·ª£c t·∫°o ·ªü ƒë√¢u?
3. L√†m sao fix m√† kh√¥ng d√πng global variable?

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Fix: Resource ph·∫£i stable across renders
 */

// ‚úÖ Option 1: Create resource outside component
const dataResource = wrapPromise(fetchData());

function DataComponent() {
  const data = dataResource.read();
  return <div>{data.title}</div>;
}

// ‚úÖ Option 2: Use useState to store resource
function DataComponent() {
  const [resource] = useState(() => wrapPromise(fetchData()));
  const data = resource.read();
  return <div>{data.title}</div>;
}

// ‚úÖ Option 3: Create on mount (v·ªõi useEffect - nh∆∞ng c·∫©n th·∫≠n!)
function DataComponent() {
  const [resource, setResource] = useState(null);

  useEffect(() => {
    setResource(wrapPromise(fetchData()));
  }, []);

  if (!resource) return null; // First render

  const data = resource.read();
  return <div>{data.title}</div>;
}

// Gi·∫£i th√≠ch:
// - Suspense catch promise khi component throw
// - N·∫øu promise m·ªõi m·ªói render ‚Üí React kh√¥ng bi·∫øt c√°i n√†o ƒëang pending
// - Resource ph·∫£i stable (same instance) ƒë·ªÉ Suspense track ƒë∆∞·ª£c
```

</details>

---

### Bug 2: Error Boundary Kh√¥ng Catch

```jsx
// ‚ùå Code b·ªã l·ªói
function BrokenErrorHandling() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <ErrorBoundary>
        <DataComponent />
      </ErrorBoundary>
    </Suspense>
  );
}

function DataComponent() {
  const data = errorProneResource.read(); // C√≥ th·ªÉ throw error
  return <div>{data.title}</div>;
}

// V·∫•n ƒë·ªÅ: Error kh√¥ng ƒë∆∞·ª£c Error Boundary catch!
// App crash thay v√¨ show error UI
```

**üîç Debug Questions:**

1. T·∫°i sao Error Boundary kh√¥ng catch error?
2. Th·ª© t·ª± Suspense v√† Error Boundary sai ch·ªó n√†o?
3. ƒê√∫ng th·ª© t·ª± n√™n l√† sao?

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Fix: Error Boundary ph·∫£i B·ªåC NGO√ÄI Suspense
 */

// ‚ùå WRONG: Suspense b·ªçc Error Boundary
<Suspense fallback={<div>Loading...</div>}>
  <ErrorBoundary>
    <DataComponent />
  </ErrorBoundary>
</Suspense>
// Flow:
// 1. DataComponent throw promise ‚Üí Suspense catch
// 2. Suspense suspend ‚Üí Error Boundary c≈©ng b·ªã suspend!
// 3. Khi c√≥ error ‚Üí Error Boundary kh√¥ng active ‚Üí Crash!

// ‚úÖ CORRECT: Error Boundary b·ªçc Suspense
<ErrorBoundary>
  <Suspense fallback={<div>Loading...</div>}>
    <DataComponent />
  </Suspense>
</ErrorBoundary>
// Flow:
// 1. DataComponent throw promise ‚Üí Suspense catch ‚Üí Show loading
// 2. Promise reject ‚Üí Component throw error ‚Üí Error Boundary catch!
// 3. Show error UI ‚úì

// üí° REMEMBER: Error Boundary ‚Üí Suspense ‚Üí Component
// Analogy: Security (Error) ‚Üí Airlock (Suspense) ‚Üí Room (Component)
```

</details>

---

### Bug 3: Infinite Re-fetching

```jsx
// ‚ùå Code b·ªã l·ªói
function InfiniteLoop() {
  const [query, setQuery] = useState('react');

  // Resource created on every render!
  const searchResource = wrapPromise(fetchSearch(query));

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />

      <Suspense fallback={<div>Searching...</div>}>
        <SearchResults resource={searchResource} />
      </Suspense>
    </div>
  );
}

// V·∫•n ƒë·ªÅ: M·ªói keystroke ‚Üí New resource ‚Üí Suspend ‚Üí Re-render ‚Üí New resource ‚Üí ...
```

**üîç Debug Questions:**

1. T·∫°i sao search kh√¥ng bao gi·ªù ho√†n th√†nh?
2. Khi n√†o n√™n t·∫°o resource m·ªõi?
3. L√†m sao handle user input v·ªõi Suspense?

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Fix: Control khi n√†o fetch v·ªõi explicit trigger
 */

// ‚úÖ Option 1: Debounced search v·ªõi separate trigger
function DebouncedSearch() {
  const [query, setQuery] = useState('react');
  const [searchQuery, setSearchQuery] = useState('react');
  const [resource, setResource] = useState(() =>
    wrapPromise(fetchSearch('react')),
  );

  // Debounce effect (ch∆∞a h·ªçc useEffect dependency optimally, nh∆∞ng concept ƒë√∫ng)
  useEffect(() => {
    const timer = setTimeout(() => {
      setSearchQuery(query);
      setResource(wrapPromise(fetchSearch(query)));
    }, 500);

    return () => clearTimeout(timer);
  }, [query]);

  return (
    <div>
      <input
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Type to search...'
      />

      <Suspense fallback={<div>Searching for "{searchQuery}"...</div>}>
        <SearchResults resource={resource} />
      </Suspense>
    </div>
  );
}

// ‚úÖ Option 2: useTransition cho smooth UX
function TransitionSearch() {
  const [query, setQuery] = useState('react');
  const [resource, setResource] = useState(() =>
    wrapPromise(fetchSearch('react')),
  );
  const [isPending, startTransition] = useTransition();

  const handleSearch = (newQuery) => {
    setQuery(newQuery);

    // Non-urgent update ‚Üí UI stays responsive
    startTransition(() => {
      setResource(wrapPromise(fetchSearch(newQuery)));
    });
  };

  return (
    <div>
      <input
        value={query}
        onChange={(e) => handleSearch(e.target.value)}
      />

      {isPending && <div>Updating results...</div>}

      <Suspense fallback={<div>Loading...</div>}>
        <SearchResults resource={resource} />
      </Suspense>
    </div>
  );
}

// Gi·∫£i th√≠ch:
// - Suspense + User input = Tricky!
// - M·ªói input change ‚Üí New resource ‚Üí Suspend ‚Üí Bad UX
// - Gi·∫£i ph√°p: Debounce ho·∫∑c useTransition
// - useTransition t·ªët h∆°n: No delay, shows old content while loading new
```

</details>

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

- [ ] T√¥i hi·ªÉu Suspense l√† g√¨ v√† ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o (throw promise ‚Üí React catch)
- [ ] T√¥i bi·∫øt khi n√†o d√πng single vs multiple Suspense boundaries
- [ ] T√¥i bi·∫øt th·ª© t·ª± ƒë√∫ng: Error Boundary b·ªçc Suspense b·ªçc Component
- [ ] T√¥i hi·ªÉu Suspense KH√îNG t·ª± ƒë·ªông fetch data (c·∫ßn library ho·∫∑c custom)
- [ ] T√¥i bi·∫øt Suspense + useTransition = Smooth user input UX
- [ ] T√¥i hi·ªÉu progressive loading benefits (perceived performance)
- [ ] T√¥i bi·∫øt fallback UI n√™n realistic (skeleton, kh√¥ng ch·ªâ spinner)

### Code Review Checklist

**Khi review code c√≥ Suspense, check:**

- [ ] Resource ƒë∆∞·ª£c t·∫°o ·ªü ƒë√¢u? (Outside component ho·∫∑c useState)
- [ ] Suspense boundaries c√≥ h·ª£p l√Ω kh√¥ng? (Critical vs non-critical)
- [ ] Error Boundaries ƒë·∫∑t ƒë√∫ng ch·ªó? (B·ªçc ngo√†i Suspense)
- [ ] Fallback UI c√≥ prevent layout shift kh√¥ng? (Skeleton v·ªõi fixed size)
- [ ] C√≥ handle empty states kh√¥ng? (No results found)
- [ ] C√≥ handle user input properly kh√¥ng? (Debounce ho·∫∑c useTransition)
- [ ] Performance c√≥ t·ªëi ∆∞u kh√¥ng? (Parallel loading, kh√¥ng waterfall)

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**T·∫°o Image Gallery v·ªõi Suspense:**

```jsx
/**
 * Requirements:
 * 1. Grid of images (load parallel)
 * 2. Each image trong ri√™ng Suspense boundary
 * 3. Skeleton loader cho m·ªói image
 * 4. Error boundary cho failed images
 * 5. "Load More" button
 *
 * Mock API:
 * function fetchImages(page) {
 *   return Promise (array of { id, url, title })
 * }
 *
 * Challenge: Images load at different speeds
 * Solution: Individual Suspense per image
 */
```

### N√¢ng cao (60 ph√∫t)

**Refactor Todo App (Ng√†y 15) v·ªõi Suspense:**

```jsx
/**
 * Nhi·ªám v·ª•:
 * 1. Thay localStorage sync b·∫±ng fake async API
 * 2. Th√™m Suspense cho initial load
 * 3. useTransition cho filter changes
 * 4. Error boundary cho save failures
 * 5. Optimistic updates cho add/delete/toggle
 *
 * H·ªçc:
 * - Async state management v·ªõi Suspense
 * - Optimistic UI patterns
 * - Error recovery strategies
 */
```

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - Suspense:**
   - https://react.dev/reference/react/Suspense
   - ƒê·ªçc: Overview, Reference, Usage examples

2. **React Docs - useSuspenseQuery (future):**
   - Preview c√°ch libraries implement Suspense
   - Hi·ªÉu pattern ƒë·ªÉ √°p d·ª•ng cho custom hooks

### ƒê·ªçc th√™m

1. **React 18 Working Group Discussions:**
   - Hi·ªÉu design decisions behind Suspense
   - Real-world use cases from community

2. **Building Your Own Data Fetching Solution:**
   - Vi·∫øt custom hooks v·ªõi Suspense support
   - Resource pattern deep dive

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (c·∫ßn bi·∫øt)

- **Ng√†y 16-20:** useEffect cho data fetching
- **Ng√†y 47:** useTransition cho non-urgent updates
- **Ng√†y 48:** useDeferredValue concept
- **JavaScript Promises:** async/await, Promise states

### H∆∞·ªõng t·ªõi (s·∫Ω d√πng)

- **Ng√†y 50:** Error Boundaries chi ti·∫øt h∆°n
- **Module React Query:** Suspense-enabled data fetching
- **Module Next.js:** Server Components + Suspense
- **Production apps:** Real Suspense patterns v·ªõi libraries

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**1. Suspense hi·ªán t·∫°i (2024-2025):**

```jsx
// ‚ö†Ô∏è Suspense for Data Fetching v·∫´n ƒëang experimental
// Production code n√™n d√πng libraries c√≥ Suspense support:

// ‚úÖ React Query
const { data } = useSuspenseQuery(['user'], fetchUser);

// ‚úÖ SWR
const { data } = useSWR('/api/user', fetcher, { suspense: true });

// ‚ùå KH√îNG t·ª± implement wrapPromise pattern cho production
// ‚Üí Use libraries, ch√∫ng handle edge cases t·ªët h∆°n
```

**2. Performance Monitoring:**

```jsx
// Track Suspense boundaries v·ªõi Performance API
// (Future: React DevTools s·∫Ω show Suspense waterfall)

useEffect(() => {
  performance.mark('suspense-start');

  return () => {
    performance.mark('suspense-end');
    performance.measure('suspense-duration', 'suspense-start', 'suspense-end');
  };
}, []);
```

**3. Accessibility:**

```jsx
// ‚úÖ Announce loading states cho screen readers
<div
  role='status'
  aria-live='polite'
  aria-atomic='true'
>
  {isPending ? 'Loading new results...' : `${count} results found`}
</div>

// ‚úÖ Maintain focus during Suspense transitions
// (useTransition helps preserve focus automatically)
```

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior:**

- Q: "Suspense l√† g√¨?"
- A: "C∆° ch·∫ø c·ªßa React ƒë·ªÉ declaratively handle async operations, ƒë·∫∑c bi·ªát l√† loading states. Component throw promise ‚Üí React catch ‚Üí Show fallback UI."

**Mid:**

- Q: "Khi n√†o d√πng single vs multiple Suspense boundaries?"
- A: "Ph·ª• thu·ªôc v√†o loading times v√† priorities. N·∫øu data load c√πng th·ªùi ƒëi·ªÉm (~100ms kh√°c bi·ªát) ‚Üí Single boundary ƒë∆°n gi·∫£n h∆°n. N·∫øu kh√°c bi·ªát l·ªõn ‚Üí Multiple boundaries cho better perceived performance. Critical data n√™n c√≥ boundary ri√™ng."

**Senior:**

- Q: "Thi·∫øt k·∫ø Suspense strategy cho app v·ªõi 10+ API calls khi mount?"
- A: "
  1. Ph√¢n lo·∫°i theo priority (critical, important, nice-to-have)
  2. Critical path: Single boundary (minimize wait)
  3. Non-critical: Separate boundaries (progressive loading)
  4. Error boundaries b·ªçc critical, graceful degradation cho non-critical
  5. Monitor actual loading times ‚Üí Adjust boundaries
  6. Use useTransition cho user-triggered updates
  7. Consider code splitting (React.lazy) + Suspense cho bundle optimization
     "

### War Stories

**Story 1: The Premature Optimization**

```
Team: "Ch√∫ng ta c·∫ßn Suspense boundary cho M·ªåI COMPONENT ƒë·ªÉ optimize!"

Reality:
- 50+ Suspense boundaries
- Code c·ª±c ph·ª©c t·∫°p
- Layout shift everywhere
- Maintenance nightmare

Lesson:
- Start simple (fewer boundaries)
- Measure actual performance
- Add boundaries only when needed
- Sometimes manual loading states are better!
```

**Story 2: The Missing Error Boundary**

```
Product: "T·∫°i sao app crash khi API fail?"

Issue:
<Suspense>
  <Component /> {/* throws error */}
</Suspense>

Fix:
<ErrorBoundary>
  <Suspense>
    <Component />
  </Suspense>
</ErrorBoundary>

Lesson: ALWAYS pair Suspense v·ªõi Error Boundary!
```

**Story 3: The Resource Recreation Loop**

```
Bug: "Search never finishes, infinitely loading!"

Cause:
function Search() {
  const resource = wrapPromise(fetchSearch(query)); // WRONG!
  // New resource every render ‚Üí Suspense never resolves
}

Fix:
const [resource, setResource] = useState(() => wrapPromise(...));

Lesson: Resources ph·∫£i stable across renders!
```

---

## üéØ PREVIEW NG√ÄY 50

**Ng√†y mai:** Error Boundaries Deep Dive

Ch√∫ng ta s·∫Ω h·ªçc:

- Class-based Error Boundaries (understand legacy)
- react-error-boundary library (modern approach)
- Error recovery strategies
- Retry mechanisms
- Fallback UI patterns
- Error logging & monitoring

**Teaser:**

```jsx
// Error Boundary + Suspense = Complete async handling!
<ErrorBoundary
  fallback={<ErrorUI />}
  onReset={() => refetchData()}
>
  <Suspense fallback={<Loading />}>
    <AsyncComponent />
  </Suspense>
</ErrorBoundary>
```

H·∫πn g·∫∑p l·∫°i! üöÄ
