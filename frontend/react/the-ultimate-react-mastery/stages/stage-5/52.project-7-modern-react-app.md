# ğŸ“… NGÃ€Y 52: âš¡ PROJECT 7 - MODERN REACT APP

## ğŸ“ Phase 5, Week 11, Day 52 of 75

NgÃ y hÃ´m nay lÃ  project tá»•ng há»£p táº¥t cáº£ React 18 features Ä‘Ã£ há»c. Báº¡n sáº½ xÃ¢y dá»±ng má»™t **Product Search Dashboard** production-ready vá»›i concurrent rendering, Suspense boundaries, Error boundaries, vÃ  performance optimization. Project nÃ y táº­p trung vÃ o viá»‡c táº¡o UX mÆ°á»£t mÃ  ngay cáº£ khi xá»­ lÃ½ heavy computations vÃ  async operations. ÄÃ¢y lÃ  cÆ¡ há»™i Ä‘á»ƒ báº¡n chá»©ng minh kháº£ nÄƒng Ã¡p dá»¥ng modern React features vÃ o production code.

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (10 phÃºt)

- [ ] TÃ­ch há»£p useTransition Ä‘á»ƒ táº¡o responsive UI khi search/filter
- [ ] Ãp dá»¥ng useDeferredValue cho heavy computations mÃ  khÃ´ng block UI
- [ ] Implement Suspense boundaries vá»›i fallback UI phÃ¹ há»£p
- [ ] Setup Error Boundaries vá»›i recovery strategies
- [ ] Äo lÆ°á»ng vÃ  optimize performance vá»›i React DevTools Profiler
- [ ] Viáº¿t production-ready code vá»›i proper error handling vÃ  loading states

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

1. **Concurrent Features**: Giáº£i thÃ­ch sá»± khÃ¡c biá»‡t giá»¯a useTransition vÃ  useDeferredValue. Khi nÃ o dÃ¹ng cÃ¡i nÃ o?

2. **Suspense**: Táº¡i sao cáº§n chia Suspense boundaries thÃ nh nhiá»u pháº§n thay vÃ¬ wrap toÃ n bá»™ app?

3. **Error Boundaries**: Class component Error Boundary báº¯t Ä‘Æ°á»£c nhá»¯ng loáº¡i lá»—i nÃ o? Loáº¡i lá»—i nÃ o KHÃ”NG báº¯t Ä‘Æ°á»£c?

---

## ğŸ“– PHáº¦N 1: PROJECT OVERVIEW (15 phÃºt)

### 1.1 Product Requirements

**User Story:**

> "LÃ  ngÆ°á»i dÃ¹ng, tÃ´i muá»‘n tÃ¬m kiáº¿m vÃ  lá»c sáº£n pháº©m trong má»™t danh sÃ¡ch lá»›n vá»›i tráº£i nghiá»‡m mÆ°á»£t mÃ , khÃ´ng bá»‹ lag, vÃ  Ä‘Æ°á»£c thÃ´ng bÃ¡o rÃµ rÃ ng khi cÃ³ lá»—i xáº£y ra."

**Business Goals:**

- Search pháº£i responsive ngay cáº£ vá»›i 10,000+ sáº£n pháº©m
- UI khÃ´ng bá»‹ freeze khi apply filters phá»©c táº¡p
- Loading states pháº£i rÃµ rÃ ng vÃ  professional
- Errors pháº£i Ä‘Æ°á»£c handle gracefully vá»›i recovery options
- Performance pháº£i Ä‘áº¡t Web Vitals standards

### 1.2 Technical Challenge

**Váº¥n Ä‘á» cáº§n giáº£i quyáº¿t:**

```jsx
// âŒ PROBLEMATIC APPROACH (React 17 mindset)
const Dashboard = () => {
  const [products, setProducts] = useState([]);
  const [search, setSearch] = useState('');
  const [filters, setFilters] = useState({});

  // Problem 1: Search blocks UI
  const handleSearch = (value) => {
    setSearch(value); // Input updates
    // Heavy filtering happens synchronously
    const filtered = heavyFilter(allProducts, value, filters);
    setProducts(filtered); // Blocks render!
  };

  // Problem 2: No loading feedback
  // User doesn't know if app is frozen or processing

  // Problem 3: No error boundaries
  // One component error crashes entire app

  // Problem 4: No Suspense
  // Loading data shows blank screen
};
```

**Giáº£i phÃ¡p Modern React:**

```jsx
// âœ… MODERN REACT 18 APPROACH
const Dashboard = () => {
  // Separate urgent vs non-urgent updates
  const [search, setSearch] = useState('');
  const deferredSearch = useDeferredValue(search);
  const [isPending, startTransition] = useTransition();

  // Concurrent rendering
  const handleSearch = (value) => {
    setSearch(value); // Urgent: Update input immediately

    startTransition(() => {
      // Non-urgent: Heavy filtering
      applyFilters(value);
    });
  };

  return (
    <ErrorBoundary fallback={<ErrorUI />}>
      <Suspense fallback={<LoadingSkeleton />}>
        <SearchInput
          value={search}
          onChange={handleSearch}
        />
        {isPending && <LoadingIndicator />}
        <ProductList search={deferredSearch} />
      </Suspense>
    </ErrorBoundary>
  );
};
```

### 1.3 Features Overview

**Core Features:**

1. âœ… **Real-time Search** vá»›i useTransition
2. âœ… **Advanced Filters** vá»›i useDeferredValue
3. âœ… **Data Fetching** vá»›i Suspense
4. âœ… **Error Handling** vá»›i Error Boundaries
5. âœ… **Performance Monitoring** vá»›i Profiler API

**Technical Features:**

1. âœ… Concurrent rendering optimization
2. âœ… Multiple Suspense boundaries
3. âœ… Granular error boundaries
4. âœ… Loading state composition
5. âœ… Performance metrics tracking

### 1.4 Architecture Decisions

**State Management Strategy:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           App Level                 â”‚
â”‚  - Error Boundary (global)          â”‚
â”‚  - Performance Provider             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚  Search     â”‚  â”‚  Filters   â”‚
â”‚  (urgent)   â”‚  â”‚ (deferred) â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Product List  â”‚
        â”‚  (Suspense)    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Suspense Boundaries Strategy:**

```jsx
// âŒ BAD: Single boundary for everything
<Suspense fallback={<FullPageLoader />}>
  <Header />      {/* Delays everything */}
  <Sidebar />     {/* Delays everything */}
  <ProductList /> {/* Delays everything */}
</Suspense>

// âœ… GOOD: Granular boundaries
<Header />  {/* Static, no Suspense needed */}
<Sidebar>
  <Suspense fallback={<SidebarSkeleton />}>
    <Filters />  {/* Independent loading */}
  </Suspense>
</Sidebar>
<Suspense fallback={<ProductSkeleton />}>
  <ProductList />  {/* Independent loading */}
</Suspense>
```

---

## ğŸ’» PHáº¦N 2: TECHNICAL REQUIREMENTS (30 phÃºt)

### 2.1 Project Structure

```
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ErrorBoundary/
â”‚   â”‚   â”œâ”€â”€ ErrorBoundary.jsx
â”‚   â”‚   â”œâ”€â”€ ErrorFallback.jsx
â”‚   â”‚   â””â”€â”€ ErrorBoundary.test.jsx
â”‚   â”‚
â”‚   â”œâ”€â”€ ProductDashboard/
â”‚   â”‚   â”œâ”€â”€ ProductDashboard.jsx
â”‚   â”‚   â”œâ”€â”€ SearchBar.jsx
â”‚   â”‚   â”œâ”€â”€ FilterPanel.jsx
â”‚   â”‚   â”œâ”€â”€ ProductList.jsx
â”‚   â”‚   â””â”€â”€ ProductCard.jsx
â”‚   â”‚
â”‚   â”œâ”€â”€ LoadingStates/
â”‚   â”‚   â”œâ”€â”€ ProductSkeleton.jsx
â”‚   â”‚   â”œâ”€â”€ FilterSkeleton.jsx
â”‚   â”‚   â””â”€â”€ LoadingIndicator.jsx
â”‚   â”‚
â”‚   â””â”€â”€ Performance/
â”‚       â”œâ”€â”€ PerformanceMonitor.jsx
â”‚       â””â”€â”€ RenderTracker.jsx
â”‚
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useProducts.js
â”‚   â”œâ”€â”€ useSearch.js
â”‚   â”œâ”€â”€ useFilters.js
â”‚   â””â”€â”€ usePerformance.js
â”‚
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ filterProducts.js
â”‚   â”œâ”€â”€ generateMockData.js
â”‚   â””â”€â”€ performance.js
â”‚
â””â”€â”€ App.jsx
```

### 2.2 Acceptance Criteria

**Functional Requirements:**

- [ ] Search input pháº£n há»“i ngay láº­p tá»©c (< 16ms)
- [ ] Filtering 10,000 items khÃ´ng block UI
- [ ] Loading states hiá»ƒn thá»‹ trong < 200ms
- [ ] Errors cÃ³ recovery options (retry, reset)
- [ ] Táº¥t cáº£ interactions cÃ³ feedback rÃµ rÃ ng

**Performance Requirements:**

- [ ] First Contentful Paint < 1.5s
- [ ] Time to Interactive < 3s
- [ ] Search input lag < 50ms
- [ ] Filter apply < 100ms (perceived)
- [ ] No layout shifts (CLS = 0)

**Quality Requirements:**

- [ ] TypeScript types Ä‘áº§y Ä‘á»§ (optional nhÆ°ng recommended)
- [ ] Error boundaries á»Ÿ 3 levels (App, Feature, Component)
- [ ] Suspense boundaries á»Ÿ 2+ levels
- [ ] Console warnings = 0
- [ ] Accessibility compliant (keyboard nav, ARIA)

### 2.3 Mock Data Strategy

```jsx
// utils/generateMockData.js

/**
 * Generates realistic product data for testing
 * @param {number} count - Number of products to generate
 * @returns {Array} Array of product objects
 */
export const generateProducts = (count = 10000) => {
  const categories = ['Electronics', 'Clothing', 'Books', 'Home', 'Sports'];
  const brands = ['BrandA', 'BrandB', 'BrandC', 'BrandD', 'BrandE'];

  return Array.from({ length: count }, (_, i) => ({
    id: `product-${i}`,
    name: `Product ${i}`,
    category: categories[i % categories.length],
    brand: brands[i % brands.length],
    price: Math.floor(Math.random() * 1000) + 10,
    rating: (Math.random() * 5).toFixed(1),
    inStock: Math.random() > 0.2,
    description: `Description for product ${i}`.repeat(5),
  }));
};

/**
 * Simulates network delay
 * @param {number} ms - Delay in milliseconds
 */
export const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

/**
 * Simulates API call with random failure
 * @param {number} failureRate - Probability of failure (0-1)
 */
export const fetchProducts = async (failureRate = 0.1) => {
  await delay(1000 + Math.random() * 1000); // 1-2s delay

  if (Math.random() < failureRate) {
    throw new Error('Failed to fetch products');
  }

  return generateProducts(10000);
};
```

### 2.4 Performance Budget

```jsx
// utils/performance.js

export const PERFORMANCE_BUDGET = {
  // Core Web Vitals
  LCP: 2500, // Largest Contentful Paint
  FID: 100, // First Input Delay
  CLS: 0.1, // Cumulative Layout Shift

  // Custom metrics
  searchResponseTime: 50, // Search input lag
  filterApplyTime: 100, // Filter perceived time
  renderTime: 16, // 60fps target
};

export const measurePerformance = (metricName, callback) => {
  const start = performance.now();
  const result = callback();
  const end = performance.now();

  const duration = end - start;
  console.log(`[Performance] ${metricName}: ${duration.toFixed(2)}ms`);

  return { result, duration };
};

export const withPerformanceTracking = (Component) => {
  return (props) => {
    const renderStart = performance.now();

    React.useEffect(() => {
      const renderEnd = performance.now();
      const renderTime = renderEnd - renderStart;

      if (renderTime > PERFORMANCE_BUDGET.renderTime) {
        console.warn(
          `[Performance] ${Component.name} render time: ${renderTime.toFixed(2)}ms exceeds budget of ${PERFORMANCE_BUDGET.renderTime}ms`,
        );
      }
    });

    return <Component {...props} />;
  };
};
```

---

## ğŸ”¨ PHáº¦N 3: IMPLEMENTATION PHASES (120 phÃºt)

### Phase 1: Setup & Infrastructure (30 phÃºt)

**â­â­â­ Task 1.1: Error Boundary Setup**

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Implement production-grade Error Boundary
 * â±ï¸ Thá»i gian: 15 phÃºt
 *
 * Requirements:
 * 1. Báº¯t táº¥t cáº£ component errors
 * 2. Hiá»ƒn thá»‹ fallback UI vá»›i error details
 * 3. CÃ³ nÃºt Retry vÃ  Reset
 * 4. Log errors to console (production sáº½ log to service)
 *
 * ğŸ’¡ Gá»£i Ã½: DÃ¹ng react-error-boundary hoáº·c implement custom
 */
```

<details>
<summary>ğŸ’¡ Solution - ErrorBoundary.jsx</summary>

```jsx
import { Component } from 'react';

/**
 * Production-grade Error Boundary
 * Catches errors in child component tree
 */
export class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log to error reporting service in production
    console.error('Error Boundary caught:', error, errorInfo);

    this.setState({
      error,
      errorInfo,
    });

    // Call optional error callback
    this.props.onError?.(error, errorInfo);
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
    this.props.onReset?.();
  };

  render() {
    if (this.state.hasError) {
      // Custom fallback UI
      if (this.props.fallback) {
        return this.props.fallback({
          error: this.state.error,
          errorInfo: this.state.errorInfo,
          reset: this.handleReset,
        });
      }

      // Default fallback UI
      return (
        <div style={{ padding: '2rem', textAlign: 'center' }}>
          <h2>âš ï¸ Something went wrong</h2>
          <details style={{ marginTop: '1rem', textAlign: 'left' }}>
            <summary>Error Details</summary>
            <pre
              style={{
                background: '#f5f5f5',
                padding: '1rem',
                overflow: 'auto',
              }}
            >
              {this.state.error?.toString()}
              {this.state.errorInfo?.componentStack}
            </pre>
          </details>
          <button
            onClick={this.handleReset}
            style={{
              marginTop: '1rem',
              padding: '0.5rem 1rem',
              cursor: 'pointer',
            }}
          >
            Try Again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Example usage:
// <ErrorBoundary
//   fallback={({ error, reset }) => (
//     <CustomErrorUI error={error} onRetry={reset} />
//   )}
//   onError={(error, errorInfo) => {
//     // Log to service
//   }}
// >
//   <App />
// </ErrorBoundary>
```

</details>

**â­â­â­ Task 1.2: Mock Data & API Simulation**

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Setup realistic mock data vá»›i simulated API
 * â±ï¸ Thá»i gian: 15 phÃºt
 *
 * Requirements:
 * 1. Generate 10,000 products vá»›i realistic fields
 * 2. Simulate network delay (1-2s random)
 * 3. Simulate random failures (10% rate)
 * 4. CÃ³ option Ä‘á»ƒ control delay vÃ  failure rate
 */
```

<details>
<summary>ğŸ’¡ Solution - mockApi.js</summary>

```jsx
/**
 * Mock data generation utilities
 */

const CATEGORIES = [
  'Electronics',
  'Clothing',
  'Books',
  'Home & Garden',
  'Sports',
  'Toys',
];
const BRANDS = [
  'TechCorp',
  'StyleCo',
  'HomeBase',
  'SportPro',
  'BookWorld',
  'GadgetHub',
];

/**
 * Generate single product
 */
const generateProduct = (id) => ({
  id: `prod-${id}`,
  name: `Product ${id}`,
  category: CATEGORIES[id % CATEGORIES.length],
  brand: BRANDS[id % BRANDS.length],
  price: Math.floor(Math.random() * 1000) + 10,
  rating: (Math.random() * 5).toFixed(1),
  inStock: Math.random() > 0.2,
  description: `High quality ${CATEGORIES[id % CATEGORIES.length].toLowerCase()} product with excellent features and durability.`,
  imageUrl: `https://via.placeholder.com/150?text=Product+${id}`,
});

/**
 * Generate array of products
 */
export const generateProducts = (count = 10000) => {
  return Array.from({ length: count }, (_, i) => generateProduct(i));
};

/**
 * Simulate network delay
 */
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

/**
 * Simulated API - fetchProducts
 * @param {Object} options - Configuration options
 * @param {number} options.minDelay - Minimum delay in ms
 * @param {number} options.maxDelay - Maximum delay in ms
 * @param {number} options.failureRate - Probability of failure (0-1)
 * @returns {Promise<Array>} Products array
 */
export const fetchProducts = async ({
  minDelay = 1000,
  maxDelay = 2000,
  failureRate = 0.1,
} = {}) => {
  // Simulate network delay
  const delayTime = minDelay + Math.random() * (maxDelay - minDelay);
  await delay(delayTime);

  // Simulate random failure
  if (Math.random() < failureRate) {
    throw new Error('Network error: Failed to fetch products');
  }

  return generateProducts(10000);
};

/**
 * Create suspense-compatible resource
 * This is a simplified version - production should use libraries like React Query
 */
export const createResource = (promise) => {
  let status = 'pending';
  let result;

  const suspender = promise.then(
    (data) => {
      status = 'success';
      result = data;
    },
    (error) => {
      status = 'error';
      result = error;
    },
  );

  return {
    read() {
      if (status === 'pending') {
        throw suspender; // Suspense will catch this
      }
      if (status === 'error') {
        throw result;
      }
      return result;
    },
  };
};

// Example usage:
// const productResource = createResource(fetchProducts());
//
// function ProductList() {
//   const products = productResource.read(); // Suspends if pending
//   return <div>{products.length} products</div>;
// }
```

</details>

### Phase 2: Core Components (40 phÃºt)

**â­â­â­â­ Task 2.1: Search vá»›i useTransition**

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Implement responsive search vá»›i useTransition
 * â±ï¸ Thá»i gian: 20 phÃºt
 *
 * Requirements:
 * 1. Input updates ngay láº­p tá»©c (urgent)
 * 2. Search results update non-urgently
 * 3. Hiá»ƒn thá»‹ loading indicator khi isPending
 * 4. KhÃ´ng block UI khi search trong 10k items
 *
 * ğŸ“ Technical Details:
 * - DÃ¹ng useTransition cho search action
 * - Separate urgent (input) vs non-urgent (filtering) updates
 * - Show subtle loading indicator (khÃ´ng lÃ m giÃ¡n Ä‘oáº¡n UX)
 */
```

<details>
<summary>ğŸ’¡ Solution - SearchBar.jsx</summary>

```jsx
import { useState, useTransition } from 'react';

/**
 * Responsive search bar using useTransition
 * Input is always responsive, search results update non-urgently
 */
export function SearchBar({ products, onSearchResults }) {
  const [searchValue, setSearchValue] = useState('');
  const [isPending, startTransition] = useTransition();

  const handleSearchChange = (e) => {
    const value = e.target.value;

    // Urgent: Update input immediately
    setSearchValue(value);

    // Non-urgent: Filter products
    startTransition(() => {
      const filtered = filterProducts(products, value);
      onSearchResults(filtered);
    });
  };

  return (
    <div style={{ position: 'relative' }}>
      <input
        type='search'
        value={searchValue}
        onChange={handleSearchChange}
        placeholder='Search products...'
        style={{
          width: '100%',
          padding: '0.75rem',
          fontSize: '1rem',
          border: '2px solid #ddd',
          borderRadius: '8px',
          outline: 'none',
        }}
      />

      {isPending && (
        <div
          style={{
            position: 'absolute',
            right: '1rem',
            top: '50%',
            transform: 'translateY(-50%)',
            color: '#666',
          }}
        >
          ğŸ”„ Searching...
        </div>
      )}
    </div>
  );
}

/**
 * Filter products by search term
 * This is intentionally NOT optimized to simulate heavy work
 */
function filterProducts(products, searchTerm) {
  if (!searchTerm) return products;

  const lowerSearch = searchTerm.toLowerCase();

  // Simulate heavy computation
  return products.filter((product) => {
    // Intentionally inefficient for demo purposes
    const matches =
      product.name.toLowerCase().includes(lowerSearch) ||
      product.category.toLowerCase().includes(lowerSearch) ||
      product.brand.toLowerCase().includes(lowerSearch) ||
      product.description.toLowerCase().includes(lowerSearch);

    // Simulate more work
    for (let i = 0; i < 1000; i++) {
      Math.random();
    }

    return matches;
  });
}

// Usage:
// <SearchBar
//   products={allProducts}
//   onSearchResults={(filtered) => setDisplayProducts(filtered)}
// />
```

</details>

**â­â­â­â­ Task 2.2: Filters vá»›i useDeferredValue**

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Implement advanced filters vá»›i useDeferredValue
 * â±ï¸ Thá»i gian: 20 phÃºt
 *
 * Requirements:
 * 1. Multiple filter controls (category, price range, rating, stock)
 * 2. Filter UI updates immediately
 * 3. Filter results update vá»›i deferred value
 * 4. Show stale indicator khi filters Ä‘ang apply
 *
 * ğŸ“ Technical Details:
 * - DÃ¹ng useDeferredValue cho filter state
 * - UI filters always responsive
 * - Heavy filtering doesn't block interaction
 * - Visual feedback khi filters Ä‘ang Ä‘Æ°á»£c apply
 */
```

<details>
<summary>ğŸ’¡ Solution - FilterPanel.jsx</summary>

```jsx
import { useState, useDeferredValue, useMemo } from 'react';

/**
 * Advanced filter panel using useDeferredValue
 * Filter controls are always responsive
 * Heavy filtering is deferred
 */
export function FilterPanel({ products, onFilteredResults }) {
  const [filters, setFilters] = useState({
    category: 'all',
    minPrice: 0,
    maxPrice: 1000,
    minRating: 0,
    inStockOnly: false,
  });

  // Defer the heavy filtering operation
  const deferredFilters = useDeferredValue(filters);

  // Check if we're showing stale data
  const isStale = filters !== deferredFilters;

  // Apply filters (this is heavy computation)
  const filteredProducts = useMemo(() => {
    return applyFilters(products, deferredFilters);
  }, [products, deferredFilters]);

  // Update parent with results
  useMemo(() => {
    onFilteredResults(filteredProducts);
  }, [filteredProducts, onFilteredResults]);

  return (
    <div
      style={{
        padding: '1rem',
        background: '#f9f9f9',
        borderRadius: '8px',
        opacity: isStale ? 0.7 : 1,
        transition: 'opacity 0.2s',
      }}
    >
      <h3>Filters {isStale && '(Updating...)'}</h3>

      {/* Category Filter */}
      <div style={{ marginBottom: '1rem' }}>
        <label>
          Category:
          <select
            value={filters.category}
            onChange={(e) =>
              setFilters((prev) => ({
                ...prev,
                category: e.target.value,
              }))
            }
            style={{ marginLeft: '0.5rem', padding: '0.25rem' }}
          >
            <option value='all'>All Categories</option>
            <option value='Electronics'>Electronics</option>
            <option value='Clothing'>Clothing</option>
            <option value='Books'>Books</option>
            <option value='Home & Garden'>Home & Garden</option>
            <option value='Sports'>Sports</option>
          </select>
        </label>
      </div>

      {/* Price Range */}
      <div style={{ marginBottom: '1rem' }}>
        <label>
          Price Range: ${filters.minPrice} - ${filters.maxPrice}
          <input
            type='range'
            min='0'
            max='1000'
            value={filters.maxPrice}
            onChange={(e) =>
              setFilters((prev) => ({
                ...prev,
                maxPrice: Number(e.target.value),
              }))
            }
            style={{ display: 'block', width: '100%', marginTop: '0.5rem' }}
          />
        </label>
      </div>

      {/* Rating Filter */}
      <div style={{ marginBottom: '1rem' }}>
        <label>
          Minimum Rating: {filters.minRating}â˜…
          <input
            type='range'
            min='0'
            max='5'
            step='0.5'
            value={filters.minRating}
            onChange={(e) =>
              setFilters((prev) => ({
                ...prev,
                minRating: Number(e.target.value),
              }))
            }
            style={{ display: 'block', width: '100%', marginTop: '0.5rem' }}
          />
        </label>
      </div>

      {/* Stock Filter */}
      <div>
        <label>
          <input
            type='checkbox'
            checked={filters.inStockOnly}
            onChange={(e) =>
              setFilters((prev) => ({
                ...prev,
                inStockOnly: e.target.checked,
              }))
            }
          />{' '}
          In Stock Only
        </label>
      </div>

      <div style={{ marginTop: '1rem', fontSize: '0.875rem', color: '#666' }}>
        Showing {filteredProducts.length} products
      </div>
    </div>
  );
}

/**
 * Apply all filters to products
 * Intentionally heavy to demonstrate useDeferredValue benefit
 */
function applyFilters(products, filters) {
  return products.filter((product) => {
    // Category filter
    if (filters.category !== 'all' && product.category !== filters.category) {
      return false;
    }

    // Price filter
    if (product.price < filters.minPrice || product.price > filters.maxPrice) {
      return false;
    }

    // Rating filter
    if (parseFloat(product.rating) < filters.minRating) {
      return false;
    }

    // Stock filter
    if (filters.inStockOnly && !product.inStock) {
      return false;
    }

    // Simulate heavy work
    for (let i = 0; i < 5000; i++) {
      Math.random();
    }

    return true;
  });
}

// Usage:
// <FilterPanel
//   products={allProducts}
//   onFilteredResults={(filtered) => setDisplayProducts(filtered)}
// />
```

</details>

### Phase 3: Suspense & Loading States (30 phÃºt)

**â­â­â­â­ Task 3.1: Product List vá»›i Suspense**

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Implement ProductList vá»›i proper Suspense boundaries
 * â±ï¸ Thá»i gian: 20 phÃºt
 *
 * Requirements:
 * 1. Wrap ProductList trong Suspense vá»›i skeleton fallback
 * 2. Separate Suspense cho filters (independent loading)
 * 3. Loading skeleton pháº£i realistic
 * 4. Smooth transition tá»« loading â†’ content
 *
 * ğŸ“ Architecture:
 * - Granular Suspense boundaries (khÃ´ng wrap toÃ n bá»™ app)
 * - Meaningful fallback UI (khÃ´ng generic spinners)
 * - Progressive loading (show parts as ready)
 */
```

<details>
<summary>ğŸ’¡ Solution - ProductDashboard.jsx vá»›i Suspense</summary>

```jsx
import { Suspense, useState } from 'react';
import { ErrorBoundary } from './ErrorBoundary';
import { SearchBar } from './SearchBar';
import { FilterPanel } from './FilterPanel';
import { ProductList } from './ProductList';
import { ProductSkeleton, FilterSkeleton } from './LoadingStates';

/**
 * Main dashboard with proper Suspense and Error boundaries
 * Demonstrates production-grade loading architecture
 */
export function ProductDashboard({ productResource }) {
  const [displayProducts, setDisplayProducts] = useState(null);

  return (
    <div style={{ maxWidth: '1200px', margin: '0 auto', padding: '2rem' }}>
      <h1>ğŸ›ï¸ Product Dashboard</h1>

      {/* Global Error Boundary */}
      <ErrorBoundary
        fallback={({ error, reset }) => (
          <div
            style={{
              padding: '2rem',
              background: '#fee',
              borderRadius: '8px',
              textAlign: 'center',
            }}
          >
            <h2>âŒ Dashboard Error</h2>
            <p>{error.message}</p>
            <button onClick={reset}>Reload Dashboard</button>
          </div>
        )}
      >
        <div
          style={{
            display: 'grid',
            gridTemplateColumns: '250px 1fr',
            gap: '2rem',
            marginTop: '2rem',
          }}
        >
          {/* Sidebar with independent Suspense */}
          <aside>
            <ErrorBoundary>
              <Suspense fallback={<FilterSkeleton />}>
                <FilterPanel
                  productResource={productResource}
                  onFilteredResults={setDisplayProducts}
                />
              </Suspense>
            </ErrorBoundary>
          </aside>

          {/* Main content */}
          <main>
            {/* Search (no Suspense needed - local state) */}
            <ErrorBoundary>
              <div style={{ marginBottom: '1rem' }}>
                <SearchBar
                  productResource={productResource}
                  onSearchResults={setDisplayProducts}
                />
              </div>
            </ErrorBoundary>

            {/* Product List with Suspense */}
            <ErrorBoundary
              fallback={({ error, reset }) => (
                <div
                  style={{
                    padding: '2rem',
                    background: '#fff3cd',
                    borderRadius: '8px',
                  }}
                >
                  <h3>âš ï¸ Failed to load products</h3>
                  <p>{error.message}</p>
                  <button onClick={reset}>Retry</button>
                </div>
              )}
            >
              <Suspense fallback={<ProductSkeleton count={20} />}>
                <ProductList
                  productResource={productResource}
                  displayProducts={displayProducts}
                />
              </Suspense>
            </ErrorBoundary>
          </main>
        </div>
      </ErrorBoundary>
    </div>
  );
}

/**
 * Product List component that suspends while loading
 */
function ProductList({ productResource, displayProducts }) {
  // This will suspend if data is not ready
  const allProducts = productResource.read();

  const products = displayProducts || allProducts;

  return (
    <div>
      <div
        style={{
          marginBottom: '1rem',
          color: '#666',
          fontSize: '0.875rem',
        }}
      >
        Showing {products.length} of {allProducts.length} products
      </div>

      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
          gap: '1rem',
        }}
      >
        {products.slice(0, 100).map((product) => (
          <ProductCard
            key={product.id}
            product={product}
          />
        ))}
      </div>

      {products.length === 0 && (
        <div
          style={{
            textAlign: 'center',
            padding: '3rem',
            color: '#999',
          }}
        >
          No products found
        </div>
      )}
    </div>
  );
}

/**
 * Individual product card
 */
function ProductCard({ product }) {
  return (
    <div
      style={{
        border: '1px solid #ddd',
        borderRadius: '8px',
        padding: '1rem',
        background: 'white',
      }}
    >
      <div
        style={{
          background: '#f0f0f0',
          height: '150px',
          borderRadius: '4px',
          marginBottom: '0.5rem',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        ğŸ“¦
      </div>
      <h3 style={{ fontSize: '1rem', margin: '0.5rem 0' }}>{product.name}</h3>
      <p style={{ fontSize: '0.875rem', color: '#666', margin: '0.25rem 0' }}>
        {product.category}
      </p>
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginTop: '0.5rem',
        }}
      >
        <span style={{ fontWeight: 'bold' }}>${product.price}</span>
        <span>{product.rating}â˜…</span>
      </div>
      {!product.inStock && (
        <div
          style={{
            marginTop: '0.5rem',
            color: '#d32f2f',
            fontSize: '0.75rem',
          }}
        >
          Out of Stock
        </div>
      )}
    </div>
  );
}

// Usage in App.jsx:
// const productResource = createResource(fetchProducts());
//
// function App() {
//   return <ProductDashboard productResource={productResource} />;
// }
```

</details>

**â­â­â­ Task 3.2: Loading Skeletons**

<details>
<summary>ğŸ’¡ Solution - LoadingStates.jsx</summary>

```jsx
/**
 * Loading skeleton components
 * Realistic placeholders that match actual content layout
 */

export function ProductSkeleton({ count = 20 }) {
  return (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
        gap: '1rem',
      }}
    >
      {Array.from({ length: count }, (_, i) => (
        <div
          key={i}
          style={{
            border: '1px solid #ddd',
            borderRadius: '8px',
            padding: '1rem',
            background: 'white',
          }}
        >
          {/* Image skeleton */}
          <div
            style={{
              background:
                'linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%)',
              backgroundSize: '200% 100%',
              animation: 'shimmer 1.5s infinite',
              height: '150px',
              borderRadius: '4px',
              marginBottom: '0.5rem',
            }}
          />

          {/* Title skeleton */}
          <div
            style={{
              background:
                'linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%)',
              backgroundSize: '200% 100%',
              animation: 'shimmer 1.5s infinite',
              height: '1rem',
              borderRadius: '4px',
              marginBottom: '0.5rem',
            }}
          />

          {/* Category skeleton */}
          <div
            style={{
              background:
                'linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%)',
              backgroundSize: '200% 100%',
              animation: 'shimmer 1.5s infinite',
              height: '0.875rem',
              width: '60%',
              borderRadius: '4px',
            }}
          />
        </div>
      ))}

      <style>{`
        @keyframes shimmer {
          0% { background-position: -200% 0; }
          100% { background-position: 200% 0; }
        }
      `}</style>
    </div>
  );
}

export function FilterSkeleton() {
  return (
    <div
      style={{
        padding: '1rem',
        background: '#f9f9f9',
        borderRadius: '8px',
      }}
    >
      <div
        style={{
          background: '#e0e0e0',
          height: '1.5rem',
          borderRadius: '4px',
          marginBottom: '1rem',
        }}
      />

      {[1, 2, 3, 4].map((i) => (
        <div
          key={i}
          style={{ marginBottom: '1rem' }}
        >
          <div
            style={{
              background: '#e0e0e0',
              height: '1rem',
              width: '40%',
              borderRadius: '4px',
              marginBottom: '0.5rem',
            }}
          />
          <div
            style={{
              background: '#f0f0f0',
              height: '2rem',
              borderRadius: '4px',
            }}
          />
        </div>
      ))}
    </div>
  );
}

export function LoadingIndicator() {
  return (
    <div
      style={{
        position: 'fixed',
        top: '1rem',
        right: '1rem',
        background: 'rgba(0, 0, 0, 0.8)',
        color: 'white',
        padding: '0.75rem 1rem',
        borderRadius: '8px',
        display: 'flex',
        alignItems: 'center',
        gap: '0.5rem',
        zIndex: 1000,
      }}
    >
      <div
        style={{
          width: '16px',
          height: '16px',
          border: '2px solid white',
          borderTopColor: 'transparent',
          borderRadius: '50%',
          animation: 'spin 0.8s linear infinite',
        }}
      />
      Processing...
      <style>{`
        @keyframes spin {
          to { transform: rotate(360deg); }
        }
      `}</style>
    </div>
  );
}
```

</details>

### Phase 4: Integration & Polish (20 phÃºt)

**â­â­â­â­â­ Task 4.1: Complete App Integration**

<details>
<summary>ğŸ’¡ Solution - App.jsx (Complete Integration)</summary>

```jsx
import { ErrorBoundary } from './components/ErrorBoundary/ErrorBoundary';
import { ProductDashboard } from './components/ProductDashboard/ProductDashboard';
import { createResource, fetchProducts } from './utils/mockApi';

/**
 * Create product resource outside component
 * This triggers the fetch immediately when module loads
 */
const productResource = createResource(
  fetchProducts({
    minDelay: 1000,
    maxDelay: 2000,
    failureRate: 0.1, // 10% chance of error to test Error Boundary
  }),
);

/**
 * Root App component
 * Demonstrates production-grade error handling at app level
 */
function App() {
  return (
    <ErrorBoundary
      fallback={({ error, reset }) => (
        <div
          style={{
            minHeight: '100vh',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            background: '#f5f5f5',
          }}
        >
          <div
            style={{
              background: 'white',
              padding: '2rem',
              borderRadius: '8px',
              boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
              maxWidth: '500px',
              textAlign: 'center',
            }}
          >
            <h1 style={{ color: '#d32f2f' }}>ğŸ’¥ Application Error</h1>
            <p style={{ color: '#666', margin: '1rem 0' }}>{error.message}</p>
            <button
              onClick={reset}
              style={{
                background: '#1976d2',
                color: 'white',
                border: 'none',
                padding: '0.75rem 1.5rem',
                borderRadius: '4px',
                cursor: 'pointer',
                fontSize: '1rem',
              }}
            >
              Reload Application
            </button>
          </div>
        </div>
      )}
      onError={(error, errorInfo) => {
        // In production, send to error tracking service
        console.error('App-level error:', error);
        console.error('Error info:', errorInfo);
      }}
    >
      <ProductDashboard productResource={productResource} />
    </ErrorBoundary>
  );
}

export default App;

// Note: To test error boundary, you can:
// 1. Increase failureRate to 1.0 in fetchProducts
// 2. Throw error in any component
// 3. Break the mock API intentionally
```

</details>

---

## ğŸ“Š PHáº¦N 4: TESTING & OPTIMIZATION (30 phÃºt)

### 4.1 Performance Checklist

**Manual Testing:**

```jsx
// utils/performanceTest.js

/**
 * Performance testing utilities
 * Run these in browser console to measure performance
 */

export const performanceTests = {
  // Test 1: Search Response Time
  testSearchSpeed: () => {
    console.log('ğŸ§ª Testing Search Speed...');
    const input = document.querySelector('input[type="search"]');

    const start = performance.now();
    input.value = 'test';
    input.dispatchEvent(new Event('input', { bubbles: true }));
    const end = performance.now();

    console.log(`âœ… Input lag: ${(end - start).toFixed(2)}ms`);
    console.log(end - start < 50 ? 'âœ… PASS' : 'âŒ FAIL (> 50ms)');
  },

  // Test 2: Filter Apply Time
  testFilterSpeed: () => {
    console.log('ğŸ§ª Testing Filter Speed...');
    const select = document.querySelector('select');

    const start = performance.now();
    select.value = 'Electronics';
    select.dispatchEvent(new Event('change', { bubbles: true }));

    // Wait for transition to complete
    setTimeout(() => {
      const end = performance.now();
      console.log(`âœ… Filter perceived time: ${(end - start).toFixed(2)}ms`);
      console.log(end - start < 100 ? 'âœ… PASS' : 'âŒ FAIL (> 100ms)');
    }, 100);
  },

  // Test 3: Render Count
  testRenderCount: () => {
    console.log('ğŸ§ª Counting renders...');
    console.log('Open React DevTools Profiler and start recording');
    console.log('Then type in search box and check render count');
  },

  // Test 4: Memory Leaks
  testMemoryLeaks: () => {
    console.log('ğŸ§ª Testing Memory Leaks...');
    console.log('1. Open DevTools â†’ Memory');
    console.log('2. Take heap snapshot');
    console.log('3. Perform actions (search, filter)');
    console.log('4. Take another snapshot');
    console.log('5. Compare - should not grow significantly');
  },
};

// Run all tests
export const runAllTests = () => {
  Object.values(performanceTests).forEach((test) => {
    test();
  });
};

// Usage in console:
// import { runAllTests } from './utils/performanceTest';
// runAllTests();
```

### 4.2 React DevTools Profiler Guide

```markdown
ğŸ“Š PROFILING CHECKLIST:

1. **Setup:**
   - [ ] Open React DevTools
   - [ ] Switch to Profiler tab
   - [ ] Click "Record" button

2. **Test Scenarios:**
   - [ ] Type in search box (test useTransition)
   - [ ] Change filters (test useDeferredValue)
   - [ ] Check "why did this render?"
   - [ ] Look for unnecessary re-renders

3. **Metrics to Check:**
   - [ ] Commit duration < 16ms (60fps)
   - [ ] No redundant renders
   - [ ] Suspense boundaries working
   - [ ] useTransition showing separate renders

4. **Expected Results:**
   âœ… Search input: 2 renders (urgent + non-urgent)
   âœ… Filters: Stale visual feedback before update
   âœ… ProductList: Only renders when data changes
   âœ… ProductCard: Memoized, doesn't re-render unnecessarily
```

### 4.3 Optimization Opportunities

```jsx
/**
 * OPTIMIZATION CHECKLIST
 *
 * Already Implemented:
 * âœ… useTransition for responsive UI
 * âœ… useDeferredValue for heavy computations
 * âœ… Suspense for async operations
 * âœ… Error boundaries for resilience
 *
 * Advanced Optimizations (Optional):
 * ğŸ”² React.memo on ProductCard
 * ğŸ”² useMemo for filter calculations
 * ğŸ”² useCallback for event handlers
 * ğŸ”² Virtual scrolling (react-window) for 10k+ items
 * ğŸ”² Web Workers for filtering
 * ğŸ”² IndexedDB for client-side caching
 *
 * Production Enhancements:
 * ğŸ”² Error tracking (Sentry)
 * ğŸ”² Performance monitoring (Web Vitals)
 * ğŸ”² A11y testing (axe-core)
 * ğŸ”² E2E tests (Playwright)
 */
```

---

## âœ… PHáº¦N 5: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

**React 18 Features:**

- [ ] TÃ´i hiá»ƒu khi nÃ o dÃ¹ng useTransition vs useDeferredValue
- [ ] TÃ´i biáº¿t cÃ¡ch setup Suspense boundaries Ä‘Ãºng cÃ¡ch
- [ ] TÃ´i cÃ³ thá»ƒ implement Error Boundaries
- [ ] TÃ´i hiá»ƒu concurrent rendering hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o
- [ ] TÃ´i biáº¿t cÃ¡ch debug performance vá»›i React DevTools

**Code Quality:**

- [ ] Components cÃ³ clear responsibilities
- [ ] Error handling á»Ÿ nhiá»u levels
- [ ] Loading states meaningful vÃ  realistic
- [ ] Code cÃ³ comments giáº£i thÃ­ch decisions
- [ ] No console warnings/errors

**Performance:**

- [ ] Search input responsive (< 50ms lag)
- [ ] Filters apply smooth (perceived < 100ms)
- [ ] No unnecessary re-renders
- [ ] Suspense boundaries granular
- [ ] Memory khÃ´ng leak

### Production Readiness Checklist

```markdown
ğŸ“‹ PRODUCTION CHECKLIST:

Architecture:

- [ ] Proper component hierarchy
- [ ] Separation of concerns (UI vs logic)
- [ ] Reusable components vÃ  hooks
- [ ] Clear data flow

Error Handling:

- [ ] Error boundaries at multiple levels
- [ ] Graceful degradation
- [ ] User-friendly error messages
- [ ] Recovery options (retry, reset)

Performance:

- [ ] Concurrent features properly used
- [ ] Loading states smooth
- [ ] No UI blocking
- [ ] Profiler shows good metrics

User Experience:

- [ ] Feedback for all actions
- [ ] Loading indicators clear
- [ ] Error states helpful
- [ ] Smooth transitions

Code Quality:

- [ ] Comments explain WHY, not WHAT
- [ ] Consistent naming
- [ ] No magic numbers
- [ ] DRY principle followed
```

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (60 phÃºt)

**Exercise 1: Add More Concurrent Features**

ThÃªm cÃ¡c features sau vÃ o dashboard:

1. **Sort Options vá»›i useTransition**
   - Sort by: Price (low-high, high-low), Rating, Name
   - Sorting khÃ´ng block UI
   - Show sorting indicator

2. **Pagination vá»›i useDeferredValue**
   - Show 50 items per page
   - Page change smooth
   - Total pages calculated correctly

3. **Advanced Error Recovery**
   - Retry button vá»›i exponential backoff
   - Fallback to cached data
   - Offline indicator

**Acceptance Criteria:**

- [ ] Táº¥t cáº£ sorts < 100ms perceived time
- [ ] Pagination smooth (no jumps)
- [ ] Error recovery works
- [ ] Code follows established patterns

### NÃ¢ng cao (90 phÃºt)

**Exercise 2: Add Real-time Features**

Implement "simulated real-time updates":

1. **Live Product Updates**
   - Random products update every 5s (price, stock)
   - Updates don't disrupt current view
   - Smooth animations for changes

2. **Optimistic Updates**
   - "Add to Cart" button
   - Optimistic UI update
   - Rollback on error

3. **Performance Monitoring Dashboard**
   - Display render times
   - Show memory usage
   - Track interaction metrics
   - Warning when budget exceeded

**Advanced Requirements:**

- [ ] Updates use useTransition
- [ ] No layout shifts (CLS = 0)
- [ ] Performance monitoring accurate
- [ ] UI remains responsive

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - Concurrent Features:**
   - https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react
   - Focus: useTransition, useDeferredValue patterns

2. **React Docs - Suspense:**
   - https://react.dev/reference/react/Suspense
   - Focus: Best practices, boundaries strategy

3. **Web Vitals:**
   - https://web.dev/vitals/
   - Focus: LCP, FID, CLS metrics

### Äá»c thÃªm

1. **Patterns.dev - React Performance:**
   - https://www.patterns.dev/posts/react-performance
   - Advanced optimization techniques

2. **Kent C. Dodds - React Performance:**
   - https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (cáº§n biáº¿t):

**Tá»« NgÃ y 46-51:**

- NgÃ y 46: Concurrent rendering concept
- NgÃ y 47: useTransition basics
- NgÃ y 48: useDeferredValue basics
- NgÃ y 49: Suspense for data fetching
- NgÃ y 50: Error Boundaries
- NgÃ y 51: RSC overview (khÃ´ng cáº§n implement)

**Tá»« Phase trÆ°á»›c:**

- useState, useEffect, useReducer (state management)
- useMemo, useCallback, React.memo (optimization)
- Custom hooks (logic extraction)

### HÆ°á»›ng tá»›i (sáº½ dÃ¹ng trong):

**NgÃ y 53-60 (Testing & Quality):**

- Testing concurrent features
- Performance testing strategies
- A11y testing

**Capstone Project (NgÃ y 61-75):**

- Táº¥t cáº£ patterns há»c hÃ´m nay
- Production-grade implementation
- Real deployment

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. When to Use Concurrent Features:**

```jsx
// âœ… GOOD Use Cases:
- Heavy lists (1000+ items)
- Complex filtering/sorting
- Real-time data updates
- Resource-intensive computations

// âŒ BAD Use Cases:
- Simple forms (< 50 items)
- Static content
- Already fast operations
// Don't add complexity without measuring first!
```

**2. Suspense Boundaries Strategy:**

```markdown
Level 1 (App): Catch-all for critical errors
Level 2 (Feature): Independent features load separately
Level 3 (Component): Specific components (e.g., heavy chart)

Rule of thumb:

- Boundary per independent data source
- Boundary per user workflow
- NOT boundary per component (too granular!)
```

**3. Error Boundary Placement:**

```jsx
// âŒ Too granular
<ErrorBoundary>
  <Button />
</ErrorBoundary>

// âŒ Too broad
<ErrorBoundary>
  <EntireApp />
</ErrorBoundary>

// âœ… Just right
<ErrorBoundary> {/* App-level */}
  <Header />
  <ErrorBoundary> {/* Feature-level */}
    <Dashboard />
  </ErrorBoundary>
</ErrorBoundary>
```

**4. Performance Budget:**

```markdown
Establish budgets BEFORE building:

âœ… DO:

- Set concrete targets (< 50ms input lag)
- Measure before optimizing
- Profile in production mode
- Test on low-end devices

âŒ DON'T:

- Optimize prematurely
- Trust "feels fast" gut feeling
- Only test on MacBook Pro
- Ignore real user metrics
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

**Q1:** "Giáº£i thÃ­ch sá»± khÃ¡c biá»‡t giá»¯a useTransition vÃ  useDeferredValue?"

**Expected Answer:**

```markdown
useTransition:

- Cho phÃ©p mark updates lÃ  non-urgent
- Tráº£ vá» isPending flag
- DÃ¹ng khi báº¡n control update (e.g., onClick)

useDeferredValue:

- Defer má»™t value thay vÃ¬ update
- DÃ¹ng khi báº¡n nháº­n value tá»« props/state
- Tá»± Ä‘á»™ng show stale content

Khi nÃ o dÃ¹ng gÃ¬:

- useTransition: Khi báº¡n trigger action (search, filter)
- useDeferredValue: Khi báº¡n react to value (display results)
```

**Q2:** "Táº¡i sao cáº§n Error Boundaries khi Ä‘Ã£ cÃ³ try-catch?"

**Expected Answer:**

```markdown
Error Boundaries báº¯t:
âœ… Render errors
âœ… Lifecycle method errors
âœ… Constructor errors

try-catch KHÃ”NG báº¯t Ä‘Æ°á»£c:
âŒ Render phase errors
âŒ Async errors (need to wrap trong component)
âŒ Event handler errors (cáº§n try-catch thá»§ cÃ´ng)

VÃ­ dá»¥:
function Component() {
// try-catch KHÃ”NG báº¯t Ä‘Æ°á»£c
return <div>{props.data.map()}</div>; // Error here!
}
```

**Mid Level:**

**Q3:** "LÃ m sao debug performance issues vá»›i React 18?"

**Expected Answer:**

```markdown
Tools:

1. React DevTools Profiler
   - Flame graph Ä‘á»ƒ identify slow components
   - Ranked chart Ä‘á»ƒ compare
   - "Why did this render?"

2. Performance API
   - performance.measure()
   - User Timing API
   - Mark significant events

3. Chrome DevTools
   - Performance tab
   - Memory profiler
   - Coverage tool

Process:

1. Reproduce issue
2. Profile in production mode
3. Identify bottleneck
4. Apply targeted fix
5. Measure again
```

**Q4:** "Khi nÃ o NÃŠN vÃ  KHÃ”NG NÃŠN dÃ¹ng Suspense?"

**Expected Answer:**

```markdown
âœ… NÃŠN dÃ¹ng khi:

- Data fetching (with compatible library)
- Code splitting (React.lazy)
- Async dependencies

âŒ KHÃ”NG NÃŠN dÃ¹ng khi:

- Legacy data fetching (useEffect + setState)
- Components khÃ´ng suspend
- Overuse (too many boundaries)

Best practices:

- Colocate Suspense vá»›i component cáº§n data
- Multiple boundaries > Single boundary
- Meaningful fallbacks > Generic spinners
```

**Senior Level:**

**Q5:** "Thiáº¿t káº¿ loading architecture cho app production vá»›i 10+ features?"

**Expected Answer:**

```markdown
Architecture:

1. Skeleton screens (immediate feedback)
2. Progressive loading (show what's ready)
3. Optimistic UI (assume success)
4. Stale-while-revalidate (instant + fresh)

Suspense strategy:

- Route level: Major page transitions
- Feature level: Independent sections
- Component level: Heavy components only

Error recovery:

- Retry with exponential backoff
- Fallback to cached data
- Degraded mode (show partial data)

Metrics:

- Track loading times per feature
- Monitor error rates
- A/B test loading strategies
```

**Q6:** "Trade-offs cá»§a concurrent rendering? Khi nÃ o KHÃ”NG dÃ¹ng?"

**Expected Answer:**

```markdown
Pros:
âœ… Better UX (no blocking)
âœ… Prioritized updates
âœ… Automatic batching

Cons:
âŒ Complexity tÄƒng
âŒ Component render nhiá»u láº§n hÆ¡n
âŒ Need to understand interruption

KHÃ”NG dÃ¹ng khi:

- App Ä‘Ã£ Ä‘á»§ nhanh (< 16ms renders)
- Team chÆ°a quen React 18
- Complexity > benefit
- Simple CRUD apps

DÃ¹ng khi:

- Heavy computations
- Large lists (1000+ items)
- Real-time updates
- Complex interactions
```

### War Stories

**Story 1: Over-optimization Disaster**

```markdown
ğŸ”¥ THE PROBLEM:
Team wrapped EVERY component trong Suspense vÃ  Error Boundary.
Result: 100+ boundaries, impossible to debug, worse UX.

ğŸ’¡ LESSON:
"Measure first, optimize later"

- Start simple
- Add boundaries when needed
- Don't cargo-cult patterns
```

**Story 2: Suspense Waterfall**

```markdown
ğŸ”¥ THE PROBLEM:
Nested Suspense causing serial loading:
Suspense 1 loads â†’ reveals Suspense 2 â†’ loads â†’ reveals Suspense 3

ğŸ’¡ SOLUTION:
Parallel loading with Promise.all:
const [data1, data2, data3] = use(Promise.all([
fetchData1(),
fetchData2(),
fetchData3()
]));

LESSON: Understand data dependencies before adding boundaries.
```

**Story 3: Error Boundary Blind Spots**

```markdown
ğŸ”¥ THE PROBLEM:
Error Boundary at app level only.
Bug in sidebar crashed entire app.
Users lost form data.

ğŸ’¡ SOLUTION:
Granular boundaries:

- App level: Last resort
- Feature level: Sidebar, Main, Modal
- Component level: Complex widgets

LESSON: Fail gracefully, fail locally.
```

---

## ğŸ¯ PREVIEW NGÃ€Y MAI

**NgÃ y 53: Testing Philosophy & Strategy**

NgÃ y mai chÃºng ta sáº½ chuyá»ƒn sang Phase 6: Testing & Quality. Báº¡n sáº½ há»c:

- Testing pyramid vÃ  strategy
- What to test, what NOT to test
- Test structure (Arrange, Act, Assert)
- Mocking strategies
- Confidence vs cost trade-offs

Táº¥t cáº£ React 18 features há»c tuáº§n nÃ y sáº½ Ä‘Æ°á»£c test. Chuáº©n bá»‹ Ä‘á»ƒ viáº¿t tests cho concurrent features, Suspense, vÃ  Error Boundaries!

**Chuáº©n bá»‹:**

- Ã”n láº¡i useState, useEffect (sáº½ test hooks)
- Review project hÃ´m nay (sáº½ viáº¿t tests cho nÃ³)
- Mindset: "How do I PROVE this works?" thay vÃ¬ "It works on my machine"

---

âœ… **HoÃ n thÃ nh NgÃ y 52!**

ChÃºc má»«ng báº¡n Ä‘Ã£ hoÃ n thÃ nh project tá»•ng há»£p React 18! ÄÃ¢y lÃ  milestone quan trá»ng - báº¡n Ä‘Ã£ cÃ³ kháº£ nÄƒng build production-grade apps vá»›i modern React features. Phase tiáº¿p theo (Testing) sáº½ giÃºp báº¡n tá»± tin deploy code vÃ o production.

**Action Items:**

1. âœ… HoÃ n thiá»‡n project vá»›i táº¥t cáº£ features
2. âœ… Profile vá»›i React DevTools
3. âœ… LÃ m bÃ i táº­p vá» nhÃ 
4. âœ… Review code cá»§a chÃ­nh mÃ¬nh (self code review)
5. âœ… Chuáº©n bá»‹ cho Testing phase

**Nhá»›:** Code cháº¡y Ä‘Æ°á»£c â‰  Code production-ready. Testing lÃ  bÆ°á»›c cuá»‘i Ä‘á»ƒ Ä‘áº£m báº£o quality! ğŸš€
