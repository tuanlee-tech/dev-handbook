# üìÖ NG√ÄY 54: React Testing Library - Basics

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

- [ ] Hi·ªÉu philosophy c·ªßa React Testing Library v√† c√°ch ti·∫øp c·∫≠n "test nh∆∞ user"
- [ ] S·ª≠ d·ª•ng th√†nh th·∫°o render, screen v√† c√°c query methods c∆° b·∫£n
- [ ] Vi·∫øt ƒë∆∞·ª£c unit tests cho components v·ªõi props, state, v√† events
- [ ] Ph√¢n bi·ªát v√† √°p d·ª•ng ƒë√∫ng getBy/queryBy/findBy queries
- [ ] Debug tests hi·ªáu qu·∫£ v·ªõi screen.debug() v√† testing-playground

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

1. **Testing Philosophy (Ng√†y 53)**: T·∫°i sao n√™n "test behavior, not implementation"?
2. **React Fundamentals**: Component v·ªõi props + state + events ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o?
3. **DOM APIs**: `querySelector`, `textContent`, `getAttribute` d√πng ƒë·ªÉ l√†m g√¨?

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

**Scenario: Team lead review code c·ªßa b·∫°n**

```jsx
// ‚ùå Test n√†y PASS nh∆∞ng component v·∫´n BROKEN cho users
test('counter works', () => {
  const wrapper = shallow(<Counter />);
  expect(wrapper.state('count')).toBe(0);
  wrapper.instance().increment();
  expect(wrapper.state('count')).toBe(1);
});

// Component th·ª±c t·∫ø:
const Counter = () => {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>Count: {count}</p>
      {/* ‚ùå BUG: Button kh√¥ng g·ªçi increment! */}
      <button>Increment</button>
    </div>
  );
};
```

**V·∫•n ƒë·ªÅ:** Test ki·ªÉm tra implementation (state, methods) ch·ª© kh√¥ng ki·ªÉm tra behavior (user th·∫•y g√¨, l√†m g√¨).

### 1.2 Gi·∫£i Ph√°p: React Testing Library

**Philosophy:** "The more your tests resemble the way your software is used, the more confidence they can give you."

```jsx
// ‚úÖ Test n√†y S·∫º FAIL v√¨ button kh√¥ng ho·∫°t ƒë·ªông
test('counter increments when button clicked', () => {
  render(<Counter />);

  // T√¨m nh∆∞ user t√¨m: b·∫±ng text
  const button = screen.getByRole('button', { name: /increment/i });

  // Click nh∆∞ user click
  fireEvent.click(button);

  // Verify nh∆∞ user nh√¨n th·∫•y
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
```

**L·ª£i √≠ch:**

- Test ph√°t hi·ªán bug th·∫≠t (button kh√¥ng click ƒë∆∞·ª£c)
- Test kh√¥ng break khi refactor (ƒë·ªïi useState ‚Üí useReducer v·∫´n OK)
- Test document c√°ch d√πng component

### 1.3 Mental Model

```
USER PERSPECTIVE           RTL QUERIES              DOM
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"T√¥i th·∫•y button          getByRole('button')    <button>
 c√≥ ch·ªØ Submit"           getByText('Submit')

"T√¥i click v√†o ƒë√≥"        fireEvent.click()      onclick handler

"T√¥i th·∫•y th√¥ng b√°o       getByText('Success')   <div>Success</div>
 Success"

FLOW:
1. render(<Component />)     ‚Üí Mount component v√†o DOM
2. screen.getBy*()          ‚Üí T√¨m element nh∆∞ user t√¨m
3. fireEvent.*()            ‚Üí T∆∞∆°ng t√°c nh∆∞ user
4. expect().toBeInTheDocument() ‚Üí Verify k·∫øt qu·∫£
```

**Analogy:** RTL nh∆∞ m·ªôt robot test th·ªß c√¥ng:

- **Kh√¥ng** m·ªü Chrome DevTools xem code
- **Ch·ªâ** d√πng m·∫Øt (screen queries) v√† tay (fireEvent)
- **Ki·ªÉm tra** nh·ªØng g√¨ nh√¨n th·∫•y tr√™n m√†n h√¨nh

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

| ‚ùå Sai L·∫ßm                  | ‚úÖ ƒê√∫ng                    | üí° T·∫°i Sao            |
| --------------------------- | -------------------------- | --------------------- |
| Test state/props tr·ª±c ti·∫øp  | Test output (DOM)          | User kh√¥ng th·∫•y state |
| D√πng className ƒë·ªÉ query     | D√πng role/label/text       | User kh√¥ng th·∫•y class |
| Test implementation details | Test behavior              | Refactor-safe tests   |
| Wrapper.find('button')      | screen.getByRole('button') | User perspective      |
| Snapshot m·ªçi th·ª©            | Targeted assertions        | Snapshots d·ªÖ outdated |

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Pattern C∆° B·∫£n ‚≠ê

**Setup Test Environment**

```jsx
// Counter.jsx
/**
 * Simple counter component for demo
 */
const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Counter App</h1>
      <p>Current count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
};

// Counter.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import Counter from './Counter';

// ‚ùå C√ÅCH SAI: Test implementation
test('‚ùå BAD: checking state directly', () => {
  const wrapper = mount(<Counter />);
  expect(wrapper.state('count')).toBe(0); // Fragile!
});

// ‚úÖ C√ÅCH ƒê√öNG: Test behavior
test('‚úÖ GOOD: displays initial count', () => {
  render(<Counter />);

  // User sees this text
  expect(screen.getByText('Current count: 0')).toBeInTheDocument();
});

test('increments count when button clicked', () => {
  render(<Counter />);

  // Find button by accessible name
  const incrementButton = screen.getByRole('button', { name: /increment/i });

  // Simulate user click
  fireEvent.click(incrementButton);

  // Verify result
  expect(screen.getByText('Current count: 1')).toBeInTheDocument();
});

test('resets count to zero', () => {
  render(<Counter />);

  // Setup: increment first
  const incrementButton = screen.getByRole('button', { name: /increment/i });
  fireEvent.click(incrementButton);
  fireEvent.click(incrementButton);

  // Action: reset
  const resetButton = screen.getByRole('button', { name: /reset/i });
  fireEvent.click(resetButton);

  // Verify
  expect(screen.getByText('Current count: 0')).toBeInTheDocument();
});
```

**Key Points:**

- `render()` mounts component
- `screen` l√† global object ƒë·ªÉ query DOM
- `fireEvent` trigger events
- Assertions ki·ªÉm tra DOM, kh√¥ng ph·∫£i internal state

### Demo 2: Query Methods Deep Dive ‚≠ê‚≠ê

**Understanding getBy vs queryBy vs findBy**

```jsx
// LoginForm.jsx
const LoginForm = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);

  const handleSubmit = (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    setTimeout(() => {
      const email = e.target.email.value;
      if (email === 'test@example.com') {
        setSuccess(true);
        setLoading(false);
      } else {
        setError('Invalid credentials');
        setLoading(false);
      }
    }, 1000);
  };

  return (
    <form onSubmit={handleSubmit}>
      <h2>Login</h2>

      <input
        type='email'
        name='email'
        placeholder='Enter email'
        aria-label='Email address'
      />

      <button
        type='submit'
        disabled={loading}
      >
        {loading ? 'Loading...' : 'Login'}
      </button>

      {error && <div role='alert'>{error}</div>}
      {success && <div>Welcome back!</div>}
    </form>
  );
};

// LoginForm.test.jsx
describe('LoginForm', () => {
  test('renders login form', () => {
    render(<LoginForm />);

    // getBy: throws if not found (for elements that MUST exist)
    expect(screen.getByRole('heading', { name: /login/i })).toBeInTheDocument();
    expect(screen.getByLabelText(/email address/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /login/i })).toBeInTheDocument();
  });

  test('error message not shown initially', () => {
    render(<LoginForm />);

    // ‚ùå WRONG: getBy will throw error
    // expect(screen.getByRole('alert')).not.toBeInTheDocument();

    // ‚úÖ CORRECT: queryBy returns null if not found
    expect(screen.queryByRole('alert')).not.toBeInTheDocument();
  });

  test('shows loading state during submission', () => {
    render(<LoginForm />);

    const emailInput = screen.getByLabelText(/email address/i);
    const submitButton = screen.getByRole('button', { name: /login/i });

    // Fill form
    fireEvent.change(emailInput, { target: { value: 'test@example.com' } });

    // Submit
    fireEvent.click(submitButton);

    // Button text changes immediately
    expect(
      screen.getByRole('button', { name: /loading/i }),
    ).toBeInTheDocument();
  });

  test('shows error for invalid credentials', async () => {
    render(<LoginForm />);

    const emailInput = screen.getByLabelText(/email address/i);
    const submitButton = screen.getByRole('button', { name: /login/i });

    fireEvent.change(emailInput, { target: { value: 'wrong@example.com' } });
    fireEvent.click(submitButton);

    // ‚úÖ findBy for async elements (returns Promise)
    const errorMessage = await screen.findByRole('alert');
    expect(errorMessage).toHaveTextContent('Invalid credentials');
  });

  test('shows success message for valid credentials', async () => {
    render(<LoginForm />);

    const emailInput = screen.getByLabelText(/email address/i);
    const submitButton = screen.getByRole('button', { name: /login/i });

    fireEvent.change(emailInput, { target: { value: 'test@example.com' } });
    fireEvent.click(submitButton);

    // Wait for async operation
    const successMessage = await screen.findByText(/welcome back/i);
    expect(successMessage).toBeInTheDocument();
  });
});
```

**Query Methods Decision Tree:**

```
Element t·ªìn t·∫°i NGAY L·∫¨P T·ª®C?
‚îú‚îÄ YES ‚Üí getBy*
‚îÇ   ‚îî‚îÄ Throws if not found
‚îÇ   ‚îî‚îÄ Best for: elements that must exist
‚îÇ
‚îú‚îÄ NO (might not exist) ‚Üí queryBy*
‚îÇ   ‚îî‚îÄ Returns null if not found
‚îÇ   ‚îî‚îÄ Best for: asserting absence
‚îÇ
‚îî‚îÄ ASYNC (appears later) ‚Üí findBy*
    ‚îî‚îÄ Returns Promise
    ‚îî‚îÄ Best for: async operations
```

### Demo 3: Query Priority & Best Practices ‚≠ê‚≠ê‚≠ê

```jsx
// ProductCard.jsx
const ProductCard = ({ product, onAddToCart }) => {
  const [quantity, setQuantity] = useState(1);

  return (
    <article>
      <img
        src={product.image}
        alt={product.name}
      />

      <h3>{product.name}</h3>

      <p>{product.description}</p>

      <div>
        <span data-testid='price'>${product.price}</span>

        {product.inStock ? (
          <span className='badge-success'>In Stock</span>
        ) : (
          <span className='badge-danger'>Out of Stock</span>
        )}
      </div>

      <div>
        <label htmlFor={`qty-${product.id}`}>Quantity:</label>
        <input
          id={`qty-${product.id}`}
          type='number'
          value={quantity}
          onChange={(e) => setQuantity(Number(e.target.value))}
          min='1'
          max='10'
        />
      </div>

      <button
        onClick={() => onAddToCart(product.id, quantity)}
        disabled={!product.inStock}
        aria-label={`Add ${product.name} to cart`}
      >
        Add to Cart
      </button>
    </article>
  );
};

// ProductCard.test.jsx
describe('ProductCard', () => {
  const mockProduct = {
    id: '1',
    name: 'Awesome T-Shirt',
    description: 'Comfortable cotton t-shirt',
    price: 29.99,
    image: '/tshirt.jpg',
    inStock: true,
  };

  const mockAddToCart = jest.fn();

  // ‚ùå ANTI-PATTERN: Using test IDs everywhere
  test('‚ùå BAD: relying on test IDs', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockAddToCart}
      />,
    );

    // This works but is not user-centric
    expect(screen.getByTestId('price')).toHaveTextContent('$29.99');
  });

  // ‚úÖ BEST PRACTICE: Query priority
  test('‚úÖ GOOD: using semantic queries', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockAddToCart}
      />,
    );

    // 1. By Role (BEST - accessible)
    expect(
      screen.getByRole('heading', { name: /awesome t-shirt/i }),
    ).toBeInTheDocument();

    expect(
      screen.getByRole('button', { name: /add awesome t-shirt to cart/i }),
    ).toBeInTheDocument();

    // 2. By Label Text (for form inputs)
    expect(screen.getByLabelText(/quantity/i)).toHaveValue(1);

    // 3. By Alt Text (for images)
    expect(screen.getByAltText(/awesome t-shirt/i)).toHaveAttribute(
      'src',
      '/tshirt.jpg',
    );

    // 4. By Text (for content)
    expect(screen.getByText(/comfortable cotton/i)).toBeInTheDocument();

    // 5. By Test ID (LAST RESORT - only if nothing else works)
    // Should avoid when possible
  });

  test('shows in stock badge', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockAddToCart}
      />,
    );

    // Text-based query
    expect(screen.getByText(/in stock/i)).toBeInTheDocument();
    expect(screen.queryByText(/out of stock/i)).not.toBeInTheDocument();
  });

  test('disables button when out of stock', () => {
    const outOfStockProduct = { ...mockProduct, inStock: false };

    render(
      <ProductCard
        product={outOfStockProduct}
        onAddToCart={mockAddToCart}
      />,
    );

    const button = screen.getByRole('button', { name: /add/i });
    expect(button).toBeDisabled();
    expect(screen.getByText(/out of stock/i)).toBeInTheDocument();
  });

  test('calls onAddToCart with correct arguments', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockAddToCart}
      />,
    );

    // Change quantity
    const quantityInput = screen.getByLabelText(/quantity/i);
    fireEvent.change(quantityInput, { target: { value: '3' } });

    // Click add to cart
    const button = screen.getByRole('button', { name: /add/i });
    fireEvent.click(button);

    // Verify callback
    expect(mockAddToCart).toHaveBeenCalledTimes(1);
    expect(mockAddToCart).toHaveBeenCalledWith('1', 3);
  });

  test('handles multiple additions', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockAddToCart}
      />,
    );

    const button = screen.getByRole('button', { name: /add/i });

    fireEvent.click(button);
    fireEvent.click(button);

    expect(mockAddToCart).toHaveBeenCalledTimes(2);
  });
});
```

**Query Priority (t·ª´ t·ªët nh·∫•t ƒë·∫øn cu·ªëi c√πng):**

1. **getByRole** - Accessible v√† semantic
2. **getByLabelText** - Forms
3. **getByPlaceholderText** - Forms (fallback)
4. **getByText** - Content
5. **getByDisplayValue** - Form current value
6. **getByAltText** - Images
7. **getByTitle** - Title attribute
8. **getByTestId** - LAST RESORT

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (90 ph√∫t)

### ‚≠ê B√†i 1: First Test - Warmup (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Vi·∫øt test ƒë·∫ßu ti√™n v·ªõi RTL
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: findBy, queryBy (ch·ªâ d√πng getBy)
 *
 * Requirements:
 * 1. Test component renders v·ªõi props
 * 2. Test button click thay ƒë·ªïi UI
 * 3. D√πng screen queries
 * 4. Assertions v·ªõi toBeInTheDocument()
 *
 * üí° G·ª£i √Ω: B·∫Øt ƒë·∫ßu v·ªõi getByRole v√† getByText
 */

// Greeting.jsx - Component c·∫ßn test
const Greeting = ({ name, onGreet }) => {
  const [greeted, setGreeted] = useState(false);

  return (
    <div>
      <h1>Hello, {name}!</h1>
      {greeted ? (
        <p>Nice to meet you!</p>
      ) : (
        <button
          onClick={() => {
            setGreeted(true);
            onGreet();
          }}
        >
          Greet Me
        </button>
      )}
    </div>
  );
};

// ‚ùå C√ÅCH SAI: Test state tr·ª±c ti·∫øp
test('‚ùå BAD: testing internal state', () => {
  const wrapper = shallow(
    <Greeting
      name='John'
      onGreet={() => {}}
    />,
  );
  expect(wrapper.state('greeted')).toBe(false); // Fragile!
  wrapper.find('button').simulate('click');
  expect(wrapper.state('greeted')).toBe(true);
});

// ‚úÖ C√ÅCH ƒê√öNG: Test behavior
// TODO: Implement this test
test('‚úÖ GOOD: shows greeting message after click', () => {
  // 1. Setup mock
  const mockOnGreet = jest.fn();

  // 2. Render component
  // TODO: render(<Greeting name="John" onGreet={mockOnGreet} />);

  // 3. Verify initial render
  // TODO: Check heading contains "Hello, John!"
  // TODO: Check button exists with text "Greet Me"

  // 4. Simulate interaction
  // TODO: Click button

  // 5. Verify result
  // TODO: Check "Nice to meet you!" appears
  // TODO: Check button no longer exists
  // TODO: Verify callback was called
});
```

<details>
<summary>üí° Solution</summary>

```jsx
import { render, screen, fireEvent } from '@testing-library/react';
import Greeting from './Greeting';

/**
 * Test suite for Greeting component
 */
describe('Greeting', () => {
  test('shows greeting message after click', () => {
    // Setup
    const mockOnGreet = jest.fn();

    // Render
    render(
      <Greeting
        name='John'
        onGreet={mockOnGreet}
      />,
    );

    // Verify initial state
    expect(screen.getByRole('heading')).toHaveTextContent('Hello, John!');
    expect(
      screen.getByRole('button', { name: /greet me/i }),
    ).toBeInTheDocument();

    // Interaction
    const button = screen.getByRole('button', { name: /greet me/i });
    fireEvent.click(button);

    // Verify result
    expect(screen.getByText(/nice to meet you/i)).toBeInTheDocument();
    expect(
      screen.queryByRole('button', { name: /greet me/i }),
    ).not.toBeInTheDocument();
    expect(mockOnGreet).toHaveBeenCalledTimes(1);
  });

  test('renders different names correctly', () => {
    render(
      <Greeting
        name='Alice'
        onGreet={() => {}}
      />,
    );
    expect(screen.getByText(/hello, alice!/i)).toBeInTheDocument();
  });
});

// Expected output:
// ‚úì shows greeting message after click
// ‚úì renders different names correctly
```

</details>

---

### ‚≠ê‚≠ê B√†i 2: Query Methods (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Ph√¢n bi·ªát getBy vs queryBy vs findBy
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Component c√≥ conditional rendering v√† async operations
 *
 * ü§î PH√ÇN T√çCH:
 * - getBy: Element t·ªìn t·∫°i ngay l·∫≠p t·ª©c
 * - queryBy: Element c√≥ th·ªÉ kh√¥ng t·ªìn t·∫°i (check absence)
 * - findBy: Element xu·∫•t hi·ªán sau async operation
 *
 * üí≠ KHI N√ÄO D√ôNG G√å?
 * Document quy·∫øt ƒë·ªãnh c·ªßa b·∫°n trong test comments
 */

// StatusMessage.jsx
const StatusMessage = () => {
  const [status, setStatus] = useState('idle'); // idle | loading | success | error
  const [message, setMessage] = useState('');

  const fetchData = () => {
    setStatus('loading');
    setMessage('');

    setTimeout(() => {
      if (Math.random() > 0.5) {
        setStatus('success');
        setMessage('Data loaded successfully!');
      } else {
        setStatus('error');
        setMessage('Failed to load data');
      }
    }, 1000);
  };

  return (
    <div>
      <h2>Status Dashboard</h2>

      <button onClick={fetchData}>Fetch Data</button>

      {status === 'loading' && <div role='status'>Loading...</div>}

      {status === 'success' && (
        <div
          role='alert'
          style={{ color: 'green' }}
        >
          {message}
        </div>
      )}

      {status === 'error' && (
        <div
          role='alert'
          style={{ color: 'red' }}
        >
          {message}
        </div>
      )}
    </div>
  );
};

// StatusMessage.test.jsx
describe('StatusMessage', () => {
  test('initial render - no messages shown', () => {
    render(<StatusMessage />);

    // TODO: Verify heading exists (use getBy)
    // TODO: Verify button exists (use getBy)
    // TODO: Verify loading NOT shown (use queryBy)
    // TODO: Verify alert NOT shown (use queryBy)
  });

  test('shows loading state when fetching', () => {
    render(<StatusMessage />);

    // TODO: Click button
    // TODO: Verify loading appears (use getBy)
  });

  test('shows success message after fetch', async () => {
    // Mock Math.random to always succeed
    jest.spyOn(Math, 'random').mockReturnValue(0.9);

    render(<StatusMessage />);

    // TODO: Click button
    // TODO: Wait for success message (use findBy)
    // TODO: Verify loading is gone (use queryBy)

    Math.random.mockRestore();
  });

  test('shows error message on failure', async () => {
    jest.spyOn(Math, 'random').mockReturnValue(0.1);

    render(<StatusMessage />);

    // TODO: Click button
    // TODO: Wait for error message (use findBy)
    // TODO: Verify correct message text

    Math.random.mockRestore();
  });
});
```

<details>
<summary>üí° Solution</summary>

```jsx
import { render, screen, fireEvent } from '@testing-library/react';
import StatusMessage from './StatusMessage';

describe('StatusMessage', () => {
  test('initial render - no messages shown', () => {
    render(<StatusMessage />);

    // getBy: Elements that MUST exist
    expect(
      screen.getByRole('heading', { name: /status dashboard/i }),
    ).toBeInTheDocument();
    expect(
      screen.getByRole('button', { name: /fetch data/i }),
    ).toBeInTheDocument();

    // queryBy: Assert elements DON'T exist
    expect(screen.queryByRole('status')).not.toBeInTheDocument();
    expect(screen.queryByRole('alert')).not.toBeInTheDocument();
  });

  test('shows loading state when fetching', () => {
    render(<StatusMessage />);

    const button = screen.getByRole('button', { name: /fetch data/i });
    fireEvent.click(button);

    // Loading appears immediately
    expect(screen.getByRole('status')).toHaveTextContent('Loading...');
  });

  test('shows success message after fetch', async () => {
    jest.spyOn(Math, 'random').mockReturnValue(0.9);

    render(<StatusMessage />);

    const button = screen.getByRole('button', { name: /fetch data/i });
    fireEvent.click(button);

    // findBy: Wait for async element
    const alert = await screen.findByRole('alert');
    expect(alert).toHaveTextContent('Data loaded successfully!');

    // Loading should be gone
    expect(screen.queryByRole('status')).not.toBeInTheDocument();

    Math.random.mockRestore();
  });

  test('shows error message on failure', async () => {
    jest.spyOn(Math, 'random').mockReturnValue(0.1);

    render(<StatusMessage />);

    fireEvent.click(screen.getByRole('button', { name: /fetch data/i }));

    const alert = await screen.findByRole('alert');
    expect(alert).toHaveTextContent('Failed to load data');

    Math.random.mockRestore();
  });
});

// Decision rationale:
// - getBy: Heading and button always exist ‚Üí throw if missing
// - queryBy: Loading/alerts conditionally rendered ‚Üí need null check
// - findBy: Success/error appear after 1000ms ‚Üí need to wait
```

</details>

---

### ‚≠ê‚≠ê‚≠ê B√†i 3: Todo App Testing (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Test realistic component v·ªõi multiple interactions
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën qu·∫£n l√Ω todos ƒë·ªÉ track c√¥ng vi·ªác"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Add new todo b·∫±ng form
 * - [ ] Toggle todo status (active/completed)
 * - [ ] Delete todo
 * - [ ] Filter todos (all/active/completed)
 * - [ ] Show todo count
 *
 * üé® Technical Constraints:
 * - Form validation: kh√¥ng cho submit empty todo
 * - UI updates sau m·ªói action
 * - Filter kh√¥ng ·∫£nh h∆∞·ªüng data
 *
 * üö® Edge Cases c·∫ßn handle:
 * - Empty state message
 * - Toggle multiple todos
 * - Filter v·ªõi 0 results
 *
 * üìù Implementation Checklist:
 * - [ ] Test form submission
 * - [ ] Test toggle functionality
 * - [ ] Test delete functionality
 * - [ ] Test filtering
 * - [ ] Test empty states
 */

// TodoApp.jsx (already implemented)
const TodoApp = () => {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all'); // all | active | completed
  const [inputValue, setInputValue] = useState('');

  const addTodo = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      setTodos([
        ...todos,
        {
          id: Date.now(),
          text: inputValue,
          completed: false,
        },
      ]);
      setInputValue('');
    }
  };

  const toggleTodo = (id) => {
    setTodos(
      todos.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo,
      ),
    );
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter((todo) => todo.id !== id));
  };

  const filteredTodos = todos.filter((todo) => {
    if (filter === 'active') return !todo.completed;
    if (filter === 'completed') return todo.completed;
    return true;
  });

  const activeCount = todos.filter((t) => !t.completed).length;

  return (
    <div>
      <h1>My Todos</h1>

      <form onSubmit={addTodo}>
        <input
          type='text'
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder='What needs to be done?'
          aria-label='New todo'
        />
        <button type='submit'>Add</button>
      </form>

      <div
        role='group'
        aria-label='Filter todos'
      >
        <button
          onClick={() => setFilter('all')}
          aria-pressed={filter === 'all'}
        >
          All
        </button>
        <button
          onClick={() => setFilter('active')}
          aria-pressed={filter === 'active'}
        >
          Active
        </button>
        <button
          onClick={() => setFilter('completed')}
          aria-pressed={filter === 'completed'}
        >
          Completed
        </button>
      </div>

      <p>{activeCount} items left</p>

      {filteredTodos.length === 0 ? (
        <p>No todos to show</p>
      ) : (
        <ul>
          {filteredTodos.map((todo) => (
            <li key={todo.id}>
              <input
                type='checkbox'
                checked={todo.completed}
                onChange={() => toggleTodo(todo.id)}
                aria-label={`Toggle ${todo.text}`}
              />
              <span
                style={{
                  textDecoration: todo.completed ? 'line-through' : 'none',
                }}
              >
                {todo.text}
              </span>
              <button
                onClick={() => deleteTodo(todo.id)}
                aria-label={`Delete ${todo.text}`}
              >
                Delete
              </button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

// TodoApp.test.jsx - TODO: Implement these tests
describe('TodoApp', () => {
  test('renders empty state initially', () => {
    // TODO: Verify heading, input, filter buttons exist
    // TODO: Verify "No todos to show" message
    // TODO: Verify "0 items left"
  });

  test('adds new todo', () => {
    // TODO: Type into input
    // TODO: Submit form
    // TODO: Verify todo appears in list
    // TODO: Verify input cleared
    // TODO: Verify count updated
  });

  test('does not add empty todo', () => {
    // TODO: Submit form without typing
    // TODO: Verify no todo added
  });

  test('toggles todo completion', () => {
    // TODO: Add a todo
    // TODO: Click checkbox
    // TODO: Verify text has line-through
    // TODO: Verify active count decreased
  });

  test('deletes todo', () => {
    // TODO: Add a todo
    // TODO: Click delete button
    // TODO: Verify todo removed
    // TODO: Verify count updated
  });

  test('filters active todos', () => {
    // TODO: Add 3 todos
    // TODO: Complete 1 todo
    // TODO: Click "Active" filter
    // TODO: Verify only 2 active todos shown
  });

  test('filters completed todos', () => {
    // TODO: Add 3 todos
    // TODO: Complete 2 todos
    // TODO: Click "Completed" filter
    // TODO: Verify only 2 completed todos shown
  });

  test('shows all todos when "All" filter selected', () => {
    // TODO: Add 3 todos
    // TODO: Complete 1 todo
    // TODO: Click "Completed" then "All"
    // TODO: Verify all 3 todos shown
  });
});
```

<details>
<summary>üí° Solution</summary>

```jsx
import { render, screen, fireEvent } from '@testing-library/react';
import TodoApp from './TodoApp';

describe('TodoApp', () => {
  test('renders empty state initially', () => {
    render(<TodoApp />);

    expect(
      screen.getByRole('heading', { name: /my todos/i }),
    ).toBeInTheDocument();
    expect(screen.getByLabelText(/new todo/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /add/i })).toBeInTheDocument();

    // Filter buttons
    expect(screen.getByRole('button', { name: /^all$/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /active/i })).toBeInTheDocument();
    expect(
      screen.getByRole('button', { name: /completed/i }),
    ).toBeInTheDocument();

    expect(screen.getByText(/no todos to show/i)).toBeInTheDocument();
    expect(screen.getByText(/0 items left/i)).toBeInTheDocument();
  });

  test('adds new todo', () => {
    render(<TodoApp />);

    const input = screen.getByLabelText(/new todo/i);
    const addButton = screen.getByRole('button', { name: /add/i });

    // Add todo
    fireEvent.change(input, { target: { value: 'Buy groceries' } });
    fireEvent.click(addButton);

    // Verify
    expect(screen.getByText(/buy groceries/i)).toBeInTheDocument();
    expect(input).toHaveValue(''); // Input cleared
    expect(screen.getByText(/1 items left/i)).toBeInTheDocument();
    expect(screen.queryByText(/no todos/i)).not.toBeInTheDocument();
  });

  test('does not add empty todo', () => {
    render(<TodoApp />);

    const addButton = screen.getByRole('button', { name: /add/i });

    // Try to add empty
    fireEvent.click(addButton);

    // Still shows empty state
    expect(screen.getByText(/no todos to show/i)).toBeInTheDocument();
    expect(screen.getByText(/0 items left/i)).toBeInTheDocument();
  });

  test('toggles todo completion', () => {
    render(<TodoApp />);

    // Add todo
    const input = screen.getByLabelText(/new todo/i);
    fireEvent.change(input, { target: { value: 'Learn testing' } });
    fireEvent.submit(input.closest('form'));

    // Toggle
    const checkbox = screen.getByLabelText(/toggle learn testing/i);
    fireEvent.click(checkbox);

    // Verify completed
    expect(checkbox).toBeChecked();
    expect(screen.getByText(/0 items left/i)).toBeInTheDocument();

    // Toggle back
    fireEvent.click(checkbox);
    expect(checkbox).not.toBeChecked();
    expect(screen.getByText(/1 items left/i)).toBeInTheDocument();
  });

  test('deletes todo', () => {
    render(<TodoApp />);

    // Add todo
    const input = screen.getByLabelText(/new todo/i);
    fireEvent.change(input, { target: { value: 'Delete me' } });
    fireEvent.submit(input.closest('form'));

    expect(screen.getByText(/delete me/i)).toBeInTheDocument();

    // Delete
    const deleteButton = screen.getByRole('button', {
      name: /delete delete me/i,
    });
    fireEvent.click(deleteButton);

    // Verify removed
    expect(screen.queryByText(/delete me/i)).not.toBeInTheDocument();
    expect(screen.getByText(/no todos to show/i)).toBeInTheDocument();
  });

  test('filters active todos', () => {
    render(<TodoApp />);

    // Add 3 todos
    const input = screen.getByLabelText(/new todo/i);

    fireEvent.change(input, { target: { value: 'Todo 1' } });
    fireEvent.submit(input.closest('form'));

    fireEvent.change(input, { target: { value: 'Todo 2' } });
    fireEvent.submit(input.closest('form'));

    fireEvent.change(input, { target: { value: 'Todo 3' } });
    fireEvent.submit(input.closest('form'));

    // Complete one
    const checkbox = screen.getByLabelText(/toggle todo 2/i);
    fireEvent.click(checkbox);

    // Filter active
    const activeButton = screen.getByRole('button', { name: /active/i });
    fireEvent.click(activeButton);

    // Verify
    expect(screen.getByText(/todo 1/i)).toBeInTheDocument();
    expect(screen.queryByText(/todo 2/i)).not.toBeInTheDocument();
    expect(screen.getByText(/todo 3/i)).toBeInTheDocument();
  });

  test('filters completed todos', () => {
    render(<TodoApp />);

    const input = screen.getByLabelText(/new todo/i);

    // Add 3 todos
    ['Task A', 'Task B', 'Task C'].forEach((task) => {
      fireEvent.change(input, { target: { value: task } });
      fireEvent.submit(input.closest('form'));
    });

    // Complete 2
    fireEvent.click(screen.getByLabelText(/toggle task a/i));
    fireEvent.click(screen.getByLabelText(/toggle task c/i));

    // Filter completed
    fireEvent.click(screen.getByRole('button', { name: /completed/i }));

    // Verify
    expect(screen.getByText(/task a/i)).toBeInTheDocument();
    expect(screen.queryByText(/task b/i)).not.toBeInTheDocument();
    expect(screen.getByText(/task c/i)).toBeInTheDocument();
  });

  test('shows all todos when "All" filter selected', () => {
    render(<TodoApp />);

    const input = screen.getByLabelText(/new todo/i);

    // Add and complete
    fireEvent.change(input, { target: { value: 'Item 1' } });
    fireEvent.submit(input.closest('form'));

    fireEvent.change(input, { target: { value: 'Item 2' } });
    fireEvent.submit(input.closest('form'));

    fireEvent.click(screen.getByLabelText(/toggle item 1/i));

    // Go to completed filter
    fireEvent.click(screen.getByRole('button', { name: /completed/i }));
    expect(screen.queryByText(/item 2/i)).not.toBeInTheDocument();

    // Back to all
    fireEvent.click(screen.getByRole('button', { name: /^all$/i }));

    // Both visible
    expect(screen.getByText(/item 1/i)).toBeInTheDocument();
    expect(screen.getByText(/item 2/i)).toBeInTheDocument();
  });
});

// All tests pass:
// ‚úì renders empty state initially
// ‚úì adds new todo
// ‚úì does not add empty todo
// ‚úì toggles todo completion
// ‚úì deletes todo
// ‚úì filters active todos
// ‚úì filters completed todos
// ‚úì shows all todos when "All" filter selected
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê B√†i 4: Testing Strategy (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Design comprehensive test strategy
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Nhi·ªám v·ª•:
 * 1. Ph√¢n t√≠ch component SearchableProductList
 * 2. Identify test scenarios (happy path, edge cases, errors)
 * 3. Quy·∫øt ƒë·ªãnh query methods cho t·ª´ng scenario
 * 4. Vi·∫øt test plan
 *
 * ADR Template:
 * - Context: Component c√≥ search, filter, sort
 * - Decision: Test approach ƒë√£ ch·ªçn
 * - Rationale: T·∫°i sao ch·ªçn approach n√†y
 * - Consequences: Trade-offs accepted
 * - Alternatives Considered: C√°c options kh√°c
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 * Implement tests theo plan
 *
 * üß™ PHASE 3: Review (10 ph√∫t)
 * - [ ] All scenarios covered?
 * - [ ] Using right query methods?
 * - [ ] Tests readable and maintainable?
 */

// SearchableProductList.jsx
const SearchableProductList = ({ products }) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [sortBy, setSortBy] = useState('name'); // name | price
  const [priceFilter, setPriceFilter] = useState('all'); // all | under50 | over50

  const filteredProducts = products
    .filter((p) => {
      const matchesSearch = p.name
        .toLowerCase()
        .includes(searchTerm.toLowerCase());

      if (priceFilter === 'under50') {
        return matchesSearch && p.price < 50;
      }
      if (priceFilter === 'over50') {
        return matchesSearch && p.price >= 50;
      }
      return matchesSearch;
    })
    .sort((a, b) => {
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      }
      return a.price - b.price;
    });

  return (
    <div>
      <h1>Product Catalog</h1>

      <input
        type='search'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder='Search products...'
        aria-label='Search products'
      />

      <div
        role='group'
        aria-label='Sort options'
      >
        <label>
          <input
            type='radio'
            name='sort'
            value='name'
            checked={sortBy === 'name'}
            onChange={() => setSortBy('name')}
          />
          Sort by Name
        </label>
        <label>
          <input
            type='radio'
            name='sort'
            value='price'
            checked={sortBy === 'price'}
            onChange={() => setSortBy('price')}
          />
          Sort by Price
        </label>
      </div>

      <select
        value={priceFilter}
        onChange={(e) => setPriceFilter(e.target.value)}
        aria-label='Filter by price'
      >
        <option value='all'>All Prices</option>
        <option value='under50'>Under $50</option>
        <option value='over50'>$50 and Above</option>
      </select>

      <p>{filteredProducts.length} products found</p>

      {filteredProducts.length === 0 ? (
        <p>No products match your criteria</p>
      ) : (
        <ul aria-label='Product list'>
          {filteredProducts.map((product) => (
            <li key={product.id}>
              <h3>{product.name}</h3>
              <p>${product.price}</p>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

// TODO: Write comprehensive test suite
// Consider:
// - Initial render
// - Search functionality
// - Sorting (name vs price)
// - Price filtering
// - Combined search + filter + sort
// - Empty results
// - Edge cases (empty product list, special characters in search)
```

<details>
<summary>üí° Solution</summary>

```jsx
import { render, screen, fireEvent } from '@testing-library/react';
import SearchableProductList from './SearchableProductList';

/**
 * Test Strategy ADR
 *
 * Context:
 * - Component combines search, filter, and sort
 * - Multiple user interactions affect displayed data
 * - Need to test combinations of filters
 *
 * Decision:
 * - Test each feature independently first
 * - Then test combinations
 * - Use semantic queries (role, label)
 * - Setup helper for common data
 *
 * Rationale:
 * - Independent tests easier to debug
 * - Combinations test real user behavior
 * - Semantic queries = accessibility compliance
 *
 * Consequences:
 * - More tests but better coverage
 * - Longer test suite but maintainable
 *
 * Alternatives Considered:
 * - Snapshot testing: rejected (too brittle)
 * - Only testing combinations: rejected (hard to debug)
 */

describe('SearchableProductList', () => {
  const mockProducts = [
    { id: '1', name: 'Laptop', price: 999 },
    { id: '2', name: 'Mouse', price: 25 },
    { id: '3', name: 'Keyboard', price: 75 },
    { id: '4', name: 'Monitor', price: 300 },
    { id: '5', name: 'Headphones', price: 45 },
  ];

  describe('Initial Render', () => {
    test('displays all products', () => {
      render(<SearchableProductList products={mockProducts} />);

      expect(
        screen.getByRole('heading', { name: /product catalog/i }),
      ).toBeInTheDocument();
      expect(screen.getByText(/5 products found/i)).toBeInTheDocument();

      // All products visible
      mockProducts.forEach((product) => {
        expect(screen.getByText(product.name)).toBeInTheDocument();
      });
    });

    test('shows empty state for no products', () => {
      render(<SearchableProductList products={[]} />);

      expect(screen.getByText(/0 products found/i)).toBeInTheDocument();
      expect(screen.getByText(/no products match/i)).toBeInTheDocument();
    });
  });

  describe('Search Functionality', () => {
    test('filters products by search term', () => {
      render(<SearchableProductList products={mockProducts} />);

      const searchInput = screen.getByLabelText(/search products/i);

      fireEvent.change(searchInput, { target: { value: 'mouse' } });

      expect(screen.getByText(/1 products found/i)).toBeInTheDocument();
      expect(screen.getByText(/mouse/i)).toBeInTheDocument();
      expect(screen.queryByText(/laptop/i)).not.toBeInTheDocument();
    });

    test('search is case-insensitive', () => {
      render(<SearchableProductList products={mockProducts} />);

      const searchInput = screen.getByLabelText(/search products/i);

      fireEvent.change(searchInput, { target: { value: 'KEYBOARD' } });

      expect(screen.getByText(/keyboard/i)).toBeInTheDocument();
    });

    test('shows no results for non-matching search', () => {
      render(<SearchableProductList products={mockProducts} />);

      const searchInput = screen.getByLabelText(/search products/i);

      fireEvent.change(searchInput, { target: { value: 'xyz123' } });

      expect(screen.getByText(/0 products found/i)).toBeInTheDocument();
      expect(screen.getByText(/no products match/i)).toBeInTheDocument();
    });
  });

  describe('Sorting', () => {
    test('sorts by name (default)', () => {
      render(<SearchableProductList products={mockProducts} />);

      const productList = screen.getByLabelText(/product list/i);
      const items = productList.querySelectorAll('h3');

      // Alphabetical order
      expect(items[0]).toHaveTextContent('Headphones');
      expect(items[1]).toHaveTextContent('Keyboard');
      expect(items[2]).toHaveTextContent('Laptop');
      expect(items[3]).toHaveTextContent('Monitor');
      expect(items[4]).toHaveTextContent('Mouse');
    });

    test('sorts by price', () => {
      render(<SearchableProductList products={mockProducts} />);

      const priceSortRadio = screen.getByLabelText(/sort by price/i);
      fireEvent.click(priceSortRadio);

      const productList = screen.getByLabelText(/product list/i);
      const items = productList.querySelectorAll('h3');

      // Price order (ascending)
      expect(items[0]).toHaveTextContent('Mouse'); // $25
      expect(items[1]).toHaveTextContent('Headphones'); // $45
      expect(items[2]).toHaveTextContent('Keyboard'); // $75
      expect(items[3]).toHaveTextContent('Monitor'); // $300
      expect(items[4]).toHaveTextContent('Laptop'); // $999
    });
  });

  describe('Price Filtering', () => {
    test('filters products under $50', () => {
      render(<SearchableProductList products={mockProducts} />);

      const priceFilter = screen.getByLabelText(/filter by price/i);
      fireEvent.change(priceFilter, { target: { value: 'under50' } });

      expect(screen.getByText(/2 products found/i)).toBeInTheDocument();
      expect(screen.getByText(/mouse/i)).toBeInTheDocument();
      expect(screen.getByText(/headphones/i)).toBeInTheDocument();
      expect(screen.queryByText(/laptop/i)).not.toBeInTheDocument();
    });

    test('filters products $50 and above', () => {
      render(<SearchableProductList products={mockProducts} />);

      const priceFilter = screen.getByLabelText(/filter by price/i);
      fireEvent.change(priceFilter, { target: { value: 'over50' } });

      expect(screen.getByText(/3 products found/i)).toBeInTheDocument();
      expect(screen.getByText(/keyboard/i)).toBeInTheDocument();
      expect(screen.queryByText(/mouse/i)).not.toBeInTheDocument();
    });
  });

  describe('Combined Filters', () => {
    test('applies search + price filter', () => {
      render(<SearchableProductList products={mockProducts} />);

      // Search for 'o'
      const searchInput = screen.getByLabelText(/search products/i);
      fireEvent.change(searchInput, { target: { value: 'o' } });

      // Filter under $50
      const priceFilter = screen.getByLabelText(/filter by price/i);
      fireEvent.change(priceFilter, { target: { value: 'under50' } });

      // Should show: Mouse, Headphones (both have 'o' and under $50)
      expect(screen.getByText(/2 products found/i)).toBeInTheDocument();
      expect(screen.getByText(/mouse/i)).toBeInTheDocument();
      expect(screen.getByText(/headphones/i)).toBeInTheDocument();
    });

    test('applies all filters: search + price + sort', () => {
      render(<SearchableProductList products={mockProducts} />);

      // Search 'e'
      fireEvent.change(screen.getByLabelText(/search products/i), {
        target: { value: 'e' },
      });

      // Price filter: over $50
      fireEvent.change(screen.getByLabelText(/filter by price/i), {
        target: { value: 'over50' },
      });

      // Sort by price
      fireEvent.click(screen.getByLabelText(/sort by price/i));

      // Should show: Keyboard ($75), Monitor ($300) sorted by price
      const items = screen.getAllByRole('heading', { level: 3 });
      expect(items).toHaveLength(2);
      expect(items[0]).toHaveTextContent('Keyboard');
      expect(items[1]).toHaveTextContent('Monitor');
    });
  });

  describe('Edge Cases', () => {
    test('handles clearing search', () => {
      render(<SearchableProductList products={mockProducts} />);

      const searchInput = screen.getByLabelText(/search products/i);

      // Search
      fireEvent.change(searchInput, { target: { value: 'laptop' } });
      expect(screen.getByText(/1 products found/i)).toBeInTheDocument();

      // Clear
      fireEvent.change(searchInput, { target: { value: '' } });
      expect(screen.getByText(/5 products found/i)).toBeInTheDocument();
    });

    test('handles switching between filters', () => {
      render(<SearchableProductList products={mockProducts} />);

      const priceFilter = screen.getByLabelText(/filter by price/i);

      // Under $50
      fireEvent.change(priceFilter, { target: { value: 'under50' } });
      expect(screen.getByText(/2 products found/i)).toBeInTheDocument();

      // Over $50
      fireEvent.change(priceFilter, { target: { value: 'over50' } });
      expect(screen.getByText(/3 products found/i)).toBeInTheDocument();

      // All
      fireEvent.change(priceFilter, { target: { value: 'all' } });
      expect(screen.getByText(/5 products found/i)).toBeInTheDocument();
    });
  });
});

// Test Results:
// ‚úì Initial Render (2 tests)
// ‚úì Search Functionality (3 tests)
// ‚úì Sorting (2 tests)
// ‚úì Price Filtering (2 tests)
// ‚úì Combined Filters (2 tests)
// ‚úì Edge Cases (2 tests)
//
// Total: 13 tests, all passing
// Coverage: Comprehensive feature coverage with combinations
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê B√†i 5: Production-Ready Form Testing (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Test production-grade form v·ªõi validation
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 * - Multi-field registration form
 * - Real-time validation
 * - Async email check
 * - Accessible error messages
 * - Loading states
 *
 * üèóÔ∏è Technical Design Doc:
 * 1. Component Architecture: Single form component
 * 2. State Management Strategy: useState for each field + errors
 * 3. Validation: Client-side + async server check
 * 4. Error Handling Strategy: Field-level errors
 *
 * ‚úÖ Production Checklist:
 * - [ ] All form fields tested
 * - [ ] Validation rules tested
 * - [ ] Error messages accessible
 * - [ ] Loading states tested
 * - [ ] Success flow tested
 * - [ ] Async operations tested
 * - [ ] Edge cases covered
 *
 * üìù Test Documentation:
 * - Write clear test descriptions
 * - Group related tests
 * - Document assumptions
 */

// RegistrationForm.jsx (Production component)
const RegistrationForm = ({ onSubmit }) => {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
  });

  const [errors, setErrors] = useState({});
  const [loading, setLoading] = useState(false);
  const [checkingEmail, setCheckingEmail] = useState(false);
  const [submitSuccess, setSubmitSuccess] = useState(false);

  const validateField = (name, value) => {
    switch (name) {
      case 'username':
        if (!value) return 'Username is required';
        if (value.length < 3) return 'Username must be at least 3 characters';
        return '';

      case 'email':
        if (!value) return 'Email is required';
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
          return 'Invalid email format';
        }
        return '';

      case 'password':
        if (!value) return 'Password is required';
        if (value.length < 8) return 'Password must be at least 8 characters';
        if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(value)) {
          return 'Password must contain uppercase, lowercase, and number';
        }
        return '';

      case 'confirmPassword':
        if (value !== formData.password) return 'Passwords do not match';
        return '';

      default:
        return '';
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));

    // Real-time validation
    const error = validateField(name, value);
    setErrors((prev) => ({ ...prev, [name]: error }));

    // Check email availability (debounced in real app)
    if (name === 'email' && !error && value) {
      setCheckingEmail(true);
      setTimeout(() => {
        if (value === 'taken@example.com') {
          setErrors((prev) => ({ ...prev, email: 'Email already in use' }));
        }
        setCheckingEmail(false);
      }, 500);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Validate all fields
    const newErrors = {};
    Object.keys(formData).forEach((key) => {
      const error = validateField(key, formData[key]);
      if (error) newErrors[key] = error;
    });

    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return;
    }

    setLoading(true);

    try {
      await onSubmit(formData);
      setSubmitSuccess(true);
    } catch (error) {
      setErrors({ submit: 'Registration failed. Please try again.' });
    } finally {
      setLoading(false);
    }
  };

  if (submitSuccess) {
    return (
      <div role='alert'>
        <h2>Registration Successful!</h2>
        <p>Welcome, {formData.username}!</p>
      </div>
    );
  }

  return (
    <form
      onSubmit={handleSubmit}
      noValidate
    >
      <h2>Create Account</h2>

      <div>
        <label htmlFor='username'>Username *</label>
        <input
          id='username'
          name='username'
          type='text'
          value={formData.username}
          onChange={handleChange}
          aria-invalid={!!errors.username}
          aria-describedby={errors.username ? 'username-error' : undefined}
        />
        {errors.username && (
          <span
            id='username-error'
            role='alert'
          >
            {errors.username}
          </span>
        )}
      </div>

      <div>
        <label htmlFor='email'>Email *</label>
        <input
          id='email'
          name='email'
          type='email'
          value={formData.email}
          onChange={handleChange}
          aria-invalid={!!errors.email}
          aria-describedby={errors.email ? 'email-error' : undefined}
        />
        {checkingEmail && <span>Checking availability...</span>}
        {errors.email && (
          <span
            id='email-error'
            role='alert'
          >
            {errors.email}
          </span>
        )}
      </div>

      <div>
        <label htmlFor='password'>Password *</label>
        <input
          id='password'
          name='password'
          type='password'
          value={formData.password}
          onChange={handleChange}
          aria-invalid={!!errors.password}
          aria-describedby={errors.password ? 'password-error' : undefined}
        />
        {errors.password && (
          <span
            id='password-error'
            role='alert'
          >
            {errors.password}
          </span>
        )}
      </div>

      <div>
        <label htmlFor='confirmPassword'>Confirm Password *</label>
        <input
          id='confirmPassword'
          name='confirmPassword'
          type='password'
          value={formData.confirmPassword}
          onChange={handleChange}
          aria-invalid={!!errors.confirmPassword}
          aria-describedby={
            errors.confirmPassword ? 'confirm-error' : undefined
          }
        />
        {errors.confirmPassword && (
          <span
            id='confirm-error'
            role='alert'
          >
            {errors.confirmPassword}
          </span>
        )}
      </div>

      {errors.submit && (
        <div
          role='alert'
          style={{ color: 'red' }}
        >
          {errors.submit}
        </div>
      )}

      <button
        type='submit'
        disabled={loading || checkingEmail}
      >
        {loading ? 'Creating Account...' : 'Register'}
      </button>
    </form>
  );
};

// TODO: Write comprehensive test suite covering:
// - Form rendering
// - Field validation (each field)
// - Real-time validation
// - Email availability check
// - Password matching
// - Submit validation
// - Success flow
// - Error handling
// - Accessibility
```

<details>
<summary>üí° Solution</summary>

```jsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import RegistrationForm from './RegistrationForm';

/**
 * Comprehensive test suite for production registration form
 *
 * Coverage areas:
 * 1. Initial render and form structure
 * 2. Individual field validation
 * 3. Real-time validation feedback
 * 4. Async email checking
 * 5. Form submission (success/failure)
 * 6. Accessibility compliance
 * 7. Edge cases and error recovery
 */

describe('RegistrationForm', () => {
  const mockOnSubmit = jest.fn();

  beforeEach(() => {
    mockOnSubmit.mockClear();
  });

  describe('Initial Render', () => {
    test('renders all form fields', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      expect(
        screen.getByRole('heading', { name: /create account/i }),
      ).toBeInTheDocument();

      expect(screen.getByLabelText(/username/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/^email/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/^password/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/confirm password/i)).toBeInTheDocument();

      expect(
        screen.getByRole('button', { name: /register/i }),
      ).toBeInTheDocument();
    });

    test('all fields are initially empty', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      expect(screen.getByLabelText(/username/i)).toHaveValue('');
      expect(screen.getByLabelText(/^email/i)).toHaveValue('');
      expect(screen.getByLabelText(/^password/i)).toHaveValue('');
      expect(screen.getByLabelText(/confirm password/i)).toHaveValue('');
    });
  });

  describe('Username Validation', () => {
    test('shows error for empty username on change', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const usernameInput = screen.getByLabelText(/username/i);

      fireEvent.change(usernameInput, { target: { value: '' } });
      fireEvent.blur(usernameInput);

      expect(screen.getByText(/username is required/i)).toBeInTheDocument();
    });

    test('shows error for username too short', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const usernameInput = screen.getByLabelText(/username/i);

      fireEvent.change(usernameInput, { target: { value: 'ab' } });

      expect(screen.getByText(/at least 3 characters/i)).toBeInTheDocument();
    });

    test('accepts valid username', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const usernameInput = screen.getByLabelText(/username/i);

      fireEvent.change(usernameInput, { target: { value: 'johndoe' } });

      expect(screen.queryByText(/username/i)).not.toBeInTheDocument();
    });
  });

  describe('Email Validation', () => {
    test('shows error for invalid email format', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const emailInput = screen.getByLabelText(/^email/i);

      fireEvent.change(emailInput, { target: { value: 'notanemail' } });

      expect(screen.getByText(/invalid email format/i)).toBeInTheDocument();
    });

    test('checks email availability asynchronously', async () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const emailInput = screen.getByLabelText(/^email/i);

      fireEvent.change(emailInput, { target: { value: 'test@example.com' } });

      // Should show checking state
      expect(screen.getByText(/checking availability/i)).toBeInTheDocument();

      // Wait for check to complete
      await waitFor(() => {
        expect(
          screen.queryByText(/checking availability/i),
        ).not.toBeInTheDocument();
      });
    });

    test('shows error if email is already taken', async () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const emailInput = screen.getByLabelText(/^email/i);

      fireEvent.change(emailInput, { target: { value: 'taken@example.com' } });

      // Wait for async check
      const errorMessage = await screen.findByText(/email already in use/i);
      expect(errorMessage).toBeInTheDocument();
    });
  });

  describe('Password Validation', () => {
    test('shows error for password too short', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const passwordInput = screen.getByLabelText(/^password/i);

      fireEvent.change(passwordInput, { target: { value: 'short' } });

      expect(screen.getByText(/at least 8 characters/i)).toBeInTheDocument();
    });

    test('shows error for weak password', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const passwordInput = screen.getByLabelText(/^password/i);

      fireEvent.change(passwordInput, { target: { value: 'alllowercase' } });

      expect(
        screen.getByText(/must contain uppercase, lowercase, and number/i),
      ).toBeInTheDocument();
    });

    test('accepts strong password', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const passwordInput = screen.getByLabelText(/^password/i);

      fireEvent.change(passwordInput, { target: { value: 'StrongPass123' } });

      expect(screen.queryByText(/password must/i)).not.toBeInTheDocument();
    });
  });

  describe('Password Confirmation', () => {
    test('shows error when passwords do not match', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      fireEvent.change(screen.getByLabelText(/^password/i), {
        target: { value: 'Password123' },
      });

      fireEvent.change(screen.getByLabelText(/confirm password/i), {
        target: { value: 'Different123' },
      });

      expect(screen.getByText(/passwords do not match/i)).toBeInTheDocument();
    });

    test('no error when passwords match', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      fireEvent.change(screen.getByLabelText(/^password/i), {
        target: { value: 'Password123' },
      });

      fireEvent.change(screen.getByLabelText(/confirm password/i), {
        target: { value: 'Password123' },
      });

      expect(
        screen.queryByText(/passwords do not match/i),
      ).not.toBeInTheDocument();
    });
  });

  describe('Form Submission', () => {
    const fillValidForm = () => {
      fireEvent.change(screen.getByLabelText(/username/i), {
        target: { value: 'johndoe' },
      });

      fireEvent.change(screen.getByLabelText(/^email/i), {
        target: { value: 'john@example.com' },
      });

      fireEvent.change(screen.getByLabelText(/^password/i), {
        target: { value: 'SecurePass123' },
      });

      fireEvent.change(screen.getByLabelText(/confirm password/i), {
        target: { value: 'SecurePass123' },
      });
    };

    test('prevents submission with invalid data', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const submitButton = screen.getByRole('button', { name: /register/i });
      fireEvent.click(submitButton);

      // Should show validation errors
      expect(screen.getByText(/username is required/i)).toBeInTheDocument();
      expect(mockOnSubmit).not.toHaveBeenCalled();
    });

    test('submits form with valid data', async () => {
      mockOnSubmit.mockResolvedValue({});

      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      fillValidForm();

      // Wait for email check
      await waitFor(() => {
        expect(screen.queryByText(/checking/i)).not.toBeInTheDocument();
      });

      const submitButton = screen.getByRole('button', { name: /register/i });
      fireEvent.click(submitButton);

      await waitFor(() => {
        expect(mockOnSubmit).toHaveBeenCalledWith({
          username: 'johndoe',
          email: 'john@example.com',
          password: 'SecurePass123',
          confirmPassword: 'SecurePass123',
        });
      });
    });

    test('shows loading state during submission', async () => {
      mockOnSubmit.mockImplementation(
        () =>
          new Promise((resolve) => {
            setTimeout(resolve, 1000);
          }),
      );

      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      fillValidForm();

      await waitFor(() => {
        expect(screen.queryByText(/checking/i)).not.toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('button', { name: /register/i }));

      expect(
        screen.getByRole('button', { name: /creating account/i }),
      ).toBeDisabled();
    });

    test('shows success message after successful submission', async () => {
      mockOnSubmit.mockResolvedValue({});

      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      fillValidForm();

      await waitFor(() => {
        expect(screen.queryByText(/checking/i)).not.toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('button', { name: /register/i }));

      const successMessage = await screen.findByRole('alert');
      expect(successMessage).toHaveTextContent(/registration successful/i);
      expect(successMessage).toHaveTextContent(/welcome, johndoe/i);
    });

    test('shows error message on submission failure', async () => {
      mockOnSubmit.mockRejectedValue(new Error('Server error'));

      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      fillValidForm();

      await waitFor(() => {
        expect(screen.queryByText(/checking/i)).not.toBeInTheDocument();
      });

      fireEvent.click(screen.getByRole('button', { name: /register/i }));

      const errorMessage = await screen.findByText(/registration failed/i);
      expect(errorMessage).toBeInTheDocument();
    });
  });

  describe('Accessibility', () => {
    test('error messages are announced to screen readers', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      fireEvent.change(screen.getByLabelText(/username/i), {
        target: { value: 'ab' },
      });

      const errorMessage = screen.getByText(/at least 3 characters/i);
      expect(errorMessage).toHaveAttribute('role', 'alert');
    });

    test('invalid fields have aria-invalid attribute', () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      const usernameInput = screen.getByLabelText(/username/i);
      fireEvent.change(usernameInput, { target: { value: 'ab' } });

      expect(usernameInput).toHaveAttribute('aria-invalid', 'true');
      expect(usernameInput).toHaveAttribute(
        'aria-describedby',
        'username-error',
      );
    });

    test('submit button disabled during async operations', async () => {
      render(<RegistrationForm onSubmit={mockOnSubmit} />);

      fireEvent.change(screen.getByLabelText(/^email/i), {
        target: { value: 'test@example.com' },
      });

      const submitButton = screen.getByRole('button', { name: /register/i });
      expect(submitButton).toBeDisabled();

      await waitFor(() => {
        expect(submitButton).not.toBeDisabled();
      });
    });
  });
});

// Test Summary:
// ‚úì Initial Render (2 tests)
// ‚úì Username Validation (3 tests)
// ‚úì Email Validation (3 tests)
// ‚úì Password Validation (3 tests)
// ‚úì Password Confirmation (2 tests)
// ‚úì Form Submission (6 tests)
// ‚úì Accessibility (3 tests)
//
// Total: 22 tests
// All scenarios covered: validation, async operations, success/error flows, accessibility
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh Query Methods

| Query Type     | Khi N√†o D√πng            | Throw Error? | Returns              | Async? | Use Case                 |
| -------------- | ----------------------- | ------------ | -------------------- | ------ | ------------------------ |
| **getBy**      | Element PH·∫¢I t·ªìn t·∫°i    | ‚úÖ Yes       | `Element`            | ‚ùå No  | Heading, buttons, labels |
| **queryBy**    | Element c√≥ th·ªÉ kh√¥ng c√≥ | ‚ùå No        | `Element \| null`    | ‚ùå No  | Asserting absence        |
| **findBy**     | Element xu·∫•t hi·ªán sau   | ‚úÖ Yes       | `Promise<Element>`   | ‚úÖ Yes | Async rendering          |
| **getAllBy**   | Multiple elements       | ‚úÖ Yes       | `Element[]`          | ‚ùå No  | Lists, options           |
| **queryAllBy** | Multiple (optional)     | ‚ùå No        | `Element[]`          | ‚ùå No  | Conditional lists        |
| **findAllBy**  | Multiple async          | ‚úÖ Yes       | `Promise<Element[]>` | ‚úÖ Yes | Async lists              |

### B·∫£ng So S√°nh Query Priority

| Priority | Method                   | Accessible? | User-Like? | When to Use          | Example                                    |
| -------- | ------------------------ | ----------- | ---------- | -------------------- | ------------------------------------------ |
| ü•á 1     | **getByRole**            | ‚úÖ Best     | ‚úÖ Best    | Always preferred     | `getByRole('button', { name: /submit/i })` |
| ü•à 2     | **getByLabelText**       | ‚úÖ Great    | ‚úÖ Great   | Form inputs          | `getByLabelText('Email')`                  |
| ü•â 3     | **getByPlaceholderText** | ‚ö†Ô∏è OK       | ‚ö†Ô∏è OK      | No label available   | `getByPlaceholderText('Enter email')`      |
| 4        | **getByText**            | ‚úÖ Good     | ‚úÖ Good    | Content verification | `getByText('Welcome')`                     |
| 5        | **getByDisplayValue**    | ‚ö†Ô∏è OK       | ‚ö†Ô∏è OK      | Form current value   | `getByDisplayValue('John')`                |
| 6        | **getByAltText**         | ‚úÖ Good     | ‚úÖ Good    | Images               | `getByAltText('Profile photo')`            |
| 7        | **getByTitle**           | ‚ö†Ô∏è Rare     | ‚ö†Ô∏è Rare    | Title attribute      | `getByTitle('Close')`                      |
| üö´ Last  | **getByTestId**          | ‚ùå No       | ‚ùå No      | Last resort only     | `getByTestId('custom-element')`            |

### Decision Tree: Ch·ªçn Query Method

```
START: C·∫ßn query element
‚îÇ
‚îú‚îÄ Element t·ªìn t·∫°i NGAY?
‚îÇ  ‚îú‚îÄ YES ‚Üí D√πng getBy*
‚îÇ  ‚îÇ    ‚îî‚îÄ C√≥ nhi·ªÅu elements?
‚îÇ  ‚îÇ       ‚îú‚îÄ YES ‚Üí getAllBy*
‚îÇ  ‚îÇ       ‚îî‚îÄ NO ‚Üí getBy*
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ NO ‚Üí Element xu·∫•t hi·ªán SAU?
‚îÇ     ‚îú‚îÄ Async operation ‚Üí findBy* / findAllBy*
‚îÇ     ‚îî‚îÄ Conditional render ‚Üí queryBy* / queryAllBy*
‚îÇ
‚îî‚îÄ Ch·ªçn query type C·ª§ TH·ªÇ:
   1. Element c√≥ role? ‚Üí getByRole (BEST)
   2. Form input? ‚Üí getByLabelText
   3. Text content? ‚Üí getByText
   4. Image? ‚Üí getByAltText
   5. Last resort? ‚Üí getByTestId (AVOID)
```

### Trade-offs Matrix

| Approach                 | Pros                                    | Cons                                   | When to Use                 |
| ------------------------ | --------------------------------------- | -------------------------------------- | --------------------------- |
| **Test Implementation**  | Fast to write, specific                 | Breaks on refactor, not user-centric   | ‚ùå Never (anti-pattern)     |
| **Snapshot Testing**     | Comprehensive, auto-generated           | Brittle, hard to review                | ‚ö†Ô∏è Sparingly for stable UI  |
| **RTL Behavior Testing** | User-centric, refactor-safe, accessible | Slightly verbose, need query knowledge | ‚úÖ Always (best practice)   |
| **E2E Testing**          | Full system, realistic                  | Slow, flaky, expensive                 | ‚ö†Ô∏è Critical user flows only |

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Query Method Sai

```jsx
// Component
const AlertMessage = ({ show, message }) => {
  return show ? <div role='alert'>{message}</div> : null;
};

// ‚ùå Test b·ªã l·ªói
test('does not show alert initially', () => {
  render(
    <AlertMessage
      show={false}
      message='Error'
    />,
  );

  // üí• ERROR: Unable to find an element with role="alert"
  expect(screen.getByRole('alert')).not.toBeInTheDocument();
});

// ü§î DEBUG QUESTIONS:
// 1. T·∫°i sao test fail?
// 2. getBy vs queryBy kh√°c nhau nh∆∞ th·∫ø n√†o?
// 3. Khi n√†o d√πng getBy, khi n√†o d√πng queryBy?

// ‚úÖ FIX:
test('does not show alert initially', () => {
  render(
    <AlertMessage
      show={false}
      message='Error'
    />,
  );

  // Use queryBy for elements that might not exist
  expect(screen.queryByRole('alert')).not.toBeInTheDocument();
  // Or: expect(screen.queryByRole('alert')).toBeNull();
});

// üí° LESSON:
// - getBy throws if element not found
// - queryBy returns null if element not found
// - D√πng queryBy ƒë·ªÉ assert ABSENCE (not.toBeInTheDocument)
// - D√πng getBy ƒë·ªÉ assert PRESENCE (toBeInTheDocument)
```

### Bug 2: Async Test Kh√¥ng ƒê·ª£i

```jsx
// Component
const DataLoader = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    setTimeout(() => {
      setData('Loaded data');
    }, 1000);
  }, []);

  return data ? <p>{data}</p> : <p>Loading...</p>;
};

// ‚ùå Test fail
test('loads data', () => {
  render(<DataLoader />);

  // üí• ERROR: Unable to find element with text "Loaded data"
  expect(screen.getByText('Loaded data')).toBeInTheDocument();
});

// ü§î DEBUG QUESTIONS:
// 1. T·∫°i sao kh√¥ng t√¨m th·∫•y "Loaded data"?
// 2. Data xu·∫•t hi·ªán khi n√†o?
// 3. C·∫ßn d√πng query method n√†o?

// ‚úÖ FIX:
test('loads data', async () => {
  render(<DataLoader />);

  // Initially shows loading
  expect(screen.getByText('Loading...')).toBeInTheDocument();

  // Wait for data to appear
  const dataElement = await screen.findByText('Loaded data');
  expect(dataElement).toBeInTheDocument();

  // Loading should be gone
  expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
});

// üí° LESSON:
// - findBy returns Promise ‚Üí wait for async operations
// - Always await findBy queries
// - Test must be async function
// - Verify both loading and loaded states
```

### Bug 3: Query Priority Sai

```jsx
// Component
const SubmitButton = ({ onClick }) => {
  return (
    <button
      onClick={onClick}
      className='btn-primary'
      data-testid='submit-btn'
    >
      Submit Form
    </button>
  );
};

// ‚ùå Anti-pattern tests
test('‚ùå BAD: using testid', () => {
  render(<SubmitButton onClick={() => {}} />);

  const button = screen.getByTestId('submit-btn');
  expect(button).toBeInTheDocument();
});

test('‚ùå BAD: using className', () => {
  render(<SubmitButton onClick={() => {}} />);

  // This doesn't even work in RTL!
  const button = screen.getByClassName('btn-primary'); // ‚ùå Not a valid query
});

// ‚úÖ CORRECT: Use semantic queries
test('‚úÖ GOOD: using role', () => {
  const mockClick = jest.fn();
  render(<SubmitButton onClick={mockClick} />);

  // Best practice: accessible query
  const button = screen.getByRole('button', { name: /submit form/i });
  expect(button).toBeInTheDocument();

  fireEvent.click(button);
  expect(mockClick).toHaveBeenCalled();
});

// ü§î DEBUG QUESTIONS:
// 1. T·∫°i sao kh√¥ng n√™n d√πng testid?
// 2. User t√¨m button nh∆∞ th·∫ø n√†o?
// 3. Query n√†o accessible nh·∫•t?

// üí° LESSON:
// Query Priority:
// 1. getByRole (BEST - accessible)
// 2. getByLabelText (forms)
// 3. getByText (content)
// 4. getByTestId (LAST RESORT)
//
// Avoid:
// - className (not user-visible)
// - wrapper.find() (implementation detail)
// - enzyme-style queries
```

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

```jsx
// T·ª± ƒë√°nh gi√° ki·∫øn th·ª©c c·ªßa b·∫°n:

// 1. RTL Philosophy
[ ] T√¥i hi·ªÉu "test nh∆∞ user" nghƒ©a l√† g√¨
[ ] T√¥i bi·∫øt t·∫°i sao kh√¥ng n√™n test implementation
[ ] T√¥i c√≥ th·ªÉ gi·∫£i th√≠ch behavior vs implementation testing

// 2. Render & Screen
[ ] T√¥i bi·∫øt c√°ch d√πng render()
[ ] T√¥i hi·ªÉu screen l√† global object
[ ] T√¥i bi·∫øt khi n√†o d√πng screen.debug()

// 3. Query Methods
[ ] T√¥i ph√¢n bi·ªát ƒë∆∞·ª£c getBy/queryBy/findBy
[ ] T√¥i bi·∫øt khi n√†o d√πng method n√†o
[ ] T√¥i hi·ªÉu getAllBy/queryAllBy/findAllBy

// 4. Query Priority
[ ] T√¥i ∆∞u ti√™n getByRole tr∆∞·ªõc
[ ] T√¥i tr√°nh d√πng getByTestId
[ ] T√¥i bi·∫øt query methods theo accessibility

// 5. User Events
[ ] T√¥i bi·∫øt d√πng fireEvent cho interactions
[ ] T√¥i test ƒë∆∞·ª£c form submissions
[ ] T√¥i handle ƒë∆∞·ª£c async events

// 6. Assertions
[ ] T√¥i d√πng ƒë√∫ng matchers (toBeInTheDocument, etc.)
[ ] T√¥i test c·∫£ positive v√† negative cases
[ ] T√¥i verify callbacks ƒë∆∞·ª£c g·ªçi

// 7. Async Testing
[ ] T√¥i d√πng await v·ªõi findBy
[ ] T√¥i d√πng waitFor khi c·∫ßn
[ ] T√¥i handle ƒë∆∞·ª£c loading states

// 8. Best Practices
[ ] Tests c·ªßa t√¥i readable v√† maintainable
[ ] T√¥i group related tests trong describe
[ ] T√¥i vi·∫øt clear test descriptions
```

### Code Review Checklist

```jsx
// Checklist review code tests c·ªßa b·∫°n:

‚úÖ QUERY SELECTION
[ ] D√πng getByRole khi c√≥ th·ªÉ
[ ] Tr√°nh getByTestId (ch·ªâ last resort)
[ ] Queries ph·∫£n √°nh user behavior

‚úÖ ASYNC HANDLING
[ ] D√πng findBy cho async elements
[ ] Await t·∫•t c·∫£ findBy calls
[ ] Test function l√† async khi c·∫ßn

‚úÖ ASSERTIONS
[ ] Assert c·∫£ presence v√† absence
[ ] D√πng queryBy cho not.toBeInTheDocument
[ ] Verify callbacks v·ªõi jest.fn()

‚úÖ TEST STRUCTURE
[ ] M·ªói test focused v√† isolated
[ ] Clear test descriptions
[ ] Arrange-Act-Assert pattern

‚úÖ ACCESSIBILITY
[ ] Queries accessible (role, label)
[ ] Test aria attributes khi c√≥
[ ] Verify screen reader experience

‚úÖ COVERAGE
[ ] Happy path tested
[ ] Error cases tested
[ ] Edge cases tested
[ ] Loading states tested

‚úÖ MAINTAINABILITY
[ ] Tests d·ªÖ ƒë·ªçc
[ ] Kh√¥ng hard-code values
[ ] Setup helpers cho repeated logic
[ ] Mock external dependencies
```

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**B√†i 1: Test Component Tree**

```jsx
/**
 * Test component c√≥ parent-child relationship
 */

// ParentChild.jsx
const Parent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Parent Component</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <Child count={count} />
    </div>
  );
};

const Child = ({ count }) => {
  return (
    <div>
      <h2>Child Component</h2>
      <p>Count from parent: {count}</p>
    </div>
  );
};

// TODO: Write tests for:
// 1. Parent renders v·ªõi child
// 2. Child nh·∫≠n props t·ª´ parent
// 3. Parent state update ‚Üí Child re-renders
// 4. Verify text trong child thay ƒë·ªïi
```

### N√¢ng cao (60 ph√∫t)

**B√†i 2: Multi-Step Form Testing**

```jsx
/**
 * Test wizard form v·ªõi multiple steps
 */

// Wizard.jsx
const Wizard = () => {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    phone: '',
  });

  const nextStep = () => setStep(step + 1);
  const prevStep = () => setStep(step - 1);

  const updateField = (field, value) => {
    setFormData({ ...formData, [field]: value });
  };

  return (
    <div>
      <h2>Step {step} of 3</h2>

      {step === 1 && (
        <div>
          <label>Name</label>
          <input
            value={formData.name}
            onChange={(e) => updateField('name', e.target.value)}
          />
          <button
            onClick={nextStep}
            disabled={!formData.name}
          >
            Next
          </button>
        </div>
      )}

      {step === 2 && (
        <div>
          <label>Email</label>
          <input
            type='email'
            value={formData.email}
            onChange={(e) => updateField('email', e.target.value)}
          />
          <button onClick={prevStep}>Back</button>
          <button
            onClick={nextStep}
            disabled={!formData.email}
          >
            Next
          </button>
        </div>
      )}

      {step === 3 && (
        <div>
          <label>Phone</label>
          <input
            value={formData.phone}
            onChange={(e) => updateField('phone', e.target.value)}
          />
          <button onClick={prevStep}>Back</button>
          <button disabled={!formData.phone}>Submit</button>

          <div>
            <h3>Summary</h3>
            <p>Name: {formData.name}</p>
            <p>Email: {formData.email}</p>
            <p>Phone: {formData.phone}</p>
          </div>
        </div>
      )}
    </div>
  );
};

// TODO: Write comprehensive tests for:
// 1. Navigation gi·ªØa c√°c steps
// 2. Form data persistence across steps
// 3. Validation (Next button disabled)
// 4. Back button functionality
// 5. Summary display
// 6. Complete user flow t·ª´ step 1 ‚Üí 3
```

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Testing Library Docs**
   - https://testing-library.com/docs/react-testing-library/intro/
   - Focus: API Reference, Queries, Example

2. **Common Mistakes with RTL**
   - https://kentcdodds.com/blog/common-mistakes-with-react-testing-library
   - H·ªçc anti-patterns ƒë·ªÉ tr√°nh

### ƒê·ªçc th√™m

1. **Testing Playground**
   - https://testing-playground.com/
   - Tool ƒë·ªÉ generate queries t·ªët nh·∫•t

2. **Query Priority Guide**
   - https://testing-library.com/docs/queries/about/#priority
   - Chi ti·∫øt v·ªÅ query selection

3. **Async Testing**
   - https://testing-library.com/docs/dom-testing-library/api-async/
   - findBy, waitFor patterns

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn

- **Ng√†y 53**: Testing Philosophy
  - AAA pattern
  - Test behavior not implementation
  - User-centric testing

- **React Fundamentals** (Ng√†y 1-52):
  - Components, props, state
  - Events v√† forms
  - Conditional rendering
  - Async operations

### H∆∞·ªõng t·ªõi

- **Ng√†y 55**: Testing Hooks & Context
  - renderHook()
  - Testing custom hooks
  - Context providers trong tests

- **Ng√†y 56**: Mocking API Calls
  - Mock Service Worker (MSW)
  - Testing async data fetching
  - Loading/error states

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**1. Test Coverage Goals**

```
Kh√¥ng ph·∫£i 100% coverage l√† t·ªët nh·∫•t:
- Critical paths: 100% coverage
- UI variations: 80% coverage
- Edge cases: ƒê·ªß ƒë·ªÉ confident
- Implementation details: 0% (don't test)

Metric quan tr·ªçng:
- Confidence level (c√≥ t·ª± tin ship kh√¥ng?)
- Test maintenance cost
- Bug detection rate
```

**2. Testing Strategy**

```
// ‚ùå BAD: Test m·ªçi th·ª©
test('button has correct class', () => {
  render(<Button />);
  expect(screen.getByRole('button')).toHaveClass('btn-primary');
});

// ‚úÖ GOOD: Test behavior
test('submits form when clicked', () => {
  render(<Form />);
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));
  expect(mockSubmit).toHaveBeenCalled();
});

Priority:
1. User flows (can they complete tasks?)
2. Error handling (graceful failures?)
3. Accessibility (everyone can use it?)
4. Edge cases (what can break?)
```

**3. Performance Considerations**

```jsx
// Tests ch·∫°y ch·∫≠m?

// ‚ùå Render to√†n b·ªô app tree
test('header shows user name', () => {
  render(<App />); // Renders everything!
  // ...
});

// ‚úÖ Render ch·ªâ component c·∫ßn test
test('header shows user name', () => {
  render(<Header user={{ name: 'John' }} />); // Isolated!
  // ...
});

Tips:
- Mock heavy dependencies
- Use beforeEach wisely
- Parallel test execution (jest --maxWorkers)
- Skip expensive setup cho simple tests
```

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior Level:**

Q1: "getBy v√† queryBy kh√°c nhau nh∆∞ th·∫ø n√†o?"

```
Expected Answer:
- getBy throws error n·∫øu kh√¥ng t√¨m th·∫•y element
- queryBy returns null n·∫øu kh√¥ng t√¨m th·∫•y
- D√πng getBy ƒë·ªÉ assert element T·ªíN T·∫†I
- D√πng queryBy ƒë·ªÉ assert element KH√îNG T·ªíN T·∫†I
- Example code minh h·ªça
```

Q2: "T·∫°i sao RTL recommend d√πng getByRole?"

```
Expected Answer:
- Reflects user perspective (screen reader)
- Enforces accessibility
- Semantic v√† meaningful
- Less likely to break on refactor
- Example: getByRole('button', { name: /submit/i })
```

**Mid Level:**

Q3: "L√†m sao test async component trong RTL?"

```
Expected Answer:
- Use findBy queries (returns Promise)
- Use waitFor for complex scenarios
- Test loading states
- Test error states
- Clean up async operations
- Example:
  const data = await screen.findByText('Loaded');
  expect(data).toBeInTheDocument();
```

Q4: "Query priority trong RTL l√† g√¨? T·∫°i sao?"

```
Expected Answer:
Priority order:
1. getByRole - Most accessible
2. getByLabelText - Forms
3. getByText - Content
4. getByTestId - Last resort

Rationale:
- Reflects user behavior
- Accessibility compliance
- Maintainable tests
- Discourage implementation testing
```

**Senior Level:**

Q5: "Design testing strategy cho large application"

```
Expected Answer:
1. Test Pyramid:
   - 70% Unit (components, utilities)
   - 20% Integration (features)
   - 10% E2E (critical flows)

2. What to Test:
   - User workflows
   - Error boundaries
   - Accessibility
   - Performance (loading states)

3. What NOT to Test:
   - Implementation details
   - Third-party library internals
   - CSS styling (use visual regression)

4. Infrastructure:
   - Shared test utilities
   - Mock providers
   - Test data factories
   - CI/CD integration

5. Maintenance:
   - Refactor-safe tests
   - Clear test descriptions
   - Avoid brittle selectors
```

### War Stories

**Story 1: The Snapshot Disaster**

```
Situation:
Team c√≥ 500+ snapshot tests. M·ªói l·∫ßn update UI,
ph·∫£i review h√†ng trƒÉm snapshot changes.

Problem:
- Snapshots qu√° brittle
- Hard to review (auto-approve common)
- Bugs slipped through
- Tests kh√¥ng document behavior

Solution:
- Migrate sang RTL behavior tests
- Keep snapshots ch·ªâ cho static components
- Focus on user interactions
- Test coverage tƒÉng 30%

Lesson:
"Snapshots are useful, but don't replace real tests.
Test behavior, not markup."
```

**Story 2: The TestID Trap**

```
Situation:
To√†n b·ªô tests d√πng data-testid.
Product team mu·ªën refactor HTML structure.

Problem:
- data-testid everywhere trong JSX (ugly)
- Tests kh√¥ng enforce accessibility
- Refactor broke tests unnecessarily
- No screen reader testing

Solution:
- Gradual migration to getByRole
- Add ARIA labels where missing
- Improved accessibility score
- Tests more maintainable

Lesson:
"If your test would fail when you improve accessibility,
your test is testing the wrong thing."
```

**Story 3: The Async Race Condition**

```
Situation:
Tests pass locally, fail trong CI randomly.

Problem:
test('loads data', () => {
  render(<DataLoader />);
  // ‚ùå No waiting!
  expect(screen.getByText('Data')).toBeInTheDocument();
});

Solution:
test('loads data', async () => {
  render(<DataLoader />);
  // ‚úÖ Wait for async
  const data = await screen.findByText('Data');
  expect(data).toBeInTheDocument();
});

Added:
- Timeout configuration
- Better error messages
- Loading state tests

Lesson:
"Always await async operations. If test is flaky,
it's probably a timing issue."
```

---

## üéØ Preview Ng√†y Mai

**Ng√†y 55: Testing Hooks & Context**

Ng√†y mai ch√∫ng ta s·∫Ω h·ªçc:

- Testing custom hooks v·ªõi `renderHook()`
- Testing components s·ª≠ d·ª•ng Context
- Wrapper pattern cho providers
- Testing hook dependencies
- Testing hook cleanup

Concepts m·ªõi:

- `renderHook()` t·ª´ `@testing-library/react-hooks`
- Context providers trong test environment
- Testing hook return values
- Testing hook re-renders

Chu·∫©n b·ªã:

- Review custom hooks ƒë√£ vi·∫øt (Ng√†y 24, 29)
- Review Context API (Ng√†y 36-38)
- Suy nghƒ©: L√†m sao test logic kh√¥ng c√≥ UI?

H·∫πn g·∫∑p l·∫°i! üöÄ
