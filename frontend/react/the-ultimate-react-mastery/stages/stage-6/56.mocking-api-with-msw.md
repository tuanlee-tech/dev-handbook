# ğŸ“… NGÃ€Y 56: MOCKING API CALLS Vá»šI MSW

> **TÃ³m táº¯t:** HÃ´m nay chÃºng ta nÃ¢ng cáº¥p tá»« `jest.fn()` mock thá»§ cÃ´ng (NgÃ y 55) lÃªn MSW (Mock Service Worker) â€” má»™t cÃ´ng cá»¥ mock á»Ÿ táº§ng network, khÃ´ng pháº£i táº§ng module. Báº¡n sáº½ há»c cÃ¡ch setup MSW má»™t láº§n, Ä‘á»‹nh nghÄ©a handlers, vÃ  tÃ¡i sá»­ dá»¥ng chÃºng cho má»i test. Káº¿t quáº£ lÃ  tests realistic hÆ¡n, dá»… maintain hÆ¡n, vÃ  gáº§n vá»›i behavior production nháº¥t cÃ³ thá»ƒ mÃ  khÃ´ng cáº§n backend tháº­t.

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] Giáº£i thÃ­ch Ä‘Æ°á»£c MSW hoáº¡t Ä‘á»™ng á»Ÿ táº§ng network, khÃ´ng pháº£i táº§ng `fetch` â€” vÃ  táº¡i sao Ä‘iá»u Ä‘Ã³ quan trá»ng
- [ ] Setup MSW server vá»›i `setupServer`, Ä‘á»‹nh nghÄ©a handlers cho GET/POST requests
- [ ] Test Ä‘áº§y Ä‘á»§ loading state, success state, vÃ  error state cá»§a má»™t component fetch data

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

1. á» NgÃ y 55, báº¡n Ä‘Ã£ mock fetch báº±ng `jest.fn()`. Náº¿u component dÃ¹ng `axios` thay vÃ¬ `fetch`, mock Ä‘Ã³ cÃ³ cÃ²n hoáº¡t Ä‘á»™ng khÃ´ng? Táº¡i sao?
2. `waitFor` vÃ  `screen.findBy*` Ä‘á»u chá» async updates. ChÃºng khÃ¡c nhau nhÆ° tháº¿ nÃ o?
3. `server.resetHandlers()` Ä‘Æ°á»£c gá»i trong `afterEach` â€” náº¿u bá» dÃ²ng nÃ y, Ä‘iá»u gÃ¬ cÃ³ thá»ƒ xáº£y ra?

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

Sau ngÃ y 55, code test cá»§a báº¡n trÃ´ng nhÆ° tháº¿ nÃ y:

```tsx
// NgÃ y 55 approach â€” mock global.fetch
const mockFetch = jest.fn();
global.fetch = mockFetch;

beforeEach(() => mockFetch.mockReset());

it('should show users', async () => {
  mockFetch.mockResolvedValueOnce({
    ok: true,
    json: () => Promise.resolve([{ id: 1, name: 'Alice' }]),
  });

  render(<UserList />);
  await screen.findByText('Alice');
});
```

Approach nÃ y cÃ³ 3 váº¥n Ä‘á» lá»›n:

**1. Fragile vÃ  verbose:** Má»—i test pháº£i tá»± setup mock response, ká»ƒ cáº£ khi response giá»‘ng nhau. Náº¿u component cÃ³ 3 API calls, báº¡n pháº£i mock 3 láº§n theo Ä‘Ãºng thá»© tá»±.

**2. KhÃ´ng test Ä‘Æ°á»£c network layer:** `mockFetch` chá»‰ mock JavaScript function, khÃ´ng mock network. Náº¿u component dÃ¹ng `axios`, `ky`, hay `XMLHttpRequest`, mock nÃ y vÃ´ dá»¥ng.

**3. Dá»… sai silently:** `mockResolvedValueOnce` theo thá»© tá»±. Náº¿u thá»© tá»± gá»i thay Ä‘á»•i, mock sai response mÃ  khÃ´ng cÃ³ lá»—i rÃµ rÃ ng.

### 1.2 Giáº£i PhÃ¡p: MSW hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o?

MSW (Mock Service Worker) intercept request á»Ÿ **service worker level** trong browser, hoáº·c á»Ÿ **Node.js http level** trong test environment.

```
âŒ CÃ¡ch cÅ© (mock function):
Component â†’ fetch() [MOCKED] â†’ tráº£ vá» fake response
                  â†‘
            Bá» qua toÃ n bá»™ network stack

âœ… MSW (mock network):
Component â†’ fetch() â†’ XMLHttpRequest/node-fetch â†’ [MSW INTERCEPTS] â†’ tráº£ vá» fake response
                                                         â†‘
                                                  Giá»‘ng nhÆ° cÃ³ server tháº­t,
                                                  nhÆ°ng khÃ´ng cáº§n server tháº­t
```

**Lá»£i Ã­ch thá»±c táº¿:**

- Component dÃ¹ng `fetch`, `axios`, `ky` hay báº¥t cá»© HTTP client nÃ o â€” MSW Ä‘á»u báº¯t Ä‘Æ°á»£c
- Äá»‹nh nghÄ©a handlers má»™t láº§n, dÃ¹ng cho má»i test trong cáº£ project
- Error scenarios rÃµ rÃ ng: `ctx.status(404)` thay vÃ¬ `{ ok: false, status: 404 }`
- CÃ¹ng handlers cÃ³ thá»ƒ dÃ¹ng cho dev environment (browser Service Worker)

### 1.3 Mental Model

```
MSW Architecture trong Test Environment:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Test File                       â”‚
â”‚                                                   â”‚
â”‚  beforeAll(() => server.listen())                 â”‚
â”‚  afterEach(() => server.resetHandlers())          â”‚
â”‚  afterAll(() => server.close())                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ render component
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Component Under Test                â”‚
â”‚   useEffect â†’ fetch('/api/users')                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ HTTP request
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MSW Request Interceptor              â”‚
â”‚   CÃ³ handler cho GET /api/users?  â†’  YES         â”‚
â”‚   Execute handler â†’ return mock response          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ mock response
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Component receives data              â”‚
â”‚   setState(data) â†’ re-render â†’ show UI            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Analogy:** Mock `fetch` báº±ng `jest.fn()` giá»‘ng nhÆ° thay nhÃ¢n viÃªn bÆ°u tÃ¡ báº±ng ngÆ°á»i giáº£. MSW giá»‘ng nhÆ° láº­p má»™t bÆ°u cá»¥c giáº£ táº¡i Ä‘á»‹a chá»‰ Ä‘Ã³ â€” báº¥t ká»³ ai gá»­i thÆ° Ä‘áº¿n Ä‘á»‹a chá»‰ nÃ y (dÃ¹ dÃ¹ng xe mÃ¡y, xe Ä‘áº¡p, hay Ä‘i bá»™) Ä‘á»u nháº­n Ä‘Æ°á»£c pháº£n há»“i tá»« bÆ°u cá»¥c giáº£ Ä‘Ã³.

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

âŒ **"MSW cháº­m hÆ¡n mock function"**
â†’ MSW trong test environment (Node.js) khÃ´ng dÃ¹ng Service Worker, khÃ´ng cÃ³ network latency tháº­t. Tá»‘c Ä‘á»™ tÆ°Æ¡ng Ä‘Æ°Æ¡ng mock function.

âŒ **"Pháº£i define handler cho má»i request"**
â†’ Unhandled requests máº·c Ä‘á»‹nh bá»‹ warn (khÃ´ng error). Báº¡n cÃ³ thá»ƒ dÃ¹ng `server.listen({ onUnhandledRequest: 'error' })` Ä‘á»ƒ strict hÆ¡n.

âŒ **"server.resetHandlers() xÃ³a táº¥t cáº£ handlers"**
â†’ `resetHandlers()` chá»‰ xÃ³a handlers Ä‘Æ°á»£c thÃªm báº±ng `server.use()` trong test. Handlers gá»‘c tá»« `setupServer()` khÃ´ng bá»‹ áº£nh hÆ°á»Ÿng.

âŒ **"MSW chá»‰ dÃ¹ng Ä‘Æ°á»£c vá»›i RTL"**
â†’ MSW Ä‘á»™c láº­p vá»›i testing framework. DÃ¹ng Ä‘Æ°á»£c vá»›i Jest, Vitest, Playwright, hay tháº­m chÃ­ manual testing trong browser.

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Setup MSW (lÃ m má»™t láº§n cho cáº£ project)

```bash
npm install msw --save-dev
```

```tsx
// src/mocks/handlers.ts
// Äá»‹nh nghÄ©a "default" mock responses â€” dÃ¹ng cho happy path
import { http, HttpResponse } from 'msw';

export const handlers = [
  // GET /api/users â€” tráº£ vá» danh sÃ¡ch users
  http.get('/api/users', () => {
    return HttpResponse.json([
      { id: '1', name: 'Alice', email: 'alice@example.com', role: 'admin' },
      { id: '2', name: 'Bob', email: 'bob@example.com', role: 'user' },
    ]);
  }),

  // GET /api/users/:id â€” tráº£ vá» user cá»¥ thá»ƒ
  http.get('/api/users/:id', ({ params }) => {
    const { id } = params;

    const users: Record<string, object> = {
      '1': {
        id: '1',
        name: 'Alice',
        email: 'alice@example.com',
        role: 'admin',
      },
      '2': { id: '2', name: 'Bob', email: 'bob@example.com', role: 'user' },
    };

    const user = users[id as string];
    if (!user) {
      return new HttpResponse(null, { status: 404 });
    }

    return HttpResponse.json(user);
  }),

  // POST /api/users â€” táº¡o user má»›i
  http.post('/api/users', async ({ request }) => {
    const body = (await request.json()) as { name: string; email: string };

    return HttpResponse.json(
      { id: '3', ...body, role: 'user' },
      { status: 201 },
    );
  }),
];
```

```tsx
// src/mocks/server.ts
// Server dÃ¹ng cho test environment (Node.js)
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);
```

```tsx
// src/setupTests.ts (hoáº·c jest.setup.ts)
// Cháº¡y trÆ°á»›c Táº¤T Cáº¢ tests
import { server } from './mocks/server';

// Báº¯t Ä‘áº§u intercept trÆ°á»›c má»i test
beforeAll(() => server.listen({ onUnhandledRequest: 'warn' }));

// Reset handlers vá» máº·c Ä‘á»‹nh sau má»—i test
// (loáº¡i bá» override Ä‘Æ°á»£c thÃªm báº±ng server.use() trong test)
afterEach(() => server.resetHandlers());

// Táº¯t interceptor sau khi táº¥t cáº£ tests cháº¡y xong
afterAll(() => server.close());
```

```json
// jest.config.js hoáº·c package.json
{
  "jest": {
    "setupFilesAfterFramework": ["<rootDir>/src/setupTests.ts"]
  }
}
```

---

### Demo 1: Test Component Fetch Data â­

```tsx
// components/UserList.tsx
interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user';
}

export function UserList() {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch('/api/users')
      .then((res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
      .then((data) => {
        setUsers(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err.message);
        setLoading(false);
      });
  }, []);

  if (loading) return <div role='status'>Loading users...</div>;
  if (error) return <div role='alert'>Error: {error}</div>;
  if (users.length === 0) return <p>No users found</p>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>
          <span>{user.name}</span>
          <span>{user.email}</span>
          {user.role === 'admin' && (
            <span data-testid={`admin-${user.id}`}>Admin</span>
          )}
        </li>
      ))}
    </ul>
  );
}
```

```tsx
// components/UserList.test.tsx
import { render, screen } from '@testing-library/react';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';
import { UserList } from './UserList';

// KHÃ”NG cáº§n setup/teardown server á»Ÿ Ä‘Ã¢y!
// setupTests.ts Ä‘Ã£ lo rá»“i.

describe('UserList', () => {
  it('should show loading state initially', () => {
    render(<UserList />);
    // Loading hiá»ƒn thá»‹ ngay láº­p tá»©c â€” khÃ´ng cáº§n await
    expect(screen.getByRole('status')).toHaveTextContent('Loading users...');
  });

  it('should render list of users', async () => {
    render(<UserList />);

    // DÃ¹ng findBy* â€” tá»± Ä‘á»™ng chá» async update
    // Handler máº·c Ä‘á»‹nh tá»« handlers.ts sáº½ tráº£ vá» Alice vÃ  Bob
    expect(await screen.findByText('Alice')).toBeInTheDocument();
    expect(screen.getByText('Bob')).toBeInTheDocument();
  });

  it('should show admin badge for admin users', async () => {
    render(<UserList />);

    await screen.findByText('Alice');

    // Alice lÃ  admin, Bob khÃ´ng pháº£i
    expect(screen.getByTestId('admin-1')).toBeInTheDocument();
    expect(screen.queryByTestId('admin-2')).not.toBeInTheDocument();
  });

  it('should show error when API fails', async () => {
    // Override handler cho test nÃ y
    server.use(
      http.get('/api/users', () => {
        return new HttpResponse(null, { status: 500 });
      }),
    );
    // Sau test nÃ y, server.resetHandlers() trong setupTests.ts
    // sáº½ xÃ³a override nÃ y â€” test tiáº¿p theo váº«n dÃ¹ng handler gá»‘c

    render(<UserList />);

    expect(await screen.findByRole('alert')).toHaveTextContent('HTTP 500');
  });

  it('should show empty state when no users', async () => {
    server.use(
      http.get('/api/users', () => {
        return HttpResponse.json([]);
      }),
    );

    render(<UserList />);

    expect(await screen.findByText('No users found')).toBeInTheDocument();
  });
});
```

### Demo 2: Test Component POST Data â­â­

```tsx
// components/CreateUserForm.tsx
interface CreateUserFormProps {
  onSuccess: (user: User) => void;
}

export function CreateUserForm({ onSuccess }: CreateUserFormProps) {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setSubmitting(true);
    setError(null);

    try {
      const res = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, email }),
      });

      if (!res.ok) throw new Error(`HTTP ${res.status}`);

      const newUser = await res.json();
      onSuccess(newUser);
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name
        <input
          value={name}
          onChange={(e) => setName(e.target.value)}
          required
        />
      </label>
      <label>
        Email
        <input
          type='email'
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </label>
      {error && <p role='alert'>{error}</p>}
      <button
        type='submit'
        disabled={submitting}
      >
        {submitting ? 'Creating...' : 'Create User'}
      </button>
    </form>
  );
}
```

```tsx
// components/CreateUserForm.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';
import { CreateUserForm } from './CreateUserForm';

describe('CreateUserForm', () => {
  const mockOnSuccess = jest.fn();

  beforeEach(() => {
    mockOnSuccess.mockReset();
  });

  it('should submit form and call onSuccess', async () => {
    const user = userEvent.setup();
    render(<CreateUserForm onSuccess={mockOnSuccess} />);

    await user.type(screen.getByLabelText('Name'), 'Charlie');
    await user.type(screen.getByLabelText('Email'), 'charlie@example.com');
    await user.click(screen.getByRole('button', { name: 'Create User' }));

    // Chá» button trá»Ÿ láº¡i tráº¡ng thÃ¡i bÃ¬nh thÆ°á»ng (submitting = false)
    await screen.findByRole('button', { name: 'Create User' });

    // Handler POST máº·c Ä‘á»‹nh tá»« handlers.ts Ä‘Ã£ Ä‘Æ°á»£c gá»i
    expect(mockOnSuccess).toHaveBeenCalledWith({
      id: '3',
      name: 'Charlie',
      email: 'charlie@example.com',
      role: 'user',
    });
  });

  it('should show submitting state during request', async () => {
    // Override Ä‘á»ƒ delay response â€” test loading state
    server.use(
      http.post('/api/users', async () => {
        // Tráº£ vá» Promise khÃ´ng resolve ngay
        await new Promise((resolve) => setTimeout(resolve, 100));
        return HttpResponse.json({ id: '3', name: 'Charlie' }, { status: 201 });
      }),
    );

    const user = userEvent.setup();
    render(<CreateUserForm onSuccess={mockOnSuccess} />);

    await user.type(screen.getByLabelText('Name'), 'Charlie');
    await user.type(screen.getByLabelText('Email'), 'charlie@example.com');
    await user.click(screen.getByRole('button', { name: 'Create User' }));

    // Ngay sau click â€” button Ä‘ang submitting
    expect(screen.getByRole('button')).toHaveTextContent('Creating...');
    expect(screen.getByRole('button')).toBeDisabled();

    // Chá» hoÃ n thÃ nh
    await screen.findByRole('button', { name: 'Create User' });
  });

  it('should show error when server returns 422', async () => {
    server.use(
      http.post('/api/users', () => {
        return HttpResponse.json(
          { message: 'Email already exists' },
          { status: 422 },
        );
      }),
    );

    const user = userEvent.setup();
    render(<CreateUserForm onSuccess={mockOnSuccess} />);

    await user.type(screen.getByLabelText('Name'), 'Alice');
    await user.type(screen.getByLabelText('Email'), 'alice@example.com');
    await user.click(screen.getByRole('button', { name: 'Create User' }));

    expect(await screen.findByRole('alert')).toHaveTextContent('HTTP 422');
    expect(mockOnSuccess).not.toHaveBeenCalled();
  });
});
```

### Demo 3: Network Error vs HTTP Error â­â­â­

```tsx
// PhÃ¢n biá»‡t hai loáº¡i lá»—i quan trá»ng:
// 1. HTTP Error (server tráº£ vá» 4xx/5xx) â€” fetch() KHÃ”NG throw, pháº£i check res.ok
// 2. Network Error (khÃ´ng káº¿t ná»‘i Ä‘Æ°á»£c server) â€” fetch() THROW Error

// components/RobustFetcher.tsx
export function RobustFetcher({ url }: { url: string }) {
  const [state, setState] = useState<{
    data: unknown;
    loading: boolean;
    error: string | null;
    errorType: 'network' | 'http' | null;
  }>({ data: null, loading: true, error: null, errorType: null });

  useEffect(() => {
    let cancelled = false;

    fetch(url)
      .then(async (res) => {
        if (!res.ok) {
          // HTTP error â€” server pháº£n há»“i nhÆ°ng vá»›i error status
          const errorData = await res.json().catch(() => null);
          throw Object.assign(
            new Error(errorData?.message ?? `HTTP ${res.status}`),
            { type: 'http' as const },
          );
        }
        return res.json();
      })
      .then((data) => {
        if (!cancelled)
          setState({ data, loading: false, error: null, errorType: null });
      })
      .catch((err) => {
        if (!cancelled)
          setState({
            data: null,
            loading: false,
            error: err.message,
            errorType: err.type ?? 'network',
          });
      });

    return () => {
      cancelled = true;
    };
  }, [url]);

  if (state.loading) return <p role='status'>Loading...</p>;
  if (state.error) {
    return (
      <p
        role='alert'
        data-error-type={state.errorType}
      >
        {state.errorType === 'network'
          ? 'Cannot connect to server. Check your internet connection.'
          : `Error: ${state.error}`}
      </p>
    );
  }
  return <pre>{JSON.stringify(state.data, null, 2)}</pre>;
}
```

```tsx
// components/RobustFetcher.test.tsx
import { http, HttpResponse, passthrough } from 'msw';

describe('RobustFetcher â€” error scenarios', () => {
  it('should handle HTTP 404 error', async () => {
    server.use(
      http.get('/api/data', () => {
        return HttpResponse.json(
          { message: 'Resource not found' },
          { status: 404 },
        );
      }),
    );

    render(<RobustFetcher url='/api/data' />);

    const alert = await screen.findByRole('alert');
    expect(alert).toHaveTextContent('Resource not found');
    expect(alert).toHaveAttribute('data-error-type', 'http');
  });

  it('should handle network error (no connection)', async () => {
    server.use(
      http.get('/api/data', () => {
        // MSW cÃ¡ch simulate network error
        return HttpResponse.error();
      }),
    );

    render(<RobustFetcher url='/api/data' />);

    const alert = await screen.findByRole('alert');
    expect(alert).toHaveTextContent('Cannot connect to server');
    expect(alert).toHaveAttribute('data-error-type', 'network');
  });

  it('should handle successful response', async () => {
    // KhÃ´ng cáº§n override â€” dÃ¹ng handler máº·c Ä‘á»‹nh
    server.use(
      http.get('/api/data', () => {
        return HttpResponse.json({ result: 42 });
      }),
    );

    render(<RobustFetcher url='/api/data' />);

    await screen.findByText(/"result": 42/);
  });
});
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ BÃ i 1: Setup vÃ  Test Handler CÆ¡ Báº£n (15 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Viáº¿t handlers vÃ  test component GET cÆ¡ báº£n
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: jest.fn() Ä‘á»ƒ mock fetch
 *
 * Requirements:
 * 1. Táº¡o handler cho GET /api/products
 * 2. Test loading state
 * 3. Test hiá»ƒn thá»‹ dá»¯ liá»‡u
 */

// Component Ä‘Ã£ cho sáºµn:
interface Product {
  id: string;
  name: string;
  price: number;
}

export function ProductList() {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('/api/products')
      .then((res) => res.json())
      .then((data) => {
        setProducts(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <p role='status'>Loading...</p>;
  return (
    <ul>
      {products.map((p) => (
        <li key={p.id}>
          {p.name} â€” ${p.price}
        </li>
      ))}
    </ul>
  );
}

// âŒ CÃ¡ch SAI â€” váº«n dÃ¹ng jest.fn():
const mockFetch = jest.fn();
global.fetch = mockFetch;
mockFetch.mockResolvedValue({
  json: () => [{ id: '1', name: 'Phone', price: 999 }],
});
// KhÃ´ng biáº¿t URL nÃ o Ä‘Æ°á»£c gá»i, khÃ´ng test Ä‘Æ°á»£c error cases dá»… dÃ ng

// âœ… CÃ¡ch ÄÃšNG â€” MSW handler:
// Xem nhiá»‡m vá»¥ bÃªn dÆ°á»›i

// ğŸ¯ NHIá»†M Vá»¤:
// 1. Táº¡o handler cho GET /api/products trong handlers.ts
// 2. Viáº¿t test file cho ProductList
describe('ProductList', () => {
  it('should show loading state initially', () => {
    // TODO
  });

  it('should render products from API', async () => {
    // TODO: dÃ¹ng findBy* Ä‘á»ƒ chá»
  });

  it('should format price correctly', async () => {
    // TODO
  });
});
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
// src/mocks/handlers.ts â€” thÃªm vÃ o file handlers
import { http, HttpResponse } from 'msw';

export const handlers = [
  // ... handlers khÃ¡c ...

  http.get('/api/products', () => {
    return HttpResponse.json([
      { id: '1', name: 'Laptop', price: 1299 },
      { id: '2', name: 'Phone', price: 999 },
      { id: '3', name: 'Headphones', price: 199 },
    ]);
  }),
];
```

```jsx
// components/ProductList.test.tsx
import { render, screen } from '@testing-library/react';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';
import { ProductList } from './ProductList';

/**
 * ProductList â€” test component hiá»ƒn thá»‹ danh sÃ¡ch sáº£n pháº©m
 * setupTests.ts Ä‘Ã£ handle server lifecycle
 */
describe('ProductList', () => {
  it('should show loading state initially', () => {
    render(<ProductList />);
    // Loading hiá»ƒn thá»‹ synchronously â€” khÃ´ng cáº§n await
    expect(screen.getByRole('status')).toHaveTextContent('Loading...');
  });

  it('should render products from API', async () => {
    render(<ProductList />);

    // findBy* tá»± Ä‘á»™ng chá» element xuáº¥t hiá»‡n
    expect(await screen.findByText(/Laptop/)).toBeInTheDocument();
    expect(screen.getByText(/Phone/)).toBeInTheDocument();
    expect(screen.getByText(/Headphones/)).toBeInTheDocument();
  });

  it('should format price correctly', async () => {
    render(<ProductList />);

    await screen.findByText(/Laptop/);

    // Kiá»ƒm tra format "$1299"
    expect(screen.getByText(/\$1299/)).toBeInTheDocument();
  });

  it('should show empty list when no products', async () => {
    server.use(http.get('/api/products', () => HttpResponse.json([])));

    render(<ProductList />);

    // Loading biáº¿n máº¥t, khÃ´ng cÃ³ list item
    await screen.findByRole('list'); // <ul> váº«n render
    expect(screen.queryAllByRole('listitem')).toHaveLength(0);
  });
});

// Result: 4 tests passed
```

</details>

---

### â­â­ BÃ i 2: Override Handler trong Test (25 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Biáº¿t khi nÃ o dÃ¹ng handler máº·c Ä‘á»‹nh vs server.use() override
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: Báº¡n cÃ³ component SearchUsers tÃ¬m kiáº¿m user theo tÃªn.
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 * Approach A: Äá»‹nh nghÄ©a táº¥t cáº£ scenarios trong handlers.ts (default)
 * Pros: Centralized, reusable
 * Cons: Handlers phá»©c táº¡p, khÃ³ maintain nhiá»u cases
 *
 * Approach B: Handler máº·c Ä‘á»‹nh cho happy path,
 *             server.use() override cho error/edge cases
 * Pros: Handlers máº·c Ä‘á»‹nh Ä‘Æ¡n giáº£n, override chá»‰ khi cáº§n
 * Cons: Logic test phÃ¢n tÃ¡n
 *
 * ğŸ’­ Báº N CHá»ŒN GÃŒ? HÃ£y implement Approach B.
 */

// Component cáº§n test:
export function SearchUsers() {
  const [query, setQuery] = useState('');
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const search = async (searchQuery) => {
    if (!searchQuery.trim()) return;

    setLoading(true);
    setError(null);

    try {
      const res = await fetch(`/api/users?search=${searchQuery}`);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      setUsers(await res.json());
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <input
        placeholder='Search users...'
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      <button onClick={() => search(query)}>Search</button>

      {loading && <p role='status'>Searching...</p>}
      {error && <p role='alert'>{error}</p>}
      <ul>
        {users.map((u) => (
          <li key={u.id}>{u.name}</li>
        ))}
      </ul>
    </div>
  );
}

// ğŸ¯ NHIá»†M Vá»¤:
// 1. ThÃªm handler cho GET /api/users?search=* vÃ o handlers.ts
// 2. Test happy path (dÃ¹ng default handler)
// 3. Test "no results" (override handler)
// 4. Test error (override handler)
// 5. Test khÃ´ng search khi query rá»—ng
describe('SearchUsers', () => {
  // TODO: implement
});
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
// handlers.ts â€” thÃªm search handler
http.get('/api/users', ({ request }) => {
  const url = new URL(request.url);
  const search = url.searchParams.get('search');

  // Náº¿u khÃ´ng cÃ³ search query, tráº£ vá» táº¥t cáº£
  if (!search) {
    return HttpResponse.json([
      { id: '1', name: 'Alice', email: 'alice@example.com' },
      { id: '2', name: 'Bob', email: 'bob@example.com' },
    ]);
  }

  // Happy path: tÃ¬m Alice
  const allUsers = [
    { id: '1', name: 'Alice', email: 'alice@example.com' },
    { id: '2', name: 'Bob', email: 'bob@example.com' },
  ];

  return HttpResponse.json(
    allUsers.filter(u => u.name.toLowerCase().includes(search.toLowerCase()))
  );
}),
```

```jsx
// SearchUsers.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';
import { SearchUsers } from './SearchUsers';

/**
 * SearchUsers â€” test search functionality
 * Default handler: tráº£ vá» káº¿t quáº£ theo tÃªn (Alice, Bob)
 * Override handler: error cases vÃ  edge cases
 */
describe('SearchUsers', () => {
  it('should search and display results', async () => {
    const user = userEvent.setup();
    render(<SearchUsers />);

    await user.type(screen.getByPlaceholderText('Search users...'), 'Alice');
    await user.click(screen.getByRole('button', { name: 'Search' }));

    // Default handler lá»c theo tÃªn
    expect(await screen.findByText('Alice')).toBeInTheDocument();
    expect(screen.queryByText('Bob')).not.toBeInTheDocument();
  });

  it('should show loading state during search', async () => {
    server.use(
      http.get('/api/users', async () => {
        await new Promise((r) => setTimeout(r, 50)); // delay nhá»
        return HttpResponse.json([{ id: '1', name: 'Alice' }]);
      }),
    );

    const user = userEvent.setup();
    render(<SearchUsers />);

    await user.type(screen.getByPlaceholderText('Search users...'), 'Alice');
    await user.click(screen.getByRole('button', { name: 'Search' }));

    // Ngay sau click â€” loading
    expect(screen.getByRole('status')).toHaveTextContent('Searching...');

    // Sau khi xong â€” loading biáº¿n máº¥t
    await screen.findByText('Alice');
    expect(screen.queryByRole('status')).not.toBeInTheDocument();
  });

  it('should show empty state when no results found', async () => {
    server.use(http.get('/api/users', () => HttpResponse.json([])));

    const user = userEvent.setup();
    render(<SearchUsers />);

    await user.type(screen.getByPlaceholderText('Search users...'), 'xyz');
    await user.click(screen.getByRole('button', { name: 'Search' }));

    // Chá» loading biáº¿n máº¥t
    await screen.findByRole('list');
    expect(screen.queryAllByRole('listitem')).toHaveLength(0);
  });

  it('should show error when API fails', async () => {
    server.use(
      http.get('/api/users', () => new HttpResponse(null, { status: 503 })),
    );

    const user = userEvent.setup();
    render(<SearchUsers />);

    await user.type(screen.getByPlaceholderText('Search users...'), 'Alice');
    await user.click(screen.getByRole('button', { name: 'Search' }));

    expect(await screen.findByRole('alert')).toHaveTextContent('HTTP 503');
  });

  it('should NOT search when query is empty', async () => {
    const user = userEvent.setup();
    render(<SearchUsers />);

    // Click search vá»›i input rá»—ng
    await user.click(screen.getByRole('button', { name: 'Search' }));

    // KhÃ´ng cÃ³ status, khÃ´ng cÃ³ results, khÃ´ng cÃ³ error
    expect(screen.queryByRole('status')).not.toBeInTheDocument();
    expect(screen.queryAllByRole('listitem')).toHaveLength(0);
  });
});

// Result: 5 tests passed
```

</details>

---

### â­â­â­ BÃ i 3: Test CRUD Flow Äáº§y Äá»§ (40 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Test toÃ n bá»™ CRUD flow vá»›i handlers cho má»—i method
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ User Story:
 * "LÃ  admin, tÃ´i muá»‘n quáº£n lÃ½ danh sÃ¡ch tags Ä‘á»ƒ
 * tÃ´i cÃ³ thá»ƒ thÃªm, sá»­a, xÃ³a tags tá»« dashboard."
 *
 * âœ… Acceptance Criteria:
 * - [ ] Hiá»ƒn thá»‹ danh sÃ¡ch tags khi load
 * - [ ] ThÃªm tag má»›i vÃ  hiá»ƒn thá»‹ ngay trong list
 * - [ ] XÃ³a tag vÃ  remove khá»i list
 * - [ ] Show error khi tÃªn tag Ä‘Ã£ tá»“n táº¡i (409 Conflict)
 *
 * ğŸš¨ Edge Cases:
 * - XÃ³a tag Ä‘ang Ä‘Æ°á»£c dÃ¹ng â†’ API tráº£ 409
 * - TÃªn tag trá»‘ng â†’ khÃ´ng gá»i API
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] Handlers cho GET, POST, DELETE /api/tags
 * - [ ] Test loading state
 * - [ ] Test add tag success flow
 * - [ ] Test delete tag flow
 * - [ ] Test duplicate tag error
 * - [ ] Test delete conflict error
 */

interface Tag {
  id: string;
  name: string;
  color: string;
}

export function TagManager() {
  const [tags, setTags] = useState<Tag[]>([]);
  const [loading, setLoading] = useState(true);
  const [newTagName, setNewTagName] = useState('');
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch('/api/tags')
      .then((r) => r.json())
      .then((data) => {
        setTags(data);
        setLoading(false);
      });
  }, []);

  const addTag = async () => {
    if (!newTagName.trim()) return;
    setError(null);

    const res = await fetch('/api/tags', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: newTagName.trim() }),
    });

    if (res.status === 409) {
      setError('Tag name already exists');
      return;
    }
    if (!res.ok) {
      setError(`Failed to create tag: HTTP ${res.status}`);
      return;
    }

    const created = await res.json();
    setTags((prev) => [...prev, created]);
    setNewTagName('');
  };

  const deleteTag = async (id: string) => {
    const res = await fetch(`/api/tags/${id}`, { method: 'DELETE' });

    if (res.status === 409) {
      setError('Cannot delete tag: it is currently in use');
      return;
    }
    if (!res.ok) return;

    setTags((prev) => prev.filter((t) => t.id !== id));
  };

  if (loading) return <p role='status'>Loading tags...</p>;

  return (
    <div>
      <div>
        <input
          value={newTagName}
          onChange={(e) => setNewTagName(e.target.value)}
          placeholder='New tag name'
          aria-label='New tag name'
        />
        <button onClick={addTag}>Add Tag</button>
      </div>
      {error && <p role='alert'>{error}</p>}
      <ul>
        {tags.map((tag) => (
          <li key={tag.id}>
            {tag.name}
            <button
              onClick={() => deleteTag(tag.id)}
              aria-label={`Delete ${tag.name}`}
            >
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}

// ğŸ¯ NHIá»†M Vá»¤: Viáº¿t handlers vÃ  Ä‘áº§y Ä‘á»§ test suite
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
// handlers.ts â€” thÃªm tag handlers
// State trong-memory cho tags (reset sau má»—i test qua resetHandlers)
let mockTags = [
  { id: '1', name: 'react', color: '#61dafb' },
  { id: '2', name: 'typescript', color: '#3178c6' },
];

http.get('/api/tags', () => {
  return HttpResponse.json(mockTags);
}),

http.post('/api/tags', async ({ request }) => {
  const { name } = await request.json();

  // Check duplicate
  if (mockTags.some(t => t.name === name)) {
    return new HttpResponse(null, { status: 409 });
  }

  const newTag = { id: String(Date.now()), name, color: '#888888' };
  mockTags.push(newTag);
  return HttpResponse.json(newTag, { status: 201 });
}),

http.delete('/api/tags/:id', ({ params }) => {
  const { id } = params;
  mockTags = mockTags.filter(t => t.id !== id);
  return new HttpResponse(null, { status: 204 });
}),
```

```jsx
// TagManager.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';
import { TagManager } from './TagManager';

/**
 * TagManager â€” CRUD flow tests
 * Handlers máº·c Ä‘á»‹nh: GET/POST/DELETE /api/tags
 * Override cho error scenarios
 */
describe('TagManager', () => {
  it('should load and display tags', async () => {
    render(<TagManager />);

    expect(screen.getByRole('status')).toHaveTextContent('Loading tags...');

    expect(await screen.findByText('react')).toBeInTheDocument();
    expect(screen.getByText('typescript')).toBeInTheDocument();
    expect(screen.queryByRole('status')).not.toBeInTheDocument();
  });

  it('should add a new tag', async () => {
    const user = userEvent.setup();
    render(<TagManager />);

    await screen.findByText('react'); // Chá» load xong

    await user.type(screen.getByLabelText('New tag name'), 'javascript');
    await user.click(screen.getByRole('button', { name: 'Add Tag' }));

    // Tag má»›i xuáº¥t hiá»‡n trong list
    expect(await screen.findByText('javascript')).toBeInTheDocument();

    // Input Ä‘Æ°á»£c clear sau khi thÃªm thÃ nh cÃ´ng
    expect(screen.getByLabelText('New tag name')).toHaveValue('');
  });

  it('should show error when adding duplicate tag', async () => {
    server.use(
      http.post('/api/tags', () => new HttpResponse(null, { status: 409 })),
    );

    const user = userEvent.setup();
    render(<TagManager />);

    await screen.findByText('react');

    await user.type(screen.getByLabelText('New tag name'), 'react'); // tÃªn Ä‘Ã£ tá»“n táº¡i
    await user.click(screen.getByRole('button', { name: 'Add Tag' }));

    expect(await screen.findByRole('alert')).toHaveTextContent(
      'Tag name already exists',
    );
  });

  it('should NOT call API when tag name is empty', async () => {
    const requestSpy = jest.fn();
    server.use(
      http.post('/api/tags', () => {
        requestSpy();
        return HttpResponse.json({}, { status: 201 });
      }),
    );

    const user = userEvent.setup();
    render(<TagManager />);

    await screen.findByText('react');

    // Click vá»›i input rá»—ng
    await user.click(screen.getByRole('button', { name: 'Add Tag' }));

    expect(requestSpy).not.toHaveBeenCalled();
  });

  it('should delete a tag', async () => {
    const user = userEvent.setup();
    render(<TagManager />);

    await screen.findByText('react');

    await user.click(screen.getByRole('button', { name: 'Delete react' }));

    // 'react' biáº¿n máº¥t khá»i list
    await screen.findByText('typescript'); // wait for re-render
    expect(screen.queryByText('react')).not.toBeInTheDocument();
  });

  it('should show error when deleting tag in use', async () => {
    server.use(
      http.delete(
        '/api/tags/:id',
        () => new HttpResponse(null, { status: 409 }),
      ),
    );

    const user = userEvent.setup();
    render(<TagManager />);

    await screen.findByText('react');
    await user.click(screen.getByRole('button', { name: 'Delete react' }));

    expect(await screen.findByRole('alert')).toHaveTextContent(
      'Cannot delete tag: it is currently in use',
    );

    // Tag váº«n cÃ²n trong list
    expect(screen.getByText('react')).toBeInTheDocument();
  });
});

// Result: 6 tests passed
```

</details>

---

### â­â­â­â­ BÃ i 4: Stateful Handlers vÃ  Test Isolation (60 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Xá»­ lÃ½ stateful API mock Ä‘Ãºng cÃ¡ch Ä‘á»ƒ tests khÃ´ng áº£nh hÆ°á»Ÿng nhau
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Váº¥n Ä‘á»: Khi handlers dÃ¹ng state in-memory (nhÆ° mockTags á»Ÿ BÃ i 3),
 * state Ä‘Ã³ KHÃ”NG tá»± reset giá»¯a cÃ¡c tests vÃ¬ server.resetHandlers()
 * chá»‰ reset handler registration, khÃ´ng reset handler state.
 *
 * So sÃ¡nh 3 approaches:
 *
 * Approach A: Handler stateless â€” má»—i test override handler vá»›i data riÃªng
 * Approach B: Reset state trong beforeEach báº±ng helper function
 * Approach C: Handler factory â€” createHandlers(initialData) táº¡o fresh handlers
 *
 * ADR:
 * - Context: Tests cáº§n isolated state, khÃ´ng share qua handlers
 * - Decision: Approach B (reset function) cho Ä‘Æ¡n giáº£n,
 *             Approach C (factory) cho complex scenarios
 * - Rationale: B Ä‘Æ¡n giáº£n maintain, C flexible hÆ¡n nhÆ°ng verbose
 * - Consequences: Pháº£i nhá»› gá»i reset trong beforeEach
 *
 * ğŸ’» PHASE 2: Implement Approach B (30 phÃºt)
 * Táº¡o NotificationManager component vÃ  test suite
 * vá»›i stateful API (notifications cÃ³ thá»ƒ mark as read)
 *
 * ğŸ§ª PHASE 3: Verify Isolation (10 phÃºt)
 * - [ ] Test 1: mark notification A as read
 * - [ ] Test 2: kiá»ƒm tra notification A váº«n unread (test isolation hoáº¡t Ä‘á»™ng)
 */

interface Notification {
  id: string;
  message: string;
  read: boolean;
}

export function NotificationCenter() {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('/api/notifications')
      .then((r) => r.json())
      .then((data) => {
        setNotifications(data);
        setLoading(false);
      });
  }, []);

  const markAsRead = async (id: string) => {
    await fetch(`/api/notifications/${id}/read`, { method: 'PATCH' });
    setNotifications((prev) =>
      prev.map((n) => (n.id === id ? { ...n, read: true } : n)),
    );
  };

  if (loading) return <p role='status'>Loading...</p>;

  return (
    <ul>
      {notifications.map((n) => (
        <li
          key={n.id}
          data-read={String(n.read)}
        >
          {n.message}
          {!n.read && (
            <button onClick={() => markAsRead(n.id)}>Mark as read</button>
          )}
        </li>
      ))}
    </ul>
  );
}
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
// handlers.ts â€” stateful notification handlers vá»›i reset function

// State in-memory â€” PHáº¢I reset trÆ°á»›c má»—i test
let mockNotifications = [
  { id: '1', message: 'New comment on your post', read: false },
  { id: '2', message: 'Alice liked your photo', read: false },
  { id: '3', message: 'System maintenance tonight', read: true },
];

// Export reset function Ä‘á»ƒ dÃ¹ng trong beforeEach
export function resetNotifications() {
  mockNotifications = [
    { id: '1', message: 'New comment on your post', read: false },
    { id: '2', message: 'Alice liked your photo', read: false },
    { id: '3', message: 'System maintenance tonight', read: true },
  ];
}

// Handler Ä‘á»c tá»« mockNotifications (reactive vá»›i state)
http.get('/api/notifications', () => {
  return HttpResponse.json(mockNotifications);
}),

http.patch('/api/notifications/:id/read', ({ params }) => {
  const { id } = params;
  mockNotifications = mockNotifications.map(n =>
    n.id === id ? { ...n, read: true } : n
  );
  return new HttpResponse(null, { status: 204 });
}),
```

```jsx
// NotificationCenter.test.tsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';
import { NotificationCenter } from './NotificationCenter';
import { resetNotifications } from '../mocks/handlers';

/**
 * NotificationCenter â€” stateful API tests
 * QUAN TRá»ŒNG: Reset mock state trong beforeEach Ä‘á»ƒ test isolation
 */
describe('NotificationCenter', () => {
  // â­ Reset handler state trÆ°á»›c má»—i test
  // resetHandlers() trong setupTests.ts reset handler REGISTRATION
  // nhÆ°ng KHÃ”NG reset handler's internal state (mockNotifications)
  beforeEach(() => {
    resetNotifications();
  });

  it('should display unread and read notifications', async () => {
    render(<NotificationCenter />);

    await screen.findByText('New comment on your post');

    // Unread notifications cÃ³ button
    expect(
      screen.getAllByRole('button', { name: 'Mark as read' }),
    ).toHaveLength(2); // 2 unread

    // Read notification khÃ´ng cÃ³ button
    const readItem = screen
      .getByText('System maintenance tonight')
      .closest('li');
    expect(readItem).toHaveAttribute('data-read', 'true');
  });

  it('should mark notification as read', async () => {
    const user = userEvent.setup();
    render(<NotificationCenter />);

    await screen.findByText('New comment on your post');

    const markReadButtons = screen.getAllByRole('button', {
      name: 'Mark as read',
    });
    await user.click(markReadButtons[0]); // Click first unread

    // Button biáº¿n máº¥t sau khi mark as read
    expect(
      screen.getAllByRole('button', { name: 'Mark as read' }),
    ).toHaveLength(1); // CÃ²n 1 unread
  });

  it('TEST ISOLATION: notification should still be unread in this test', async () => {
    // Náº¿u khÃ´ng cÃ³ resetNotifications() trong beforeEach,
    // test trÆ°á»›c sáº½ áº£nh hÆ°á»Ÿng vÃ  test nÃ y sáº½ fail.
    render(<NotificationCenter />);

    await screen.findByText('New comment on your post');

    // Váº«n cÃ²n 2 unread â€” state Ä‘Ã£ Ä‘Æ°á»£c reset
    expect(
      screen.getAllByRole('button', { name: 'Mark as read' }),
    ).toHaveLength(2);
  });

  it('should handle mark-as-read API failure gracefully', async () => {
    server.use(
      http.patch(
        '/api/notifications/:id/read',
        () => new HttpResponse(null, { status: 500 }),
      ),
    );

    const user = userEvent.setup();
    render(<NotificationCenter />);

    await screen.findByText('New comment on your post');
    await user.click(
      screen.getAllByRole('button', { name: 'Mark as read' })[0],
    );

    // DÃ¹ API fail, component khÃ´ng crash (tÃ¹y implementation)
    // Náº¿u muá»‘n revert optimistic update, sáº½ rollback á»Ÿ Ä‘Ã¢y
    // Trong implementation hiá»‡n táº¡i: UI update trÆ°á»›c khi API confirm
    // Test nÃ y verify component khÃ´ng throw
    expect(screen.getByText('New comment on your post')).toBeInTheDocument();
  });
});

// Result: 4 tests passed, test isolation verified
```

</details>

---

### â­â­â­â­â­ BÃ i 5: Production Challenge â€” Test Dashboard vá»›i Multiple Endpoints (90 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Test component fetch nhiá»u endpoints song song, production-grade
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * AdminDashboard load 3 endpoints song song:
 * - GET /api/stats â€” tá»•ng sá»‘ user, posts, revenue
 * - GET /api/recent-activity â€” 5 hoáº¡t Ä‘á»™ng gáº§n nháº¥t
 * - GET /api/alerts â€” cáº£nh bÃ¡o há»‡ thá»‘ng (cÃ³ thá»ƒ rá»—ng)
 *
 * Loading: hiá»ƒn thá»‹ skeleton cho má»—i section riÃªng
 * Partial failure: section nÃ o fail â†’ show error trong section Ä‘Ã³,
 *                  section khÃ¡c váº«n hiá»ƒn thá»‹ bÃ¬nh thÆ°á»ng
 *
 * ğŸ—ï¸ Technical Design Doc:
 * 1. Component Architecture: 3 sub-sections (Stats, Activity, Alerts)
 * 2. State Management: useReducer vá»›i actions per section
 * 3. API: Promise.all vá»›i per-section error handling
 * 4. Performance: parallel fetch, khÃ´ng waterfall
 *
 * âœ… Production Checklist:
 * - [ ] TypeScript types
 * - [ ] Partial failure handling
 * - [ ] Loading per section
 * - [ ] Empty state cho Alerts
 * - [ ] Test coverage cho má»i combination failure
 * - [ ] a11y: loading sections cÃ³ role="status"
 */

// ğŸ¯ NHIá»†M Vá»¤: Implement AdminDashboard VÃ€ viáº¿t test suite Ä‘áº§y Ä‘á»§
// Hint: DÃ¹ng useReducer Ä‘á»ƒ quáº£n lÃ½ state phá»©c táº¡p (Ä‘Ã£ há»c NgÃ y 26-29)
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
// handlers.ts â€” dashboard handlers
http.get('/api/stats', () => {
  return HttpResponse.json({
    totalUsers: 1247,
    totalPosts: 8432,
    revenue: 52840,
  });
}),

http.get('/api/recent-activity', () => {
  return HttpResponse.json([
    { id: '1', type: 'signup', user: 'Charlie', timestamp: '2024-01-15T10:00:00Z' },
    { id: '2', type: 'post', user: 'Alice', timestamp: '2024-01-15T09:30:00Z' },
    { id: '3', type: 'purchase', user: 'Bob', timestamp: '2024-01-15T09:00:00Z' },
  ]);
}),

http.get('/api/alerts', () => {
  return HttpResponse.json([]); // Default: no alerts
}),
```

```jsx
// AdminDashboard.tsx
const initialState = {
  stats: { data: null, loading: true, error: null },
  activity: { data: null, loading: true, error: null },
  alerts: { data: null, loading: true, error: null },
};

function dashboardReducer(state, action) {
  switch (action.type) {
    case 'SECTION_SUCCESS':
      return {
        ...state,
        [action.section]: { data: action.data, loading: false, error: null },
      };
    case 'SECTION_ERROR':
      return {
        ...state,
        [action.section]: { data: null, loading: false, error: action.error },
      };
    default:
      return state;
  }
}

export function AdminDashboard() {
  const [state, dispatch] = useReducer(dashboardReducer, initialState);

  useEffect(() => {
    const fetchSection = (url, section) =>
      fetch(url)
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return res.json();
        })
        .then((data) => dispatch({ type: 'SECTION_SUCCESS', section, data }))
        .catch((err) =>
          dispatch({ type: 'SECTION_ERROR', section, error: err.message }),
        );

    // Fetch táº¥t cáº£ song song â€” khÃ´ng waterfall
    fetchSection('/api/stats', 'stats');
    fetchSection('/api/recent-activity', 'activity');
    fetchSection('/api/alerts', 'alerts');
  }, []);

  return (
    <div>
      {/* Stats Section */}
      <section aria-label='Statistics'>
        {state.stats.loading && <p role='status'>Loading stats...</p>}
        {state.stats.error && (
          <p role='alert'>Stats error: {state.stats.error}</p>
        )}
        {state.stats.data && (
          <dl>
            <dt>Users</dt>
            <dd>{state.stats.data.totalUsers.toLocaleString()}</dd>
            <dt>Posts</dt>
            <dd>{state.stats.data.totalPosts.toLocaleString()}</dd>
            <dt>Revenue</dt>
            <dd>${state.stats.data.revenue.toLocaleString()}</dd>
          </dl>
        )}
      </section>

      {/* Activity Section */}
      <section aria-label='Recent Activity'>
        {state.activity.loading && <p role='status'>Loading activity...</p>}
        {state.activity.error && (
          <p role='alert'>Activity error: {state.activity.error}</p>
        )}
        {state.activity.data && (
          <ul>
            {state.activity.data.map((a) => (
              <li key={a.id}>
                {a.user} â€” {a.type}
              </li>
            ))}
          </ul>
        )}
      </section>

      {/* Alerts Section */}
      <section aria-label='System Alerts'>
        {state.alerts.loading && <p role='status'>Loading alerts...</p>}
        {state.alerts.error && (
          <p role='alert'>Alerts error: {state.alerts.error}</p>
        )}
        {state.alerts.data?.length === 0 && <p>No active alerts</p>}
        {state.alerts.data?.length > 0 && (
          <ul>
            {state.alerts.data.map((a) => (
              <li key={a.id}>{a.message}</li>
            ))}
          </ul>
        )}
      </section>
    </div>
  );
}
```

```jsx
// AdminDashboard.test.tsx
import { render, screen, within } from '@testing-library/react';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';
import { AdminDashboard } from './AdminDashboard';

/**
 * AdminDashboard â€” test parallel fetch vÃ  partial failure
 */
describe('AdminDashboard', () => {
  it('should show loading state for all sections initially', () => {
    // Handlers khÃ´ng resolve ngay
    server.use(
      http.get('/api/stats', () => new Promise(() => {})),
      http.get('/api/recent-activity', () => new Promise(() => {})),
      http.get('/api/alerts', () => new Promise(() => {})),
    );

    render(<AdminDashboard />);

    const statusElements = screen.getAllByRole('status');
    expect(statusElements).toHaveLength(3); // 3 sections loading
  });

  it('should display all data when all APIs succeed', async () => {
    render(<AdminDashboard />);

    // Stats section
    expect(await screen.findByText('1,247')).toBeInTheDocument(); // totalUsers
    expect(screen.getByText('8,432')).toBeInTheDocument(); // totalPosts

    // Activity section
    expect(screen.getByText(/Charlie/)).toBeInTheDocument();
    expect(screen.getByText(/signup/)).toBeInTheDocument();

    // Alerts section â€” no alerts
    expect(screen.getByText('No active alerts')).toBeInTheDocument();
  });

  it('should show alerts when they exist', async () => {
    server.use(
      http.get('/api/alerts', () => {
        return HttpResponse.json([
          { id: 'a1', message: 'High CPU usage detected' },
          { id: 'a2', message: 'Database backup failed' },
        ]);
      }),
    );

    render(<AdminDashboard />);

    expect(
      await screen.findByText('High CPU usage detected'),
    ).toBeInTheDocument();
    expect(screen.getByText('Database backup failed')).toBeInTheDocument();
  });

  it('should show error in stats section but NOT affect other sections', async () => {
    // CHá»ˆ stats fail â€” activity vÃ  alerts váº«n OK
    server.use(
      http.get('/api/stats', () => new HttpResponse(null, { status: 503 })),
    );

    render(<AdminDashboard />);

    // Stats section: error
    const statsSection = screen.getByRole('region', { name: 'Statistics' });
    expect(await within(statsSection).findByRole('alert')).toHaveTextContent(
      'Stats error: HTTP 503',
    );

    // Activity section: váº«n load thÃ nh cÃ´ng
    const activitySection = screen.getByRole('region', {
      name: 'Recent Activity',
    });
    expect(
      await within(activitySection).findByText(/Charlie/),
    ).toBeInTheDocument();

    // Alerts section: váº«n load thÃ nh cÃ´ng
    expect(await screen.findByText('No active alerts')).toBeInTheDocument();
  });

  it('should handle all sections failing', async () => {
    server.use(
      http.get('/api/stats', () => new HttpResponse(null, { status: 500 })),
      http.get(
        '/api/recent-activity',
        () => new HttpResponse(null, { status: 500 }),
      ),
      http.get('/api/alerts', () => new HttpResponse(null, { status: 500 })),
    );

    render(<AdminDashboard />);

    // Chá» táº¥t cáº£ loading biáº¿n máº¥t
    const alerts = await screen.findAllByRole('alert');
    expect(alerts).toHaveLength(3); // 3 error messages

    // KhÃ´ng cÃ²n loading
    expect(screen.queryAllByRole('status')).toHaveLength(0);
  });

  it('should be accessible: loading sections have role=status', () => {
    server.use(
      http.get('/api/stats', () => new Promise(() => {})),
      http.get('/api/recent-activity', () => new Promise(() => {})),
      http.get('/api/alerts', () => new Promise(() => {})),
    );

    render(<AdminDashboard />);

    // Screen readers announce loading state
    expect(screen.getAllByRole('status')).toHaveLength(3);
  });
});

// Result: 6 tests passed
// Partial failure scenario lÃ  test quan trá»ng nháº¥t â€” verify resilience
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Jest Mock vs MSW

| TiÃªu chÃ­                | `jest.fn()` mock fetch                | MSW                                       |
| ----------------------- | ------------------------------------- | ----------------------------------------- |
| **Setup**               | KhÃ´ng cáº§n install                     | `npm install msw`                         |
| **HTTP Client support** | Chá»‰ mock `fetch`                      | Má»i HTTP client                           |
| **Handler definition**  | Má»—i test tá»± define                    | Define má»™t láº§n, dÃ¹ng láº¡i                  |
| **URL matching**        | Pháº£i check `mockFetch.mock.calls`     | Built-in URL pattern matching             |
| **Realistic**           | Mock function JS, khÃ´ng giá»‘ng network | Intercept actual network request          |
| **Reuse trong dev**     | KhÃ´ng                                 | CÃ¹ng handlers dÃ¹ng cho browser dev        |
| **Complexity**          | ÄÆ¡n giáº£n vá»›i 1-2 endpoints            | Cáº§n setup, overkill cho test Ä‘Æ¡n láº»       |
| **Khi nÃ o dÃ¹ng**        | Quick test, khÃ´ng cÃ³ nhiá»u endpoints  | Project cÃ³ API layer, cáº§n realistic tests |

### Báº£ng: Chá»n Handler Strategy

| Scenario                     | Strategy                                                  |
| ---------------------------- | --------------------------------------------------------- |
| Happy path (háº§u háº¿t tests)   | Handlers máº·c Ä‘á»‹nh trong `handlers.ts`                     |
| Error/edge case trong 1 test | `server.use()` override trong test                        |
| Nhiá»u tests cÃ¹ng scenario    | Handler riÃªng trong `handlers.ts`                         |
| Stateful API                 | State in-memory + reset function                          |
| Delay/timeout simulation     | `await new Promise(r => setTimeout(r, ms))` trong handler |
| Network error                | `HttpResponse.error()`                                    |

### Decision Tree: Jest Mock hay MSW?

```
Project cá»§a báº¡n cÃ³:
â”‚
â”œâ”€â”€ 1-2 tests cáº§n mock API, component nhá», prototype?
â”‚   â””â”€â”€ jest.fn() mock â€” Ä‘Æ¡n giáº£n, Ä‘á»§ dÃ¹ng âœ…
â”‚
â”œâ”€â”€ Test suite lá»›n, nhiá»u components fetch data?
â”‚   â””â”€â”€ MSW âœ…
â”‚       â”‚
â”‚       â”œâ”€â”€ Handlers simple, khÃ´ng cÃ³ state?
â”‚       â”‚   â””â”€â”€ Define trong handlers.ts, dÃ¹ng máº·c Ä‘á»‹nh âœ…
â”‚       â”‚
â”‚       â””â”€â”€ Handlers cÃ³ state (POST/PATCH/DELETE)?
â”‚           â””â”€â”€ State in-memory + resetXxx() function âœ…
â”‚               Gá»i reset() trong beforeEach
â”‚
â””â”€â”€ Cáº§n test timing/retry logic?
    â””â”€â”€ server.use() vá»›i delay hoáº·c HttpResponse.error() âœ…
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Handler KhÃ´ng Báº¯t Request

```tsx
// âŒ Code bá»‹ lá»—i â€” handler khÃ´ng báº¯t Ä‘Æ°á»£c request
// handlers.ts
http.get('https://api.myapp.com/users', () => {
  return HttpResponse.json([{ id: 1, name: 'Alice' }]);
});

// component dÃ¹ng relative URL
fetch('/users'); // â† URL nÃ y khÃ´ng match handler!
```

```
Warning: [MSW] No handler found for "GET /users"
Test fails: data is null
```

**Táº¡i sao sai?** Handler dÃ¹ng absolute URL, component dÃ¹ng relative URL. MSW match chÃ­nh xÃ¡c.

```tsx
// âœ… Fix: Thá»‘ng nháº¥t URL format
// Option 1: Handler dÃ¹ng relative URL (khuyáº¿n nghá»‹ cho test)
http.get('/users', () => {
  return HttpResponse.json([{ id: 1, name: 'Alice' }]);
});

// Option 2: Náº¿u component dÃ¹ng absolute URL (vÃ­ dá»¥ config baseURL)
http.get('https://api.myapp.com/users', () => {
  return HttpResponse.json([{ id: 1, name: 'Alice' }]);
});
// VÃ  component cÅ©ng pháº£i dÃ¹ng Ä‘Ãºng URL Ä‘Ã³
```

---

### Bug 2: State Leak Giá»¯a CÃ¡c Tests

```tsx
// âŒ Code bá»‹ lá»—i â€” tests áº£nh hÆ°á»Ÿng nhau
let mockItems = [{ id: '1', name: 'Item A' }];

http.post('/api/items', async ({ request }) => {
  const body = await request.json();
  mockItems.push({ id: String(Date.now()), ...body });
  return HttpResponse.json(mockItems[mockItems.length - 1], { status: 201 });
});

// Test 1: Add item
it('test 1 - add item', async () => {
  // POST /api/items â†’ mockItems = [Item A, Item B]
});

// Test 2: Check initial list â€” FAIL vÃ¬ Item B váº«n cÃ²n!
it('test 2 - initial list has 1 item', async () => {
  render(<ItemList />);
  // GET /api/items â†’ tráº£ vá» mockItems = [Item A, Item B]
  // Test expect 1 item nhÆ°ng tháº¥y 2 â†’ FAIL
});
```

**Táº¡i sao sai?** `mockItems` lÃ  module-level variable, khÃ´ng reset giá»¯a tests.

```tsx
// âœ… Fix: Export reset function vÃ  gá»i trong beforeEach
const defaultItems = [{ id: '1', name: 'Item A' }];
let mockItems = [...defaultItems];

export function resetItems() {
  mockItems = [...defaultItems];
}

// Trong test file:
beforeEach(() => {
  resetItems();
});
```

---

### Bug 3: server.use() KhÃ´ng Reset Sau Test

```tsx
// âŒ Code bá»‹ lá»—i â€” override handlers "rÃ² rá»‰" sang test tiáº¿p theo
it('test 1 - error case', () => {
  server.use(
    http.get('/api/users', () => new HttpResponse(null, { status: 500 })),
  );
  render(<UserList />);
  // Kiá»ƒm tra error message
});

it('test 2 - success case', async () => {
  render(<UserList />);
  // Váº«n tháº¥y error vÃ¬ override tá»« test 1 chÆ°a Ä‘Æ°á»£c reset!
  await screen.findByText('Alice'); // FAIL
});
```

**Táº¡i sao sai?** `server.use()` thÃªm handler runtime, `resetHandlers()` trong `afterEach` á»Ÿ `setupTests.ts` pháº£i cÃ³ máº·t.

```tsx
// âœ… Fix option 1: Äáº£m báº£o setupTests.ts cÃ³ afterEach
afterEach(() => server.resetHandlers()); // â† Cáº§n cÃ³ dÃ²ng nÃ y

// âœ… Fix option 2: Reset thá»§ cÃ´ng náº¿u khÃ´ng muá»‘n dÃ¹ng global setupTests
it('test 1 - error case', () => {
  server.use(
    http.get('/api/users', () => new HttpResponse(null, { status: 500 })),
  );

  render(<UserList />);
  // test...

  server.resetHandlers(); // Reset sau test nÃ y náº¿u khÃ´ng cÃ³ afterEach toÃ n cá»¥c
});
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

- [ ] TÃ´i hiá»ƒu MSW intercept á»Ÿ network layer, khÃ´ng pháº£i JavaScript function level
- [ ] TÃ´i biáº¿t cáº¥u trÃºc file: `handlers.ts`, `server.ts`, `setupTests.ts`
- [ ] TÃ´i biáº¿t `server.use()` Ä‘á»ƒ override handler trong 1 test
- [ ] TÃ´i hiá»ƒu táº¡i sao cáº§n `server.resetHandlers()` trong `afterEach`
- [ ] TÃ´i biáº¿t `resetHandlers()` khÃ´ng reset handler's internal state
- [ ] TÃ´i biáº¿t `HttpResponse.error()` Ä‘á»ƒ simulate network error

### Code Review Checklist

- [ ] `setupTests.ts` cÃ³ Ä‘á»§ `beforeAll`, `afterEach`, `afterAll` lifecycle
- [ ] Handlers máº·c Ä‘á»‹nh cover happy path
- [ ] `server.use()` override dÃ¹ng cho error/edge cases, khÃ´ng cho happy path
- [ ] Stateful handlers cÃ³ export reset function
- [ ] Reset function Ä‘Æ°á»£c gá»i trong `beforeEach` cá»§a test file
- [ ] URL trong handler khá»›p vá»›i URL trong component (cáº£ relative/absolute)

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

Chuyá»ƒn Ä‘á»•i test suite tá»« NgÃ y 55 (`useFetch` test vá»›i `jest.fn()`) sang dÃ¹ng MSW. So sÃ¡nh sá»‘ dÃ²ng code vÃ  Ä‘á»™ readable. Báº¡n tháº¥y approach nÃ o dá»… maintain hÆ¡n sau khi Ä‘Ã£ cÃ³ experience vá»›i cáº£ hai?

### NÃ¢ng cao (60 phÃºt)

Táº¡o má»™t `createMockServer(handlers)` utility cho phÃ©p test file táº¡o má»™t "local" mock server â€” thay vÃ¬ dÃ¹ng shared global server. Pattern nÃ y há»¯u Ã­ch khi handlers cá»§a module khÃ¡c nhau conflict. Hint: `setupServer()` cÃ³ thá»ƒ gá»i nhiá»u láº§n.

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

- [MSW Getting Started](https://mswjs.io/docs/getting-started)
- [MSW â€” Mocking REST APIs](https://mswjs.io/docs/network-behavior/rest)

### Äá»c thÃªm

- [Kent C. Dodds â€” Stop Mocking Fetch](https://kentcdodds.com/blog/stop-mocking-fetch)
- [MSW â€” Recipes (stateful mocking)](https://mswjs.io/docs/recipes/stateful-mocking)

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n

- **NgÃ y 19-20:** Data fetching patterns â€” fetch, async/await, AbortController
- **NgÃ y 54:** RTL basics â€” render, screen, queries, userEvent
- **NgÃ y 55:** renderHook, wrapper, waitFor â€” test hooks vá»›i Context

### HÆ°á»›ng tá»›i

- **NgÃ y 57:** Integration & E2E Testing â€” káº¿t há»£p MSW vá»›i Playwright Ä‘á»ƒ test full user flows

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**CÃ¹ng handlers cho dev vÃ  test.** MSW cÃ³ thá»ƒ cháº¡y trong trÃ¬nh duyá»‡t (Service Worker) â€” Ä‘Ã¢y lÃ  killer feature. Team báº¡n cÃ³ thá»ƒ dÃ¹ng cÃ¹ng handlers Ä‘á»ƒ:

- Mock API trong development khi backend chÆ°a sáºµn sÃ ng
- Demo features mÃ  khÃ´ng cáº§n backend
- Onboard developer má»›i mÃ  khÃ´ng cáº§n setup backend

```tsx
// main.tsx â€” chá»‰ enable MSW trong development
if (process.env.NODE_ENV === 'development') {
  const { worker } = await import('./mocks/browser');
  await worker.start({ onUnhandledRequest: 'bypass' });
}
```

**`onUnhandledRequest: 'error'` cho strict testing.** Trong CI, dÃ¹ng `'error'` thay vÃ¬ `'warn'` Ä‘á»ƒ test fail rÃµ rÃ ng khi cÃ³ request khÃ´ng cÃ³ handler â€” giÃºp phÃ¡t hiá»‡n API calls bá»‹ miss.

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior:** MSW lÃ  gÃ¬ vÃ  táº¡i sao dÃ¹ng nÃ³ thay vÃ¬ mock `global.fetch`?

**Mid:** Giáº£i thÃ­ch sá»± khÃ¡c nhau giá»¯a `server.resetHandlers()` vÃ  reset state cá»§a handler. Táº¡i sao cáº§n cáº£ hai?

**Senior:** Báº¡n setup MSW nhÆ° tháº¿ nÃ o Ä‘á»ƒ handlers Ä‘Æ°á»£c dÃ¹ng cáº£ trong unit tests, integration tests, Playwright E2E tests, vÃ  development environment mÃ  khÃ´ng duplicate code?

### War Stories

Dá»± Ã¡n cÅ© cá»§a tÃ´i cÃ³ 300+ tests, táº¥t cáº£ Ä‘á»u dÃ¹ng `jest.mock('../api/client')` Ä‘á»ƒ mock HTTP client. Má»™t ngÃ y team quyáº¿t Ä‘á»‹nh Ä‘á»•i tá»« `axios` sang `ky`. Káº¿t quáº£: pháº£i update 80+ test files. Náº¿u dÃ¹ng MSW tá»« Ä‘áº§u, khÃ´ng má»™t test nÃ o cáº§n thay Ä‘á»•i â€” vÃ¬ MSW mock á»Ÿ network layer, khÃ´ng quan tÃ¢m báº¡n dÃ¹ng HTTP client nÃ o. Migration máº¥t 3 ngÃ y thay vÃ¬ 30 phÃºt.

---

## ğŸ”® Preview NgÃ y 57

**NgÃ y mai (vÃ  lÃ  bÃ i cuá»‘i cá»§a Phase Testing):** Integration & E2E Testing Preview. Báº¡n sáº½ há»c Ä‘iá»ƒm khÃ¡c nhau giá»¯a unit tests (NgÃ y 54-56), integration tests, vÃ  E2E tests. ChÃºng ta sáº½ xem Playwright lÃ m Ä‘Æ°á»£c gÃ¬ mÃ  RTL + MSW khÃ´ng lÃ m Ä‘Æ°á»£c â€” vÃ  khi nÃ o nÃªn Ä‘áº§u tÆ° vÃ o E2E tests. CÅ©ng sáº½ cÃ³ testing strategy matrix Ä‘á»ƒ báº¡n biáº¿t cÃ¡ch phÃ¢n bá»• effort há»£p lÃ½ cho tá»«ng loáº¡i test.
