# ğŸ“… NGÃ€Y 55: TESTING HOOKS & CONTEXT

> **TÃ³m táº¯t:** HÃ´m nay chÃºng ta Ä‘i sÃ¢u vÃ o kiá»ƒm thá»­ hai thá»© "khÃ³ nhÃ¬n tháº¥y" nháº¥t trong React â€” custom hooks vÃ  Context. Báº¡n sáº½ há»c cÃ¡ch dÃ¹ng `renderHook` Ä‘á»ƒ test logic hook Ä‘á»™c láº­p, wrap Provider Ä‘á»ƒ test consumer, vÃ  xá»­ lÃ½ async updates Ä‘Ãºng cÃ¡ch. ÄÃ¢y lÃ  ká»¹ nÄƒng phÃ¢n biá»‡t developer viáº¿t test Ä‘á»ƒ "cÃ³ coverage" vÃ  developer viáº¿t test Ä‘á»ƒ "cÃ³ confidence".

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] DÃ¹ng `renderHook` Ä‘á»ƒ test custom hook má»™t cÃ¡ch Ä‘á»™c láº­p, khÃ´ng cáº§n mount component
- [ ] Viáº¿t wrapper function Ä‘á»ƒ cung cáº¥p Context cho hooks vÃ  components trong test
- [ ] Xá»­ lÃ½ async state updates Ä‘Ãºng cÃ¡ch vá»›i `waitFor` vÃ  `act`

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

1. Náº¿u má»™t custom hook dÃ¹ng `useState` bÃªn trong, báº¡n cÃ³ thá»ƒ render nÃ³ trá»±c tiáº¿p nhÆ° má»™t component khÃ´ng? Táº¡i sao?
2. Khi `useContext` tráº£ vá» `undefined`, Ä‘iá»u gÃ¬ xáº£y ra vÃ  nguyÃªn nhÃ¢n thÆ°á»ng gáº·p nháº¥t lÃ  gÃ¬?
3. Vá»›i RTL (ngÃ y 54), báº¡n Ä‘Ã£ biáº¿t `screen.findBy*` khÃ¡c `screen.getBy*` nhÆ° tháº¿ nÃ o?

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

Giáº£ sá»­ báº¡n Ä‘Ã£ viáº¿t hook `useFetch` sau 2 tuáº§n refactor, vÃ  bÃ¢y giá» cáº§n Ä‘áº£m báº£o nÃ³:

- Tráº£ vá» `{ data: null, loading: true, error: null }` ngay lÃºc Ä‘áº§u
- Cáº­p nháº­t `data` khi fetch thÃ nh cÃ´ng
- Set `error` khi fetch tháº¥t báº¡i
- Reset state khi `url` thay Ä‘á»•i

Náº¿u test báº±ng cÃ¡ch mount má»™t component "giáº£" nhÆ° `<div>{hook.data}</div>`, báº¡n Ä‘ang test cáº£ component láº«n hook â€” náº¿u test fail, báº¡n khÃ´ng biáº¿t lá»—i á»Ÿ Ä‘Ã¢u.

**`renderHook` giáº£i quyáº¿t Ä‘Ãºng váº¥n Ä‘á» nÃ y**: test hook nhÆ° má»™t Ä‘Æ¡n vá»‹ Ä‘á»™c láº­p.

### 1.2 Giáº£i PhÃ¡p

React Testing Library cung cáº¥p hai cÃ´ng cá»¥ chÃ­nh:

| CÃ´ng cá»¥          | DÃ¹ng cho           | Import                             |
| ---------------- | ------------------ | ---------------------------------- |
| `renderHook`     | Test custom hooks  | `@testing-library/react`           |
| `act`            | Wrap state updates | `@testing-library/react`           |
| `waitFor`        | Chá» async updates  | `@testing-library/react`           |
| `wrapper` option | Cung cáº¥p Context   | option cá»§a `renderHook` / `render` |

### 1.3 Mental Model

```
renderHook(() => useMyHook(args))
      â”‚
      â–¼
  Táº¡o má»™t "invisible component" trong mÃ´i trÆ°á»ng test
      â”‚
      â”œâ”€â”€ result.current   â†’ giÃ¡ trá»‹ hook tráº£ vá» táº¡i thá»i Ä‘iá»ƒm hiá»‡n táº¡i
      â”œâ”€â”€ rerender(args)   â†’ gá»i láº¡i hook vá»›i args má»›i (nhÆ° khi props thay Ä‘á»•i)
      â””â”€â”€ unmount()        â†’ giáº£ láº­p component bá»‹ unmount (test cleanup)


Äá»ƒ test hook cáº§n Context:

renderHook(() => useMyHook(), {
  wrapper: ({ children }) => (
    <MyContext.Provider value={mockValue}>
      {children}
    </MyContext.Provider>
  )
})
```

**Analogy:** `renderHook` giá»‘ng nhÆ° báº¡n bá» hook vÃ o má»™t "há»™p kÃ­nh" â€” báº¡n cÃ³ thá»ƒ quan sÃ¡t má»i thá»© bÃªn trong mÃ  khÃ´ng cáº§n xÃ¢y cáº£ má»™t ngÃ´i nhÃ  (component) xung quanh nÃ³.

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

âŒ **"TÃ´i cáº§n act() cho má»i state update"**
â†’ RTL Ä‘Ã£ wrap nhiá»u thá»© tá»± Ä‘á»™ng. Chá»‰ cáº§n `act()` khi update xáº£y ra NGOÃ€I RTL event (vÃ­ dá»¥: callback tá»« setTimeout, Promise resolve thá»§ cÃ´ng).

âŒ **"waitFor chá»‰ dÃ¹ng cho fetch"**
â†’ `waitFor` dÃ¹ng cho báº¥t ká»³ assertion nÃ o cáº§n chá» DOM/state cáº­p nháº­t theo thá»i gian.

âŒ **"Pháº£i test implementation cá»§a hook"**
â†’ Test behavior (output), khÃ´ng test internal state. Báº¡n khÃ´ng care hook dÃ¹ng `useState` hay `useReducer` bÃªn trong.

âŒ **"result.current tá»± cáº­p nháº­t"**
â†’ `result.current` lÃ  má»™t snapshot táº¡i thá»i Ä‘iá»ƒm báº¡n Ä‘á»c nÃ³, nhÆ°ng báº£n thÃ¢n object `result` lÃ  reactive â€” báº¡n luÃ´n Ä‘á»c giÃ¡ trá»‹ má»›i nháº¥t qua `result.current`.

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: renderHook CÆ¡ Báº£n â­

```tsx
// hooks/useCounter.ts
interface UseCounterReturn {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
}

export function useCounter(initialValue = 0): UseCounterReturn {
  const [count, setCount] = useState(initialValue);

  const increment = useCallback(() => setCount((prev) => prev + 1), []);
  const decrement = useCallback(() => setCount((prev) => prev - 1), []);
  const reset = useCallback(() => setCount(initialValue), [initialValue]);

  return { count, increment, decrement, reset };
}
```

```tsx
// hooks/useCounter.test.ts
import { renderHook, act } from '@testing-library/react';
import { useCounter } from './useCounter';

describe('useCounter', () => {
  // Test 1: Initial value
  it('should start with default value 0', () => {
    const { result } = renderHook(() => useCounter());
    expect(result.current.count).toBe(0);
  });

  it('should start with provided initial value', () => {
    const { result } = renderHook(() => useCounter(10));
    expect(result.current.count).toBe(10);
  });

  // Test 2: Actions â€” wrap mutations trong act()
  it('should increment count', () => {
    const { result } = renderHook(() => useCounter());

    act(() => {
      result.current.increment();
    });

    expect(result.current.count).toBe(1);
  });

  it('should decrement count', () => {
    const { result } = renderHook(() => useCounter(5));

    act(() => {
      result.current.decrement();
    });

    expect(result.current.count).toBe(4);
  });

  // Test 3: Reset vá» initialValue ban Ä‘áº§u
  it('should reset to initial value', () => {
    const { result } = renderHook(() => useCounter(10));

    act(() => {
      result.current.increment();
      result.current.increment();
    });
    expect(result.current.count).toBe(12);

    act(() => {
      result.current.reset();
    });
    expect(result.current.count).toBe(10); // Trá»Ÿ vá» initialValue, khÃ´ng pháº£i 0
  });

  // Test 4: Rerender vá»›i args má»›i
  it('should update when initialValue prop changes', () => {
    const { result, rerender } = renderHook(({ init }) => useCounter(init), {
      initialProps: { init: 5 },
    });

    expect(result.current.count).toBe(5);

    // Giáº£ láº­p parent component truyá»n prop má»›i
    rerender({ init: 20 });

    // count khÃ´ng Ä‘á»•i ngay láº­p tá»©c vÃ¬ reset chÆ°a Ä‘Æ°á»£c gá»i
    // ÄÃ¢y lÃ  behavior Ä‘Ãºng cá»§a hook nÃ y
    expect(result.current.count).toBe(5);

    act(() => {
      result.current.reset();
    });

    // Sau khi reset, vá» initialValue má»›i
    expect(result.current.count).toBe(20);
  });
});
```

### Demo 2: Testing Hook vá»›i Async (useFetch) â­â­

```tsx
// hooks/useFetch.ts
interface FetchState<T> {
  data: T | null;
  loading: boolean;
  error: string | null;
}

export function useFetch<T>(url: string): FetchState<T> {
  const [state, setState] = useState<FetchState<T>>({
    data: null,
    loading: true,
    error: null,
  });

  useEffect(() => {
    let cancelled = false;

    setState({ data: null, loading: true, error: null });

    fetch(url)
      .then((res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
      .then((data) => {
        if (!cancelled) setState({ data, loading: false, error: null });
      })
      .catch((err) => {
        if (!cancelled)
          setState({ data: null, loading: false, error: err.message });
      });

    return () => {
      cancelled = true;
    };
  }, [url]);

  return state;
}
```

```tsx
// hooks/useFetch.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { useFetch } from './useFetch';

// Mock global fetch â€” KHÃ”NG dÃ¹ng MSW á»Ÿ ngÃ y nÃ y
const mockFetch = jest.fn();
global.fetch = mockFetch;

describe('useFetch', () => {
  beforeEach(() => {
    mockFetch.mockReset();
  });

  it('should return loading state initially', () => {
    // Fetch khÃ´ng resolve ngay â€” tráº£ vá» Promise chÆ°a settle
    mockFetch.mockReturnValue(new Promise(() => {}));

    const { result } = renderHook(() => useFetch('/api/users'));

    // Ngay láº­p tá»©c sau render
    expect(result.current.loading).toBe(true);
    expect(result.current.data).toBeNull();
    expect(result.current.error).toBeNull();
  });

  it('should return data on success', async () => {
    const mockData = [{ id: 1, name: 'Alice' }];

    mockFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockData),
    });

    const { result } = renderHook(() => useFetch('/api/users'));

    // Chá» async update
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toEqual(mockData);
    expect(result.current.error).toBeNull();
  });

  it('should return error on failure', async () => {
    mockFetch.mockResolvedValue({
      ok: false,
      status: 404,
    });

    const { result } = renderHook(() => useFetch('/api/users'));

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.data).toBeNull();
    expect(result.current.error).toBe('HTTP 404');
  });

  it('should reset state when url changes', async () => {
    const mockData1 = { id: 1 };
    const mockData2 = { id: 2 };

    mockFetch
      .mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockData1),
      })
      .mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockData2),
      });

    const { result, rerender } = renderHook(({ url }) => useFetch(url), {
      initialProps: { url: '/api/users/1' },
    });

    await waitFor(() => expect(result.current.loading).toBe(false));
    expect(result.current.data).toEqual(mockData1);

    // Thay Ä‘á»•i URL â€” hook pháº£i reset vá» loading
    rerender({ url: '/api/users/2' });

    // Ngay sau rerender: loading láº¡i
    expect(result.current.loading).toBe(true);

    await waitFor(() => expect(result.current.loading).toBe(false));
    expect(result.current.data).toEqual(mockData2);
  });
});
```

### Demo 3: Testing Context Consumer â­â­â­

```tsx
// context/AuthContext.tsx
interface User {
  id: string;
  name: string;
  role: 'admin' | 'user';
}

interface AuthContextValue {
  user: User | null;
  login: (user: User) => void;
  logout: () => void;
  isAdmin: boolean;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);

  const login = useCallback((user: User) => setUser(user), []);
  const logout = useCallback(() => setUser(null), []);
  const isAdmin = user?.role === 'admin';

  const value = useMemo(
    () => ({ user, login, logout, isAdmin }),
    [user, login, logout, isAdmin],
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth(): AuthContextValue {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth pháº£i Ä‘Æ°á»£c dÃ¹ng trong AuthProvider');
  }
  return context;
}
```

```tsx
// context/AuthContext.test.tsx
import { renderHook, act, render, screen } from '@testing-library/react';
import { AuthProvider, useAuth } from './AuthContext';

// ============================================================
// CÃCH 1: Táº¡o wrapper riÃªng â€” dÃ¹ng cho nhiá»u test
// ============================================================
const wrapper = ({ children }: { children: React.ReactNode }) => (
  <AuthProvider>{children}</AuthProvider>
);

describe('useAuth hook', () => {
  it('should throw error khi dÃ¹ng ngoÃ i Provider', () => {
    // Suppress console.error Ä‘á»ƒ test output sáº¡ch hÆ¡n
    const consoleSpy = jest
      .spyOn(console, 'error')
      .mockImplementation(() => {});

    expect(() => {
      renderHook(() => useAuth());
    }).toThrow('useAuth pháº£i Ä‘Æ°á»£c dÃ¹ng trong AuthProvider');

    consoleSpy.mockRestore();
  });

  it('should return null user initially', () => {
    const { result } = renderHook(() => useAuth(), { wrapper });

    expect(result.current.user).toBeNull();
    expect(result.current.isAdmin).toBe(false);
  });

  it('should login user', () => {
    const { result } = renderHook(() => useAuth(), { wrapper });
    const mockUser: User = { id: '1', name: 'Alice', role: 'user' };

    act(() => {
      result.current.login(mockUser);
    });

    expect(result.current.user).toEqual(mockUser);
    expect(result.current.isAdmin).toBe(false);
  });

  it('should detect admin role', () => {
    const { result } = renderHook(() => useAuth(), { wrapper });
    const adminUser: User = { id: '2', name: 'Bob', role: 'admin' };

    act(() => {
      result.current.login(adminUser);
    });

    expect(result.current.isAdmin).toBe(true);
  });

  it('should logout user', () => {
    const { result } = renderHook(() => useAuth(), { wrapper });

    act(() => {
      result.current.login({ id: '1', name: 'Alice', role: 'user' });
    });
    expect(result.current.user).not.toBeNull();

    act(() => {
      result.current.logout();
    });
    expect(result.current.user).toBeNull();
  });
});

// ============================================================
// CÃCH 2: Test component consume Context â€” dÃ¹ng render()
// ============================================================
function UserDisplay() {
  const { user, isAdmin } = useAuth();
  if (!user) return <p>Not logged in</p>;
  return (
    <div>
      <p>Hello, {user.name}</p>
      {isAdmin && <span data-testid='admin-badge'>Admin</span>}
    </div>
  );
}

describe('Component consuming AuthContext', () => {
  it('should show not logged in by default', () => {
    render(
      <AuthProvider>
        <UserDisplay />
      </AuthProvider>,
    );

    expect(screen.getByText('Not logged in')).toBeInTheDocument();
  });

  it('should show user name after login', () => {
    // ============================================================
    // CÃCH 3: Wrapper phá»©c táº¡p vá»›i custom initial state
    // ============================================================
    function TestWrapper({ children }: { children: React.ReactNode }) {
      return (
        <AuthProvider>
          {/* ThÃªm LoginButton Ä‘á»ƒ trigger login trong test */}
          {children}
        </AuthProvider>
      );
    }

    // Giáº£ láº­p component cÃ³ nÃºt login
    function TestApp() {
      const { login } = useAuth();
      return (
        <>
          <button
            onClick={() => login({ id: '1', name: 'Charlie', role: 'user' })}
          >
            Login
          </button>
          <UserDisplay />
        </>
      );
    }

    render(
      <AuthProvider>
        <TestApp />
      </AuthProvider>,
    );

    expect(screen.getByText('Not logged in')).toBeInTheDocument();

    userEvent.click(screen.getByRole('button', { name: 'Login' }));

    expect(screen.getByText('Hello, Charlie')).toBeInTheDocument();
    expect(screen.queryByTestId('admin-badge')).not.toBeInTheDocument();
  });
});
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ BÃ i 1: Test useToggle Hook (15 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: DÃ¹ng renderHook Ä‘á»ƒ test má»™t custom hook Ä‘Æ¡n giáº£n
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useEffect, useContext (chÆ°a cáº§n)
 *
 * Requirements:
 * 1. Test initial value (default false)
 * 2. Test toggle function
 * 3. Test set vá»›i custom initial value
 */

// Hook cáº§n test (Ä‘Ã£ cho sáºµn)
export function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  const toggle = useCallback(() => setValue((v) => !v), []);
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);
  return { value, toggle, setTrue, setFalse };
}

// âŒ CÃ¡ch SAI â€” test qua component, khÃ´ng cÃ´ láº­p Ä‘Æ°á»£c hook:
function BadToggleTest() {
  const { value, toggle } = useToggle();
  return <button onClick={toggle}>{value ? 'ON' : 'OFF'}</button>;
}

test('BAD: testing toggle through component', () => {
  render(<BadToggleTest />);
  // Test nÃ y thá»±c ra Ä‘ang test component + hook cÃ¹ng lÃºc
  // Náº¿u fail, khÃ´ng biáº¿t lá»—i á»Ÿ hook hay component render
  fireEvent.click(screen.getByRole('button'));
  expect(screen.getByText('ON')).toBeInTheDocument();
});

// âœ… CÃ¡ch ÄÃšNG â€” test hook trá»±c tiáº¿p:
test('GOOD: testing hook with renderHook', () => {
  const { result } = renderHook(() => useToggle());
  expect(result.current.value).toBe(false);

  act(() => result.current.toggle());
  expect(result.current.value).toBe(true);
});

// ğŸ¯ NHIá»†M Vá»¤:
// Viáº¿t Ä‘áº§y Ä‘á»§ test suite cho useToggle vá»›i renderHook:
describe('useToggle', () => {
  it('should initialize with false by default', () => {
    // TODO
  });

  it('should initialize with provided value', () => {
    // TODO: test useToggle(true)
  });

  it('should toggle value', () => {
    // TODO: toggle tá»« false â†’ true â†’ false
  });

  it('should set to true with setTrue', () => {
    // TODO
  });

  it('should set to false with setFalse', () => {
    // TODO
  });
});
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { renderHook, act } from '@testing-library/react';
import { useToggle } from './useToggle';

/**
 * Test suite cho useToggle hook
 * Kiá»ƒm tra toÃ n bá»™ API cá»§a hook: initial value, toggle, setTrue, setFalse
 */
describe('useToggle', () => {
  it('should initialize with false by default', () => {
    const { result } = renderHook(() => useToggle());
    expect(result.current.value).toBe(false);
  });

  it('should initialize with provided value', () => {
    const { result } = renderHook(() => useToggle(true));
    expect(result.current.value).toBe(true);
  });

  it('should toggle value from false to true', () => {
    const { result } = renderHook(() => useToggle());

    act(() => {
      result.current.toggle();
    });

    expect(result.current.value).toBe(true);
  });

  it('should toggle value back to false', () => {
    const { result } = renderHook(() => useToggle());

    act(() => {
      result.current.toggle();
    });
    act(() => {
      result.current.toggle();
    });

    expect(result.current.value).toBe(false);
  });

  it('should set to true with setTrue', () => {
    const { result } = renderHook(() => useToggle(false));

    act(() => {
      result.current.setTrue();
    });

    expect(result.current.value).toBe(true);
  });

  it('should set to false with setFalse', () => {
    const { result } = renderHook(() => useToggle(true));

    act(() => {
      result.current.setFalse();
    });

    expect(result.current.value).toBe(false);
  });

  it('setTrue should be idempotent', () => {
    const { result } = renderHook(() => useToggle(true));

    act(() => {
      result.current.setTrue(); // Already true, should stay true
    });

    expect(result.current.value).toBe(true);
  });
});

// Result máº«u khi cháº¡y: 7 tests passed
```

</details>

---

### â­â­ BÃ i 2: Test Hook Phá»¥ Thuá»™c Context (25 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Test hook cáº§n Context vá»›i wrapper pattern
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: useCart hook dÃ¹ng CartContext Ä‘á»ƒ Ä‘á»c/cáº­p nháº­t giá» hÃ ng.
 *
 * Approach A: Táº¡o wrapper má»›i trong tá»«ng test
 * Pros: Flexible, khÃ´ng phá»¥ thuá»™c láº«n nhau
 * Cons: Verbose, láº·p code
 *
 * Approach B: Táº¡o má»™t helper createWrapper() dÃ¹ng chung
 * Pros: DRY, dá»… maintain
 * Cons: Cáº§n nhá»› reset state giá»¯a cÃ¡c test
 *
 * ğŸ’­ Báº N CHá»ŒN GÃŒ? HÃ£y implement Approach B vÃ  giáº£i thÃ­ch lÃ½ do.
 */

// Context vÃ  Hook Ä‘Ã£ cho sáºµn:
interface CartItem {
  id: string;
  name: string;
  quantity: number;
  price: number;
}
interface CartContextValue {
  items: CartItem[];
  addItem: (item: Omit<CartItem, 'quantity'>) => void;
  removeItem: (id: string) => void;
  total: number;
}

const CartContext = createContext<CartContextValue | undefined>(undefined);

export function CartProvider({ children }: { children: React.ReactNode }) {
  const [items, setItems] = useState<CartItem[]>([]);

  const addItem = useCallback((item: Omit<CartItem, 'quantity'>) => {
    setItems((prev) => {
      const existing = prev.find((i) => i.id === item.id);
      if (existing) {
        return prev.map((i) =>
          i.id === item.id ? { ...i, quantity: i.quantity + 1 } : i,
        );
      }
      return [...prev, { ...item, quantity: 1 }];
    });
  }, []);

  const removeItem = useCallback((id: string) => {
    setItems((prev) => prev.filter((i) => i.id !== id));
  }, []);

  const total = items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0,
  );

  return (
    <CartContext.Provider value={{ items, addItem, removeItem, total }}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart(): CartContextValue {
  const ctx = useContext(CartContext);
  if (!ctx) throw new Error('useCart must be used within CartProvider');
  return ctx;
}

// ğŸ¯ NHIá»†M Vá»¤: Viáº¿t test suite cho useCart
describe('useCart', () => {
  // TODO: Táº¡o wrapper helper
  // TODO: Test initial empty state
  // TODO: Test addItem
  // TODO: Test addItem vá»›i existing item (tÄƒng quantity)
  // TODO: Test removeItem
  // TODO: Test total calculation
  // TODO: Test throw error khi dÃ¹ng ngoÃ i Provider
});
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { renderHook, act } from '@testing-library/react';
import { CartProvider, useCart } from './CartContext';

/**
 * Helper táº¡o wrapper cho CartContext.
 * TÃ¡i sá»­ dá»¥ng trong toÃ n bá»™ test file.
 * VÃ¬ CartProvider khá»Ÿi táº¡o vá»›i state rá»—ng má»—i láº§n,
 * khÃ´ng cáº§n lo viá»‡c state bá»‹ shared giá»¯a cÃ¡c test.
 */
const wrapper = ({ children }) => <CartProvider>{children}</CartProvider>;

describe('useCart', () => {
  it('should throw when used outside CartProvider', () => {
    const consoleSpy = jest
      .spyOn(console, 'error')
      .mockImplementation(() => {});
    expect(() => {
      renderHook(() => useCart());
    }).toThrow('useCart must be used within CartProvider');
    consoleSpy.mockRestore();
  });

  it('should start with empty cart', () => {
    const { result } = renderHook(() => useCart(), { wrapper });

    expect(result.current.items).toHaveLength(0);
    expect(result.current.total).toBe(0);
  });

  it('should add a new item', () => {
    const { result } = renderHook(() => useCart(), { wrapper });

    act(() => {
      result.current.addItem({ id: 'p1', name: 'Phone', price: 999 });
    });

    expect(result.current.items).toHaveLength(1);
    expect(result.current.items[0]).toEqual({
      id: 'p1',
      name: 'Phone',
      price: 999,
      quantity: 1,
    });
  });

  it('should increase quantity when adding existing item', () => {
    const { result } = renderHook(() => useCart(), { wrapper });

    act(() => {
      result.current.addItem({ id: 'p1', name: 'Phone', price: 999 });
      result.current.addItem({ id: 'p1', name: 'Phone', price: 999 });
    });

    // Váº«n chá»‰ 1 unique item, nhÆ°ng quantity = 2
    expect(result.current.items).toHaveLength(1);
    expect(result.current.items[0].quantity).toBe(2);
  });

  it('should remove an item', () => {
    const { result } = renderHook(() => useCart(), { wrapper });

    act(() => {
      result.current.addItem({ id: 'p1', name: 'Phone', price: 999 });
      result.current.addItem({ id: 'p2', name: 'Case', price: 29 });
    });

    act(() => {
      result.current.removeItem('p1');
    });

    expect(result.current.items).toHaveLength(1);
    expect(result.current.items[0].id).toBe('p2');
  });

  it('should calculate total correctly', () => {
    const { result } = renderHook(() => useCart(), { wrapper });

    act(() => {
      result.current.addItem({ id: 'p1', name: 'Phone', price: 999 });
      result.current.addItem({ id: 'p2', name: 'Case', price: 29 });
      result.current.addItem({ id: 'p1', name: 'Phone', price: 999 }); // quantity 2
    });

    // 999 * 2 + 29 * 1 = 2027
    expect(result.current.total).toBe(2027);
  });
});

// Result: 6 tests passed
```

</details>

---

### â­â­â­ BÃ i 3: Test Async Hook vá»›i waitFor (40 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Test async state lifecycle Ä‘áº§y Ä‘á»§
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ User Story:
 * "LÃ  developer, tÃ´i muá»‘n cÃ³ hook useUserProfile(userId) Ä‘á»ƒ
 * fetch thÃ´ng tin user, Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ hiá»ƒn thá»‹ profile page."
 *
 * âœ… Acceptance Criteria:
 * - [ ] Initial state: { user: null, loading: true, error: null }
 * - [ ] Success state: { user: UserData, loading: false, error: null }
 * - [ ] Error state: { user: null, loading: false, error: string }
 * - [ ] Khi userId thay Ä‘á»•i: reset vá» loading vÃ  fetch láº¡i
 * - [ ] Cleanup: khÃ´ng update state sau khi unmount
 *
 * ğŸš¨ Edge Cases:
 * - userId lÃ  null/undefined â†’ khÃ´ng fetch
 * - userId thay Ä‘á»•i nhanh â†’ chá»‰ láº¥y káº¿t quáº£ cá»§a request cuá»‘i
 * - Component unmount trong khi Ä‘ang fetch â†’ khÃ´ng setState
 */

interface UserProfile {
  id: string;
  name: string;
  email: string;
  avatar: string;
}

// Hook cáº§n implement VÃ€ test:
export function useUserProfile(userId: string | null) {
  // TODO: Implement hook vá»›i Ä‘áº§y Ä‘á»§ states
}

// Mock fetch:
const mockFetch = jest.fn();
global.fetch = mockFetch;

// ğŸ¯ NHIá»†M Vá»¤: Viáº¿t Ä‘áº§y Ä‘á»§ test theo Acceptance Criteria
describe('useUserProfile', () => {
  beforeEach(() => {
    mockFetch.mockReset();
  });

  // TODO: Implement táº¥t cáº£ test cases
});
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { renderHook, waitFor } from '@testing-library/react';

/**
 * useUserProfile - Fetch user profile by ID
 * Handles: loading state, success, error, cleanup, null userId
 */
export function useUserProfile(userId) {
  const [state, setState] = useState({
    user: null,
    loading: userId !== null, // Náº¿u khÃ´ng cÃ³ userId, khÃ´ng loading
    error: null,
  });

  useEffect(() => {
    if (!userId) {
      setState({ user: null, loading: false, error: null });
      return;
    }

    let cancelled = false;

    setState({ user: null, loading: true, error: null });

    fetch(`/api/users/${userId}`)
      .then((res) => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      })
      .then((user) => {
        if (!cancelled) setState({ user, loading: false, error: null });
      })
      .catch((err) => {
        if (!cancelled)
          setState({ user: null, loading: false, error: err.message });
      });

    return () => {
      cancelled = true;
    };
  }, [userId]);

  return state;
}

// =========================================================
// TESTS
// =========================================================
const mockFetch = jest.fn();
global.fetch = mockFetch;

const mockUser = {
  id: '1',
  name: 'Alice',
  email: 'alice@example.com',
  avatar: 'https://example.com/alice.png',
};

describe('useUserProfile', () => {
  beforeEach(() => {
    mockFetch.mockReset();
  });

  it('should start with loading state when userId is provided', () => {
    mockFetch.mockReturnValue(new Promise(() => {})); // Never resolves

    const { result } = renderHook(() => useUserProfile('1'));

    expect(result.current).toEqual({
      user: null,
      loading: true,
      error: null,
    });
  });

  it('should not fetch when userId is null', () => {
    const { result } = renderHook(() => useUserProfile(null));

    expect(mockFetch).not.toHaveBeenCalled();
    expect(result.current.loading).toBe(false);
  });

  it('should return user data on success', async () => {
    mockFetch.mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(mockUser),
    });

    const { result } = renderHook(() => useUserProfile('1'));

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.user).toEqual(mockUser);
    expect(result.current.error).toBeNull();
    expect(mockFetch).toHaveBeenCalledWith('/api/users/1');
  });

  it('should return error on HTTP failure', async () => {
    mockFetch.mockResolvedValue({ ok: false, status: 404 });

    const { result } = renderHook(() => useUserProfile('1'));

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.user).toBeNull();
    expect(result.current.error).toBe('HTTP 404');
  });

  it('should reset and refetch when userId changes', async () => {
    const user1 = { ...mockUser, id: '1', name: 'Alice' };
    const user2 = { ...mockUser, id: '2', name: 'Bob' };

    mockFetch
      .mockResolvedValueOnce({ ok: true, json: () => Promise.resolve(user1) })
      .mockResolvedValueOnce({ ok: true, json: () => Promise.resolve(user2) });

    const { result, rerender } = renderHook(({ id }) => useUserProfile(id), {
      initialProps: { id: '1' },
    });

    await waitFor(() => expect(result.current.loading).toBe(false));
    expect(result.current.user.name).toBe('Alice');

    // Thay Ä‘á»•i userId
    rerender({ id: '2' });

    // Pháº£i reset vá» loading
    expect(result.current.loading).toBe(true);

    await waitFor(() => expect(result.current.loading).toBe(false));
    expect(result.current.user.name).toBe('Bob');
    expect(mockFetch).toHaveBeenCalledTimes(2);
  });

  it('should not update state after unmount', async () => {
    let resolvePromise;
    mockFetch.mockReturnValue(
      new Promise((resolve) => {
        resolvePromise = resolve;
      }),
    );

    const { result, unmount } = renderHook(() => useUserProfile('1'));

    // Unmount TRÆ¯á»šC khi fetch resolve
    unmount();

    // Resolve fetch sau khi Ä‘Ã£ unmount
    resolvePromise({ ok: true, json: () => Promise.resolve(mockUser) });

    // KhÃ´ng cÃ³ lá»—i "Can't perform a React state update on an unmounted component"
    // result.current váº«n lÃ  loading state vÃ¬ khÃ´ng cÃ³ update nÃ o xáº£y ra
    expect(result.current.loading).toBe(true);
  });
});

// Result: 6 tests passed, 0 "state update on unmounted component" warnings
```

</details>

---

### â­â­â­â­ BÃ i 4: Test Multi-Context App (60 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Test component phá»¥ thuá»™c nhiá»u Context
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Design (20 phÃºt)
 * Báº¡n cÃ³ component <CheckoutButton /> dÃ¹ng:
 * - useCart() Ä‘á»ƒ láº¥y items vÃ  total
 * - useAuth() Ä‘á»ƒ kiá»ƒm tra user Ä‘Ã£ login chÆ°a
 * - Náº¿u chÆ°a login: show "Login to checkout"
 * - Náº¿u cart rá»—ng: show "Cart is empty", disabled
 * - Náº¿u cÃ³ items vÃ  Ä‘Ã£ login: show "Checkout ($X.XX)"
 *
 * ğŸ¤” CÃ¢u há»i Architecture:
 * Approach A: Táº¡o má»™t AllProviders wrapper dÃ¹ng chung
 * Approach B: Táº¡o tá»«ng wrapper riÃªng vÃ  compose khi cáº§n
 * Approach C: Táº¡o helper createWrapper(options) linh hoáº¡t
 *
 * Chá»n Approach nÃ o? Viáº¿t ADR ngáº¯n (5 dÃ²ng) rá»“i implement.
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 * Implement Ä‘á»§ tests cho CheckoutButton.
 *
 * ğŸ§ª PHASE 3: Edge Cases (10 phÃºt)
 * - [ ] Test khi cáº£ hai context cÃ¹ng thay Ä‘á»•i
 * - [ ] Test button cÃ³ aria-disabled khi cart rá»—ng
 */

// Component cáº§n test:
function CheckoutButton() {
  const { items, total } = useCart();
  const { user } = useAuth();

  if (!user) {
    return <button disabled>Login to checkout</button>;
  }

  if (items.length === 0) {
    return (
      <button
        disabled
        aria-disabled='true'
      >
        Cart is empty
      </button>
    );
  }

  const formattedTotal = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(total);

  return (
    <button onClick={() => console.log('checkout')}>
      Checkout ({formattedTotal})
    </button>
  );
}
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CheckoutButton } from './CheckoutButton';
import { CartProvider } from './CartContext';
import { AuthProvider } from './AuthContext';

/**
 * ADR: Chá»n Approach C â€” createWrapper(options)
 * Context: Tests cáº§n nhiá»u tá»• há»£p state khÃ¡c nhau (login/not, empty/full cart)
 * Decision: Helper function nháº­n initial state
 * Rationale: Flexible hÆ¡n AllProviders, Ã­t repetition hÆ¡n compose tá»«ng test
 * Consequences: Cáº§n maintain helper khi thÃªm Context má»›i
 */

/**
 * Helper táº¡o wrapper vá»›i initial state tÃ¹y chá»‰nh.
 * Tráº£ vá» wrapper component Ä‘á»ƒ dÃ¹ng vá»›i render().
 */
function createWrapper({ user = null, cartItems = [] } = {}) {
  return function Wrapper({ children }) {
    return (
      <AuthProvider initialUser={user}>
        <CartProvider initialItems={cartItems}>{children}</CartProvider>
      </AuthProvider>
    );
  };
}

// NOTE: Äá»ƒ test nÃ y hoáº¡t Ä‘á»™ng, AuthProvider vÃ  CartProvider
// cáº§n accept initialUser/initialItems props.
// Trong thá»±c táº¿, cÃ³ thá»ƒ mock Context value trá»±c tiáº¿p (xem bÃªn dÆ°á»›i).

// ============================================================
// Alternative: Mock Context value trá»±c tiáº¿p (khÃ´ng cáº§n modify Provider)
// ============================================================
function renderWithContexts({ user = null, cartItems = [], total = 0 } = {}) {
  // Táº¡o mock values
  const authValue = {
    user,
    login: jest.fn(),
    logout: jest.fn(),
    isAdmin: user?.role === 'admin',
  };

  const cartValue = {
    items: cartItems,
    addItem: jest.fn(),
    removeItem: jest.fn(),
    total,
  };

  return render(
    <AuthContext.Provider value={authValue}>
      <CartContext.Provider value={cartValue}>
        <CheckoutButton />
      </CartContext.Provider>
    </AuthContext.Provider>,
  );
}

describe('CheckoutButton', () => {
  it('should show login button when user is not logged in', () => {
    renderWithContexts({ user: null });

    const button = screen.getByRole('button', { name: 'Login to checkout' });
    expect(button).toBeDisabled();
  });

  it('should show empty cart message when logged in but cart is empty', () => {
    renderWithContexts({
      user: { id: '1', name: 'Alice', role: 'user' },
      cartItems: [],
    });

    const button = screen.getByRole('button', { name: 'Cart is empty' });
    expect(button).toBeDisabled();
    expect(button).toHaveAttribute('aria-disabled', 'true');
  });

  it('should show checkout button with total when logged in and has items', () => {
    renderWithContexts({
      user: { id: '1', name: 'Alice', role: 'user' },
      cartItems: [{ id: 'p1', name: 'Phone', price: 999, quantity: 1 }],
      total: 999,
    });

    const button = screen.getByRole('button', { name: 'Checkout ($999.00)' });
    expect(button).not.toBeDisabled();
  });

  it('should format total as currency', () => {
    renderWithContexts({
      user: { id: '1', name: 'Alice', role: 'user' },
      cartItems: [{ id: 'p1', name: 'Item', price: 10.5, quantity: 2 }],
      total: 21,
    });

    expect(screen.getByText(/\$21\.00/)).toBeInTheDocument();
  });

  it('should be accessible: disabled button has aria-disabled', () => {
    renderWithContexts({
      user: { id: '1', name: 'Alice', role: 'user' },
      cartItems: [],
    });

    // Keyboard users cáº§n biáº¿t button disabled vÃ¬ cart rá»—ng
    expect(screen.getByRole('button')).toHaveAttribute('aria-disabled', 'true');
  });
});

// Result: 5 tests passed
```

</details>

---

### â­â­â­â­â­ BÃ i 5: Production Challenge â€” Test useFormField Hook (90 phÃºt)

```tsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build vÃ  test má»™t reusable form field hook production-ready
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * Hook useFormField(config) quáº£n lÃ½ state cá»§a má»™t form field vá»›i:
 * - value: giÃ¡ trá»‹ hiá»‡n táº¡i
 * - error: lá»—i validation (null náº¿u valid)
 * - touched: user Ä‘Ã£ interact chÆ°a (blur/change)
 * - validate(): cháº¡y validation vÃ  tráº£ vá» isValid
 * - props: object spread Ä‘Æ°á»£c vÃ o <input> (onChange, onBlur, value)
 *
 * ğŸ—ï¸ Technical Design:
 * 1. State: value, error, touched (useState)
 * 2. Validation: sync function tá»« config, cháº¡y khi touched=true
 * 3. props object: memoized vá»›i useMemo
 * 4. validate(): expose Ä‘á»ƒ parent form cÃ³ thá»ƒ trigger
 *
 * âœ… Production Checklist:
 * - [ ] TypeScript types Ä‘áº§y Ä‘á»§
 * - [ ] Validation chá»‰ hiá»‡n error sau khi user Ä‘Ã£ touch field
 * - [ ] validate() return boolean Ä‘á»ƒ form cÃ³ thá»ƒ check
 * - [ ] props.onChange nháº­n cáº£ SyntheticEvent láº«n raw value
 * - [ ] a11y: aria-invalid khi cÃ³ error
 * - [ ] Test coverage > 90%
 */

interface FormFieldConfig<T = string> {
  initialValue?: T;
  validate?: (value: T) => string | null; // null = valid
}

interface FormFieldReturn<T = string> {
  value: T;
  error: string | null;
  touched: boolean;
  validate: () => boolean;
  props: {
    value: T;
    onChange: (e: React.ChangeEvent<HTMLInputElement> | T) => void;
    onBlur: () => void;
    'aria-invalid': boolean;
    'aria-describedby'?: string;
  };
}

// ğŸ¯ NHIá»†M Vá»¤:
// 1. Implement useFormField hook
// 2. Viáº¿t test suite Ä‘áº§y Ä‘á»§
// 3. Test cáº£ hook (vá»›i renderHook) vÃ  component (vá»›i render)
// 4. Äáº£m báº£o edge cases Ä‘Æ°á»£c cover
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
import { renderHook, act, render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

// ============================================================
// IMPLEMENTATION
// ============================================================

/**
 * useFormField - Manages state and validation for a single form field
 * @param config.initialValue - Default field value
 * @param config.validate - Validation function, returns error message or null
 */
export function useFormField({ initialValue = '', validate } = {}) {
  const [value, setValue] = useState(initialValue);
  const [error, setError] = useState(null);
  const [touched, setTouched] = useState(false);

  const runValidation = useCallback(
    (currentValue) => {
      if (!validate) return null;
      return validate(currentValue);
    },
    [validate],
  );

  const handleChange = useCallback(
    (eventOrValue) => {
      const newValue =
        eventOrValue?.target !== undefined
          ? eventOrValue.target.value
          : eventOrValue;

      setValue(newValue);

      // Chá»‰ validate real-time náº¿u Ä‘Ã£ touched
      if (touched) {
        setError(runValidation(newValue));
      }
    },
    [touched, runValidation],
  );

  const handleBlur = useCallback(() => {
    setTouched(true);
    setError(runValidation(value));
  }, [value, runValidation]);

  const validate = useCallback(() => {
    setTouched(true);
    const validationError = runValidation(value);
    setError(validationError);
    return validationError === null;
  }, [value, runValidation]);

  const props = useMemo(
    () => ({
      value,
      onChange: handleChange,
      onBlur: handleBlur,
      'aria-invalid': error !== null && touched,
      ...(error && touched ? { 'aria-describedby': 'field-error' } : {}),
    }),
    [value, handleChange, handleBlur, error, touched],
  );

  return { value, error, touched, validate, props };
}

// ============================================================
// TESTS
// ============================================================
const emailValidator = (value) => {
  if (!value) return 'Email is required';
  if (!value.includes('@')) return 'Invalid email format';
  return null;
};

describe('useFormField', () => {
  describe('initial state', () => {
    it('should initialize with empty string by default', () => {
      const { result } = renderHook(() => useFormField());
      expect(result.current.value).toBe('');
      expect(result.current.error).toBeNull();
      expect(result.current.touched).toBe(false);
    });

    it('should initialize with provided value', () => {
      const { result } = renderHook(() =>
        useFormField({ initialValue: 'hello' }),
      );
      expect(result.current.value).toBe('hello');
    });
  });

  describe('onChange behavior', () => {
    it('should update value on change', () => {
      const { result } = renderHook(() => useFormField());

      act(() => {
        result.current.props.onChange({ target: { value: 'new value' } });
      });

      expect(result.current.value).toBe('new value');
    });

    it('should accept raw value (not just event)', () => {
      const { result } = renderHook(() => useFormField());

      act(() => {
        result.current.props.onChange('direct value');
      });

      expect(result.current.value).toBe('direct value');
    });

    it('should NOT show error before blur (not touched)', () => {
      const { result } = renderHook(() =>
        useFormField({ validate: emailValidator }),
      );

      act(() => {
        result.current.props.onChange({ target: { value: 'invalid' } });
      });

      // ChÆ°a blur â†’ chÆ°a touched â†’ khÃ´ng show error
      expect(result.current.error).toBeNull();
      expect(result.current.touched).toBe(false);
    });

    it('should validate real-time AFTER touched', () => {
      const { result } = renderHook(() =>
        useFormField({ validate: emailValidator }),
      );

      // Blur trÆ°á»›c Ä‘á»ƒ set touched
      act(() => {
        result.current.props.onBlur();
      });

      // Sau khi touched, onChange pháº£i validate
      act(() => {
        result.current.props.onChange({ target: { value: 'notanemail' } });
      });

      expect(result.current.error).toBe('Invalid email format');
    });
  });

  describe('onBlur behavior', () => {
    it('should set touched on blur', () => {
      const { result } = renderHook(() => useFormField());

      act(() => {
        result.current.props.onBlur();
      });

      expect(result.current.touched).toBe(true);
    });

    it('should validate and show error on blur', () => {
      const { result } = renderHook(() =>
        useFormField({ initialValue: '', validate: emailValidator }),
      );

      act(() => {
        result.current.props.onBlur();
      });

      expect(result.current.error).toBe('Email is required');
    });
  });

  describe('validate() method', () => {
    it('should return true when valid', () => {
      const { result } = renderHook(() =>
        useFormField({
          initialValue: 'test@example.com',
          validate: emailValidator,
        }),
      );

      let isValid;
      act(() => {
        isValid = result.current.validate();
      });

      expect(isValid).toBe(true);
      expect(result.current.error).toBeNull();
    });

    it('should return false and set error when invalid', () => {
      const { result } = renderHook(() =>
        useFormField({ initialValue: 'notanemail', validate: emailValidator }),
      );

      let isValid;
      act(() => {
        isValid = result.current.validate();
      });

      expect(isValid).toBe(false);
      expect(result.current.error).toBe('Invalid email format');
    });

    it('should set touched when validate() is called', () => {
      const { result } = renderHook(() => useFormField());

      act(() => {
        result.current.validate();
      });

      expect(result.current.touched).toBe(true);
    });
  });

  describe('accessibility props', () => {
    it('should have aria-invalid=false when no error or not touched', () => {
      const { result } = renderHook(() =>
        useFormField({ validate: emailValidator }),
      );

      expect(result.current.props['aria-invalid']).toBe(false);
    });

    it('should have aria-invalid=true when touched and has error', () => {
      const { result } = renderHook(() =>
        useFormField({ initialValue: 'bad', validate: emailValidator }),
      );

      act(() => {
        result.current.props.onBlur();
      });

      expect(result.current.props['aria-invalid']).toBe(true);
    });
  });

  describe('integration: component using hook', () => {
    function EmailInput() {
      const field = useFormField({ validate: emailValidator });
      return (
        <div>
          <label htmlFor='email'>Email</label>
          <input
            id='email'
            {...field.props}
          />
          {field.error && field.touched && (
            <p
              id='field-error'
              role='alert'
            >
              {field.error}
            </p>
          )}
        </div>
      );
    }

    it('should show error message after blur with invalid input', async () => {
      const user = userEvent.setup();
      render(<EmailInput />);

      const input = screen.getByLabelText('Email');
      await user.type(input, 'notanemail');
      await user.tab(); // trigger blur

      expect(screen.getByRole('alert')).toHaveTextContent(
        'Invalid email format',
      );
      expect(input).toHaveAttribute('aria-invalid', 'true');
    });

    it('should clear error when valid email is typed', async () => {
      const user = userEvent.setup();
      render(<EmailInput />);

      const input = screen.getByLabelText('Email');
      await user.type(input, 'bad');
      await user.tab(); // touch it, show error

      expect(screen.getByRole('alert')).toBeInTheDocument();

      await user.clear(input);
      await user.type(input, 'valid@example.com'); // now valid

      expect(screen.queryByRole('alert')).not.toBeInTheDocument();
    });
  });
});

// Result: 14 tests passed, coverage ~95%
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: CÃ¡ch Test Hook cÃ³ Context

| Approach                          | Æ¯u Ä‘iá»ƒm                        | NhÆ°á»£c Ä‘iá»ƒm                            | DÃ¹ng khi                                           |
| --------------------------------- | ------------------------------ | ------------------------------------- | -------------------------------------------------- |
| **Real Provider**                 | Test integration tháº­t, Ã­t mock | State khÃ´ng controllable tá»« bÃªn ngoÃ i | Provider Ä‘Æ¡n giáº£n, khÃ´ng cÃ³ initial state phá»©c táº¡p |
| **Mock Context value trá»±c tiáº¿p**  | Full control, setup nhanh      | KhÃ´ng test Provider logic             | Test consumer component, khÃ´ng cáº§n test Provider   |
| **createWrapper(options) helper** | Flexible, DRY                  | Cáº§n maintain helper                   | Nhiá»u test cáº§n tá»• há»£p state khÃ¡c nhau              |
| **Custom renderWithXxx helper**   | Explicit, self-documenting     | Verbose náº¿u cÃ³ nhiá»u biáº¿n             | Team lá»›n, cáº§n clarity hÆ¡n brevity                  |

### Decision Tree: Khi NÃ o DÃ¹ng GÃ¬?

```
Báº¡n cáº§n test gÃ¬?
â”‚
â”œâ”€â”€ Chá»‰ test LOGIC cá»§a hook (khÃ´ng cáº§n DOM)?
â”‚   â””â”€â”€ renderHook() âœ…
â”‚
â”œâ”€â”€ Test hook cáº§n Context?
â”‚   â”œâ”€â”€ Context phá»©c táº¡p (nhiá»u initial state)?
â”‚   â”‚   â””â”€â”€ createWrapper(options) helper âœ…
â”‚   â””â”€â”€ Context Ä‘Æ¡n giáº£n?
â”‚       â””â”€â”€ wrapper: ({ children }) => <Provider>{children}</Provider> âœ…
â”‚
â”œâ”€â”€ Test component consume Context?
â”‚   â”œâ”€â”€ Cáº§n kiá»ƒm soÃ¡t Context state trong test?
â”‚   â”‚   â””â”€â”€ Mock Context.Provider value trá»±c tiáº¿p âœ…
â”‚   â””â”€â”€ Muá»‘n test full integration?
â”‚       â””â”€â”€ Render vá»›i real Providers âœ…
â”‚
â””â”€â”€ Test async state updates?
    â”œâ”€â”€ Chá» DOM thay Ä‘á»•i?
    â”‚   â””â”€â”€ await screen.findBy*() âœ…
    â””â”€â”€ Chá» state thay Ä‘á»•i trong hook?
        â””â”€â”€ await waitFor(() => expect(...)) âœ…
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: act() Warning

```tsx
// âŒ Code bá»‹ lá»—i â€” console cÃ³ warning "act(...) not wrapped"
it('should fetch user', async () => {
  mockFetch.mockResolvedValue({
    ok: true,
    json: () => Promise.resolve({ id: 1 }),
  });

  const { result } = renderHook(() => useFetch('/api/user'));

  // â›” KhÃ´ng cÃ³ waitFor â€” assertion cháº¡y trÆ°á»›c khi state update
  expect(result.current.data).not.toBeNull();
});
```

```
Error: Warning: An update to useFetch inside a test was not wrapped in act(...)
Expected: not.toBeNull()
Received: null
```

**Táº¡i sao sai?** Promise resolve báº¥t Ä‘á»“ng bá»™, nhÆ°ng assertion cháº¡y ngay láº­p tá»©c. State chÆ°a update.

```tsx
// âœ… Fix: DÃ¹ng waitFor Ä‘á»ƒ chá»
it('should fetch user', async () => {
  mockFetch.mockResolvedValue({
    ok: true,
    json: () => Promise.resolve({ id: 1 }),
  });

  const { result } = renderHook(() => useFetch('/api/user'));

  await waitFor(() => {
    expect(result.current.data).not.toBeNull();
  });
});
```

---

### Bug 2: Stale result.current

```tsx
// âŒ Code bá»‹ lá»—i â€” test luÃ´n pass dÃ¹ logic sai
it('should toggle value twice and return to false', () => {
  const { result } = renderHook(() => useToggle());

  // LÆ°u reference vÃ o variable â€” ÄÃ‚Y LÃ€ Lá»–I
  const { toggle } = result.current;

  act(() => toggle());
  act(() => toggle());

  expect(result.current.value).toBe(false);
  // Test pass nhÆ°ng vÃ¬ lÃ½ do sai: toggle() thá»© 2 lÃ  stale closure,
  // khÃ´ng toggle láº¡i nhÆ° mong Ä‘á»£i
});
```

**Táº¡i sao sai?** `toggle` Ä‘Æ°á»£c destructure ra ngoÃ i `result.current` â€” nÃ³ lÃ  reference Ä‘áº¿n function cá»§a render Ä‘áº§u tiÃªn, cÃ³ thá»ƒ bá»‹ stale.

```tsx
// âœ… Fix: LuÃ´n gá»i qua result.current
it('should toggle value twice and return to false', () => {
  const { result } = renderHook(() => useToggle());

  act(() => result.current.toggle()); // âœ… LuÃ´n Ä‘á»c tá»« result.current
  act(() => result.current.toggle());

  expect(result.current.value).toBe(false);
});
```

---

### Bug 3: Context khÃ´ng cÃ³ trong test

```tsx
// âŒ Code bá»‹ lá»—i
it('should show user name', () => {
  render(<UserProfile userId='1' />);
  // â›” UserProfile dÃ¹ng useAuth() nhÆ°ng khÃ´ng cÃ³ AuthProvider!
  expect(screen.getByText('Alice')).toBeInTheDocument();
});
```

```
Error: useAuth pháº£i Ä‘Æ°á»£c dÃ¹ng trong AuthProvider
```

**Táº¡i sao sai?** `render()` khÃ´ng tá»± Ä‘á»™ng cung cáº¥p Context. Component throw error.

```tsx
// âœ… Fix: Wrap vá»›i Provider hoáº·c mock Context
it('should show user name', () => {
  render(
    <AuthContext.Provider
      value={{
        user: { id: '1', name: 'Alice' },
        login: jest.fn(),
        logout: jest.fn(),
        isAdmin: false,
      }}
    >
      <UserProfile userId='1' />
    </AuthContext.Provider>,
  );

  expect(screen.getByText('Alice')).toBeInTheDocument();
});
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

- [ ] TÃ´i biáº¿t `renderHook` tráº£ vá» gÃ¬ vÃ  cÃ¡ch Ä‘á»c `result.current`
- [ ] TÃ´i hiá»ƒu táº¡i sao pháº£i wrap mutations trong `act()`
- [ ] TÃ´i biáº¿t cÃ¡ch dÃ¹ng `waitFor` cho async assertions
- [ ] TÃ´i biáº¿t 3 cÃ¡ch cung cáº¥p Context trong test vÃ  khi nÃ o dÃ¹ng cÃ¡i nÃ o
- [ ] TÃ´i hiá»ƒu táº¡i sao khÃ´ng nÃªn destructure trá»±c tiáº¿p tá»« `result.current` trÆ°á»›c `act()`

### Code Review Checklist

- [ ] Má»—i test chá»‰ test má»™t behavior
- [ ] Test names mÃ´ táº£ behavior, khÃ´ng pháº£i implementation
- [ ] KhÃ´ng cÃ³ test nÃ o phá»¥ thuá»™c vÃ o thá»© tá»± cháº¡y
- [ ] Mock Ä‘Æ°á»£c reset trong `beforeEach`
- [ ] Async tests Ä‘á»u cÃ³ `await waitFor(...)` hoáº·c `await screen.findBy*()`
- [ ] `consoleSpy.mockRestore()` Ä‘Æ°á»£c gá»i sau khi mock console.error

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

Viáº¿t test suite cho `useLocalStorage` hook:

```tsx
function useLocalStorage<T>(key: string, initialValue: T) {
  // Äá»c/ghi localStorage, sync vá»›i state
}
// Hint: Mock localStorage báº±ng jest.spyOn(Storage.prototype, 'getItem')
```

### NÃ¢ng cao (60 phÃºt)

XÃ¢y dá»±ng `createContextTestHelper<T>(Context, Provider)` â€” má»™t utility function nháº­n Context vÃ  Provider, tráº£ vá»:

- `renderWithContext(ui, value)`: render component vá»›i mock context value
- `renderHookWithContext(hook, value)`: render hook vá»›i mock context value
- DÃ¹ng TypeScript generics Ä‘á»ƒ type-safe

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

- [RTL renderHook API](https://testing-library.com/docs/react-testing-library/api/#renderhook)
- [RTL â€” Testing Custom Hooks](https://testing-library.com/docs/react-testing-library/api/#renderhook)

### Äá»c thÃªm

- [Kent C. Dodds â€” How to test custom React hooks](https://kentcdodds.com/blog/how-to-test-custom-react-hooks)
- [RTL â€” Wrapping in Provider](https://testing-library.com/docs/react-testing-library/api/#wrapper)

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n

- **NgÃ y 53:** Testing Philosophy â€” test behavior, khÃ´ng test implementation
- **NgÃ y 54:** RTL basics â€” `render`, `screen`, queries, `userEvent`
- **NgÃ y 24:** Custom hooks â€” naming convention, extraction pattern
- **NgÃ y 36-37:** Context API â€” `createContext`, `Provider`, `useContext`

### HÆ°á»›ng tá»›i

- **NgÃ y 56:** MSW (Mock Service Worker) â€” mock API táº§ng network, khÃ´ng cáº§n mock fetch thá»§ cÃ´ng
- **NgÃ y 57:** Integration & E2E Testing â€” test toÃ n bá»™ flow ngÆ°á»i dÃ¹ng

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**Test utils riÃªng cho cáº£ project.** Thay vÃ¬ láº·p wrapper á»Ÿ má»i file, táº¡o `test-utils.tsx` override `render` cá»§a RTL:

```tsx
// test-utils.tsx â€” dÃ¹ng cho toÃ n bá»™ project
import { render as rtlRender } from '@testing-library/react';

function AllProviders({ children }) {
  return (
    <AuthProvider>
      <CartProvider>
        <ThemeProvider>{children}</ThemeProvider>
      </CartProvider>
    </AuthProvider>
  );
}

export function render(ui, options) {
  return rtlRender(ui, { wrapper: AllProviders, ...options });
}

export * from '@testing-library/react'; // Re-export everything
```

**Äá»«ng test implementation.** Náº¿u báº¡n refactor `useToggle` tá»« `useState` sang `useReducer`, test khÃ´ng nÃªn break â€” vÃ¬ behavior váº«n nhÆ° cÅ©.

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior:** `renderHook` khÃ¡c `render` nhÆ° tháº¿ nÃ o? Khi nÃ o dÃ¹ng cÃ¡i nÃ o?

**Mid:** Táº¡i sao pháº£i dÃ¹ng `act()` khi gá»i function tá»« hook trong test? Äiá»u gÃ¬ xáº£y ra náº¿u khÃ´ng cÃ³ `act()`?

**Senior:** Báº¡n thiáº¿t káº¿ test strategy nhÆ° tháº¿ nÃ o cho má»™t Context cÃ³ async actions (fetch trong Provider)? CÃ³ bao nhiÃªu unit tests vs integration tests lÃ  há»£p lÃ½?

### War Stories

Má»™t láº§n team tÃ´i cÃ³ bug: hook `useNotifications` khÃ´ng show error khi API fail. Unit tests Ä‘á»u green vÃ¬ má»i test Ä‘á»u mock fetch thÃ nh cÃ´ng. Lesson learned: **LuÃ´n cÃ³ Ã­t nháº¥t má»™t test cho error path**. Tá»« Ä‘Ã³ team cÃ³ convention: má»i async hook pháº£i cÃ³ test case cho success, loading, vÃ  error â€” khÃ´ng cÃ³ exception.

---

## ğŸ”® Preview NgÃ y 56

**NgÃ y mai:** MSW (Mock Service Worker) â€” thay vÃ¬ mock `global.fetch` thá»§ cÃ´ng nhÆ° hÃ´m nay, chÃºng ta sáº½ intercept request á»Ÿ táº§ng network. Tests sáº½ realistic hÆ¡n vÃ  dá»… maintain hÆ¡n vÃ¬ chá»‰ define mock má»™t láº§n, dÃ¹ng cho má»i test.

```tsx
// Preview ngÃ y mai:
const server = setupServer(
  rest.get('/api/users/:id', (req, res, ctx) => {
    return res(ctx.json({ id: req.params.id, name: 'Alice' }));
  }),
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```
