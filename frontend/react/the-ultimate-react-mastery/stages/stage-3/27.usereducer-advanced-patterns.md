# ğŸ“… NGÃ€Y 27: useReducer Advanced Patterns - Normalize State & Action Creators

## ğŸ“ Vá»‹ trÃ­: Phase 3, Tuáº§n 6, NgÃ y 27/45

### â±ï¸ Thá»i lÆ°á»£ng: 3-4 giá»

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] **Thiáº¿t káº¿ Ä‘Æ°á»£c** normalized state structure cho complex data
- [ ] **Sá»­ dá»¥ng Ä‘Æ°á»£c** action creators vÃ  action type constants
- [ ] **Tá»• chá»©c Ä‘Æ°á»£c** large reducers vá»›i reducer composition
- [ ] **Xá»­ lÃ½ Ä‘Æ°á»£c** deeply nested state updates immutably
- [ ] **Quyáº¿t Ä‘á»‹nh Ä‘Æ°á»£c** khi nÃ o normalize vs nest state structure

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i sau:

1. **Váº¥n Ä‘á» gÃ¬ xáº£y ra khi update nested object trong reducer?**
   - Gá»£i Ã½: `state.user.profile.settings.theme = 'dark'` - sao sai?

2. **Táº¡i sao action type nÃªn lÃ  constant thay vÃ¬ string literal?**
   - Gá»£i Ã½: `dispatch({ type: 'INCREMET' })` - lá»—i gÃ¬?

3. **Báº¡n Ä‘Ã£ gáº·p trÆ°á»ng há»£p reducer quÃ¡ dÃ i (>200 lines) chÆ°a?**
   - LÃ m sao organize code tá»‘t hÆ¡n?

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

HÃ£y tÆ°á»Ÿng tÆ°á»£ng báº¡n Ä‘ang build **Social Media App** vá»›i state sau:

```jsx
// âŒ Váº¤N Äá»€: Deeply Nested State
const initialState = {
  users: [
    {
      id: 1,
      name: 'Alice',
      posts: [
        {
          id: 101,
          title: 'Hello World',
          comments: [
            { id: 1001, text: 'Nice post!', author: { id: 2, name: 'Bob' } },
            { id: 1002, text: 'Thanks!', author: { id: 1, name: 'Alice' } },
          ],
        },
      ],
    },
    {
      id: 2,
      name: 'Bob',
      posts: [...],
    },
  ],
};
```

**Thá»­ update 1 comment:**

```jsx
// ğŸ˜± NIGHTMARE: Deeply nested immutable update
function reducer(state, action) {
  switch (action.type) {
    case 'EDIT_COMMENT':
      return {
        ...state,
        users: state.users.map((user) =>
          user.id === action.userId
            ? {
                ...user,
                posts: user.posts.map((post) =>
                  post.id === action.postId
                    ? {
                        ...post,
                        comments: post.comments.map((comment) =>
                          comment.id === action.commentId
                            ? { ...comment, text: action.text }
                            : comment,
                        ),
                      }
                    : post,
                ),
              }
            : user,
        ),
      };
  }
}
```

**Váº¥n Ä‘á»:**

1. ğŸ”´ **Nested hell** - 4 levels deep!
2. ğŸ”´ **Performance** - Clone entire tree má»—i láº§n update 1 comment
3. ğŸ”´ **Error-prone** - Dá»… quÃªn spread operator
4. ğŸ”´ **Hard to read** - KhÃ´ng ai muá»‘n maintain code nÃ y
5. ğŸ”´ **Duplication** - Data duplicated (author object)

### 1.2 Giáº£i PhÃ¡p: State Normalization

**Normalized State** = Flat structure, data referenced by IDs

```jsx
// âœ… GIáº¢I PHÃP: Normalized State
const normalizedState = {
  users: {
    1: { id: 1, name: 'Alice', postIds: [101] },
    2: { id: 2, name: 'Bob', postIds: [102] },
  },
  posts: {
    101: {
      id: 101,
      title: 'Hello World',
      authorId: 1,
      commentIds: [1001, 1002],
    },
    102: { id: 102, title: 'My post', authorId: 2, commentIds: [] },
  },
  comments: {
    1001: { id: 1001, text: 'Nice post!', authorId: 2, postId: 101 },
    1002: { id: 1002, text: 'Thanks!', authorId: 1, postId: 101 },
  },
};
```

**BÃ¢y giá» update comment:**

```jsx
// âœ… SIMPLE: Flat update
function reducer(state, action) {
  switch (action.type) {
    case 'EDIT_COMMENT':
      return {
        ...state,
        comments: {
          ...state.comments,
          [action.commentId]: {
            ...state.comments[action.commentId],
            text: action.text,
          },
        },
      };
  }
}
```

**Lá»£i Ã­ch:**

- âœ… **Flat structure** - KhÃ´ng cÃ³ nested hell
- âœ… **Fast updates** - Chá»‰ clone relevant parts
- âœ… **No duplication** - Reference by ID
- âœ… **Easy queries** - Direct access: `state.comments[id]`

### 1.3 Mental Model

**Nested State:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         DATABASE (Nested)            â”‚
â”‚                                      â”‚
â”‚  User {                              â”‚
â”‚    name: "Alice"                     â”‚
â”‚    posts: [                          â”‚
â”‚      {                               â”‚
â”‚        title: "Hello"                â”‚
â”‚        comments: [                   â”‚
â”‚          { text: "Nice!" }  â† Update nÃ y
â”‚        ]                             â”‚
â”‚      }                               â”‚
â”‚    ]                                 â”‚
â”‚  }                                   â”‚
â”‚                                      â”‚
â”‚  â†’ Pháº£i clone: User â†’ Posts â†’ Comments
â”‚  â†’ Slow, error-prone                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Normalized State:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      DATABASE (Normalized)           â”‚
â”‚                                      â”‚
â”‚  users: { 1: { name: "Alice" } }    â”‚
â”‚                                      â”‚
â”‚  posts: { 101: { title: "Hello" } } â”‚
â”‚                                      â”‚
â”‚  comments: {                         â”‚
â”‚    1001: { text: "Nice!" } â† Update  â”‚
â”‚  }                                   â”‚
â”‚                                      â”‚
â”‚  â†’ Chá»‰ clone: comments object       â”‚
â”‚  â†’ Fast, predictable                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Analogy:** Normalized state giá»‘ng **Database tables vá»›i foreign keys**

- Users table â†’ cÃ³ user IDs
- Posts table â†’ cÃ³ post IDs + authorId (foreign key)
- Comments table â†’ cÃ³ comment IDs + authorId, postId

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

âŒ **Hiá»ƒu láº§m 1:** "Normalization luÃ´n tá»‘t hÆ¡n nesting"

- âœ… **Sá»± tháº­t:** Trade-off! Normalized = fast updates, nhÆ°ng queries phá»©c táº¡p hÆ¡n

âŒ **Hiá»ƒu láº§m 2:** "Pháº£i normalize má»i thá»©"

- âœ… **Sá»± tháº­t:** Chá»‰ normalize khi cáº§n. Simple nested data (2 levels) OK!

âŒ **Hiá»ƒu láº§m 3:** "Action creators lÃ  boilerplate khÃ´ng cáº§n thiáº¿t"

- âœ… **Sá»± tháº­t:** Action creators prevent typos, easy refactoring, type-safe

âŒ **Hiá»ƒu láº§m 4:** "Reducer composition phá»©c táº¡p"

- âœ… **Sá»± tháº­t:** Pattern Ä‘Æ¡n giáº£n, giÃºp code maintainable hÆ¡n

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Action Type Constants & Action Creators â­

```jsx
// ğŸ¯ PATTERN 1: Action Type Constants

// âŒ CÃCH SAI: Magic strings
function TodoApp() {
  const [state, dispatch] = useReducer(reducer, initialState);

  // ğŸ› Typo: 'ADD_TDOO' â†’ Silent fail!
  dispatch({ type: 'ADD_TDOO', payload: { text: 'Learn React' } });
}

// âœ… CÃCH ÄÃšNG: Constants
// 1ï¸âƒ£ Äá»‹nh nghÄ©a constants
const ActionTypes = {
  ADD_TODO: 'ADD_TODO',
  TOGGLE_TODO: 'TOGGLE_TODO',
  DELETE_TODO: 'DELETE_TODO',
  SET_FILTER: 'SET_FILTER',
};

// 2ï¸âƒ£ DÃ¹ng trong reducer
function todoReducer(state, action) {
  switch (action.type) {
    case ActionTypes.ADD_TODO:
      return {
        ...state,
        todos: [...state.todos, action.payload],
      };

    case ActionTypes.TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo,
        ),
      };

    case ActionTypes.DELETE_TODO:
      return {
        ...state,
        todos: state.todos.filter((todo) => todo.id !== action.payload.id),
      };

    case ActionTypes.SET_FILTER:
      return {
        ...state,
        filter: action.payload.filter,
      };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// 3ï¸âƒ£ DÃ¹ng trong component
function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState);

  // âœ… Autocomplete, no typos!
  dispatch({ type: ActionTypes.ADD_TODO, payload: { text: 'Learn React' } });
  //              â†‘ IDE sáº½ suggest
}

// ------------------------------------------------------------------

// ğŸ¯ PATTERN 2: Action Creators

// âŒ CÃCH SAI: Inline action objects
function TodoApp() {
  const handleAddTodo = (text) => {
    // ğŸ› Dá»… quÃªn field, typo key names
    dispatch({
      type: ActionTypes.ADD_TODO,
      payload: {
        id: Date.now(),
        text: text,
        completed: false,
        createdAt: new Date().toISOString(),
      },
    });
  };

  // Duplicate logic everywhere!
  const handleAddAnotherTodo = (text) => {
    dispatch({
      type: ActionTypes.ADD_TODO,
      payload: {
        id: Date.now(), // Same logic
        text: text,
        completed: false,
        createdAt: new Date().toISOString(),
      },
    });
  };
}

// âœ… CÃCH ÄÃšNG: Action Creators
// 1ï¸âƒ£ Táº¡o action creator functions
const actionCreators = {
  addTodo: (text) => ({
    type: ActionTypes.ADD_TODO,
    payload: {
      id: Date.now(),
      text,
      completed: false,
      createdAt: new Date().toISOString(),
    },
  }),

  toggleTodo: (id) => ({
    type: ActionTypes.TOGGLE_TODO,
    payload: { id },
  }),

  deleteTodo: (id) => ({
    type: ActionTypes.DELETE_TODO,
    payload: { id },
  }),

  setFilter: (filter) => ({
    type: ActionTypes.SET_FILTER,
    payload: { filter },
  }),
};

// 2ï¸âƒ£ DÃ¹ng trong component
function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState);

  const handleAddTodo = (text) => {
    // âœ… Clean, consistent, no duplication
    dispatch(actionCreators.addTodo(text));
  };

  const handleToggle = (id) => {
    dispatch(actionCreators.toggleTodo(id));
  };

  const handleDelete = (id) => {
    dispatch(actionCreators.deleteTodo(id));
  };

  return (
    <div>
      {/* ... */}
      <button onClick={() => handleAddTodo('New todo')}>Add Todo</button>
      {state.todos.map((todo) => (
        <div key={todo.id}>
          <input
            type='checkbox'
            checked={todo.completed}
            onChange={() => handleToggle(todo.id)}
          />
          <span>{todo.text}</span>
          <button onClick={() => handleDelete(todo.id)}>Delete</button>
        </div>
      ))}
    </div>
  );
}
```

**ğŸ¯ Lá»£i Ã­ch:**

1. **Action Type Constants:**
   - âœ… Autocomplete trong IDE
   - âœ… Typo = compile error (vá»›i TS) hoáº·c runtime error ngay
   - âœ… Easy refactoring (rename 1 chá»—)

2. **Action Creators:**
   - âœ… Centralized action logic
   - âœ… Consistent payload structure
   - âœ… Easy to test
   - âœ… Reusable across components

### Demo 2: State Normalization - Blog App â­â­

```jsx
// ğŸ¯ Ká»ŠCH Báº¢N: Blog vá»›i Users, Posts, Comments

// âŒ NESTED STATE (Anti-pattern cho large data)
const nestedState = {
  users: [
    {
      id: 1,
      name: 'Alice',
      posts: [
        {
          id: 101,
          title: 'First Post',
          comments: [
            { id: 1001, text: 'Great!', author: { id: 2, name: 'Bob' } },
          ],
        },
      ],
    },
  ],
};

// âœ… NORMALIZED STATE
const normalizedState = {
  entities: {
    users: {
      1: { id: 1, name: 'Alice' },
      2: { id: 2, name: 'Bob' },
    },
    posts: {
      101: { id: 101, title: 'First Post', authorId: 1 },
      102: { id: 102, title: 'Second Post', authorId: 2 },
    },
    comments: {
      1001: { id: 1001, text: 'Great!', authorId: 2, postId: 101 },
      1002: { id: 1002, text: 'Nice!', authorId: 1, postId: 102 },
    },
  },
  // IDs arrays cho ordering
  allUserIds: [1, 2],
  allPostIds: [101, 102],
  postCommentIds: {
    101: [1001],
    102: [1002],
  },
};

// ------------------------------------------------------------------

// ğŸ—ï¸ ACTION TYPES
const ActionTypes = {
  ADD_POST: 'ADD_POST',
  EDIT_POST: 'EDIT_POST',
  DELETE_POST: 'DELETE_POST',
  ADD_COMMENT: 'ADD_COMMENT',
  EDIT_COMMENT: 'EDIT_COMMENT',
  DELETE_COMMENT: 'DELETE_COMMENT',
};

// ğŸ­ ACTION CREATORS
const actions = {
  addPost: (authorId, title, content) => ({
    type: ActionTypes.ADD_POST,
    payload: {
      id: Date.now(),
      authorId,
      title,
      content,
      createdAt: new Date().toISOString(),
    },
  }),

  editPost: (postId, updates) => ({
    type: ActionTypes.EDIT_POST,
    payload: { postId, updates },
  }),

  deletePost: (postId) => ({
    type: ActionTypes.DELETE_POST,
    payload: { postId },
  }),

  addComment: (postId, authorId, text) => ({
    type: ActionTypes.ADD_COMMENT,
    payload: {
      id: Date.now(),
      postId,
      authorId,
      text,
      createdAt: new Date().toISOString(),
    },
  }),

  editComment: (commentId, text) => ({
    type: ActionTypes.EDIT_COMMENT,
    payload: { commentId, text },
  }),

  deleteComment: (commentId, postId) => ({
    type: ActionTypes.DELETE_COMMENT,
    payload: { commentId, postId },
  }),
};

// ğŸ”§ REDUCER
function blogReducer(state, action) {
  switch (action.type) {
    case ActionTypes.ADD_POST: {
      const { id, authorId, title, content, createdAt } = action.payload;

      return {
        ...state,
        entities: {
          ...state.entities,
          posts: {
            ...state.entities.posts,
            [id]: { id, authorId, title, content, createdAt },
          },
        },
        allPostIds: [...state.allPostIds, id],
        postCommentIds: {
          ...state.postCommentIds,
          [id]: [],
        },
      };
    }

    case ActionTypes.EDIT_POST: {
      const { postId, updates } = action.payload;

      return {
        ...state,
        entities: {
          ...state.entities,
          posts: {
            ...state.entities.posts,
            [postId]: {
              ...state.entities.posts[postId],
              ...updates,
              updatedAt: new Date().toISOString(),
            },
          },
        },
      };
    }

    case ActionTypes.DELETE_POST: {
      const { postId } = action.payload;

      // 1ï¸âƒ£ Remove post
      const { [postId]: deletedPost, ...remainingPosts } = state.entities.posts;

      // 2ï¸âƒ£ Remove from allPostIds
      const newAllPostIds = state.allPostIds.filter((id) => id !== postId);

      // 3ï¸âƒ£ Remove associated comments
      const commentIdsToDelete = state.postCommentIds[postId] || [];
      const newComments = { ...state.entities.comments };
      commentIdsToDelete.forEach((commentId) => {
        delete newComments[commentId];
      });

      // 4ï¸âƒ£ Remove postCommentIds entry
      const { [postId]: deletedCommentIds, ...remainingPostCommentIds } =
        state.postCommentIds;

      return {
        ...state,
        entities: {
          ...state.entities,
          posts: remainingPosts,
          comments: newComments,
        },
        allPostIds: newAllPostIds,
        postCommentIds: remainingPostCommentIds,
      };
    }

    case ActionTypes.ADD_COMMENT: {
      const { id, postId, authorId, text, createdAt } = action.payload;

      return {
        ...state,
        entities: {
          ...state.entities,
          comments: {
            ...state.entities.comments,
            [id]: { id, postId, authorId, text, createdAt },
          },
        },
        postCommentIds: {
          ...state.postCommentIds,
          [postId]: [...(state.postCommentIds[postId] || []), id],
        },
      };
    }

    case ActionTypes.EDIT_COMMENT: {
      const { commentId, text } = action.payload;

      return {
        ...state,
        entities: {
          ...state.entities,
          comments: {
            ...state.entities.comments,
            [commentId]: {
              ...state.entities.comments[commentId],
              text,
              updatedAt: new Date().toISOString(),
            },
          },
        },
      };
    }

    case ActionTypes.DELETE_COMMENT: {
      const { commentId, postId } = action.payload;

      // Remove comment from entities
      const { [commentId]: deleted, ...remainingComments } =
        state.entities.comments;

      // Remove from postCommentIds
      const newPostCommentIds = state.postCommentIds[postId].filter(
        (id) => id !== commentId,
      );

      return {
        ...state,
        entities: {
          ...state.entities,
          comments: remainingComments,
        },
        postCommentIds: {
          ...state.postCommentIds,
          [postId]: newPostCommentIds,
        },
      };
    }

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// ğŸ¯ COMPONENT vá»›i Denormalization
function BlogApp() {
  const initialState = {
    entities: {
      users: {
        1: { id: 1, name: 'Alice' },
        2: { id: 2, name: 'Bob' },
      },
      posts: {},
      comments: {},
    },
    allUserIds: [1, 2],
    allPostIds: [],
    postCommentIds: {},
  };

  const [state, dispatch] = useReducer(blogReducer, initialState);

  // âœ… Helper: Denormalize data for display
  const getPostWithAuthor = (postId) => {
    const post = state.entities.posts[postId];
    if (!post) return null;

    const author = state.entities.users[post.authorId];
    return {
      ...post,
      author,
    };
  };

  const getCommentsForPost = (postId) => {
    const commentIds = state.postCommentIds[postId] || [];
    return commentIds.map((commentId) => {
      const comment = state.entities.comments[commentId];
      const author = state.entities.users[comment.authorId];
      return {
        ...comment,
        author,
      };
    });
  };

  const handleAddPost = (authorId, title, content) => {
    dispatch(actions.addPost(authorId, title, content));
  };

  const handleAddComment = (postId, authorId, text) => {
    dispatch(actions.addComment(postId, authorId, text));
  };

  return (
    <div>
      <h1>Blog Posts</h1>

      {/* Add Post Form */}
      <button onClick={() => handleAddPost(1, 'New Post', 'Content here')}>
        Add Post
      </button>

      {/* Posts List */}
      {state.allPostIds.map((postId) => {
        const post = getPostWithAuthor(postId);
        const comments = getCommentsForPost(postId);

        return (
          <article key={postId}>
            <h2>{post.title}</h2>
            <p>By {post.author.name}</p>
            <p>{post.content}</p>

            {/* Comments */}
            <div>
              <h3>Comments ({comments.length})</h3>
              {comments.map((comment) => (
                <div key={comment.id}>
                  <strong>{comment.author.name}:</strong> {comment.text}
                  <button
                    onClick={() =>
                      dispatch(actions.editComment(comment.id, 'Updated!'))
                    }
                  >
                    Edit
                  </button>
                  <button
                    onClick={() =>
                      dispatch(actions.deleteComment(comment.id, postId))
                    }
                  >
                    Delete
                  </button>
                </div>
              ))}

              <button onClick={() => handleAddComment(postId, 2, 'Nice post!')}>
                Add Comment
              </button>
            </div>
          </article>
        );
      })}
    </div>
  );
}
```

**ğŸ¯ Key Takeaways:**

1. **Normalized benefits:**
   - âœ… Edit comment: O(1) access, khÃ´ng cáº§n traverse tree
   - âœ… Delete post: XÃ³a post + cascade delete comments
   - âœ… No data duplication (author referenced by ID)

2. **Trade-off:**
   - â– Pháº£i denormalize khi display (helper functions)
   - â• But update operations fast & simple

### Demo 3: Reducer Composition â­â­â­

```jsx
// ğŸ¯ PATTERN: Split large reducer thÃ nh smaller reducers

// âŒ Váº¤N Äá»€: Reducer quÃ¡ lá»›n (300+ lines)
function monolithicReducer(state, action) {
  switch (action.type) {
    case 'USER_LOGIN': /* ... */
    case 'USER_LOGOUT': /* ... */
    case 'UPDATE_PROFILE': /* ... */
    case 'ADD_POST': /* ... */
    case 'EDIT_POST': /* ... */
    case 'DELETE_POST': /* ... */
    case 'ADD_COMMENT': /* ... */
    case 'EDIT_COMMENT': /* ... */
    case 'DELETE_COMMENT': /* ... */
    case 'SET_THEME': /* ... */
    case 'SET_LANGUAGE': /* ... */
    // ... 50 more cases
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// âœ… GIáº¢I PHÃP: Reducer Composition
// 1ï¸âƒ£ Split theo domain (users, posts, comments, settings)

// Users Reducer
function usersReducer(state = {}, action) {
  switch (action.type) {
    case ActionTypes.USER_LOGIN:
      return {
        ...state,
        [action.payload.id]: action.payload,
      };

    case ActionTypes.USER_LOGOUT:
      const { [action.payload.id]: removed, ...remaining } = state;
      return remaining;

    case ActionTypes.UPDATE_PROFILE:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id],
          ...action.payload.updates,
        },
      };

    default:
      return state;
  }
}

// Posts Reducer
function postsReducer(state = {}, action) {
  switch (action.type) {
    case ActionTypes.ADD_POST:
      return {
        ...state,
        [action.payload.id]: action.payload,
      };

    case ActionTypes.EDIT_POST:
      return {
        ...state,
        [action.payload.postId]: {
          ...state[action.payload.postId],
          ...action.payload.updates,
        },
      };

    case ActionTypes.DELETE_POST:
      const { [action.payload.postId]: deleted, ...remaining } = state;
      return remaining;

    default:
      return state;
  }
}

// Comments Reducer
function commentsReducer(state = {}, action) {
  switch (action.type) {
    case ActionTypes.ADD_COMMENT:
      return {
        ...state,
        [action.payload.id]: action.payload,
      };

    case ActionTypes.EDIT_COMMENT:
      return {
        ...state,
        [action.payload.commentId]: {
          ...state[action.payload.commentId],
          text: action.payload.text,
        },
      };

    case ActionTypes.DELETE_COMMENT:
      const { [action.payload.commentId]: deleted, ...remaining } = state;
      return remaining;

    // âœ… Cross-domain logic: Delete post â†’ Delete comments
    case ActionTypes.DELETE_POST: {
      const commentIdsToDelete = action.payload.commentIds || [];
      const newState = { ...state };
      commentIdsToDelete.forEach((id) => {
        delete newState[id];
      });
      return newState;
    }

    default:
      return state;
  }
}

// Settings Reducer
function settingsReducer(state = { theme: 'light', language: 'en' }, action) {
  switch (action.type) {
    case ActionTypes.SET_THEME:
      return {
        ...state,
        theme: action.payload.theme,
      };

    case ActionTypes.SET_LANGUAGE:
      return {
        ...state,
        language: action.payload.language,
      };

    default:
      return state;
  }
}

// 2ï¸âƒ£ Combine reducers manually (NO Redux!)
function rootReducer(state, action) {
  return {
    users: usersReducer(state.users, action),
    posts: postsReducer(state.posts, action),
    comments: commentsReducer(state.comments, action),
    settings: settingsReducer(state.settings, action),
  };
}

// 3ï¸âƒ£ Sá»­ dá»¥ng
function App() {
  const initialState = {
    users: {},
    posts: {},
    comments: {},
    settings: { theme: 'light', language: 'en' },
  };

  const [state, dispatch] = useReducer(rootReducer, initialState);

  // âœ… Now dispatch works with composed reducer
  dispatch(actions.addPost(1, 'Title', 'Content'));
  dispatch(actions.setTheme('dark'));

  return (
    <div>
      <p>Theme: {state.settings.theme}</p>
      <p>Posts: {Object.keys(state.posts).length}</p>
    </div>
  );
}
```

**ğŸ¯ Lá»£i Ã­ch Reducer Composition:**

1. **Maintainability:**
   - âœ… Má»—i reducer < 100 lines
   - âœ… Easy to find logic (users logic â†’ usersReducer)
   - âœ… Test má»—i reducer independently

2. **Separation of Concerns:**
   - âœ… Each domain isolated
   - âœ… Clear boundaries

3. **Reusability:**
   - âœ… CÃ³ thá»ƒ reuse sub-reducers
   - âœ… Share reducers across projects

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Level 1: Ãp Dá»¥ng Concept (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Convert magic strings â†’ constants + action creators
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: Redux, Context
 *
 * Requirements:
 * 1. Táº¡o ActionTypes object vá»›i constants
 * 2. Táº¡o action creators cho táº¥t cáº£ actions
 * 3. Refactor component dÃ¹ng action creators
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - ActionTypes = { INCREMENT: 'INCREMENT', ... }
 * - actionCreators = { increment: () => ({ type: ... }), ... }
 */

// âŒ CODE HIá»†N Táº I: Magic strings everywhere
function Counter() {
  const reducer = (state, action) => {
    switch (action.type) {
      case 'INCREMENT':
        return { count: state.count + 1 };
      case 'DECREMENT':
        return { count: state.count - 1 };
      case 'INCREMENT_BY':
        return { count: state.count + action.payload };
      case 'RESET':
        return { count: 0 };
      default:
        throw new Error(`Unknown action: ${action.type}`);
    }
  };

  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <h1>{state.count}</h1>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+1</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-1</button>
      <button onClick={() => dispatch({ type: 'INCREMENT_BY', payload: 5 })}>
        +5
      </button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
    </div>
  );
}

// ğŸ¯ NHIá»†M Vá»¤: Refactor vá»›i constants + action creators
// TODO: Viáº¿t ActionTypes
// TODO: Viáº¿t action creators
// TODO: Update component
```

```jsx
/**
 * Counter Component with Action Types & Action Creators
 * @returns {JSX.Element}
 */
function Counter() {
  // â”€â”€ Action Type Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ActionTypes = {
    INCREMENT: 'INCREMENT',
    DECREMENT: 'DECREMENT',
    INCREMENT_BY: 'INCREMENT_BY',
    RESET: 'RESET',
  };

  // â”€â”€ Action Creators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const actions = {
    increment: () => ({
      type: ActionTypes.INCREMENT,
    }),

    decrement: () => ({
      type: ActionTypes.DECREMENT,
    }),

    incrementBy: (amount) => ({
      type: ActionTypes.INCREMENT_BY,
      payload: amount,
    }),

    reset: () => ({
      type: ActionTypes.RESET,
    }),
  };

  // â”€â”€ Reducer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const reducer = (state, action) => {
    switch (action.type) {
      case ActionTypes.INCREMENT:
        return { count: state.count + 1 };

      case ActionTypes.DECREMENT:
        return { count: state.count - 1 };

      case ActionTypes.INCREMENT_BY:
        return { count: state.count + action.payload };

      case ActionTypes.RESET:
        return { count: 0 };

      default:
        throw new Error(`Unknown action: ${action.type}`);
    }
  };

  const [state, dispatch] = React.useReducer(reducer, { count: 0 });

  return (
    <div>
      <h1>{state.count}</h1>

      <button onClick={() => dispatch(actions.increment())}>+1</button>
      <button onClick={() => dispatch(actions.decrement())}>-1</button>
      <button onClick={() => dispatch(actions.incrementBy(5))}>+5</button>
      <button onClick={() => dispatch(actions.reset())}>Reset</button>
    </div>
  );
}

/*
Káº¿t quáº£ vÃ­ dá»¥:

Ban Ä‘áº§u: 0
Nháº¥n +1     â†’ 1
Nháº¥n +5     â†’ 6
Nháº¥n -1     â†’ 5
Nháº¥n Reset  â†’ 0
*/
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
// ÄÃ¡p Ã¡n Ä‘áº§y Ä‘á»§ (Ä‘Ã£ bao gá»“m cáº£ pháº§n trÃªn)

const ActionTypes = {
  INCREMENT: 'INCREMENT',
  DECREMENT: 'DECREMENT',
  INCREMENT_BY: 'INCREMENT_BY',
  RESET: 'RESET',
};

const actions = {
  increment: () => ({ type: ActionTypes.INCREMENT }),
  decrement: () => ({ type: ActionTypes.DECREMENT }),
  incrementBy: (amount) => ({
    type: ActionTypes.INCREMENT_BY,
    payload: amount,
  }),
  reset: () => ({ type: ActionTypes.RESET }),
};

function reducer(state, action) {
  switch (action.type) {
    case ActionTypes.INCREMENT:
      return { count: state.count + 1 };
    case ActionTypes.DECREMENT:
      return { count: state.count - 1 };
    case ActionTypes.INCREMENT_BY:
      return { count: state.count + action.payload };
    case ActionTypes.RESET:
      return { count: 0 };
    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// Trong component:
const [state, dispatch] = useReducer(reducer, { count: 0 });

// Sá»­ dá»¥ng:
<button onClick={() => dispatch(actions.increment())}>+1</button>
<button onClick={() => dispatch(actions.decrement())}>-1</button>
<button onClick={() => dispatch(actions.incrementBy(5))}>+5</button>
<button onClick={() => dispatch(actions.reset())}>Reset</button>
```

</details>

### â­â­ Level 2: Nháº­n Biáº¿t Pattern (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Quyáº¿t Ä‘á»‹nh Nested vs Normalized State
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: E-commerce Shopping Cart
 *
 * Products catalog:
 * - 100+ products
 * - Each product cÃ³ categories, reviews
 * - User cÃ³ thá»ƒ add product to cart
 * - Cart hiá»ƒn thá»‹ product details (name, price, image)
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 *
 * Approach A: Nested State
 * {
 *   cart: [
 *     {
 *       product: {
 *         id: 1,
 *         name: 'iPhone',
 *         price: 999,
 *         categories: [...],
 *         reviews: [...]
 *       },
 *       quantity: 2
 *     }
 *   ]
 * }
 *
 * Pros:
 * - ÄÆ¡n giáº£n, dá»… hiá»ƒu
 * - Query dá»… (cart items cÃ³ Ä‘áº§y Ä‘á»§ info)
 *
 * Cons:
 * - Duplicate product data (náº¿u add 2 láº§n)
 * - Update product price â†’ pháº£i update táº¥t cáº£ cart items
 * - Large payload (categories, reviews khÃ´ng cáº§n trong cart)
 *
 * Approach B: Normalized State
 * {
 *   products: {
 *     1: { id: 1, name: 'iPhone', price: 999, ... }
 *   },
 *   cart: {
 *     items: {
 *       1: { productId: 1, quantity: 2 }
 *     }
 *   }
 * }
 *
 * Pros:
 * - No duplication
 * - Update product â†’ auto reflect in cart
 * - Small cart payload
 *
 * Cons:
 * - Denormalize khi display cart
 * - More complex queries
 *
 * ğŸ’­ Báº N CHá»ŒN GÃŒ VÃ€ Táº I SAO?
 * (Viáº¿t 5-7 cÃ¢u, consider:)
 * - Number of products (100+)
 * - Update frequency (prices change?)
 * - Display requirements (cart UI cáº§n gÃ¬?)
 *
 * Sau Ä‘Ã³ implement approach Ä‘Ã£ chá»n:
 * - State shape
 * - Reducer vá»›i actions: ADD_TO_CART, REMOVE_FROM_CART, UPDATE_QUANTITY
 * - Component display cart
 */

// TODO: Viáº¿t analysis + implementation
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * E-commerce Shopping Cart vá»›i Normalized State
 *
 * PhÃ¢n tÃ­ch: Vá»›i 100+ products, updates thÆ°á»ng xuyÃªn (giÃ¡ thay Ä‘á»•i),
 * vÃ  cáº§n hiá»ƒn thá»‹ cart vá»›i info Ä‘áº§y Ä‘á»§ nhÆ°ng khÃ´ng muá»‘n duplicate data,
 * normalized state lÃ  lá»±a chá»n tá»‘t hÆ¡n nested state.
 *
 * Lá»£i Ã­ch:
 * - KhÃ´ng duplicate product info
 * - Update giÃ¡ product tá»± Ä‘á»™ng reflect trong cart
 * - Cart state nháº¹ (chá»‰ chá»©a productId + quantity)
 * - Dá»… quáº£n lÃ½ khi remove product tá»« catalog
 *
 * @returns {JSX.Element}
 */
function ShoppingCart() {
  // â”€â”€ Action Type Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ActionTypes = {
    ADD_TO_CART: 'ADD_TO_CART',
    REMOVE_FROM_CART: 'REMOVE_FROM_CART',
    UPDATE_QUANTITY: 'UPDATE_QUANTITY',
  };

  // â”€â”€ Action Creators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const actions = {
    addToCart: (productId, quantity = 1) => ({
      type: ActionTypes.ADD_TO_CART,
      payload: { productId, quantity },
    }),

    removeFromCart: (productId) => ({
      type: ActionTypes.REMOVE_FROM_CART,
      payload: { productId },
    }),

    updateQuantity: (productId, quantity) => ({
      type: ActionTypes.UPDATE_QUANTITY,
      payload: { productId, quantity },
    }),
  };

  // â”€â”€ Initial State (Normalized) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const initialState = {
    products: {
      1: { id: 1, name: 'iPhone 15', price: 999, category: 'Electronics' },
      2: { id: 2, name: 'MacBook Pro', price: 2499, category: 'Electronics' },
      3: { id: 3, name: 'AirPods', price: 199, category: 'Electronics' },
      4: { id: 4, name: 'React Book', price: 49, category: 'Books' },
    },
    cart: {
      items: {}, // { productId: { productId, quantity } }
    },
  };

  // â”€â”€ Reducer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const reducer = (state, action) => {
    switch (action.type) {
      case ActionTypes.ADD_TO_CART: {
        const { productId, quantity } = action.payload;

        // Náº¿u Ä‘Ã£ cÃ³ trong cart, tÄƒng quantity, náº¿u chÆ°a thÃ¬ thÃªm má»›i
        const currentItem = state.cart.items[productId];
        const newItem = currentItem
          ? { ...currentItem, quantity: currentItem.quantity + quantity }
          : { productId, quantity };

        return {
          ...state,
          cart: {
            ...state.cart,
            items: {
              ...state.cart.items,
              [productId]: newItem,
            },
          },
        };
      }

      case ActionTypes.REMOVE_FROM_CART: {
        const { productId } = action.payload;
        const { [productId]: removed, ...remainingItems } = state.cart.items;

        return {
          ...state,
          cart: {
            ...state.cart,
            items: remainingItems,
          },
        };
      }

      case ActionTypes.UPDATE_QUANTITY: {
        const { productId, quantity } = action.payload;

        if (quantity <= 0) {
          // Náº¿u quantity <= 0 thÃ¬ remove khá»i cart
          const { [productId]: removed, ...remainingItems } = state.cart.items;
          return {
            ...state,
            cart: {
              ...state.cart,
              items: remainingItems,
            },
          };
        }

        return {
          ...state,
          cart: {
            ...state.cart,
            items: {
              ...state.cart.items,
              [productId]: {
                ...state.cart.items[productId],
                quantity,
              },
            },
          },
        };
      }

      default:
        return state;
    }
  };

  const [state, dispatch] = React.useReducer(reducer, initialState);

  // â”€â”€ Helper: Láº¥y cart items vá»›i product details â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const getCartItemsWithDetails = () => {
    return Object.values(state.cart.items).map((cartItem) => {
      const product = state.products[cartItem.productId];
      return {
        ...cartItem,
        ...product, // denormalize: thÃªm product info vÃ o cart item
        totalPrice: product.price * cartItem.quantity,
      };
    });
  };

  const cartItems = getCartItemsWithDetails();
  const total = cartItems.reduce((sum, item) => sum + item.totalPrice, 0);

  return (
    <div>
      <h2>ğŸ›’ Shopping Cart</h2>

      {cartItems.length === 0 ? (
        <p>Cart is empty</p>
      ) : (
        <>
          <ul>
            {cartItems.map((item) => (
              <li key={item.productId}>
                <strong>{item.name}</strong>
                <span>
                  {' '}
                  - ${item.price} x {item.quantity}
                </span>
                <span> = ${item.totalPrice}</span>
                <br />
                <button
                  onClick={() =>
                    dispatch(
                      actions.updateQuantity(item.productId, item.quantity + 1),
                    )
                  }
                >
                  +
                </button>
                <button
                  onClick={() =>
                    dispatch(
                      actions.updateQuantity(item.productId, item.quantity - 1),
                    )
                  }
                >
                  -
                </button>
                <button
                  onClick={() =>
                    dispatch(actions.removeFromCart(item.productId))
                  }
                >
                  Remove
                </button>
              </li>
            ))}
          </ul>

          <p>
            <strong>Total: ${total}</strong>
          </p>
        </>
      )}

      {/* Demo: Add items */}
      <div style={{ marginTop: '20px' }}>
        <button onClick={() => dispatch(actions.addToCart(1))}>
          Add iPhone
        </button>
        <button onClick={() => dispatch(actions.addToCart(2))}>
          Add MacBook
        </button>
        <button onClick={() => dispatch(actions.addToCart(3))}>
          Add AirPods
        </button>
        <button onClick={() => dispatch(actions.addToCart(4))}>
          Add React Book
        </button>
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ vÃ­ dá»¥:

1. Nháº¥n "Add iPhone" â†’ Cart: iPhone (1) = $999
2. Nháº¥n "Add iPhone" láº§n ná»¯a â†’ Cart: iPhone (2) = $1998
3. Nháº¥n "Add React Book" â†’ Cart: iPhone (2) = $1998, React Book (1) = $49
4. Nháº¥n "-" trÃªn iPhone â†’ Cart: iPhone (1) = $999, React Book (1) = $49
5. Nháº¥n "Remove" trÃªn React Book â†’ Cart: iPhone (1) = $999
6. Nháº¥n "-" trÃªn iPhone â†’ Cart: empty
*/
```

</details>

### â­â­â­ Level 3: Ká»‹ch Báº£n Thá»±c Táº¿ (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build Normalized State cho Messaging App
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  user, tÃ´i muá»‘n chat vá»›i friends trong app"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Hiá»ƒn thá»‹ list conversations
 * - [ ] Click conversation â†’ hiá»ƒn thá»‹ messages
 * - [ ] Send message trong conversation
 * - [ ] Delete message
 * - [ ] Mark conversation as read/unread
 *
 * ğŸ¨ State Structure (Normalized):
 * {
 *   users: { [id]: { id, name, avatar } },
 *   conversations: { [id]: { id, participantIds: [], lastMessageId } },
 *   messages: { [id]: { id, conversationId, senderId, text, timestamp } },
 *   conversationMessageIds: { [conversationId]: [messageId, ...] }
 * }
 *
 * ğŸš¨ Edge Cases:
 * - Delete message â†’ update lastMessageId náº¿u lÃ  message cuá»‘i
 * - Delete conversation â†’ cascade delete messages
 * - Send message â†’ update lastMessageId trong conversation
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] ActionTypes constants (8+ actions)
 * - [ ] Action creators
 * - [ ] Reducer vá»›i normalized updates
 * - [ ] Helper functions (getConversationWithMessages, etc.)
 * - [ ] Component display conversations + messages
 */

// TODO: Full implementation

// Gá»£i Ã½ Actions:
// - ADD_CONVERSATION
// - DELETE_CONVERSATION
// - SEND_MESSAGE
// - DELETE_MESSAGE
// - MARK_READ
// - MARK_UNREAD

// Gá»£i Ã½ Initial State:
const initialState = {
  users: {
    1: { id: 1, name: 'Alice', avatar: 'ğŸ‘©' },
    2: { id: 2, name: 'Bob', avatar: 'ğŸ‘¨' },
  },
  conversations: {},
  messages: {},
  conversationMessageIds: {},
  allConversationIds: [],
};
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Messaging App - Normalized State with Conversations & Messages
 *
 * Features:
 * - List conversations
 * - View messages in selected conversation
 * - Send new message
 * - Delete message (with lastMessageId update)
 * - Mark conversation as read/unread
 *
 * @returns {JSX.Element}
 */
function MessagingApp() {
  // â”€â”€ Action Type Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ActionTypes = {
    ADD_CONVERSATION: 'ADD_CONVERSATION',
    DELETE_CONVERSATION: 'DELETE_CONVERSATION',
    SEND_MESSAGE: 'SEND_MESSAGE',
    DELETE_MESSAGE: 'DELETE_MESSAGE',
    MARK_READ: 'MARK_READ',
    MARK_UNREAD: 'MARK_UNREAD',
    SELECT_CONVERSATION: 'SELECT_CONVERSATION',
  };

  // â”€â”€ Action Creators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const actions = {
    addConversation: (participantIds, title = '') => ({
      type: ActionTypes.ADD_CONVERSATION,
      payload: {
        id: Date.now().toString(),
        participantIds,
        title,
        createdAt: new Date().toISOString(),
      },
    }),

    deleteConversation: (conversationId) => ({
      type: ActionTypes.DELETE_CONVERSATION,
      payload: { conversationId },
    }),

    sendMessage: (conversationId, senderId, text) => ({
      type: ActionTypes.SEND_MESSAGE,
      payload: {
        id: Date.now().toString(),
        conversationId,
        senderId,
        text,
        timestamp: new Date().toISOString(),
      },
    }),

    deleteMessage: (conversationId, messageId) => ({
      type: ActionTypes.DELETE_MESSAGE,
      payload: { conversationId, messageId },
    }),

    markRead: (conversationId) => ({
      type: ActionTypes.MARK_READ,
      payload: { conversationId },
    }),

    markUnread: (conversationId) => ({
      type: ActionTypes.MARK_UNREAD,
      payload: { conversationId },
    }),

    selectConversation: (conversationId) => ({
      type: ActionTypes.SELECT_CONVERSATION,
      payload: { conversationId },
    }),
  };

  // â”€â”€ Initial State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const initialState = {
    users: {
      1: { id: '1', name: 'Alice', avatar: 'ğŸ‘©' },
      2: { id: '2', name: 'Bob', avatar: 'ğŸ‘¨' },
      3: { id: '3', name: 'Charlie', avatar: 'ğŸ§‘' },
    },
    conversations: {}, // { convId: { id, participantIds, lastMessageId?, unread: boolean, title?, createdAt } }
    messages: {}, // { msgId: { id, conversationId, senderId, text, timestamp } }
    conversationMessageIds: {}, // { convId: [msgId, msgId, ...] } â€“ ordered
    selectedConversationId: null,
    allConversationIds: [],
  };

  // â”€â”€ Reducer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const reducer = (state, action) => {
    switch (action.type) {
      case ActionTypes.ADD_CONVERSATION: {
        const { id, participantIds, title, createdAt } = action.payload;
        return {
          ...state,
          conversations: {
            ...state.conversations,
            [id]: { id, participantIds, unread: false, title, createdAt },
          },
          conversationMessageIds: {
            ...state.conversationMessageIds,
            [id]: [],
          },
          allConversationIds: [...state.allConversationIds, id],
        };
      }

      case ActionTypes.DELETE_CONVERSATION: {
        const { conversationId } = action.payload;
        const { [conversationId]: removedConv, ...restConvs } =
          state.conversations;
        const { [conversationId]: removedIds, ...restMsgIds } =
          state.conversationMessageIds;

        // XÃ³a táº¥t cáº£ messages liÃªn quan
        const msgIdsToDelete = removedIds || [];
        const newMessages = { ...state.messages };
        msgIdsToDelete.forEach((msgId) => delete newMessages[msgId]);

        return {
          ...state,
          conversations: restConvs,
          messages: newMessages,
          conversationMessageIds: restMsgIds,
          allConversationIds: state.allConversationIds.filter(
            (id) => id !== conversationId,
          ),
          selectedConversationId:
            state.selectedConversationId === conversationId
              ? null
              : state.selectedConversationId,
        };
      }

      case ActionTypes.SEND_MESSAGE: {
        const { id, conversationId, senderId, text, timestamp } =
          action.payload;

        return {
          ...state,
          messages: {
            ...state.messages,
            [id]: { id, conversationId, senderId, text, timestamp },
          },
          conversationMessageIds: {
            ...state.conversationMessageIds,
            [conversationId]: [
              ...(state.conversationMessageIds[conversationId] || []),
              id,
            ],
          },
          conversations: {
            ...state.conversations,
            [conversationId]: {
              ...state.conversations[conversationId],
              lastMessageId: id,
              unread: senderId !== '1', // giáº£ sá»­ current user lÃ  id '1'
            },
          },
        };
      }

      case ActionTypes.DELETE_MESSAGE: {
        const { conversationId, messageId } = action.payload;

        const { [messageId]: removedMsg, ...restMessages } = state.messages;

        const currentMsgIds =
          state.conversationMessageIds[conversationId] || [];
        const newMsgIds = currentMsgIds.filter((id) => id !== messageId);

        let newLastMessageId =
          state.conversations[conversationId]?.lastMessageId;
        if (newLastMessageId === messageId) {
          newLastMessageId =
            newMsgIds.length > 0 ? newMsgIds[newMsgIds.length - 1] : null;
        }

        return {
          ...state,
          messages: restMessages,
          conversationMessageIds: {
            ...state.conversationMessageIds,
            [conversationId]: newMsgIds,
          },
          conversations: {
            ...state.conversations,
            [conversationId]: {
              ...state.conversations[conversationId],
              lastMessageId: newLastMessageId,
            },
          },
        };
      }

      case ActionTypes.MARK_READ:
      case ActionTypes.MARK_UNREAD: {
        const { conversationId } = action.payload;
        return {
          ...state,
          conversations: {
            ...state.conversations,
            [conversationId]: {
              ...state.conversations[conversationId],
              unread: action.type === ActionTypes.MARK_UNREAD,
            },
          },
        };
      }

      case ActionTypes.SELECT_CONVERSATION: {
        const { conversationId } = action.payload;
        return {
          ...state,
          selectedConversationId: conversationId,
          // Tá»± Ä‘á»™ng mark read khi má»Ÿ conversation (tÃ¹y chá»n)
          conversations: {
            ...state.conversations,
            [conversationId]: {
              ...state.conversations[conversationId],
              unread: false,
            },
          },
        };
      }

      default:
        return state;
    }
  };

  const [state, dispatch] = React.useReducer(reducer, initialState);

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const getConversationWithParticipants = (convId) => {
    const conv = state.conversations[convId];
    if (!conv) return null;
    return {
      ...conv,
      participants: conv.participantIds.map((id) => state.users[id]),
    };
  };

  const getMessagesForConversation = (convId) => {
    const msgIds = state.conversationMessageIds[convId] || [];
    return msgIds.map((id) => state.messages[id]);
  };

  const currentConv = state.selectedConversationId
    ? getConversationWithParticipants(state.selectedConversationId)
    : null;

  const currentMessages = state.selectedConversationId
    ? getMessagesForConversation(state.selectedConversationId)
    : [];

  // â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  return (
    <div style={{ display: 'flex', height: '80vh', fontFamily: 'system-ui' }}>
      {/* Sidebar - Conversations */}
      <div
        style={{
          width: '280px',
          borderRight: '1px solid #ddd',
          padding: '16px',
        }}
      >
        <h3>Chats</h3>
        <button
          onClick={() =>
            dispatch(actions.addConversation(['1', '2'], 'Alice & You'))
          }
          style={{ marginBottom: '12px' }}
        >
          New Chat with Alice
        </button>
        <button
          onClick={() =>
            dispatch(actions.addConversation(['1', '3'], 'Charlie Group'))
          }
        >
          New Chat with Charlie
        </button>

        <ul style={{ listStyle: 'none', padding: 0, marginTop: '16px' }}>
          {state.allConversationIds.map((convId) => {
            const conv = getConversationWithParticipants(convId);
            if (!conv) return null;
            const lastMsgId = conv.lastMessageId;
            const lastMsg = lastMsgId ? state.messages[lastMsgId] : null;
            const lastSender = lastMsg
              ? state.users[lastMsg.senderId]?.name
              : '';

            return (
              <li
                key={convId}
                onClick={() => dispatch(actions.selectConversation(convId))}
                style={{
                  padding: '12px',
                  marginBottom: '8px',
                  background:
                    state.selectedConversationId === convId
                      ? '#e0f2fe'
                      : '#f8f9fa',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  border: conv.unread
                    ? '1px solid #3b82f6'
                    : '1px solid transparent',
                }}
              >
                <strong>
                  {conv.title ||
                    conv.participants.map((p) => p.name).join(', ')}
                </strong>
                {lastMsg && (
                  <div
                    style={{
                      fontSize: '0.9em',
                      color: '#666',
                      marginTop: '4px',
                    }}
                  >
                    {lastSender}: {lastMsg.text.slice(0, 40)}
                    {lastMsg.text.length > 40 ? '...' : ''}
                  </div>
                )}
                {conv.unread && (
                  <span style={{ color: '#3b82f6', fontWeight: 'bold' }}>
                    {' '}
                    â€¢
                  </span>
                )}
              </li>
            );
          })}
        </ul>
      </div>

      {/* Main Chat Area */}
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
        {currentConv ? (
          <>
            <div
              style={{
                padding: '16px',
                borderBottom: '1px solid #ddd',
                background: '#f8f9fa',
              }}
            >
              <h2>
                {currentConv.title ||
                  currentConv.participants.map((p) => p.name).join(', ')}
              </h2>
              {currentConv.unread ? (
                <button
                  onClick={() => dispatch(actions.markRead(currentConv.id))}
                >
                  Mark as Read
                </button>
              ) : (
                <button
                  onClick={() => dispatch(actions.markUnread(currentConv.id))}
                >
                  Mark as Unread
                </button>
              )}
              <button
                onClick={() =>
                  dispatch(actions.deleteConversation(currentConv.id))
                }
                style={{ marginLeft: '12px', color: 'red' }}
              >
                Delete Conversation
              </button>
            </div>

            <div style={{ flex: 1, overflowY: 'auto', padding: '16px' }}>
              {currentMessages.map((msg) => {
                const isMe = msg.senderId === '1';
                const sender = state.users[msg.senderId];

                return (
                  <div
                    key={msg.id}
                    style={{
                      marginBottom: '16px',
                      textAlign: isMe ? 'right' : 'left',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: isMe ? 'flex-end' : 'flex-start',
                    }}
                  >
                    <small style={{ color: '#666', marginBottom: '4px' }}>
                      {sender.name} â€¢{' '}
                      {new Date(msg.timestamp).toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit',
                      })}
                    </small>
                    <div
                      style={{
                        maxWidth: '70%',
                        padding: '10px 14px',
                        borderRadius: '18px',
                        background: isMe ? '#3b82f6' : '#e5e7eb',
                        color: isMe ? 'white' : 'black',
                        position: 'relative',
                      }}
                    >
                      {msg.text}
                      <button
                        onClick={() =>
                          dispatch(
                            actions.deleteMessage(currentConv.id, msg.id),
                          )
                        }
                        style={{
                          fontSize: '0.7em',
                          marginLeft: '8px',
                          background: 'none',
                          border: 'none',
                          color: isMe ? '#bfdbfe' : '#9ca3af',
                          cursor: 'pointer',
                        }}
                      >
                        Ã—
                      </button>
                    </div>
                  </div>
                );
              })}
            </div>

            <div
              style={{
                padding: '16px',
                borderTop: '1px solid #ddd',
                display: 'flex',
              }}
            >
              <input
                type='text'
                placeholder='Type a message...'
                id='messageInput'
                style={{
                  flex: 1,
                  padding: '10px',
                  borderRadius: '20px',
                  border: '1px solid #ddd',
                }}
              />
              <button
                onClick={() => {
                  const input = document.getElementById('messageInput');
                  if (input.value.trim()) {
                    dispatch(
                      actions.sendMessage(
                        currentConv.id,
                        '1', // current user
                        input.value.trim(),
                      ),
                    );
                    input.value = '';
                  }
                }}
                style={{
                  marginLeft: '12px',
                  padding: '10px 20px',
                  borderRadius: '20px',
                  background: '#3b82f6',
                  color: 'white',
                  border: 'none',
                }}
              >
                Send
              </button>
            </div>
          </>
        ) : (
          <div
            style={{
              flex: 1,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              color: '#888',
            }}
          >
            Select a conversation to start chatting
          </div>
        )}
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ vÃ­ dá»¥:

1. Nháº¥n "New Chat with Alice" â†’ xuáº¥t hiá»‡n conversation má»›i
2. Chá»n conversation â†’ tháº¥y giao diá»‡n chat trá»‘ng
3. GÃµ "Hey Alice!" â†’ nháº¥n Send â†’ tin nháº¯n hiá»‡n bÃªn pháº£i (mÃ u xanh)
4. GÃµ "How are you?" â†’ tin nháº¯n thá»© hai
5. Nháº¥n Ã— bÃªn cáº¡nh tin nháº¯n Ä‘áº§u â†’ tin nháº¯n bá»‹ xÃ³a, lastMessageId cáº­p nháº­t
6. Nháº¥n "Mark as Unread" â†’ conversation cÃ³ dáº¥u cháº¥m xanh
7. Nháº¥n "Delete Conversation" â†’ conversation vÃ  táº¥t cáº£ messages biáº¿n máº¥t
*/
```

</details>

### â­â­â­â­ Level 4: Quyáº¿t Äá»‹nh Kiáº¿n TrÃºc (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Design State Architecture cho Large App
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Context: Spotify-like Music Player App
 *
 * Features:
 * - Browse playlists (user's + public)
 * - Each playlist cÃ³ songs
 * - Play song â†’ update currently playing
 * - Queue management (add to queue, reorder)
 * - Playback state (playing, paused, volume, progress)
 * - User can create/edit/delete playlists
 * - User can favorite songs
 *
 * State Architecture Options:
 *
 * Option A: Single Normalized State
 * {
 *   playlists: { [id]: {...} },
 *   songs: { [id]: {...} },
 *   playlistSongIds: { [playlistId]: [songId, ...] },
 *   player: { currentSongId, isPlaying, volume, ... },
 *   queue: [songId, ...],
 *   favorites: [songId, ...]
 * }
 *
 * Option B: Domain-Separated State
 * {
 *   library: {
 *     playlists: {...},
 *     songs: {...},
 *     playlistSongIds: {...}
 *   },
 *   player: { currentSongId, isPlaying, ... },
 *   queue: [...],
 *   user: { favorites: [...] }
 * }
 *
 * Option C: Reducer Composition
 * - libraryReducer (playlists, songs)
 * - playerReducer (playback state)
 * - queueReducer (queue management)
 * - userReducer (favorites, settings)
 * - Combine vá»›i rootReducer
 *
 * Nhiá»‡m vá»¥:
 * 1. So sÃ¡nh 3 options
 * 2. Consider:
 *    - Update frequency (player state updates often)
 *    - Cross-domain logic (play song from playlist â†’ update player + queue)
 *    - Testability
 *    - Code organization
 * 3. Viáº¿t ADR
 *
 * ğŸ“ ADR Template:
 *
 * ## Context
 * Music player cáº§n quáº£n lÃ½ library (playlists, songs), player state,
 * queue, vÃ  user preferences. Player state updates ráº¥t thÆ°á»ng xuyÃªn
 * (má»—i giÃ¢y), trong khi library data Ã­t thay Ä‘á»•i.
 *
 * ## Decision
 * Chá»n Option C: Reducer Composition
 *
 * ## Rationale
 * - Player updates khÃ´ng trigger re-render library data
 * - Each domain isolated, easy to test
 * - Clear code organization (player logic á»Ÿ playerReducer)
 * - Scalable (dá»… add features)
 *
 * ## Consequences
 * Trade-offs:
 * + Better performance (isolated updates)
 * + Maintainable (clear boundaries)
 * + Testable (test each reducer)
 * - More boilerplate (4 reducers + root)
 * - Cross-domain actions cáº§n handle carefully
 *
 * ## Alternatives Considered
 * - Option A: Simple nhÆ°ng player updates slow
 * - Option B: Better nhÆ°ng khÃ´ng cÃ³ clear boundaries
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 * Implement architecture Ä‘Ã£ chá»n:
 * - Define state shape
 * - Create sub-reducers
 * - Create rootReducer
 * - Action types + creators (at least 10)
 * - 2-3 actions demonstrate cross-domain logic
 *
 * Example cross-domain action:
 * PLAY_SONG:
 * - playerReducer: Update currentSongId, isPlaying
 * - queueReducer: Add to queue náº¿u chÆ°a cÃ³
 *
 * ğŸ§ª PHASE 3: Testing (10 phÃºt)
 * Write pseudo-code tests:
 * - Test playerReducer isolated
 * - Test PLAY_SONG updates both player & queue
 * - Test DELETE_PLAYLIST cascade deletes
 */

// TODO: Viáº¿t ADR + Implementation + Tests
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Level 4: Quyáº¿t Äá»‹nh Kiáº¿n TrÃºc - Spotify-like Music Player App
 *
 * Architecture Decision Record (ADR)
 *
 * ## Context
 * á»¨ng dá»¥ng music player cáº§n quáº£n lÃ½:
 * - ThÆ° viá»‡n (playlists, songs)
 * - Tráº¡ng thÃ¡i phÃ¡t nháº¡c (current song, playing/paused, volume, progress)
 * - Queue (danh sÃ¡ch phÃ¡t tiáº¿p theo, cÃ³ thá»ƒ reorder)
 * - User preferences (favorites, settings)
 *
 * Äáº·c Ä‘iá»ƒm quan trá»ng:
 * - Player state cáº­p nháº­t ráº¥t thÆ°á»ng xuyÃªn (progress má»—i giÃ¢y, play/pause, volume...)
 * - Library data thay Ä‘á»•i Ã­t hÆ¡n (thÃªm playlist, favorite song...)
 * - CÃ³ cross-domain actions: PLAY_SONG â†’ update player + queue
 * - Cáº§n testability cao vÃ  tá»• chá»©c code rÃµ rÃ ng khi scale
 *
 * ## Decision
 * Chá»n **Option C: Reducer Composition** vá»›i 4 sub-reducers riÃªng biá»‡t
 *
 * State shape:
 * {
 *   library: { playlists, songs, playlistSongIds },
 *   player: { currentSongId, isPlaying, volume, progress, ... },
 *   queue: { songIds: [], currentIndex },
 *   user: { favorites: [songId,...], settings }
 * }
 *
 * ## Rationale
 * - Player updates (progress, volume) khÃ´ng lÃ m re-render toÃ n bá»™ library â†’ performance tá»‘t
 * - Má»—i domain cÃ³ reducer riÃªng â†’ code ngáº¯n gá»n, dá»… maintain, dá»… test
 * - Cross-domain actions dá»… xá»­ lÃ½ báº±ng cÃ¡ch Ä‘á»ƒ rootReducer gá»i nhiá»u sub-reducer
 * - Queue vÃ  player tÃ¡ch biá»‡t â†’ dá»… implement shuffle, repeat, reorder
 * - Scalable: dá»… thÃªm domain má»›i (vÃ­ dá»¥: recommendations, offline mode)
 *
 * ## Consequences
 * + Performance tá»‘t hÆ¡n (isolated updates)
 * + Code organization rÃµ rÃ ng (player logic chá»‰ náº±m trong playerReducer)
 * + Test má»—i reducer Ä‘á»™c láº­p
 * - Boilerplate nhiá»u hÆ¡n (4 reducers + rootReducer)
 * - Cross-domain actions cáº§n cáº©n tháº­n (pháº£i pass action cho nhiá»u reducer)
 *
 * ## Alternatives Considered
 * - Option A (Single Normalized State): Ä‘Æ¡n giáº£n nhÆ°ng player updates gÃ¢y re-render khÃ´ng cáº§n thiáº¿t
 * - Option B (Domain-Separated State): tá»‘t hÆ¡n A nhÆ°ng khÃ´ng cÃ³ boundary rÃµ rÃ ng giá»¯a cÃ¡c domain
 *
 * @returns {JSX.Element}
 */
function MusicPlayerApp() {
  // â”€â”€ Action Type Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ActionTypes = {
    // Library
    ADD_PLAYLIST: 'ADD_PLAYLIST',
    ADD_SONG_TO_PLAYLIST: 'ADD_SONG_TO_PLAYLIST',
    REMOVE_SONG_FROM_PLAYLIST: 'REMOVE_SONG_FROM_PLAYLIST',
    TOGGLE_FAVORITE: 'TOGGLE_FAVORITE',

    // Player
    PLAY_SONG: 'PLAY_SONG',
    PAUSE: 'PAUSE',
    PLAY: 'PLAY',
    NEXT: 'NEXT',
    PREVIOUS: 'PREVIOUS',
    SET_VOLUME: 'SET_VOLUME',
    SET_PROGRESS: 'SET_PROGRESS',

    // Queue
    ADD_TO_QUEUE: 'ADD_TO_QUEUE',
    CLEAR_QUEUE: 'CLEAR_QUEUE',
    REORDER_QUEUE: 'REORDER_QUEUE',
  };

  // â”€â”€ Action Creators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const actions = {
    // Library
    addPlaylist: (title) => ({
      type: ActionTypes.ADD_PLAYLIST,
      payload: { id: Date.now().toString(), title },
    }),
    addSongToPlaylist: (playlistId, songId) => ({
      type: ActionTypes.ADD_SONG_TO_PLAYLIST,
      payload: { playlistId, songId },
    }),
    toggleFavorite: (songId) => ({
      type: ActionTypes.TOGGLE_FAVORITE,
      payload: { songId },
    }),

    // Player + Queue cross-domain
    playSong: (songId, fromQueue = false) => ({
      type: ActionTypes.PLAY_SONG,
      payload: { songId, fromQueue },
    }),
    play: () => ({ type: ActionTypes.PLAY }),
    pause: () => ({ type: ActionTypes.PAUSE }),
    next: () => ({ type: ActionTypes.NEXT }),
    previous: () => ({ type: ActionTypes.PREVIOUS }),
    setVolume: (volume) => ({
      type: ActionTypes.SET_VOLUME,
      payload: { volume },
    }),
    setProgress: (progress) => ({
      type: ActionTypes.SET_PROGRESS,
      payload: { progress },
    }),

    // Queue
    addToQueue: (songId) => ({
      type: ActionTypes.ADD_TO_QUEUE,
      payload: { songId },
    }),
  };

  // â”€â”€ Initial State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const initialState = {
    library: {
      songs: {
        s1: {
          id: 's1',
          title: 'Blinding Lights',
          artist: 'The Weeknd',
          duration: 200,
        },
        s2: {
          id: 's2',
          title: 'Levitating',
          artist: 'Dua Lipa',
          duration: 203,
        },
        s3: {
          id: 's3',
          title: 'Save Your Tears',
          artist: 'The Weeknd',
          duration: 215,
        },
      },
      playlists: {},
      playlistSongIds: {},
    },
    player: {
      currentSongId: null,
      isPlaying: false,
      volume: 80,
      progress: 0, // 0-100
    },
    queue: {
      songIds: [],
      currentIndex: -1,
    },
    user: {
      favorites: [],
    },
  };

  // â”€â”€ Sub-reducers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function libraryReducer(state = initialState.library, action) {
    switch (action.type) {
      case ActionTypes.ADD_PLAYLIST: {
        const { id, title } = action.payload;
        return {
          ...state,
          playlists: {
            ...state.playlists,
            [id]: { id, title, createdAt: new Date().toISOString() },
          },
          playlistSongIds: {
            ...state.playlistSongIds,
            [id]: [],
          },
        };
      }

      case ActionTypes.ADD_SONG_TO_PLAYLIST: {
        const { playlistId, songId } = action.payload;
        return {
          ...state,
          playlistSongIds: {
            ...state.playlistSongIds,
            [playlistId]: [
              ...(state.playlistSongIds[playlistId] || []),
              songId,
            ],
          },
        };
      }

      default:
        return state;
    }
  }

  function playerReducer(state = initialState.player, action, queueState) {
    switch (action.type) {
      case ActionTypes.PLAY_SONG: {
        const { songId, fromQueue } = action.payload;
        return {
          ...state,
          currentSongId: songId,
          isPlaying: true,
          progress: 0,
        };
      }

      case ActionTypes.PLAY:
        return { ...state, isPlaying: true };

      case ActionTypes.PAUSE:
        return { ...state, isPlaying: false };

      case ActionTypes.SET_VOLUME:
        return {
          ...state,
          volume: Math.max(0, Math.min(100, action.payload.volume)),
        };

      case ActionTypes.SET_PROGRESS:
        return { ...state, progress: action.payload.progress };

      // NEXT / PREVIOUS sáº½ Ä‘Æ°á»£c xá»­ lÃ½ á»Ÿ rootReducer
      default:
        return state;
    }
  }

  function queueReducer(state = initialState.queue, action) {
    switch (action.type) {
      case ActionTypes.PLAY_SONG: {
        const { songId, fromQueue } = action.payload;
        if (fromQueue) {
          const index = state.songIds.indexOf(songId);
          return index !== -1 ? { ...state, currentIndex: index } : state;
        }
        // Add to queue if not already playing from queue
        if (!state.songIds.includes(songId)) {
          return {
            ...state,
            songIds: [...state.songIds, songId],
            currentIndex: state.songIds.length,
          };
        }
        return { ...state, currentIndex: state.songIds.indexOf(songId) };
      }

      case ActionTypes.ADD_TO_QUEUE: {
        const { songId } = action.payload;
        if (state.songIds.includes(songId)) return state;
        return { ...state, songIds: [...state.songIds, songId] };
      }

      case ActionTypes.NEXT: {
        const nextIndex = state.currentIndex + 1;
        if (nextIndex >= state.songIds.length) return state;
        return { ...state, currentIndex: nextIndex };
      }

      case ActionTypes.PREVIOUS: {
        const prevIndex = state.currentIndex - 1;
        if (prevIndex < 0) return state;
        return { ...state, currentIndex: prevIndex };
      }

      default:
        return state;
    }
  }

  function userReducer(state = initialState.user, action) {
    switch (action.type) {
      case ActionTypes.TOGGLE_FAVORITE: {
        const { songId } = action.payload;
        const isFavorite = state.favorites.includes(songId);
        return {
          ...state,
          favorites: isFavorite
            ? state.favorites.filter((id) => id !== songId)
            : [...state.favorites, songId],
        };
      }

      default:
        return state;
    }
  }

  // â”€â”€ Root Reducer (Composition) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function rootReducer(state, action) {
    const library = libraryReducer(state.library, action);
    const queue = queueReducer(state.queue, action);
    const player = playerReducer(state.player, action, queue);
    const user = userReducer(state.user, action);

    // Cross-domain: khi NEXT/PREVIOUS â†’ update player.currentSongId
    let finalPlayer = player;
    if (
      action.type === ActionTypes.NEXT ||
      action.type === ActionTypes.PREVIOUS
    ) {
      const newSongId = queue.songIds[queue.currentIndex] || null;
      finalPlayer = {
        ...player,
        currentSongId: newSongId,
        isPlaying: newSongId ? player.isPlaying : false,
      };
    }

    // PLAY_SONG tá»« playlist â†’ tá»± Ä‘á»™ng add vÃ o queue náº¿u cáº§n
    if (action.type === ActionTypes.PLAY_SONG && !action.payload.fromQueue) {
      // Logic add to queue Ä‘Ã£ xá»­ lÃ½ trong queueReducer
    }

    return {
      ...state,
      library,
      player: finalPlayer,
      queue,
      user,
    };
  }

  const [state, dispatch] = React.useReducer(rootReducer, initialState);

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const currentSong = state.player.currentSongId
    ? state.library.songs[state.player.currentSongId]
    : null;

  // â”€â”€ UI (Simplified) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h1>Music Player</h1>

      {/* Now Playing */}
      <div
        style={{
          marginBottom: '24px',
          padding: '16px',
          background: '#f8f9fa',
          borderRadius: '12px',
        }}
      >
        <h3>Now Playing</h3>
        {currentSong ? (
          <div>
            <strong>{currentSong.title}</strong> â€” {currentSong.artist}
            <div style={{ marginTop: '12px' }}>
              <button onClick={() => dispatch(actions.play())}>Play</button>
              <button onClick={() => dispatch(actions.pause())}>Pause</button>
              <button onClick={() => dispatch(actions.previous())}>
                â—€ Previous
              </button>
              <button onClick={() => dispatch(actions.next())}>Next â–¶</button>
            </div>
            <div>
              Volume:
              <input
                type='range'
                min='0'
                max='100'
                value={state.player.volume}
                onChange={(e) =>
                  dispatch(actions.setVolume(Number(e.target.value)))
                }
              />
            </div>
            <div>Progress: {state.player.progress}%</div>
          </div>
        ) : (
          <p>Select a song to play</p>
        )}
      </div>

      {/* Controls */}
      <div style={{ marginBottom: '24px' }}>
        <button onClick={() => dispatch(actions.addPlaylist('Chill Vibes'))}>
          Create Playlist
        </button>
        <button onClick={() => dispatch(actions.playSong('s1'))}>
          Play Blinding Lights
        </button>
        <button onClick={() => dispatch(actions.playSong('s2'))}>
          Play Levitating
        </button>
        <button onClick={() => dispatch(actions.addToQueue('s3'))}>
          Add Save Your Tears to Queue
        </button>
        <button onClick={() => dispatch(actions.toggleFavorite('s1'))}>
          {state.user.favorites.includes('s1') ? 'Unfavorite' : 'Favorite'}{' '}
          Blinding Lights
        </button>
      </div>

      {/* Queue */}
      <div>
        <h3>Queue ({state.queue.songIds.length})</h3>
        <ul>
          {state.queue.songIds.map((songId, index) => {
            const song = state.library.songs[songId];
            return (
              <li
                key={songId}
                style={{
                  fontWeight:
                    index === state.queue.currentIndex ? 'bold' : 'normal',
                  color:
                    index === state.queue.currentIndex ? '#3b82f6' : 'inherit',
                }}
              >
                {song.title} â€” {song.artist}
              </li>
            );
          })}
        </ul>
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ vÃ­ dá»¥:

1. Nháº¥n "Play Blinding Lights" â†’ player chÆ¡i bÃ i s1, queue = ['s1'], currentIndex = 0
2. Nháº¥n "Add Save Your Tears to Queue" â†’ queue = ['s1', 's3']
3. Nháº¥n "Next" â†’ chuyá»ƒn sang s3, currentSongId = 's3'
4. Nháº¥n "Favorite Blinding Lights" â†’ favorites = ['s1']
5. Nháº¥n "Create Playlist" â†’ playlists cÃ³ thÃªm má»™t playlist má»›i
6. Nháº¥n "Play" / "Pause" / thay Ä‘á»•i volume â†’ chá»‰ player state thay Ä‘á»•i, khÃ´ng re-render queue/library
*/
```

</details>

### â­â­â­â­â­ Level 5: Production Challenge (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build Production-Ready Kanban Board
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 *
 * Trello-like Kanban Board vá»›i:
 * - Multiple boards
 * - Each board cÃ³ columns (Todo, In Progress, Done)
 * - Each column cÃ³ cards
 * - Drag & drop cards giá»¯a columns
 * - Add/Edit/Delete cards
 * - Add/Edit/Delete columns
 * - Card tags/labels
 * - Filter cards by tag
 * - Search cards
 * - Card details (title, description, due date, assignee)
 *
 * ğŸ—ï¸ Technical Design Doc:
 *
 * 1. State Architecture:
 *    Normalized state vá»›i:
 *    - boards: { [id]: { id, title, columnIds } }
 *    - columns: { [id]: { id, title, boardId, cardIds } }
 *    - cards: { [id]: { id, title, description, columnId, tags, ... } }
 *    - tags: { [id]: { id, name, color } }
 *
 * 2. Reducer Composition:
 *    - boardsReducer
 *    - columnsReducer
 *    - cardsReducer
 *    - tagsReducer
 *    - filterReducer
 *    - rootReducer (combine all)
 *
 * 3. Action Types (20+ actions):
 *    Boards: ADD_BOARD, EDIT_BOARD, DELETE_BOARD
 *    Columns: ADD_COLUMN, EDIT_COLUMN, DELETE_COLUMN, REORDER_COLUMNS
 *    Cards: ADD_CARD, EDIT_CARD, DELETE_CARD, MOVE_CARD
 *    Tags: ADD_TAG, EDIT_TAG, DELETE_TAG
 *    Filters: SET_TAG_FILTER, SET_SEARCH_FILTER, CLEAR_FILTERS
 *
 * 4. Cross-Domain Logic:
 *    - DELETE_BOARD: cascade delete columns & cards
 *    - DELETE_COLUMN: move cards to "Unassigned" hoáº·c delete
 *    - MOVE_CARD: update cardIds trong 2 columns
 *    - DELETE_TAG: remove tag tá»« táº¥t cáº£ cards
 *
 * 5. Performance:
 *    - useMemo for filtered/searched cards
 *    - Denormalize helpers cached
 *
 * âœ… Production Checklist:
 * - [ ] State shape documented (comments)
 * - [ ] All ActionTypes constants defined
 * - [ ] All action creators implemented
 * - [ ] All reducers implemented (4-5 reducers)
 * - [ ] rootReducer combines all
 * - [ ] Cross-domain logic handled correctly
 * - [ ] Helper functions:
 *   - [ ] getBoardWithColumns
 *   - [ ] getColumnWithCards
 *   - [ ] getFilteredCards
 * - [ ] Edge cases handled:
 *   - [ ] Delete board with columns/cards
 *   - [ ] Move card updates both columns
 *   - [ ] Filter by multiple tags
 * - [ ] Code quality:
 *   - [ ] Clear comments
 *   - [ ] Consistent naming
 *   - [ ] DRY (no duplication)
 *
 * ğŸ“ Documentation:
 * - README vá»›i state architecture diagram
 * - Action types reference
 * - Reducer responsibilities
 *
 * ğŸ” Self-Review Checklist:
 * - [ ] Immutable updates everywhere
 * - [ ] Default cases in all reducers
 * - [ ] Action creators type-safe (payload structure consistent)
 * - [ ] No magic strings (all constants)
 * - [ ] Normalized state (no nested arrays/objects)
 */

// TODO: Full implementation

// Starter: State Shape
const initialState = {
  boards: {
    // '1': { id: '1', title: 'My Board', columnIds: ['col1', 'col2'] }
  },
  columns: {
    // 'col1': { id: 'col1', title: 'Todo', boardId: '1', cardIds: ['card1'] }
  },
  cards: {
    // 'card1': { id: 'card1', title: 'Task', description: '...', columnId: 'col1', tagIds: ['tag1'] }
  },
  tags: {
    // 'tag1': { id: 'tag1', name: 'Bug', color: 'red' }
  },
  filters: {
    tagIds: [],
    searchText: '',
  },
  allBoardIds: [],
  allTagIds: [],
};

// Starter: ActionTypes
const ActionTypes = {
  // Boards
  ADD_BOARD: 'ADD_BOARD',
  EDIT_BOARD: 'EDIT_BOARD',
  DELETE_BOARD: 'DELETE_BOARD',

  // Columns
  ADD_COLUMN: 'ADD_COLUMN',
  EDIT_COLUMN: 'EDIT_COLUMN',
  DELETE_COLUMN: 'DELETE_COLUMN',
  REORDER_COLUMNS: 'REORDER_COLUMNS',

  // Cards
  ADD_CARD: 'ADD_CARD',
  EDIT_CARD: 'EDIT_CARD',
  DELETE_CARD: 'DELETE_CARD',
  MOVE_CARD: 'MOVE_CARD',

  // Tags
  ADD_TAG: 'ADD_TAG',
  EDIT_TAG: 'EDIT_TAG',
  DELETE_TAG: 'DELETE_TAG',

  // Filters
  SET_TAG_FILTER: 'SET_TAG_FILTER',
  SET_SEARCH_FILTER: 'SET_SEARCH_FILTER',
  CLEAR_FILTERS: 'CLEAR_FILTERS',
};

// TODO: Implement action creators
// TODO: Implement reducers
// TODO: Implement component
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Production-Ready Kanban Board (Trello-like)
 * Level 5 Challenge - Normalized State + Reducer Composition
 *
 * Features implemented:
 * - Multiple boards
 * - Columns per board
 * - Cards with title, description, dueDate, assignee, tags
 * - Drag & drop simulation (click to move)
 * - Add/Edit/Delete board/column/card
 * - Tag management
 * - Basic tag filter + search
 *
 * @returns {JSX.Element}
 */
function KanbanBoardApp() {
  // â”€â”€ ACTION TYPES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ActionTypes = {
    // Boards
    ADD_BOARD: 'ADD_BOARD',
    EDIT_BOARD: 'EDIT_BOARD',
    DELETE_BOARD: 'DELETE_BOARD',

    // Columns
    ADD_COLUMN: 'ADD_COLUMN',
    EDIT_COLUMN: 'EDIT_COLUMN',
    DELETE_COLUMN: 'DELETE_COLUMN',
    REORDER_COLUMNS: 'REORDER_COLUMNS',

    // Cards
    ADD_CARD: 'ADD_CARD',
    EDIT_CARD: 'EDIT_CARD',
    DELETE_CARD: 'DELETE_CARD',
    MOVE_CARD: 'MOVE_CARD',

    // Tags
    ADD_TAG: 'ADD_TAG',
    EDIT_TAG: 'EDIT_TAG',
    DELETE_TAG: 'DELETE_TAG',

    // Filters
    SET_TAG_FILTER: 'SET_TAG_FILTER',
    SET_SEARCH_FILTER: 'SET_SEARCH_FILTER',
    CLEAR_FILTERS: 'CLEAR_FILTERS',

    // UI
    SELECT_BOARD: 'SELECT_BOARD',
  };

  // â”€â”€ ACTION CREATORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const actions = {
    addBoard: (title) => ({
      type: ActionTypes.ADD_BOARD,
      payload: { id: 'b_' + Date.now(), title },
    }),
    deleteBoard: (boardId) => ({
      type: ActionTypes.DELETE_BOARD,
      payload: { boardId },
    }),
    selectBoard: (boardId) => ({
      type: ActionTypes.SELECT_BOARD,
      payload: { boardId },
    }),

    addColumn: (boardId, title) => ({
      type: ActionTypes.ADD_COLUMN,
      payload: { boardId, id: 'c_' + Date.now(), title },
    }),
    deleteColumn: (columnId) => ({
      type: ActionTypes.DELETE_COLUMN,
      payload: { columnId },
    }),

    addCard: (columnId, title) => ({
      type: ActionTypes.ADD_CARD,
      payload: { columnId, id: 'card_' + Date.now(), title },
    }),
    editCard: (cardId, updates) => ({
      type: ActionTypes.EDIT_CARD,
      payload: { cardId, updates },
    }),
    deleteCard: (cardId, columnId) => ({
      type: ActionTypes.DELETE_CARD,
      payload: { cardId, columnId },
    }),
    moveCard: (cardId, fromColumnId, toColumnId) => ({
      type: ActionTypes.MOVE_CARD,
      payload: { cardId, fromColumnId, toColumnId },
    }),

    addTag: (name, color) => ({
      type: ActionTypes.ADD_TAG,
      payload: { id: 'tag_' + Date.now(), name, color },
    }),
    deleteTag: (tagId) => ({
      type: ActionTypes.DELETE_TAG,
      payload: { tagId },
    }),

    setTagFilter: (tagIds) => ({
      type: ActionTypes.SET_TAG_FILTER,
      payload: { tagIds },
    }),
    setSearchFilter: (text) => ({
      type: ActionTypes.SET_SEARCH_FILTER,
      payload: { text },
    }),
  };

  // â”€â”€ INITIAL STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const initialState = {
    boards: {},
    columns: {},
    cards: {},
    tags: {},
    filters: {
      tagIds: [], // array of selected tag IDs (AND filter)
      searchText: '',
    },
    boardColumnOrder: {}, // { boardId: [colId, colId, ...] }
    columnCardOrder: {}, // { colId: [cardId, cardId, ...] }
    selectedBoardId: null,
    allBoardIds: [],
  };

  // â”€â”€ SUB-REDUCERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  function boardsReducer(state = {}, action) {
    switch (action.type) {
      case ActionTypes.ADD_BOARD: {
        const { id, title } = action.payload;
        return {
          ...state,
          [id]: { id, title, createdAt: new Date().toISOString() },
        };
      }

      case ActionTypes.DELETE_BOARD: {
        const { boardId } = action.payload;
        const { [boardId]: removed, ...rest } = state;
        return rest;
      }

      default:
        return state;
    }
  }

  function columnsReducer(state = {}, action, boardColumnOrder) {
    switch (action.type) {
      case ActionTypes.ADD_COLUMN: {
        const { id, boardId, title } = action.payload;
        return {
          ...state,
          [id]: { id, title, boardId },
        };
      }

      case ActionTypes.DELETE_COLUMN: {
        const { columnId } = action.payload;
        const { [columnId]: removed, ...rest } = state;
        return rest;
      }

      default:
        return state;
    }
  }

  function cardsReducer(state = {}, action) {
    switch (action.type) {
      case ActionTypes.ADD_CARD: {
        const { id, columnId, title } = action.payload;
        return {
          ...state,
          [id]: {
            id,
            title,
            description: '',
            dueDate: null,
            assignee: null,
            tagIds: [],
            columnId,
            createdAt: new Date().toISOString(),
          },
        };
      }

      case ActionTypes.EDIT_CARD: {
        const { cardId, updates } = action.payload;
        return {
          ...state,
          [cardId]: { ...state[cardId], ...updates },
        };
      }

      case ActionTypes.DELETE_CARD: {
        const { cardId } = action.payload;
        const { [cardId]: removed, ...rest } = state;
        return rest;
      }

      case ActionTypes.MOVE_CARD: {
        const { cardId } = action.payload;
        return {
          ...state,
          [cardId]: {
            ...state[cardId],
            columnId: action.payload.toColumnId,
          },
        };
      }

      default:
        return state;
    }
  }

  function tagsReducer(state = {}, action) {
    switch (action.type) {
      case ActionTypes.ADD_TAG: {
        const { id, name, color } = action.payload;
        return {
          ...state,
          [id]: { id, name, color },
        };
      }

      case ActionTypes.DELETE_TAG: {
        const { tagId } = action.payload;
        const { [tagId]: removed, ...rest } = state;
        return rest;
      }

      default:
        return state;
    }
  }

  // â”€â”€ ROOT REDUCER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function rootReducer(state, action) {
    let nextState = {
      ...state,
      boards: boardsReducer(state.boards, action),
      columns: columnsReducer(state.columns, action, state.boardColumnOrder),
      cards: cardsReducer(state.cards, action),
      tags: tagsReducer(state.tags, action),
      filters:
        action.type === ActionTypes.SET_TAG_FILTER ||
        action.type === ActionTypes.SET_SEARCH_FILTER ||
        action.type === ActionTypes.CLEAR_FILTERS
          ? filtersReducer(state.filters, action)
          : state.filters,
      selectedBoardId:
        action.type === ActionTypes.SELECT_BOARD
          ? action.payload.boardId
          : state.selectedBoardId,
    };

    // Handle cross-domain side effects
    if (action.type === ActionTypes.DELETE_BOARD) {
      const boardId = action.payload.boardId;
      const columnIds = state.boardColumnOrder[boardId] || [];

      // Remove columns
      const newColumns = { ...nextState.columns };
      columnIds.forEach((colId) => delete newColumns[colId]);
      nextState.columns = newColumns;

      // Remove cards in those columns
      const newCards = { ...nextState.cards };
      Object.values(newCards).forEach((card) => {
        if (columnIds.includes(card.columnId)) {
          delete newCards[card.id];
        }
      });
      nextState.cards = newCards;

      // Clean up orders
      const { [boardId]: removedOrder, ...restOrders } =
        nextState.boardColumnOrder;
      nextState.boardColumnOrder = restOrders;

      // Clean columnCardOrder
      const newColumnCardOrder = { ...nextState.columnCardOrder };
      columnIds.forEach((colId) => delete newColumnCardOrder[colId]);
      nextState.columnCardOrder = newColumnCardOrder;

      // Deselect if needed
      if (nextState.selectedBoardId === boardId) {
        nextState.selectedBoardId = null;
      }
    }

    if (action.type === ActionTypes.DELETE_COLUMN) {
      const columnId = action.payload.columnId;
      const cardIds = state.columnCardOrder[columnId] || [];

      // Remove cards
      const newCards = { ...nextState.cards };
      cardIds.forEach((cardId) => delete newCards[cardId]);
      nextState.cards = newCards;

      // Clean columnCardOrder
      const { [columnId]: removed, ...rest } = nextState.columnCardOrder;
      nextState.columnCardOrder = rest;
    }

    if (action.type === ActionTypes.DELETE_TAG) {
      const tagId = action.payload.tagId;
      const newCards = { ...nextState.cards };
      Object.keys(newCards).forEach((cardId) => {
        newCards[cardId] = {
          ...newCards[cardId],
          tagIds: newCards[cardId].tagIds.filter((id) => id !== tagId),
        };
      });
      nextState.cards = newCards;
    }

    return nextState;
  }

  function filtersReducer(state, action) {
    switch (action.type) {
      case ActionTypes.SET_TAG_FILTER:
        return { ...state, tagIds: action.payload.tagIds };
      case ActionTypes.SET_SEARCH_FILTER:
        return { ...state, searchText: action.payload.text };
      case ActionTypes.CLEAR_FILTERS:
        return { tagIds: [], searchText: '' };
      default:
        return state;
    }
  }

  const [state, dispatch] = React.useReducer(rootReducer, initialState);

  // â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const getColumnsForBoard = (boardId) => {
    const columnIds = state.boardColumnOrder[boardId] || [];
    return columnIds.map((id) => state.columns[id]).filter(Boolean);
  };

  const getCardsForColumn = (columnId) => {
    const cardIds = state.columnCardOrder[columnId] || [];
    return cardIds
      .map((id) => state.cards[id])
      .filter(Boolean)
      .filter((card) => {
        const matchesSearch = state.filters.searchText
          ? card.title
              .toLowerCase()
              .includes(state.filters.searchText.toLowerCase()) ||
            (card.description || '')
              .toLowerCase()
              .includes(state.filters.searchText.toLowerCase())
          : true;

        const matchesTags =
          state.filters.tagIds.length === 0
            ? true
            : state.filters.tagIds.every((tagId) =>
                card.tagIds.includes(tagId),
              );

        return matchesSearch && matchesTags;
      });
  };

  const selectedBoard = state.selectedBoardId
    ? state.boards[state.selectedBoardId]
    : null;

  // â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h1>Kanban Board</h1>

      {/* Board Selector */}
      <div style={{ marginBottom: '24px' }}>
        <h3>Boards</h3>
        <div style={{ display: 'flex', gap: '12px', flexWrap: 'wrap' }}>
          {state.allBoardIds.map((boardId) => {
            const board = state.boards[boardId];
            const isSelected = boardId === state.selectedBoardId;
            return (
              <div
                key={boardId}
                onClick={() => dispatch(actions.selectBoard(boardId))}
                style={{
                  padding: '12px 20px',
                  background: isSelected ? '#3b82f6' : '#f1f5f9',
                  color: isSelected ? 'white' : 'black',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  fontWeight: isSelected ? 'bold' : 'normal',
                }}
              >
                {board.title}
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    if (
                      window.confirm('Delete this board and all its content?')
                    ) {
                      dispatch(actions.deleteBoard(boardId));
                    }
                  }}
                  style={{
                    marginLeft: '12px',
                    color: isSelected ? '#bfdbfe' : 'red',
                    background: 'none',
                    border: 'none',
                  }}
                >
                  Ã—
                </button>
              </div>
            );
          })}

          <button
            onClick={() => {
              const title = prompt('Board title:');
              if (title) {
                dispatch(actions.addBoard(title.trim()));
              }
            }}
            style={{
              padding: '12px 20px',
              background: '#10b981',
              color: 'white',
              border: 'none',
              borderRadius: '8px',
            }}
          >
            + New Board
          </button>
        </div>
      </div>

      {selectedBoard && (
        <>
          <h2>{selectedBoard.title}</h2>

          {/* Filters */}
          <div
            style={{
              margin: '16px 0',
              display: 'flex',
              gap: '16px',
              alignItems: 'center',
            }}
          >
            <input
              placeholder='Search cards...'
              value={state.filters.searchText}
              onChange={(e) =>
                dispatch(actions.setSearchFilter(e.target.value))
              }
              style={{
                padding: '8px',
                borderRadius: '6px',
                border: '1px solid #d1d5db',
              }}
            />

            <div>
              Filter by tags:
              {Object.values(state.tags).map((tag) => (
                <label
                  key={tag.id}
                  style={{ marginLeft: '12px' }}
                >
                  <input
                    type='checkbox'
                    checked={state.filters.tagIds.includes(tag.id)}
                    onChange={(e) => {
                      const newTagIds = e.target.checked
                        ? [...state.filters.tagIds, tag.id]
                        : state.filters.tagIds.filter((id) => id !== tag.id);
                      dispatch(actions.setTagFilter(newTagIds));
                    }}
                  />
                  <span
                    style={{
                      background: tag.color,
                      color: 'white',
                      padding: '2px 8px',
                      borderRadius: '12px',
                      marginLeft: '4px',
                    }}
                  >
                    {tag.name}
                  </span>
                </label>
              ))}
            </div>

            <button
              onClick={() => dispatch({ type: ActionTypes.CLEAR_FILTERS })}
            >
              Clear Filters
            </button>

            <button
              onClick={() => {
                const name = prompt('Tag name:');
                const color = prompt('Color (e.g. #ef4444):', '#ef4444');
                if (name && color) {
                  dispatch(actions.addTag(name.trim(), color));
                }
              }}
            >
              + New Tag
            </button>
          </div>

          {/* Columns */}
          <div
            style={{
              display: 'flex',
              gap: '20px',
              overflowX: 'auto',
              paddingBottom: '20px',
            }}
          >
            {getColumnsForBoard(selectedBoard.id).map((column) => (
              <div
                key={column.id}
                style={{
                  background: '#f8fafc',
                  borderRadius: '8px',
                  width: '320px',
                  minHeight: '500px',
                  padding: '12px',
                  boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
                }}
              >
                <div
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    marginBottom: '12px',
                  }}
                >
                  <h4>{column.title}</h4>
                  <button
                    onClick={() => {
                      if (window.confirm('Delete column and move cards?')) {
                        dispatch({
                          type: ActionTypes.DELETE_COLUMN,
                          payload: { columnId: column.id },
                        });
                      }
                    }}
                    style={{ color: 'red', background: 'none', border: 'none' }}
                  >
                    Ã—
                  </button>
                </div>

                {/* Cards */}
                {getCardsForColumn(column.id).map((card) => (
                  <div
                    key={card.id}
                    style={{
                      background: 'white',
                      borderRadius: '8px',
                      padding: '12px',
                      marginBottom: '12px',
                      boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                    }}
                  >
                    <strong>{card.title}</strong>

                    {card.description && (
                      <p
                        style={{
                          margin: '8px 0',
                          fontSize: '0.9em',
                          color: '#4b5563',
                        }}
                      >
                        {card.description}
                      </p>
                    )}

                    {card.tagIds.length > 0 && (
                      <div style={{ margin: '8px 0' }}>
                        {card.tagIds.map((tagId) => {
                          const tag = state.tags[tagId];
                          return tag ? (
                            <span
                              key={tagId}
                              style={{
                                background: tag.color,
                                color: 'white',
                                padding: '2px 8px',
                                borderRadius: '12px',
                                fontSize: '0.8em',
                                marginRight: '6px',
                              }}
                            >
                              {tag.name}
                            </span>
                          ) : null;
                        })}
                      </div>
                    )}

                    <div
                      style={{
                        marginTop: '12px',
                        fontSize: '0.85em',
                        color: '#6b7280',
                      }}
                    >
                      {card.dueDate && (
                        <div>
                          Due: {new Date(card.dueDate).toLocaleDateString()}
                        </div>
                      )}
                      {card.assignee && <div>Assignee: {card.assignee}</div>}
                    </div>

                    <div
                      style={{ marginTop: '12px', display: 'flex', gap: '8px' }}
                    >
                      <button
                        onClick={() => {
                          const title = prompt('New title:', card.title);
                          if (title)
                            dispatch(actions.editCard(card.id, { title }));
                        }}
                      >
                        Edit
                      </button>

                      <button
                        onClick={() => {
                          if (window.confirm('Delete card?')) {
                            dispatch(actions.deleteCard(card.id, column.id));
                          }
                        }}
                        style={{ color: 'red' }}
                      >
                        Delete
                      </button>

                      <select
                        value=''
                        onChange={(e) => {
                          const toColumnId = e.target.value;
                          if (toColumnId) {
                            dispatch(
                              actions.moveCard(card.id, column.id, toColumnId),
                            );
                          }
                        }}
                        style={{ marginLeft: 'auto' }}
                      >
                        <option value=''>Move to...</option>
                        {getColumnsForBoard(selectedBoard.id)
                          .filter((c) => c.id !== column.id)
                          .map((c) => (
                            <option
                              key={c.id}
                              value={c.id}
                            >
                              {c.title}
                            </option>
                          ))}
                      </select>
                    </div>
                  </div>
                ))}

                {/* Add Card */}
                <button
                  onClick={() => {
                    const title = prompt('Card title:');
                    if (title) {
                      dispatch(actions.addCard(column.id, title.trim()));
                    }
                  }}
                  style={{
                    width: '100%',
                    padding: '10px',
                    marginTop: '12px',
                    background: '#e5e7eb',
                    border: 'none',
                    borderRadius: '6px',
                    cursor: 'pointer',
                  }}
                >
                  + Add Card
                </button>
              </div>
            ))}

            {/* Add Column */}
            <button
              onClick={() => {
                const title = prompt('Column title:');
                if (title) {
                  dispatch(actions.addColumn(selectedBoard.id, title.trim()));
                }
              }}
              style={{
                width: '280px',
                height: '120px',
                background: '#f1f5f9',
                border: '2px dashed #9ca3af',
                borderRadius: '8px',
                fontSize: '1.1em',
                cursor: 'pointer',
              }}
            >
              + Add Column
            </button>
          </div>
        </>
      )}

      {!selectedBoard && state.allBoardIds.length === 0 && (
        <p style={{ textAlign: 'center', color: '#6b7280', marginTop: '60px' }}>
          Create your first board to get started
        </p>
      )}
    </div>
  );
}

/*
Káº¿t quáº£ vÃ­ dá»¥:

1. Nháº¥n "+ New Board" â†’ táº¡o "Project X"
2. Chá»n board â†’ tháº¥y nÃºt "+ Add Column"
3. Táº¡o 3 cá»™t: To Do, In Progress, Done
4. Trong cá»™t To Do â†’ "+ Add Card" â†’ "Implement login"
5. ThÃªm tag "Bug" (mÃ u Ä‘á») â†’ gÃ¡n tag vÃ o card
6. Táº¡o card khÃ¡c â†’ di chuyá»ƒn card sang "In Progress" qua dropdown
7. TÃ¬m kiáº¿m "login" â†’ chá»‰ hiá»‡n card liÃªn quan
8. XÃ³a tag "Bug" â†’ tag biáº¿n máº¥t khá»i táº¥t cáº£ card
9. XÃ³a column "Done" â†’ card trong Ä‘Ã³ bá»‹ xÃ³a
10. XÃ³a board â†’ toÃ n bá»™ columns + cards biáº¿n máº¥t
*/
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Nested vs Normalized State

| TiÃªu chÃ­                  | Nested State                    | Normalized State           | Winner     |
| ------------------------- | ------------------------------- | -------------------------- | ---------- |
| **Setup Complexity**      | âœ… ÄÆ¡n giáº£n, tá»± nhiÃªn           | âŒ Phá»©c táº¡p, cáº§n plan      | Nested     |
| **Update Performance**    | âŒ Clone entire tree            | âœ… Clone only changed part | Normalized |
| **Query Simplicity**      | âœ… Direct access: `user.posts`  | âŒ Need denormalize        | Nested     |
| **Data Duplication**      | âŒ Duplicate data across tree   | âœ… No duplication          | Normalized |
| **Deeply Nested Updates** | âŒ Nightmare (4+ levels)        | âœ… Simple (1 level)        | Normalized |
| **Consistency**           | âŒ Same data in multiple places | âœ… Single source of truth  | Normalized |
| **Learning Curve**        | âœ… Easy to understand           | âŒ Cáº§n hiá»ƒu pattern        | Nested     |
| **Scalability**           | âŒ Slow khi data grows          | âœ… Scales well             | Normalized |
| **TypeScript Support**    | âš ï¸ Complex nested types         | âœ… Simple flat types       | Normalized |
| **Testing**               | âŒ Pháº£i setup entire tree       | âœ… Test isolated parts     | Normalized |

### Decision Tree: Nested vs Normalized?

```
START: Thiáº¿t káº¿ state structure?
â”‚
â”œâ”€ Data Ä‘Æ¡n giáº£n (1-2 levels nesting)?
â”‚  â””â”€ YES â†’ Nested State âœ…
â”‚     Example: { user: { name, settings: { theme } } }
â”‚
â”œâ”€ Data Ä‘Æ°á»£c update thÆ°á»ng xuyÃªn?
â”‚  â””â”€ YES â†’ Normalized State âœ…
â”‚     Reason: Fast updates quan trá»ng
â”‚
â”œâ”€ Data cÃ³ relationships phá»©c táº¡p?
â”‚  (Many-to-many, bidirectional)
â”‚  â””â”€ YES â†’ Normalized State âœ…
â”‚     Example: Users â†” Posts â†” Comments
â”‚
â”œâ”€ Data tree sÃ¢u (3+ levels)?
â”‚  â””â”€ YES â†’ Normalized State âœ…
â”‚     Reason: Avoid nested update hell
â”‚
â”œâ”€ Data cÃ³ duplication?
â”‚  (Same object in multiple places)
â”‚  â””â”€ YES â†’ Normalized State âœ…
â”‚     Example: Author info duplicated in posts
â”‚
â”œâ”€ Primarily read-only data?
â”‚  â””â”€ YES â†’ Nested State âœ…
â”‚     Example: Config, static content
â”‚
â”œâ”€ Need to reference same item tá»« multiple places?
â”‚  â””â”€ YES â†’ Normalized State âœ…
â”‚     Example: Tag referenced by multiple posts
â”‚
â””â”€ NOT SURE?
   â†’ Start Nested (simple)
   â†’ Refactor to Normalized khi:
      - Updates become slow
      - Code becomes messy
      - Data duplication issues
```

### Action Creators: Pros & Cons

| Approach            | Code                                            | Pros                                                                   | Cons                                                | Use When               |
| ------------------- | ----------------------------------------------- | ---------------------------------------------------------------------- | --------------------------------------------------- | ---------------------- |
| **Inline Objects**  | `dispatch({ type: 'ADD', payload: {...} })`     | â€¢ Ãt code<br>â€¢ Trá»±c quan                                               | â€¢ Typo risk<br>â€¢ Duplicate logic<br>â€¢ Hard refactor | Prototype, simple apps |
| **Constants**       | `dispatch({ type: Types.ADD, payload: {...} })` | â€¢ Autocomplete<br>â€¢ Catch typos                                        | â€¢ Still duplicate payload logic                     | Small-medium apps      |
| **Action Creators** | `dispatch(actions.add(data))`                   | â€¢ No duplication<br>â€¢ Consistent payload<br>â€¢ Easy test<br>â€¢ Type-safe | â€¢ More boilerplate                                  | Medium-large apps      |

### Reducer Composition Patterns

**Pattern 1: Domain-Based Split**

```jsx
// âœ… GOOD: Split by domain
rootReducer = {
  users: usersReducer,
  posts: postsReducer,
  comments: commentsReducer,
}

// Use: State shape mirrors reducers
state.users â†’ handled by usersReducer
state.posts â†’ handled by postsReducer
```

**Pattern 2: Feature-Based Split**

```jsx
// âœ… GOOD: Split by feature
rootReducer = {
  auth: authReducer,
  dashboard: dashboardReducer,
  settings: settingsReducer,
};

// Use: Feature isolation
```

**Pattern 3: Hybrid**

```jsx
// âœ… GOOD: Domain + Feature
rootReducer = {
  // Shared data
  entities: entitiesReducer, // users, posts, comments

  // Feature-specific
  auth: authReducer,
  ui: uiReducer,
};
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Incorrect Normalization ğŸ›

```jsx
// âŒ CODE Bá»Š Lá»–I
const state = {
  posts: {
    1: {
      id: 1,
      title: 'Hello',
      author: { id: 'user1', name: 'Alice' }, // ğŸ› Nested author!
      comments: [
        { id: 'c1', text: 'Nice!' }, // ğŸ› Nested comments!
      ],
    },
  },
};

function reducer(state, action) {
  switch (action.type) {
    case 'UPDATE_USER_NAME': {
      // ğŸ› Pháº£i update á»Ÿ nhiá»u chá»—!
      const newPosts = {};
      Object.keys(state.posts).forEach((postId) => {
        const post = state.posts[postId];
        if (post.author.id === action.userId) {
          newPosts[postId] = {
            ...post,
            author: { ...post.author, name: action.name },
          };
        } else {
          newPosts[postId] = post;
        }
      });
      return { ...state, posts: newPosts };
    }
  }
}
```

**â“ CÃ¢u há»i:**

1. Váº¥n Ä‘á» gÃ¬ vá»›i state structure?
2. Táº¡i sao update user name phá»©c táº¡p?
3. Fix nhÆ° tháº¿ nÃ o?

**ğŸ’¡ Giáº£i thÃ­ch:**

- Author nested â†’ duplicated trong má»—i post
- Update name â†’ pháº£i traverse táº¥t cáº£ posts
- Comments nested â†’ khÃ³ update individual comment

**âœ… Fix:**

```jsx
// âœ… Normalized state
const state = {
  users: {
    user1: { id: 'user1', name: 'Alice' },
  },
  posts: {
    1: { id: 1, title: 'Hello', authorId: 'user1', commentIds: ['c1'] },
  },
  comments: {
    c1: { id: 'c1', text: 'Nice!', authorId: 'user1' },
  },
};

function reducer(state, action) {
  switch (action.type) {
    case 'UPDATE_USER_NAME': {
      // âœ… Simple! Update 1 chá»—
      return {
        ...state,
        users: {
          ...state.users,
          [action.userId]: {
            ...state.users[action.userId],
            name: action.name,
          },
        },
      };
    }
  }
}
```

### Bug 2: Broken Cascade Delete ğŸ›

```jsx
// âŒ CODE Bá»Š Lá»–I
function reducer(state, action) {
  switch (action.type) {
    case 'DELETE_POST': {
      const { postId } = action.payload;

      // ğŸ› Delete post nhÆ°ng comments váº«n cÃ²n!
      const { [postId]: deleted, ...remainingPosts } = state.posts;

      return {
        ...state,
        posts: remainingPosts,
        // ğŸ› Comments orphaned! postCommentIds not cleaned!
      };
    }
  }
}

// State after delete:
// {
//   posts: {}, // Post deleted
//   comments: { 1001: {...}, 1002: {...} }, // Comments still here!
//   postCommentIds: { 101: [1001, 1002] } // Reference still here!
// }
```

**â“ CÃ¢u há»i:**

1. Váº¥n Ä‘á» gÃ¬ xáº£y ra sau khi delete post?
2. Memory leak á»Ÿ Ä‘Ã¢u?
3. Fix nhÆ° tháº¿ nÃ o?

**ğŸ’¡ Giáº£i thÃ­ch:**

- Delete post nhÆ°ng khÃ´ng delete comments â†’ orphaned data
- postCommentIds cÃ²n reference â†’ memory leak
- Display UI sáº½ error (render comment cá»§a post khÃ´ng tá»“n táº¡i)

**âœ… Fix:**

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'DELETE_POST': {
      const { postId } = action.payload;

      // 1ï¸âƒ£ Get comments to delete
      const commentIds = state.postCommentIds[postId] || [];

      // 2ï¸âƒ£ Delete post
      const { [postId]: deletedPost, ...remainingPosts } = state.posts;

      // 3ï¸âƒ£ Delete comments
      const newComments = { ...state.comments };
      commentIds.forEach((commentId) => {
        delete newComments[commentId];
      });

      // 4ï¸âƒ£ Delete postCommentIds entry
      const { [postId]: deletedIds, ...remainingPostCommentIds } =
        state.postCommentIds;

      return {
        ...state,
        posts: remainingPosts,
        comments: newComments,
        postCommentIds: remainingPostCommentIds,
      };
    }
  }
}
```

### Bug 3: Action Type Typo ğŸ›

```jsx
// âŒ CODE Bá»Š Lá»–I
// actions.js
const ActionTypes = {
  ADD_TODO: 'ADD_TODO',
  TOGGLE_TODO: 'TOGGLE_TODO',
  DELETE_TODO: 'DELETE_TODO',
};

// reducer.js
function reducer(state, action) {
  switch (action.type) {
    case ActionTypes.ADD_TODO: return ...;
    case ActionTypes.TOGGLE_TODO: return ...;
    case 'DELETE_TODO': return ...; // ğŸ› Magic string thay vÃ¬ constant!
  }
}

// component.js
dispatch({ type: 'DELET_TODO', payload: { id: 1 } }); // ğŸ› Typo!
// â†’ Hit default case â†’ throw error: "Unknown action: DELET_TODO"
// â†’ KhÃ³ debug vÃ¬ khÃ´ng biáº¿t typo á»Ÿ Ä‘Ã¢u
```

**â“ CÃ¢u há»i:**

1. Váº¥n Ä‘á» gÃ¬ vá»›i code?
2. LÃ m sao prevent typos?
3. Best practice?

**ğŸ’¡ Giáº£i thÃ­ch:**

- Magic strings â†’ typo khÃ´ng catch Ä‘Æ°á»£c
- Reducer dÃ¹ng constant, component dÃ¹ng string â†’ inconsistent
- Refactor action type name â†’ pháº£i find/replace everywhere

**âœ… Fix:**

```jsx
// âœ… ALWAYS use constants + action creators

// constants.js
export const ActionTypes = {
  ADD_TODO: 'ADD_TODO',
  TOGGLE_TODO: 'TOGGLE_TODO',
  DELETE_TODO: 'DELETE_TODO',
};

// actions.js
export const actions = {
  addTodo: (text) => ({
    type: ActionTypes.ADD_TODO,
    payload: { text },
  }),

  toggleTodo: (id) => ({
    type: ActionTypes.TOGGLE_TODO,
    payload: { id },
  }),

  deleteTodo: (id) => ({
    type: ActionTypes.DELETE_TODO,
    payload: { id },
  }),
};

// reducer.js
import { ActionTypes } from './constants';

function reducer(state, action) {
  switch (action.type) {
    case ActionTypes.ADD_TODO: return ...;
    case ActionTypes.TOGGLE_TODO: return ...;
    case ActionTypes.DELETE_TODO: return ...; // âœ… Consistent!
  }
}

// component.js
import { actions } from './actions';

dispatch(actions.deleteTodo(1)); // âœ… Type-safe, no typos!
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u âœ… khi báº¡n tá»± tin:

**State Normalization:**

- [ ] TÃ´i hiá»ƒu normalized state lÃ  gÃ¬
- [ ] TÃ´i biáº¿t khi nÃ o nÃªn normalize
- [ ] TÃ´i biáº¿t cÃ¡ch normalize nested data
- [ ] TÃ´i biáº¿t cÃ¡ch denormalize Ä‘á»ƒ display
- [ ] TÃ´i hiá»ƒu trade-offs: nested vs normalized

**Action Management:**

- [ ] TÃ´i dÃ¹ng action type constants thay vÃ¬ magic strings
- [ ] TÃ´i biáº¿t cÃ¡ch táº¡o action creators
- [ ] TÃ´i hiá»ƒu lá»£i Ã­ch cá»§a action creators
- [ ] TÃ´i biáº¿t cÃ¡ch organize action types (enum pattern)

**Reducer Composition:**

- [ ] TÃ´i biáº¿t khi nÃ o split reducer
- [ ] TÃ´i biáº¿t cÃ¡ch combine reducers manually
- [ ] TÃ´i hiá»ƒu domain-based vs feature-based split
- [ ] TÃ´i biáº¿t cÃ¡ch handle cross-domain actions

**Edge Cases:**

- [ ] TÃ´i biáº¿t cÃ¡ch cascade delete trong normalized state
- [ ] TÃ´i biáº¿t cÃ¡ch handle orphaned data
- [ ] TÃ´i biáº¿t cÃ¡ch update relationships (many-to-many)

### Code Review Checklist

**State Structure:**

- [ ] Flat structure cho large/complex data
- [ ] Entities keyed by ID (object, not array)
- [ ] No duplication (references by ID)
- [ ] Separate ordering arrays (`allIds`) náº¿u cáº§n

**Actions:**

- [ ] All action types lÃ  constants
- [ ] Action creators cho complex payloads
- [ ] Payload structures consistent
- [ ] Action creators documented

**Reducers:**

- [ ] Each reducer < 150 lines
- [ ] Clear domain boundaries
- [ ] Cross-domain logic documented
- [ ] Cascade deletes handled
- [ ] Immutable updates

**Code Quality:**

- [ ] No magic strings
- [ ] Clear naming (ActionTypes, actions, reducers)
- [ ] Comments cho complex logic
- [ ] Helper functions extracted

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**BÃ i 1: Normalize Nested State**

Cho nested state sau:

```jsx
const nestedState = {
  categories: [
    {
      id: 1,
      name: 'Electronics',
      products: [
        {
          id: 101,
          name: 'iPhone',
          price: 999,
          reviews: [
            {
              id: 1001,
              rating: 5,
              text: 'Great!',
              user: { id: 'u1', name: 'Alice' },
            },
            {
              id: 1002,
              rating: 4,
              text: 'Good',
              user: { id: 'u2', name: 'Bob' },
            },
          ],
        },
        {
          id: 102,
          name: 'iPad',
          price: 799,
          reviews: [],
        },
      ],
    },
    {
      id: 2,
      name: 'Books',
      products: [
        {
          id: 201,
          name: 'React Book',
          price: 49,
          reviews: [
            {
              id: 2001,
              rating: 5,
              text: 'Must read!',
              user: { id: 'u1', name: 'Alice' },
            },
          ],
        },
      ],
    },
  ],
};
```

**Nhiá»‡m vá»¥:**

1. Design normalized state structure
2. Write reducer vá»›i actions:
   - ADD_REVIEW (thÃªm review vÃ o product)
   - UPDATE_PRODUCT_PRICE
   - DELETE_CATEGORY (cascade delete products & reviews)
3. Write helper function: `getProductWithReviews(productId)`

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * BÃ i táº­p vá» nhÃ  - Normalize Nested State (Categories â†’ Products â†’ Reviews)
 *
 * 1. Normalized state structure
 * 2. Reducer há»— trá»£:
 *    - ADD_REVIEW
 *    - UPDATE_PRODUCT_PRICE
 *    - DELETE_CATEGORY (cascade delete products & reviews)
 * 3. Helper: getProductWithReviews(productId)
 *
 * @returns {JSX.Element}
 */
function NormalizedEcommerceDemo() {
  // â”€â”€ Action Type Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ActionTypes = {
    ADD_REVIEW: 'ADD_REVIEW',
    UPDATE_PRODUCT_PRICE: 'UPDATE_PRODUCT_PRICE',
    DELETE_CATEGORY: 'DELETE_CATEGORY',
  };

  // â”€â”€ Action Creators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const actions = {
    addReview: (productId, rating, text, userId) => ({
      type: ActionTypes.ADD_REVIEW,
      payload: {
        id: 'r_' + Date.now(),
        productId,
        rating,
        text,
        userId,
        createdAt: new Date().toISOString(),
      },
    }),

    updateProductPrice: (productId, newPrice) => ({
      type: ActionTypes.UPDATE_PRODUCT_PRICE,
      payload: { productId, newPrice },
    }),

    deleteCategory: (categoryId) => ({
      type: ActionTypes.DELETE_CATEGORY,
      payload: { categoryId },
    }),
  };

  // â”€â”€ Normalized Initial State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const initialState = {
    categories: {
      1: { id: '1', name: 'Electronics' },
      2: { id: '2', name: 'Books' },
    },
    products: {
      101: { id: '101', name: 'iPhone', price: 999, categoryId: '1' },
      102: { id: '102', name: 'iPad', price: 799, categoryId: '1' },
      201: { id: '201', name: 'React Book', price: 49, categoryId: '2' },
    },
    reviews: {},
    categoryProductIds: {
      1: ['101', '102'],
      2: ['201'],
    },
    productReviewIds: {
      101: [],
      102: [],
      201: [],
    },
    users: {
      u1: { id: 'u1', name: 'Alice' },
      u2: { id: 'u2', name: 'Bob' },
    },
  };

  // â”€â”€ Reducer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const reducer = (state, action) => {
    switch (action.type) {
      case ActionTypes.ADD_REVIEW: {
        const { id, productId, rating, text, userId, createdAt } =
          action.payload;

        return {
          ...state,
          reviews: {
            ...state.reviews,
            [id]: { id, productId, rating, text, userId, createdAt },
          },
          productReviewIds: {
            ...state.productReviewIds,
            [productId]: [...(state.productReviewIds[productId] || []), id],
          },
        };
      }

      case ActionTypes.UPDATE_PRODUCT_PRICE: {
        const { productId, newPrice } = action.payload;

        return {
          ...state,
          products: {
            ...state.products,
            [productId]: {
              ...state.products[productId],
              price: newPrice,
            },
          },
        };
      }

      case ActionTypes.DELETE_CATEGORY: {
        const { categoryId } = action.payload;

        // 1. Láº¥y táº¥t cáº£ product IDs trong category
        const productIds = state.categoryProductIds[categoryId] || [];

        // 2. XÃ³a cÃ¡c reviews cá»§a cÃ¡c product Ä‘Ã³
        const newReviews = { ...state.reviews };
        const newProductReviewIds = { ...state.productReviewIds };
        productIds.forEach((productId) => {
          const reviewIds = state.productReviewIds[productId] || [];
          reviewIds.forEach((reviewId) => delete newReviews[reviewId]);
          delete newProductReviewIds[productId];
        });

        // 3. XÃ³a cÃ¡c products
        const newProducts = { ...state.products };
        productIds.forEach((productId) => delete newProducts[productId]);

        // 4. XÃ³a category vÃ  má»‘i quan há»‡
        const { [categoryId]: removedCategory, ...restCategories } =
          state.categories;
        const { [categoryId]: removedProductIds, ...restCategoryProductIds } =
          state.categoryProductIds;

        return {
          ...state,
          categories: restCategories,
          products: newProducts,
          reviews: newReviews,
          categoryProductIds: restCategoryProductIds,
          productReviewIds: newProductReviewIds,
        };
      }

      default:
        return state;
    }
  };

  const [state, dispatch] = React.useReducer(reducer, initialState);

  // â”€â”€ Helper: Denormalize product + reviews â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const getProductWithReviews = (productId) => {
    const product = state.products[productId];
    if (!product) return null;

    const reviewIds = state.productReviewIds[productId] || [];
    const reviews = reviewIds.map((id) => {
      const review = state.reviews[id];
      return {
        ...review,
        user: state.users[review.userId],
      };
    });

    const category = state.categories[product.categoryId];

    return {
      ...product,
      category,
      reviews,
    };
  };

  // â”€â”€ UI Demo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  return (
    <div style={{ fontFamily: 'system-ui', padding: '20px' }}>
      <h2>Normalized E-commerce State Demo</h2>

      <div
        style={{
          margin: '20px 0',
          display: 'flex',
          gap: '16px',
          flexWrap: 'wrap',
        }}
      >
        {/* Hiá»ƒn thá»‹ táº¥t cáº£ products */}
        {Object.values(state.products).map((product) => {
          const fullProduct = getProductWithReviews(product.id);
          return (
            <div
              key={product.id}
              style={{
                border: '1px solid #d1d5db',
                borderRadius: '8px',
                padding: '16px',
                width: '320px',
              }}
            >
              <h4>{fullProduct.name}</h4>
              <p>Category: {fullProduct.category?.name}</p>
              <p>
                Price: <strong>${fullProduct.price}</strong>
              </p>

              <button
                onClick={() => {
                  const newPrice = prompt('New price:', fullProduct.price);
                  if (newPrice && !isNaN(newPrice)) {
                    dispatch(
                      actions.updateProductPrice(product.id, Number(newPrice)),
                    );
                  }
                }}
              >
                Update Price
              </button>

              <div style={{ marginTop: '16px' }}>
                <h5>Reviews ({fullProduct.reviews.length})</h5>
                {fullProduct.reviews.map((review) => (
                  <div
                    key={review.id}
                    style={{ margin: '8px 0', fontSize: '0.95em' }}
                  >
                    <strong>{review.user.name}</strong> ({review.rating}â˜…):{' '}
                    {review.text}
                  </div>
                ))}

                <button
                  onClick={() => {
                    const text = prompt('Your review:');
                    const rating = prompt('Rating (1-5):');
                    if (
                      text &&
                      rating &&
                      ['1', '2', '3', '4', '5'].includes(rating)
                    ) {
                      dispatch(
                        actions.addReview(
                          product.id,
                          Number(rating),
                          text,
                          Math.random() > 0.5 ? 'u1' : 'u2', // random user
                        ),
                      );
                    }
                  }}
                  style={{ marginTop: '8px' }}
                >
                  Add Review
                </button>
              </div>
            </div>
          );
        })}
      </div>

      <div style={{ marginTop: '40px' }}>
        <h3>Actions</h3>
        <button
          onClick={() => {
            if (
              window.confirm(
                'Delete Electronics category and all its products & reviews?',
              )
            ) {
              dispatch(actions.deleteCategory('1'));
            }
          }}
          style={{
            background: '#ef4444',
            color: 'white',
            padding: '10px 16px',
            border: 'none',
            borderRadius: '6px',
          }}
        >
          Delete Electronics Category
        </button>
      </div>

      <pre
        style={{
          marginTop: '40px',
          background: '#f8f9fa',
          padding: '16px',
          borderRadius: '8px',
        }}
      >
        {JSON.stringify(state, null, 2)}
      </pre>
    </div>
  );
}

/*
Káº¿t quáº£ vÃ­ dá»¥:

Ban Ä‘áº§u:
- iPhone $999, 0 reviews
- iPad $799, 0 reviews
- React Book $49, 0 reviews

Thao tÃ¡c:
1. Update price iPhone â†’ 1099 â†’ giÃ¡ thay Ä‘á»•i ngay láº­p tá»©c
2. Add review cho iPhone: "Great phone!" 5â˜… â†’ review xuáº¥t hiá»‡n
3. Add review khÃ¡c cho iPhone â†’ danh sÃ¡ch reviews tÄƒng
4. Delete category "Electronics" â†’ iPhone & iPad + táº¥t cáº£ reviews cá»§a chÃºng biáº¿n máº¥t
   React Book váº«n cÃ²n vÃ¬ thuá»™c category khÃ¡c
*/
```

</details>

### NÃ¢ng cao (60 phÃºt)

**BÃ i 2: Build Reddit-like Comment System**

Requirements:

1. Posts cÃ³ nested comments (unlimited depth)
2. Comments cÃ³ replies (cÅ©ng lÃ  comments)
3. User cÃ³ thá»ƒ upvote/downvote comments
4. Display comment tree with indentation

State structure gá»£i Ã½:

```jsx
{
  posts: { [id]: { id, title, content, commentIds } },
  comments: {
    [id]: {
      id,
      text,
      authorId,
      postId,
      parentId, // null náº¿u top-level, commentId náº¿u reply
      replyIds: [], // Array of reply comment IDs
      upvotes: 0,
      downvotes: 0
    }
  },
  users: { [id]: { id, name } }
}
```

Actions:

- ADD_COMMENT (cÃ³ thá»ƒ lÃ  top-level hoáº·c reply)
- EDIT_COMMENT
- DELETE_COMMENT (cascade delete replies)
- UPVOTE_COMMENT
- DOWNVOTE_COMMENT

Challenges:

- Nested comments display (recursive component)
- Cascade delete vá»›i unlimited depth
- Calculate total replies count

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * BÃ i táº­p vá» nhÃ  - Reddit-like Comment System (Nested comments, unlimited depth)
 *
 * Features:
 * - Posts cÃ³ comments + replies (recursive)
 * - Upvote / Downvote comments
 * - Add comment (top-level hoáº·c reply)
 * - Edit comment
 * - Delete comment (cascade delete replies)
 * - Hiá»ƒn thá»‹ comment tree vá»›i indentation
 *
 * @returns {JSX.Element}
 */
function RedditCommentsDemo() {
  // â”€â”€ Action Type Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const ActionTypes = {
    ADD_COMMENT: 'ADD_COMMENT',
    EDIT_COMMENT: 'EDIT_COMMENT',
    DELETE_COMMENT: 'DELETE_COMMENT',
    UPVOTE_COMMENT: 'UPVOTE_COMMENT',
    DOWNVOTE_COMMENT: 'DOWNVOTE_COMMENT',
  };

  // â”€â”€ Action Creators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const actions = {
    addComment: (postId, parentId, text, authorId = 'u1') => ({
      type: ActionTypes.ADD_COMMENT,
      payload: {
        id: 'c_' + Date.now(),
        postId,
        parentId: parentId || null,
        text,
        authorId,
        timestamp: new Date().toISOString(),
        upvotes: 0,
        downvotes: 0,
      },
    }),

    editComment: (commentId, newText) => ({
      type: ActionTypes.EDIT_COMMENT,
      payload: { commentId, newText },
    }),

    deleteComment: (commentId) => ({
      type: ActionTypes.DELETE_COMMENT,
      payload: { commentId },
    }),

    upvoteComment: (commentId) => ({
      type: ActionTypes.UPVOTE_COMMENT,
      payload: { commentId },
    }),

    downvoteComment: (commentId) => ({
      type: ActionTypes.DOWNVOTE_COMMENT,
      payload: { commentId },
    }),
  };

  // â”€â”€ Initial State (Normalized) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const initialState = {
    posts: {
      p1: {
        id: 'p1',
        title: 'React vs Vue in 2026 â€“ which one are you using?',
        content: 'Letâ€™s discuss the current state of these frameworks...',
        commentIds: [],
      },
    },
    comments: {}, // { commentId: { id, text, authorId, postId, parentId, replyIds, upvotes, downvotes, timestamp } }
    users: {
      u1: { id: 'u1', name: 'Alice', avatar: 'ğŸ‘©' },
      u2: { id: 'u2', name: 'Bob', avatar: 'ğŸ‘¨' },
      u3: { id: 'u3', name: 'Charlie', avatar: 'ğŸ§‘' },
    },
  };

  // â”€â”€ Reducer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const reducer = (state, action) => {
    switch (action.type) {
      case ActionTypes.ADD_COMMENT: {
        const { id, postId, parentId, text, authorId, timestamp } =
          action.payload;

        const newComment = {
          id,
          postId,
          parentId,
          text,
          authorId,
          timestamp,
          upvotes: 0,
          downvotes: 0,
          replyIds: [],
        };

        // ThÃªm vÃ o comments
        let newState = {
          ...state,
          comments: {
            ...state.comments,
            [id]: newComment,
          },
        };

        // Cáº­p nháº­t replyIds cá»§a parent (náº¿u lÃ  reply)
        if (parentId) {
          newState = {
            ...newState,
            comments: {
              ...newState.comments,
              [parentId]: {
                ...newState.comments[parentId],
                replyIds: [...(newState.comments[parentId].replyIds || []), id],
              },
            },
          };
        }
        // Cáº­p nháº­t commentIds cá»§a post (náº¿u lÃ  top-level)
        else {
          newState = {
            ...newState,
            posts: {
              ...newState.posts,
              [postId]: {
                ...newState.posts[postId],
                commentIds: [...(newState.posts[postId].commentIds || []), id],
              },
            },
          };
        }

        return newState;
      }

      case ActionTypes.EDIT_COMMENT: {
        const { commentId, newText } = action.payload;
        return {
          ...state,
          comments: {
            ...state.comments,
            [commentId]: {
              ...state.comments[commentId],
              text: newText,
              editedAt: new Date().toISOString(),
            },
          },
        };
      }

      case ActionTypes.DELETE_COMMENT: {
        const { commentId } = action.payload;

        // Thu tháº­p táº¥t cáº£ comment IDs cáº§n xÃ³a (cascade)
        const toDelete = new Set([commentId]);
        const queue = [commentId];

        while (queue.length > 0) {
          const current = queue.shift();
          const comment = state.comments[current];
          if (comment?.replyIds) {
            comment.replyIds.forEach((rid) => {
              if (!toDelete.has(rid)) {
                toDelete.add(rid);
                queue.push(rid);
              }
            });
          }
        }

        // XÃ³a comments
        const newComments = { ...state.comments };
        toDelete.forEach((id) => delete newComments[id]);

        // Cáº­p nháº­t parent (náº¿u cÃ³)
        const parentId = state.comments[commentId]?.parentId;
        if (parentId) {
          newComments[parentId] = {
            ...newComments[parentId],
            replyIds: (newComments[parentId].replyIds || []).filter(
              (id) => !toDelete.has(id),
            ),
          };
        }
        // Cáº­p nháº­t post (náº¿u top-level)
        else {
          const postId = state.comments[commentId]?.postId;
          if (postId) {
            const post = state.posts[postId];
            state.posts[postId] = {
              ...post,
              commentIds: (post.commentIds || []).filter(
                (id) => !toDelete.has(id),
              ),
            };
          }
        }

        return {
          ...state,
          comments: newComments,
        };
      }

      case ActionTypes.UPVOTE_COMMENT:
      case ActionTypes.DOWNVOTE_COMMENT: {
        const { commentId } = action.payload;
        const field =
          action.type === ActionTypes.UPVOTE_COMMENT ? 'upvotes' : 'downvotes';

        return {
          ...state,
          comments: {
            ...state.comments,
            [commentId]: {
              ...state.comments[commentId],
              [field]: (state.comments[commentId][field] || 0) + 1,
            },
          },
        };
      }

      default:
        return state;
    }
  };

  const [state, dispatch] = React.useReducer(reducer, initialState);

  // â”€â”€ Recursive Comment Component â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function Comment({ commentId, depth = 0 }) {
    const comment = state.comments[commentId];
    if (!comment) return null;

    const author = state.users[comment.authorId];
    const score = comment.upvotes - comment.downvotes;

    return (
      <div style={{ marginLeft: `${depth * 24}px`, marginBottom: '16px' }}>
        <div
          style={{
            borderLeft: depth > 0 ? '2px solid #d1d5db' : 'none',
            paddingLeft: depth > 0 ? '16px' : '0',
          }}
        >
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
              marginBottom: '4px',
            }}
          >
            <strong>{author.name}</strong>
            <span style={{ color: '#6b7280', fontSize: '0.85em' }}>
              â€¢{' '}
              {new Date(comment.timestamp).toLocaleString([], {
                dateStyle: 'short',
                timeStyle: 'short',
              })}
              {comment.editedAt && ' (edited)'}
            </span>
          </div>

          <p style={{ margin: '4px 0 8px' }}>{comment.text}</p>

          <div
            style={{
              display: 'flex',
              gap: '16px',
              fontSize: '0.9em',
              color: '#4b5563',
            }}
          >
            <button onClick={() => dispatch(actions.upvoteComment(commentId))}>
              â–² {comment.upvotes}
            </button>
            <button
              onClick={() => dispatch(actions.downvoteComment(commentId))}
            >
              â–¼ {comment.downvotes}
            </button>
            <span>Score: {score}</span>

            <button
              onClick={() => {
                const text = prompt('Reply:', '');
                if (text?.trim()) {
                  dispatch(
                    actions.addComment(comment.postId, comment.id, text.trim()),
                  );
                }
              }}
            >
              Reply
            </button>

            <button
              onClick={() => {
                const newText = prompt('Edit comment:', comment.text);
                if (newText?.trim() && newText !== comment.text) {
                  dispatch(actions.editComment(comment.id, newText.trim()));
                }
              }}
            >
              Edit
            </button>

            <button
              onClick={() => {
                if (window.confirm('Delete this comment and all replies?')) {
                  dispatch(actions.deleteComment(comment.id));
                }
              }}
              style={{ color: '#ef4444' }}
            >
              Delete
            </button>
          </div>

          {/* Replies */}
          {comment.replyIds?.length > 0 && (
            <div style={{ marginTop: '12px' }}>
              {comment.replyIds.map((replyId) => (
                <Comment
                  key={replyId}
                  commentId={replyId}
                  depth={depth + 1}
                />
              ))}
            </div>
          )}
        </div>
      </div>
    );
  }

  // â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const post = state.posts.p1;
  const topLevelComments = (post.commentIds || [])
    .map((id) => state.comments[id])
    .filter(Boolean);

  return (
    <div
      style={{
        maxWidth: '800px',
        margin: '0 auto',
        padding: '20px',
        fontFamily: 'system-ui',
      }}
    >
      <h1>{post.title}</h1>
      <p style={{ color: '#4b5563' }}>{post.content}</p>

      <div style={{ marginTop: '32px' }}>
        <h3>Comments ({topLevelComments.length})</h3>

        <div style={{ margin: '16px 0' }}>
          <textarea
            id='topComment'
            placeholder='What are your thoughts?'
            style={{
              width: '100%',
              minHeight: '80px',
              padding: '12px',
              borderRadius: '8px',
              border: '1px solid #d1d5db',
            }}
          />
          <button
            onClick={() => {
              const input = document.getElementById('topComment');
              if (input.value.trim()) {
                dispatch(actions.addComment('p1', null, input.value.trim()));
                input.value = '';
              }
            }}
            style={{
              marginTop: '8px',
              padding: '8px 16px',
              background: '#3b82f6',
              color: 'white',
              border: 'none',
              borderRadius: '6px',
              cursor: 'pointer',
            }}
          >
            Comment
          </button>
        </div>

        <div>
          {topLevelComments.map((comment) => (
            <Comment
              key={comment.id}
              commentId={comment.id}
              depth={0}
            />
          ))}
        </div>

        {topLevelComments.length === 0 && (
          <p
            style={{ color: '#6b7280', textAlign: 'center', marginTop: '40px' }}
          >
            Be the first to comment!
          </p>
        )}
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ vÃ­ dá»¥:

1. GÃµ "Vue still has better DX in 2026" â†’ Comment â†’ xuáº¥t hiá»‡n top-level comment
2. Nháº¥n Reply dÆ°á»›i comment â†’ gÃµ "Nah, React Server Components win" â†’ reply xuáº¥t hiá»‡n thá»¥t vÃ o
3. Reply tiáº¿p dÆ°á»›i reply â†’ táº¡o depth 3
4. Upvote / Downvote â†’ score thay Ä‘á»•i
5. Edit comment â†’ text cáº­p nháº­t + (edited)
6. Delete comment á»Ÿ depth 2 â†’ toÃ n bá»™ subtree (náº¿u cÃ³ replies) bá»‹ xÃ³a
*/
```

</details>

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **Normalizing State Shape:**
   - https://redux.js.org/usage/structuring-reducers/normalizing-state-shape
   - Ãp dá»¥ng cho useReducer (khÃ´ng cáº§n Redux)

2. **React Docs - Extracting State Logic:**
   - https://react.dev/learn/extracting-state-logic-into-a-reducer
   - Pháº§n "Comparing useState and useReducer"

### Äá»c thÃªm

3. **Immutable Update Patterns:**
   - https://redux.js.org/usage/structuring-reducers/immutable-update-patterns
   - Deep updates, arrays, objects

4. **Reducer Composition:**
   - https://redux.js.org/usage/structuring-reducers/splitting-reducer-logic
   - Pattern Ã¡p dá»¥ng Ä‘Æ°á»£c cho useReducer

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (ÄÃ£ há»c)

- **NgÃ y 26:** useReducer Fundamentals
  - HÃ´m nay build trÃªn ná»n Ä‘Ã³: advanced patterns
  - Reducer basics â†’ Now: complex state structures

- **NgÃ y 1-2:** ES6 Destructuring, Spread
  - Critical cho immutable updates
  - `const { [id]: deleted, ...rest } = state.items`

- **NgÃ y 31-34:** Performance (memo, useMemo)
  - Normalized state â†’ fast updates
  - Denormalize helpers â†’ useMemo

### HÆ°á»›ng tá»›i (Sáº½ há»c)

- **NgÃ y 28:** useReducer + useEffect
  - Data fetching patterns
  - Normalize API responses
  - Loading/error states trong reducer

- **NgÃ y 29:** Custom Hooks vá»›i useReducer
  - useNormalizedData hook
  - useEntityManager hook
  - Reusable state management

- **Phase 5:** Context API
  - Context + useReducer = Global state
  - Alternative to Redux
  - Normalized state globally

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. Khi nÃ o KHÃ”NG normalize:**

```jsx
// âœ… GOOD: Nested OK cho read-only config
const themeConfig = {
  light: {
    colors: { primary: '#007bff', secondary: '#6c757d' },
    fonts: { heading: 'Arial', body: 'Helvetica' },
  },
  dark: {
    /* ... */
  },
};

// âŒ BAD: Normalize sáº½ over-engineering
// {
//   themes: { light: {...}, dark: {...} },
//   colors: { primary_light: '#007bff', ... },
//   fonts: { heading_light: 'Arial', ... }
// }
```

**2. Normalization levels:**

```jsx
// Level 1: Flat entities
{ users: {...}, posts: {...}, comments: {...} }

// Level 2: Relationships tracked
{ users: {...}, posts: {...}, userPostIds: {...} }

// Level 3: Full relational (nhÆ° database)
// with indexes, lookups, etc.

// â†’ Chá»n level phÃ¹ há»£p vá»›i complexity
```

**3. Migration strategy:**

```jsx
// âŒ DON'T: Refactor everything at once
// âœ… DO: Migrate gradually

// Step 1: Add normalized entities alongside nested
const state = {
  // Old (keep working)
  users: [...nested...],

  // New (add gradually)
  normalizedUsers: {...},
};

// Step 2: Migrate reads to normalized
// Step 3: Migrate writes
// Step 4: Remove old structure
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

1. **Q:** "Normalized state lÃ  gÃ¬?"

   **Expected:**
   - Flat structure, no nesting
   - Entities keyed by ID
   - References by ID thay vÃ¬ embedding
   - Example: posts reference userId, khÃ´ng embed user object

2. **Q:** "Táº¡i sao dÃ¹ng action creators?"

   **Expected:**
   - Prevent typos
   - Centralize logic
   - Consistent payload
   - Easy to refactor

**Mid Level:**

3. **Q:** "LÃ m sao handle cascade delete trong normalized state?"

   **Expected:**
   - Identify related entities (postCommentIds)
   - Delete main entity
   - Loop vÃ  delete related entities
   - Clean up relationship arrays
   - Example code

4. **Q:** "Trade-off cá»§a normalized state?"

   **Expected:**
   - Pros: Fast updates, no duplication, scalable
   - Cons: Complex queries, need denormalize, boilerplate
   - When to use: Large data, frequent updates, relationships
   - When not: Simple data, read-only

**Senior Level:**

5. **Q:** "Thiáº¿t káº¿ state architecture cho social network app (users, posts, comments, likes, shares). Explain your decisions."

   **Expected:**
   - Normalized structure vá»›i entities
   - Separate metadata (counts, timestamps)
   - Consider read/write patterns
   - Indexes cho common queries
   - Pagination strategy
   - Caching denormalized data
   - Performance tradeoffs
   - Migration path

### War Stories

**Story 1: Nested Hell â†’ Normalized Heaven**

> "App e-commerce cÃ³ products nested trong categories, reviews nested trong products. Update product price pháº£i clone entire category tree. Performance terrible vá»›i 1000+ products. Sau 2 ngÃ y refactor sang normalized: state.products[id].price = X. Update time tá»« 150ms â†’ 5ms. Code tá»« 50 lines nested spread â†’ 10 lines flat. Lesson: Profile before optimize, nhÆ°ng normalized thÆ°á»ng win." - Senior Engineer

**Story 2: Premature Normalization**

> "Junior dev normalize Táº¤T Cáº¢, ká»ƒ cáº£ user settings object (3 fields). Káº¿t quáº£: Simple feature cáº§n 5 actions, 3 reducers, 10 helper functions. Code review: 'This is 2 levels deep, nested is fine'. Rolled back, code giáº£m 70%. Lesson: Normalize khi Cáº¦N, khÃ´ng pháº£i by default." - Tech Lead

**Story 3: Action Creator Saved Us**

> "Production bug: Feature flag typo 'ENABEL_FEATURE' â†’ silent fail trong switch/case, users khÃ´ng tháº¥y feature. Vá»›i action creator, typo = autocomplete error ngay. Sau Ä‘Ã³ enforce rule: NO dispatch inline objects. Only action creators. Bugs giáº£m 40%." - CTO

---

## ğŸ¯ PREVIEW NGÃ€Y MAI

**NgÃ y 28: useReducer + useEffect - Async Actions Pattern**

Báº¡n sáº½ há»c:

- âœ¨ Data fetching vá»›i useReducer
- âœ¨ Loading/Success/Error states pattern
- âœ¨ Request cancellation
- âœ¨ Optimistic updates
- âœ¨ Retry logic

Chuáº©n bá»‹:

- HoÃ n thÃ nh bÃ i táº­p hÃ´m nay (normalize state)
- Review useEffect (NgÃ y 16-20)
- Review data fetching basics
- Suy nghÄ©: LÃ m sao combine reducer (sync) + effects (async)?

---

**ğŸ‰ ChÃºc má»«ng! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 27!**

Báº¡n giá» Ä‘Ã£ master:

- âœ… State normalization
- âœ… Action type constants & creators
- âœ… Reducer composition
- âœ… Complex state architectures

Tomorrow: Async world vá»›i useReducer! ğŸ’ª
