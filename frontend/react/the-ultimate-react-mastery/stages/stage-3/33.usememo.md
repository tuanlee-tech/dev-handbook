# üìÖ NG√ÄY 33: useMemo - T·ªëi ∆Øu T√≠nh To√°n ƒê·∫Øt ƒê·ªè

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

- [ ] Hi·ªÉu khi n√†o m·ªôt t√≠nh to√°n ƒë∆∞·ª£c coi l√† "ƒë·∫Øt ƒë·ªè" (expensive)
- [ ] S·ª≠ d·ª•ng useMemo ƒë·ªÉ cache k·∫øt qu·∫£ t√≠nh to√°n
- [ ] Ph√¢n bi·ªát khi n√†o N√äN v√† KH√îNG N√äN d√πng useMemo
- [ ] ƒêo l∆∞·ªùng performance tr∆∞·ªõc/sau khi optimize v·ªõi useMemo

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

1. React.memo ngƒÉn ch·∫∑n re-render khi n√†o? (Ng√†y 32)
2. T·∫°i sao object/array m·ªõi t·∫°o m·ªói render c√≥ th·ªÉ ph√° v·ª° React.memo?
3. L√†m sao bi·∫øt m·ªôt component ƒëang re-render qu√° nhi·ªÅu?

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

```jsx
/**
 * ‚ùå PROBLEM: T√≠nh to√°n ph·ª©c t·∫°p ch·∫°y l·∫°i m·ªói render
 */
function ProductList({ products, category }) {
  const [sortOrder, setSortOrder] = useState('asc');

  // ‚ö†Ô∏è H√†m n√†y ch·∫°y M·ªñI RENDER - k·ªÉ c·∫£ khi products kh√¥ng ƒë·ªïi!
  const expensiveFilter = (list) => {
    console.log('üî¥ Filtering 10,000 products...');
    let result = list.filter((p) => p.category === category);

    // Gi·∫£ s·ª≠ sort r·∫•t ph·ª©c t·∫°p (custom algorithm)
    result.sort((a, b) => {
      // Complex comparison logic
      const scoreA = calculateComplexScore(a);
      const scoreB = calculateComplexScore(b);
      return sortOrder === 'asc' ? scoreA - scoreB : scoreB - scoreA;
    });

    return result;
  };

  const filtered = expensiveFilter(products); // üêå Ch·∫°y m·ªói render!

  return (
    <div>
      <button onClick={() => setSortOrder('asc')}>Sort Asc</button>
      <button onClick={() => setSortOrder('desc')}>Sort Desc</button>
      {/* Ch·ªâ click button th√¥i m√† filter l·∫°i 10,000 items! */}
      {filtered.map((p) => (
        <ProductCard
          key={p.id}
          product={p}
        />
      ))}
    </div>
  );
}
```

**V·∫•n ƒë·ªÅ:**

- T√≠nh to√°n ch·∫°y l·∫°i ngay c·∫£ khi `products` v√† `category` kh√¥ng ƒë·ªïi
- User ch·ªâ click button sort ‚Üí filter l·∫°i to√†n b·ªô list
- Waste CPU cycles cho t√≠nh to√°n tr√πng l·∫∑p

### 1.2 Gi·∫£i Ph√°p: useMemo

```jsx
import { useMemo } from 'react';

function ProductList({ products, category }) {
  const [sortOrder, setSortOrder] = useState('asc');

  // ‚úÖ Ch·ªâ t√≠nh l·∫°i khi products, category, ho·∫∑c sortOrder thay ƒë·ªïi
  const filtered = useMemo(() => {
    console.log('üü¢ Filtering (cached when possible)...');
    let result = products.filter((p) => p.category === category);

    result.sort((a, b) => {
      const scoreA = calculateComplexScore(a);
      const scoreB = calculateComplexScore(b);
      return sortOrder === 'asc' ? scoreA - scoreB : scoreB - scoreA;
    });

    return result;
  }, [products, category, sortOrder]); // Dependencies

  return (
    <div>
      <button onClick={() => setSortOrder('asc')}>Sort Asc</button>
      {filtered.map((p) => (
        <ProductCard
          key={p.id}
          product={p}
        />
      ))}
    </div>
  );
}
```

### 1.3 Mental Model

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Component Render                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                     ‚îÇ
‚îÇ   useMemo(() => {                   ‚îÇ
‚îÇ     return expensiveCalculation();  ‚îÇ
‚îÇ   }, [dep1, dep2])                  ‚îÇ
‚îÇ                                     ‚îÇ
‚îÇ          ‚Üì                          ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ
‚îÇ   ‚îÇ Check deps      ‚îÇ               ‚îÇ
‚îÇ   ‚îÇ changed?        ‚îÇ               ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ
‚îÇ            ‚îÇ                        ‚îÇ
‚îÇ      YES ‚îÄ‚îÄ‚îº‚îÄ‚îÄ NO                   ‚îÇ
‚îÇ       ‚Üì         ‚Üì                   ‚îÇ
‚îÇ   Recalculate  Return cached        ‚îÇ
‚îÇ   & cache      value                ‚îÇ
‚îÇ                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

ANALOGY: B·ªô nh·ªõ cache c·ªßa tr√¨nh duy·ªát
- L·∫ßn ƒë·∫ßu: Download file (t√≠nh to√°n)
- L·∫ßn sau: D√πng cache (n·∫øu file ch∆∞a ƒë·ªïi)
- File ƒë·ªïi: Download l·∫°i (dependencies thay ƒë·ªïi)
```

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

‚ùå **"useMemo l√†m code ch·∫°y nhanh h∆°n"**
‚Üí Sai! useMemo c√≥ overhead. Ch·ªâ nhanh h∆°n khi t√≠nh to√°n th·ª±c s·ª± ƒë·∫Øt ƒë·ªè.

‚ùå **"N√™n wrap m·ªçi th·ª© trong useMemo"**
‚Üí Over-optimization! useMemo t·ªën memory v√† c√≥ cost ƒë·ªÉ compare dependencies.

‚ùå **"useMemo ngƒÉn re-render"**
‚Üí Sai! React.memo ngƒÉn re-render. useMemo ch·ªâ cache value.

‚ùå **"Dependencies array gi·ªëng useEffect"**
‚Üí ƒê√∫ng v·ªÅ syntax, nh∆∞ng kh√°c v·ªÅ timing (synchronous vs asynchronous).

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: T√≠nh To√°n ƒê·∫Øt ƒê·ªè ‚≠ê

```jsx
/**
 * üìä Example: Fibonacci calculation
 * Without useMemo: Recalculates every render
 */
function FibonacciCalculator() {
  const [number, setNumber] = useState(35);
  const [count, setCount] = useState(0);

  // ‚ùå BAD: T√≠nh to√°n expensive m·ªói render
  const fibonacci = (n) => {
    console.log('Computing fibonacci...');
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
  };

  const result = fibonacci(number); // üêå Slow!

  return (
    <div>
      <p>
        Fibonacci({number}) = {result}
      </p>
      <button onClick={() => setNumber(number + 1)}>Next Number</button>

      {/* Click n√†y c≈©ng trigger fibonacci t√≠nh l·∫°i! */}
      <button onClick={() => setCount(count + 1)}>
        Unrelated Counter: {count}
      </button>
    </div>
  );
}

// ‚úÖ GOOD: Cache v·ªõi useMemo
function FibonacciCalculatorOptimized() {
  const [number, setNumber] = useState(35);
  const [count, setCount] = useState(0);

  const fibonacci = (n) => {
    console.log('Computing fibonacci...');
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
  };

  // Ch·ªâ t√≠nh l·∫°i khi number thay ƒë·ªïi
  const result = useMemo(() => fibonacci(number), [number]);

  return (
    <div>
      <p>
        Fibonacci({number}) = {result}
      </p>
      <button onClick={() => setNumber(number + 1)}>Next Number</button>

      {/* Click n√†y KH√îNG trigger fibonacci! */}
      <button onClick={() => setCount(count + 1)}>
        Unrelated Counter: {count}
      </button>
    </div>
  );
}

// üéØ K·∫æT QU·∫¢:
// Without useMemo: Counter click ‚Üí fibonacci runs ‚Üí UI freezes
// With useMemo: Counter click ‚Üí instant update
```

### Demo 2: Referential Equality v·ªõi React.memo ‚≠ê‚≠ê

```jsx
/**
 * üé® Example: Passing filtered data to memoized child
 */
const ExpensiveChild = React.memo(({ data }) => {
  console.log('üé® Child rendered');

  return (
    <ul>
      {data.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
});

// ‚ùå BAD: M·ªói render t·∫°o array m·ªõi ‚Üí React.memo v√¥ d·ª•ng
function ParentBad({ items }) {
  const [count, setCount] = useState(0);

  // Array m·ªõi m·ªói render!
  const filtered = items.filter((item) => item.active);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Trigger Re-render: {count}
      </button>
      {/* ExpensiveChild re-render m·ªói l·∫ßn click! */}
      <ExpensiveChild data={filtered} />
    </div>
  );
}

// ‚úÖ GOOD: useMemo ƒë·∫£m b·∫£o referential equality
function ParentGood({ items }) {
  const [count, setCount] = useState(0);

  // C√πng array reference n·∫øu items kh√¥ng ƒë·ªïi
  const filtered = useMemo(() => items.filter((item) => item.active), [items]);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Trigger Re-render: {count}
      </button>
      {/* ExpensiveChild KH√îNG re-render! */}
      <ExpensiveChild data={filtered} />
    </div>
  );
}

// üéØ K·∫æT QU·∫¢:
// Bad: Click button ‚Üí Child re-renders (array reference m·ªõi)
// Good: Click button ‚Üí Child KH√îNG re-render (same reference)
```

### Demo 3: When NOT to Use useMemo ‚≠ê‚≠ê‚≠ê

```jsx
/**
 * ‚ö†Ô∏è ANTI-PATTERNS: Khi useMemo l√†m h·∫°i h∆°n l·ª£i
 */

// ‚ùå ANTI-PATTERN 1: Simple calculations
function BadExample1() {
  const [price, setPrice] = useState(100);
  const [quantity, setQuantity] = useState(1);

  // üö´ KH√îNG c·∫ßn useMemo cho ph√©p t√≠nh ƒë∆°n gi·∫£n!
  const total = useMemo(() => price * quantity, [price, quantity]);

  // ‚úÖ ƒê∆†N GI·∫¢N H∆†N:
  const totalSimple = price * quantity;

  return <div>Total: {total}</div>;
}

// ‚ùå ANTI-PATTERN 2: Dependencies thay ƒë·ªïi th∆∞·ªùng xuy√™n
function BadExample2({ searchTerm, allItems }) {
  // searchTerm ƒë·ªïi m·ªói keystroke
  // ‚Üí useMemo overhead > benefit
  const filtered = useMemo(
    () => allItems.filter((item) => item.name.includes(searchTerm)),
    [searchTerm, allItems],
  );

  // ‚úÖ BETTER: Ch·ªâ filter tr·ª±c ti·∫øp (tr·ª´ khi list c·ª±c l·ªõn)
  const filteredSimple = allItems.filter((item) =>
    item.name.includes(searchTerm),
  );

  return <div>{/* ... */}</div>;
}

// ‚ùå ANTI-PATTERN 3: Primitive values
function BadExample3() {
  const [user, setUser] = useState({ name: 'John', age: 30 });

  // üö´ String l√† primitive, kh√¥ng c·∫ßn memo!
  const greeting = useMemo(() => `Hello, ${user.name}!`, [user.name]);

  // ‚úÖ ƒê∆†N GI·∫¢N:
  const greetingSimple = `Hello, ${user.name}!`;

  return <div>{greeting}</div>;
}

// ‚úÖ GOOD USE CASE: Expensive + infrequent changes
function GoodExample({ largeDataset }) {
  const [filterType, setFilterType] = useState('all');

  // Dataset l·ªõn + logic ph·ª©c t·∫°p + √≠t thay ƒë·ªïi
  const processed = useMemo(() => {
    console.log('Processing 100,000 items...');

    return largeDataset
      .filter((item) => filterType === 'all' || item.type === filterType)
      .map((item) => ({
        ...item,
        score: calculateComplexScore(item), // Expensive!
        ranking: calculateRanking(item), // Expensive!
      }))
      .sort((a, b) => b.score - a.score);
  }, [largeDataset, filterType]);

  return <div>{/* Render processed data */}</div>;
}
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Level 1: √Åp D·ª•ng C∆° B·∫£n (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: S·ª≠ d·ª•ng useMemo cho t√≠nh to√°n ƒë∆°n gi·∫£n
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: useCallback, Context
 *
 * Requirements:
 * 1. T√≠nh t·ªïng c√°c s·ªë trong array ch·ªâ khi array thay ƒë·ªïi
 * 2. Log ra console m·ªói khi t√≠nh to√°n ch·∫°y
 * 3. C√≥ button trigger re-render nh∆∞ng KH√îNG t√≠nh l·∫°i sum
 */

// ‚ùå C√°ch SAI: T√≠nh m·ªói render
function SumCalculatorBad() {
  const [numbers] = useState([1, 2, 3, 4, 5]);
  const [count, setCount] = useState(0);

  // Ch·∫°y m·ªói render!
  const sum = numbers.reduce((acc, n) => acc + n, 0);

  return (
    <div>
      <p>Sum: {sum}</p>
      <button onClick={() => setCount(count + 1)}>Re-render: {count}</button>
    </div>
  );
}

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
// TODO: S·ª≠ d·ª•ng useMemo ƒë·ªÉ cache sum
// TODO: Th√™m console.log ƒë·ªÉ verify ch·ªâ t√≠nh 1 l·∫ßn
// TODO: Verify button click kh√¥ng trigger recalculation
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Sum calculator with memoization
 */
function SumCalculator() {
  const [numbers] = useState([1, 2, 3, 4, 5]);
  const [count, setCount] = useState(0);

  // ‚úÖ Ch·ªâ t√≠nh khi numbers thay ƒë·ªïi
  const sum = useMemo(() => {
    console.log('üî¢ Calculating sum...');
    return numbers.reduce((acc, n) => acc + n, 0);
  }, [numbers]);

  return (
    <div>
      <p>Sum: {sum}</p>
      <button onClick={() => setCount(count + 1)}>Re-render: {count}</button>
      <p>Render count: {count}</p>
    </div>
  );
}

// üéØ K·∫æT QU·∫¢:
// - Console log ch·ªâ xu·∫•t hi·ªán 1 l·∫ßn (l√∫c mount)
// - Click button ‚Üí count tƒÉng nh∆∞ng KH√îNG log "Calculating sum"
```

</details>

### ‚≠ê‚≠ê Level 2: So S√°nh Approaches (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: So s√°nh performance v·ªõi/kh√¥ng useMemo
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Filter danh s√°ch 1000 users theo search term
 *
 * ü§î PH√ÇN T√çCH:
 *
 * Approach A: Kh√¥ng d√πng useMemo
 * Pros: - Code ƒë∆°n gi·∫£n
 *       - Kh√¥ng c√≥ overhead c·ªßa memo
 * Cons: - Filter l·∫°i m·ªói render
 *       - T·∫°o array m·ªõi m·ªói l·∫ßn
 *
 * Approach B: D√πng useMemo
 * Pros: - Skip filter n·∫øu deps kh√¥ng ƒë·ªïi
 *       - Stable reference cho child components
 * Cons: - Memory overhead
 *       - Deps comparison cost
 *
 * üí≠ B·∫†N CH·ªåN G√å V√Ä T·∫†I SAO?
 *
 * Requirements:
 * 1. T·∫°o 1000 fake users
 * 2. Implement c·∫£ 2 approaches
 * 3. Measure performance (console.time)
 * 4. So s√°nh khi search term thay ƒë·ªïi th∆∞·ªùng xuy√™n
 * 5. Document khi n√†o approach n√†o t·ªët h∆°n
 */

// TODO: Implement v√† so s√°nh
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * User search with performance comparison
 */
import { useState, useMemo } from 'react';

// Helper: Generate fake users
function generateUsers(count) {
  return Array.from({ length: count }, (_, i) => ({
    id: i,
    name: `User ${i}`,
    email: `user${i}@example.com`,
  }));
}

// Approach A: No useMemo
function SearchWithoutMemo() {
  const [users] = useState(() => generateUsers(1000));
  const [search, setSearch] = useState('');
  const [renderCount, setRenderCount] = useState(0);

  console.time('Filter without memo');
  const filtered = users.filter((user) =>
    user.name.toLowerCase().includes(search.toLowerCase()),
  );
  console.timeEnd('Filter without memo');

  return (
    <div>
      <h3>Without useMemo</h3>
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder='Search users...'
      />
      <button onClick={() => setRenderCount(renderCount + 1)}>
        Force Render: {renderCount}
      </button>
      <p>Found: {filtered.length} users</p>
    </div>
  );
}

// Approach B: With useMemo
function SearchWithMemo() {
  const [users] = useState(() => generateUsers(1000));
  const [search, setSearch] = useState('');
  const [renderCount, setRenderCount] = useState(0);

  const filtered = useMemo(() => {
    console.time('Filter with memo');
    const result = users.filter((user) =>
      user.name.toLowerCase().includes(search.toLowerCase()),
    );
    console.timeEnd('Filter with memo');
    return result;
  }, [users, search]);

  return (
    <div>
      <h3>With useMemo</h3>
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder='Search users...'
      />
      <button onClick={() => setRenderCount(renderCount + 1)}>
        Force Render: {renderCount}
      </button>
      <p>Found: {filtered.length} users</p>
    </div>
  );
}

// Comparison Component
function PerformanceComparison() {
  return (
    <div>
      <SearchWithoutMemo />
      <hr />
      <SearchWithMemo />
    </div>
  );
}

/**
 * üìä DECISION MATRIX:
 *
 * Use WITHOUT useMemo when:
 * - List < 100 items
 * - Filter logic simple (single field check)
 * - Search changes on EVERY keystroke
 *
 * Use WITH useMemo when:
 * - List > 1000 items
 * - Complex filter logic (multiple fields, regex)
 * - Debounced search (search changes less frequently)
 * - Passing to memoized children
 *
 * üéØ K·∫æT QU·∫¢ TH·ª∞C T·∫æ:
 * - Without memo + Force Render: Filter runs (~1ms)
 * - With memo + Force Render: Skip filter (0ms)
 * - Typing search: Both run filter (search changes)
 */
```

</details>

### ‚≠ê‚≠ê‚≠ê Level 3: Complex Filtering & Sorting (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Optimize data table v·ªõi multiple operations
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën filter v√† sort danh s√°ch products
 * ƒë·ªÉ d·ªÖ d√†ng t√¨m s·∫£n ph·∫©m ph√π h·ª£p"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Filter by category (Electronics, Books, Clothing)
 * - [ ] Filter by price range (min, max)
 * - [ ] Sort by name, price (asc/desc)
 * - [ ] Display count of filtered results
 * - [ ] Smooth performance v·ªõi 5000 products
 *
 * üé® Technical Constraints:
 * - Products array c√≥ 5000 items
 * - Filter + sort ph·∫£i efficient
 * - Kh√¥ng lag khi user interact
 *
 * üö® Edge Cases c·∫ßn handle:
 * - Empty results
 * - Invalid price range (min > max)
 * - T·∫•t c·∫£ filters cleared ‚Üí show all
 *
 * üìù Implementation Checklist:
 * - [ ] useMemo cho filtered data
 * - [ ] useMemo cho sorted data (ho·∫∑c combine?)
 * - [ ] Measure performance
 * - [ ] Console log ƒë·ªÉ verify memo working
 */

// TODO: Implement ProductTable component
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Optimized product table with filtering and sorting
 */
import { useState, useMemo } from 'react';

// Generate fake products
function generateProducts(count) {
  const categories = ['Electronics', 'Books', 'Clothing'];
  const names = ['Product A', 'Product B', 'Product C', 'Product D'];

  return Array.from({ length: count }, (_, i) => ({
    id: i,
    name: `${names[i % names.length]} ${i}`,
    category: categories[i % categories.length],
    price: Math.floor(Math.random() * 1000) + 10,
  }));
}

function ProductTable() {
  const [products] = useState(() => generateProducts(5000));

  // Filters
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [minPrice, setMinPrice] = useState(0);
  const [maxPrice, setMaxPrice] = useState(1000);

  // Sort
  const [sortBy, setSortBy] = useState('name');
  const [sortOrder, setSortOrder] = useState('asc');

  // Force re-render counter
  const [renderCount, setRenderCount] = useState(0);

  // ‚úÖ Step 1: Filter (most expensive operation)
  const filteredProducts = useMemo(() => {
    console.log('üîç Filtering products...');

    return products.filter((product) => {
      const categoryMatch =
        selectedCategory === 'all' || product.category === selectedCategory;
      const priceMatch = product.price >= minPrice && product.price <= maxPrice;

      return categoryMatch && priceMatch;
    });
  }, [products, selectedCategory, minPrice, maxPrice]);

  // ‚úÖ Step 2: Sort filtered results
  const sortedProducts = useMemo(() => {
    console.log('üìä Sorting products...');

    const sorted = [...filteredProducts];

    sorted.sort((a, b) => {
      let comparison = 0;

      if (sortBy === 'name') {
        comparison = a.name.localeCompare(b.name);
      } else if (sortBy === 'price') {
        comparison = a.price - b.price;
      }

      return sortOrder === 'asc' ? comparison : -comparison;
    });

    return sorted;
  }, [filteredProducts, sortBy, sortOrder]);

  return (
    <div>
      <h2>Product Catalog (5000 items)</h2>

      {/* Filters */}
      <div
        style={{ marginBottom: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <label>
          Category:
          <select
            value={selectedCategory}
            onChange={(e) => setSelectedCategory(e.target.value)}
          >
            <option value='all'>All</option>
            <option value='Electronics'>Electronics</option>
            <option value='Books'>Books</option>
            <option value='Clothing'>Clothing</option>
          </select>
        </label>

        <label style={{ marginLeft: '10px' }}>
          Min Price:
          <input
            type='number'
            value={minPrice}
            onChange={(e) => setMinPrice(Number(e.target.value))}
          />
        </label>

        <label style={{ marginLeft: '10px' }}>
          Max Price:
          <input
            type='number'
            value={maxPrice}
            onChange={(e) => setMaxPrice(Number(e.target.value))}
          />
        </label>
      </div>

      {/* Sort Controls */}
      <div style={{ marginBottom: '20px' }}>
        <label>
          Sort by:
          <select
            value={sortBy}
            onChange={(e) => setSortBy(e.target.value)}
          >
            <option value='name'>Name</option>
            <option value='price'>Price</option>
          </select>
        </label>

        <label style={{ marginLeft: '10px' }}>
          Order:
          <select
            value={sortOrder}
            onChange={(e) => setSortOrder(e.target.value)}
          >
            <option value='asc'>Ascending</option>
            <option value='desc'>Descending</option>
          </select>
        </label>
      </div>

      {/* Force Re-render Test */}
      <button onClick={() => setRenderCount(renderCount + 1)}>
        Force Re-render: {renderCount}
      </button>

      {/* Results */}
      <p>
        <strong>Showing {sortedProducts.length} products</strong>
      </p>

      <div style={{ maxHeight: '400px', overflow: 'auto' }}>
        {sortedProducts.slice(0, 50).map((product) => (
          <div
            key={product.id}
            style={{ padding: '5px', borderBottom: '1px solid #ccc' }}
          >
            {product.name} - {product.category} - ${product.price}
          </div>
        ))}
        {sortedProducts.length > 50 && (
          <p>... and {sortedProducts.length - 50} more</p>
        )}
      </div>
    </div>
  );
}

/**
 * üéØ PERFORMANCE NOTES:
 *
 * ‚úÖ With useMemo:
 * - Force re-render: 0ms (no filtering/sorting)
 * - Change filter: ~5-10ms (only filter runs)
 * - Change sort: ~2-5ms (only sort runs)
 *
 * ‚ùå Without useMemo:
 * - Every interaction: ~15-20ms (filter + sort both run)
 * - Force re-render: ~15-20ms (unnecessary work)
 *
 * üìä OPTIMIZATION STRATEGY:
 * 1. Separate filter and sort memos (different deps)
 * 2. Filter first (reduces array size for sort)
 * 3. Only show first 50 items (virtual scrolling concept)
 */
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê Level 4: Architecture Decision - Nested Memoization (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Design efficient data transformation pipeline
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Scenario: Dashboard v·ªõi nhi·ªÅu derived data:
 * - Raw transactions (10,000 items)
 * - Grouped by category
 * - Calculated totals per category
 * - Sorted categories by total
 * - Top 5 categories
 * - Chart data format
 *
 * Nhi·ªám v·ª•:
 * 1. So s√°nh √≠t nh·∫•t 3 approaches:
 *    - Single useMemo cho t·∫•t c·∫£ transformations
 *    - Multiple useMemo chain (transform ‚Üí group ‚Üí total ‚Üí sort)
 *    - Hybrid approach
 *
 * 2. Document pros/cons m·ªói approach
 * 3. Vi·∫øt ADR (Architecture Decision Record)
 *
 * ADR Template:
 * - Context: Pipeline data transformation ph·ª©c t·∫°p
 * - Decision: Approach ƒë√£ ch·ªçn
 * - Rationale: T·∫°i sao approach n√†y t·ªët nh·∫•t
 * - Consequences: Trade-offs accepted
 * - Alternatives Considered: C√°c options kh√°c v√† l√Ω do reject
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 * Implement approach ƒë√£ ch·ªçn
 *
 * üß™ PHASE 3: Testing (10 ph√∫t)
 * - Test v·ªõi different filters
 * - Measure performance
 * - Verify memoization working correctly
 */

// TODO: Complete ADR and implementation
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * ADR: Data Transformation Pipeline Architecture
 *
 * CONTEXT:
 * Dashboard c·∫ßn transform 10,000 transactions qua nhi·ªÅu b∆∞·ªõc:
 * raw ‚Üí grouped ‚Üí totals ‚Üí sorted ‚Üí top N ‚Üí chart format
 *
 * DECISION: Chain of useMemo (Approach B)
 *
 * RATIONALE:
 * 1. Granular caching - m·ªói step cache ri√™ng
 * 2. Filters ·ªü ƒë·∫ßu pipeline ‚Üí minimize data cho steps sau
 * 3. D·ªÖ debug - log m·ªói step ri√™ng
 * 4. Reusable - c√≥ th·ªÉ d√πng intermediate results
 *
 * ALTERNATIVES CONSIDERED:
 *
 * A. Single mega useMemo:
 *    Pros: Simple, one memo overhead
 *    Cons: Re-run everything khi b·∫•t k·ª≥ filter n√†o ƒë·ªïi
 *    Rejected: Kh√¥ng t·ªëi ∆∞u khi ch·ªâ sort order thay ƒë·ªïi
 *
 * C. No memoization:
 *    Pros: No memory overhead
 *    Cons: Too slow v·ªõi 10,000 items
 *    Rejected: Performance unacceptable
 *
 * CONSEQUENCES:
 * + Better performance v·ªõi selective updates
 * + Easier debugging
 * - More memory (multiple cached values)
 * - More complex code
 */

import { useState, useMemo } from 'react';

// Generate transactions
function generateTransactions(count) {
  const categories = [
    'Food',
    'Transport',
    'Entertainment',
    'Shopping',
    'Bills',
  ];

  return Array.from({ length: count }, (_, i) => ({
    id: i,
    category: categories[Math.floor(Math.random() * categories.length)],
    amount: Math.floor(Math.random() * 500) + 10,
    date: new Date(
      2024,
      Math.floor(Math.random() * 12),
      Math.floor(Math.random() * 28),
    ),
  }));
}

function TransactionDashboard() {
  const [transactions] = useState(() => generateTransactions(10000));

  // Filters
  const [minAmount, setMinAmount] = useState(0);
  const [selectedMonth, setSelectedMonth] = useState('all');

  // Sort
  const [sortOrder, setSortOrder] = useState('desc');
  const [topN, setTopN] = useState(5);

  // Debug
  const [renderCount, setRenderCount] = useState(0);

  // ‚úÖ STEP 1: Filter transactions
  const filteredTransactions = useMemo(() => {
    console.log('üîç Step 1: Filtering...');

    return transactions.filter((t) => {
      const amountMatch = t.amount >= minAmount;
      const monthMatch =
        selectedMonth === 'all' ||
        t.date.getMonth() === parseInt(selectedMonth);

      return amountMatch && monthMatch;
    });
  }, [transactions, minAmount, selectedMonth]);

  // ‚úÖ STEP 2: Group by category
  const groupedByCategory = useMemo(() => {
    console.log('üìä Step 2: Grouping...');

    const groups = {};

    filteredTransactions.forEach((t) => {
      if (!groups[t.category]) {
        groups[t.category] = [];
      }
      groups[t.category].push(t);
    });

    return groups;
  }, [filteredTransactions]);

  // ‚úÖ STEP 3: Calculate totals
  const categoryTotals = useMemo(() => {
    console.log('üí∞ Step 3: Calculating totals...');

    return Object.entries(groupedByCategory).map(([category, txns]) => ({
      category,
      total: txns.reduce((sum, t) => sum + t.amount, 0),
      count: txns.length,
      average: txns.reduce((sum, t) => sum + t.amount, 0) / txns.length,
    }));
  }, [groupedByCategory]);

  // ‚úÖ STEP 4: Sort categories
  const sortedCategories = useMemo(() => {
    console.log('üî¢ Step 4: Sorting...');

    const sorted = [...categoryTotals];
    sorted.sort((a, b) => {
      return sortOrder === 'desc' ? b.total - a.total : a.total - b.total;
    });

    return sorted;
  }, [categoryTotals, sortOrder]);

  // ‚úÖ STEP 5: Take top N
  const topCategories = useMemo(() => {
    console.log('üèÜ Step 5: Taking top N...');
    return sortedCategories.slice(0, topN);
  }, [sortedCategories, topN]);

  // ‚úÖ STEP 6: Format for chart
  const chartData = useMemo(() => {
    console.log('üìà Step 6: Formatting chart data...');

    return {
      labels: topCategories.map((c) => c.category),
      datasets: [
        {
          data: topCategories.map((c) => c.total),
          backgroundColor: [
            '#FF6384',
            '#36A2EB',
            '#FFCE56',
            '#4BC0C0',
            '#9966FF',
          ],
        },
      ],
    };
  }, [topCategories]);

  return (
    <div>
      <h2>Transaction Dashboard</h2>
      <p>Analyzing {transactions.length} transactions</p>

      {/* Filters */}
      <div
        style={{ padding: '10px', background: '#f0f0f0', marginBottom: '20px' }}
      >
        <label>
          Min Amount: $
          <input
            type='number'
            value={minAmount}
            onChange={(e) => setMinAmount(Number(e.target.value))}
          />
        </label>

        <label style={{ marginLeft: '10px' }}>
          Month:
          <select
            value={selectedMonth}
            onChange={(e) => setSelectedMonth(e.target.value)}
          >
            <option value='all'>All</option>
            {Array.from({ length: 12 }, (_, i) => (
              <option
                key={i}
                value={i}
              >
                Month {i + 1}
              </option>
            ))}
          </select>
        </label>

        <label style={{ marginLeft: '10px' }}>
          Sort:
          <select
            value={sortOrder}
            onChange={(e) => setSortOrder(e.target.value)}
          >
            <option value='desc'>Highest First</option>
            <option value='asc'>Lowest First</option>
          </select>
        </label>

        <label style={{ marginLeft: '10px' }}>
          Top:
          <input
            type='number'
            min='1'
            max='10'
            value={topN}
            onChange={(e) => setTopN(Number(e.target.value))}
          />
        </label>
      </div>

      {/* Debug */}
      <button onClick={() => setRenderCount(renderCount + 1)}>
        Force Re-render: {renderCount}
      </button>

      {/* Results */}
      <div>
        <h3>Top {topN} Categories</h3>
        {topCategories.map((cat, idx) => (
          <div
            key={cat.category}
            style={{ padding: '10px', borderBottom: '1px solid #ccc' }}
          >
            <strong>
              #{idx + 1} {cat.category}
            </strong>
            <div>Total: ${cat.total.toFixed(2)}</div>
            <div>Transactions: {cat.count}</div>
            <div>Average: ${cat.average.toFixed(2)}</div>
          </div>
        ))}
      </div>

      {/* Chart data preview */}
      <div style={{ marginTop: '20px' }}>
        <h3>Chart Data</h3>
        <pre>{JSON.stringify(chartData, null, 2)}</pre>
      </div>
    </div>
  );
}

/**
 * üéØ PERFORMANCE ANALYSIS:
 *
 * Scenario: User changes topN from 5 to 10
 *
 * With chained memos:
 * - Steps 1-4: SKIP (cached) ‚úÖ
 * - Step 5: RUN (topN changed)
 * - Step 6: RUN (depends on step 5)
 * Total: ~1-2ms
 *
 * With single memo:
 * - All steps: RUN (any dependency changed) ‚ùå
 * Total: ~15-20ms
 *
 * üìä MEMORY vs SPEED TRADE-OFF:
 * Memory: 6 cached values (~few KB)
 * Speed gain: 10-15ms per interaction
 * Verdict: Worth it for responsive UX
 */
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Level 5: Production Challenge - Smart Memo Strategy (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Build analytics dashboard v·ªõi intelligent memoization
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 * E-commerce analytics dashboard hi·ªÉn th·ªã:
 * - Sales over time (line chart)
 * - Product performance (bar chart)
 * - Category breakdown (pie chart)
 * - Geographic distribution (map data)
 * - Top customers (leaderboard)
 *
 * üèóÔ∏è Technical Design Doc:
 *
 * 1. Data Architecture:
 *    - 20,000 order records
 *    - Each order: { id, productId, customerId, amount, date, location, category }
 *    - Compute-intensive aggregations
 *
 * 2. Memoization Strategy:
 *    Decision matrix:
 *    - Which aggregations to memo?
 *    - Which to compute on-demand?
 *    - Dependencies structure?
 *
 * 3. Performance Budget:
 *    - Initial render: < 100ms
 *    - Filter change: < 50ms
 *    - Re-render (no deps change): < 5ms
 *
 * ‚úÖ Production Checklist:
 * - [ ] Memoize expensive computations appropriately
 * - [ ] Avoid over-memoization (cost > benefit)
 * - [ ] Dependencies correctly specified
 * - [ ] Performance measured and logged
 * - [ ] Edge cases handled (empty data, single category, etc.)
 * - [ ] Console logs for debugging (removable)
 * - [ ] Code comments explaining memo decisions
 *
 * üìù Documentation Requirements:
 * - Inline comments explaining each useMemo decision
 * - Performance notes
 * - When to refactor notes
 */

// TODO: Implement AnalyticsDashboard
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * Production-grade Analytics Dashboard
 * Demonstrates strategic memoization for complex data transformations
 */
import { useState, useMemo } from 'react';

// ============================================
// DATA GENERATION
// ============================================

function generateOrders(count) {
  const products = Array.from({ length: 50 }, (_, i) => `Product ${i}`);
  const customers = Array.from({ length: 100 }, (_, i) => `Customer ${i}`);
  const categories = ['Electronics', 'Clothing', 'Food', 'Books', 'Sports'];
  const locations = ['North', 'South', 'East', 'West', 'Central'];

  return Array.from({ length: count }, (_, i) => ({
    id: i,
    productId: products[Math.floor(Math.random() * products.length)],
    customerId: customers[Math.floor(Math.random() * customers.length)],
    amount: Math.floor(Math.random() * 500) + 20,
    date: new Date(
      2024,
      Math.floor(Math.random() * 12),
      Math.floor(Math.random() * 28),
    ),
    location: locations[Math.floor(Math.random() * locations.length)],
    category: categories[Math.floor(Math.random() * categories.length)],
  }));
}

// ============================================
// MAIN COMPONENT
// ============================================

function AnalyticsDashboard() {
  // Raw data - initialize once
  const [orders] = useState(() => {
    console.log('üèóÔ∏è Generating 20,000 orders...');
    return generateOrders(20000);
  });

  // Filters
  const [dateRange, setDateRange] = useState({ start: 0, end: 11 }); // months
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [minAmount, setMinAmount] = useState(0);

  // UI state
  const [renderCount, setRenderCount] = useState(0);

  // ============================================
  // MEMOIZATION STRATEGY
  // ============================================

  /**
   * MEMO DECISION 1: Filtered Orders
   *
   * WHY MEMO?
   * - 20,000 items filter is expensive (~10-15ms)
   * - Used by ALL downstream computations
   * - Filters change infrequently (user action)
   *
   * DEPS: dateRange, selectedCategory, minAmount
   * COST: ~5KB memory
   * BENEFIT: Skip 10-15ms on unrelated re-renders
   * VERDICT: ‚úÖ Worth it
   */
  const filteredOrders = useMemo(() => {
    console.log('üîç [MEMO] Filtering orders...');
    performance.mark('filter-start');

    const filtered = orders.filter((order) => {
      const month = order.date.getMonth();
      const dateMatch = month >= dateRange.start && month <= dateRange.end;
      const categoryMatch =
        selectedCategory === 'all' || order.category === selectedCategory;
      const amountMatch = order.amount >= minAmount;

      return dateMatch && categoryMatch && amountMatch;
    });

    performance.mark('filter-end');
    performance.measure('Filter', 'filter-start', 'filter-end');

    return filtered;
  }, [orders, dateRange, selectedCategory, minAmount]);

  /**
   * MEMO DECISION 2: Sales Timeline
   *
   * WHY MEMO?
   * - Grouping + aggregation expensive (~5-8ms)
   * - Chart data structure complex
   * - Only depends on filtered orders
   *
   * WHY NOT SKIP MEMO?
   * - Even 5ms feels laggy on interactions
   * - Chart re-renders are visually jarring
   *
   * VERDICT: ‚úÖ Memo
   */
  const salesTimeline = useMemo(() => {
    console.log('üìà [MEMO] Computing sales timeline...');

    const monthlyData = {};

    filteredOrders.forEach((order) => {
      const monthKey = `${order.date.getMonth()}-${order.date.getFullYear()}`;

      if (!monthlyData[monthKey]) {
        monthlyData[monthKey] = { total: 0, count: 0 };
      }

      monthlyData[monthKey].total += order.amount;
      monthlyData[monthKey].count += 1;
    });

    return Object.entries(monthlyData).map(([key, data]) => ({
      month: key,
      total: data.total,
      average: data.total / data.count,
      count: data.count,
    }));
  }, [filteredOrders]);

  /**
   * MEMO DECISION 3: Category Breakdown
   *
   * Similar rationale to sales timeline
   */
  const categoryBreakdown = useMemo(() => {
    console.log('ü•ß [MEMO] Computing category breakdown...');

    const breakdown = {};

    filteredOrders.forEach((order) => {
      if (!breakdown[order.category]) {
        breakdown[order.category] = { total: 0, count: 0 };
      }
      breakdown[order.category].total += order.amount;
      breakdown[order.category].count += 1;
    });

    return Object.entries(breakdown).map(([category, data]) => ({
      category,
      total: data.total,
      count: data.count,
      percentage:
        (data.total / filteredOrders.reduce((sum, o) => sum + o.amount, 0)) *
        100,
    }));
  }, [filteredOrders]);

  /**
   * MEMO DECISION 4: Top Customers
   *
   * WHY MEMO?
   * - Sorting 100 customers moderate cost (~2-3ms)
   * - Only need top 10
   *
   * COULD SKIP?
   * - 2-3ms not terrible
   * - BUT: Depends on filtered orders which changes infrequently
   *
   * VERDICT: ‚úÖ Memo (small cost, measurable benefit)
   */
  const topCustomers = useMemo(() => {
    console.log('üèÜ [MEMO] Computing top customers...');

    const customerTotals = {};

    filteredOrders.forEach((order) => {
      if (!customerTotals[order.customerId]) {
        customerTotals[order.customerId] = 0;
      }
      customerTotals[order.customerId] += order.amount;
    });

    return Object.entries(customerTotals)
      .map(([customerId, total]) => ({ customerId, total }))
      .sort((a, b) => b.total - a.total)
      .slice(0, 10);
  }, [filteredOrders]);

  /**
   * MEMO DECISION 5: Geographic Distribution
   *
   * WHY NOT MEMO?
   * - Only 5 locations (very fast grouping)
   * - Simple count operation
   * - Cost: < 1ms
   * - Memo overhead > computation cost
   *
   * VERDICT: ‚ùå Skip memo
   */
  const geoDistribution = (() => {
    // NO useMemo here - too cheap
    const dist = {};
    filteredOrders.forEach((order) => {
      dist[order.location] = (dist[order.location] || 0) + 1;
    });
    return dist;
  })();

  /**
   * MEMO DECISION 6: Summary Stats
   *
   * WHY NOT MEMO?
   * - Single reduce pass (~1-2ms)
   * - Simple arithmetic
   * - Primitives (no referential equality issues)
   *
   * ALTERNATIVE CONSIDERED:
   * - Could memo to skip 1-2ms
   * - BUT: Not worth memory cost for such cheap calc
   *
   * VERDICT: ‚ùå Skip memo
   */
  const stats = (() => {
    const total = filteredOrders.reduce((sum, o) => sum + o.amount, 0);
    const count = filteredOrders.length;
    const average = count > 0 ? total / count : 0;

    return { total, count, average };
  })();

  // ============================================
  // RENDER
  // ============================================

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h1>üìä E-Commerce Analytics Dashboard</h1>

      {/* Filters */}
      <div
        style={{
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
          marginBottom: '20px',
        }}
      >
        <h3>Filters</h3>

        <label style={{ marginRight: '15px' }}>
          Date Range:
          <select
            value={dateRange.start}
            onChange={(e) =>
              setDateRange({ ...dateRange, start: Number(e.target.value) })
            }
          >
            {Array.from({ length: 12 }, (_, i) => (
              <option
                key={i}
                value={i}
              >
                Month {i + 1}
              </option>
            ))}
          </select>
          {' to '}
          <select
            value={dateRange.end}
            onChange={(e) =>
              setDateRange({ ...dateRange, end: Number(e.target.value) })
            }
          >
            {Array.from({ length: 12 }, (_, i) => (
              <option
                key={i}
                value={i}
              >
                Month {i + 1}
              </option>
            ))}
          </select>
        </label>

        <label style={{ marginRight: '15px' }}>
          Category:
          <select
            value={selectedCategory}
            onChange={(e) => setSelectedCategory(e.target.value)}
          >
            <option value='all'>All</option>
            <option value='Electronics'>Electronics</option>
            <option value='Clothing'>Clothing</option>
            <option value='Food'>Food</option>
            <option value='Books'>Books</option>
            <option value='Sports'>Sports</option>
          </select>
        </label>

        <label>
          Min Amount: $
          <input
            type='number'
            value={minAmount}
            onChange={(e) => setMinAmount(Number(e.target.value))}
            style={{ width: '80px' }}
          />
        </label>
      </div>

      {/* Debug */}
      <button onClick={() => setRenderCount(renderCount + 1)}>
        üîÑ Force Re-render: {renderCount}
      </button>

      {/* Summary Stats */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(3, 1fr)',
          gap: '15px',
          marginBottom: '20px',
        }}
      >
        <div
          style={{
            padding: '15px',
            background: '#e3f2fd',
            borderRadius: '8px',
          }}
        >
          <h4>Total Revenue</h4>
          <p style={{ fontSize: '24px', margin: 0 }}>
            ${stats.total.toLocaleString()}
          </p>
        </div>
        <div
          style={{
            padding: '15px',
            background: '#f3e5f5',
            borderRadius: '8px',
          }}
        >
          <h4>Orders</h4>
          <p style={{ fontSize: '24px', margin: 0 }}>
            {stats.count.toLocaleString()}
          </p>
        </div>
        <div
          style={{
            padding: '15px',
            background: '#e8f5e9',
            borderRadius: '8px',
          }}
        >
          <h4>Average Order</h4>
          <p style={{ fontSize: '24px', margin: 0 }}>
            ${stats.average.toFixed(2)}
          </p>
        </div>
      </div>

      {/* Charts Grid */}
      <div
        style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px' }}
      >
        {/* Sales Timeline */}
        <div
          style={{
            padding: '15px',
            background: 'white',
            borderRadius: '8px',
            border: '1px solid #ddd',
          }}
        >
          <h3>üìà Sales Timeline</h3>
          {salesTimeline.map((item) => (
            <div
              key={item.month}
              style={{ padding: '5px', borderBottom: '1px solid #eee' }}
            >
              <strong>{item.month}</strong>: ${item.total.toLocaleString()}(
              {item.count} orders, avg ${item.average.toFixed(2)})
            </div>
          ))}
        </div>

        {/* Category Breakdown */}
        <div
          style={{
            padding: '15px',
            background: 'white',
            borderRadius: '8px',
            border: '1px solid #ddd',
          }}
        >
          <h3>ü•ß Category Breakdown</h3>
          {categoryBreakdown.map((item) => (
            <div
              key={item.category}
              style={{ padding: '5px', borderBottom: '1px solid #eee' }}
            >
              <strong>{item.category}</strong>: ${item.total.toLocaleString()}(
              {item.percentage.toFixed(1)}%)
            </div>
          ))}
        </div>

        {/* Top Customers */}
        <div
          style={{
            padding: '15px',
            background: 'white',
            borderRadius: '8px',
            border: '1px solid #ddd',
          }}
        >
          <h3>üèÜ Top 10 Customers</h3>
          {topCustomers.map((customer, idx) => (
            <div
              key={customer.customerId}
              style={{ padding: '5px', borderBottom: '1px solid #eee' }}
            >
              #{idx + 1} {customer.customerId}: $
              {customer.total.toLocaleString()}
            </div>
          ))}
        </div>

        {/* Geographic Distribution */}
        <div
          style={{
            padding: '15px',
            background: 'white',
            borderRadius: '8px',
            border: '1px solid #ddd',
          }}
        >
          <h3>üó∫Ô∏è Geographic Distribution</h3>
          {Object.entries(geoDistribution).map(([location, count]) => (
            <div
              key={location}
              style={{ padding: '5px', borderBottom: '1px solid #eee' }}
            >
              <strong>{location}</strong>: {count} orders
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

/**
 * üìä PERFORMANCE REPORT
 *
 * Initial Render:
 * - Orders generation: ~50ms (one-time)
 * - Filter: ~12ms
 * - All memos: ~25ms total
 * Total: ~87ms ‚úÖ (under 100ms budget)
 *
 * Filter Change (e.g., category):
 * - Filter: ~12ms
 * - Dependent memos: ~20ms
 * Total: ~32ms ‚úÖ (under 50ms budget)
 *
 * Force Re-render (no deps change):
 * - All computations: SKIPPED
 * - Render only: ~2ms ‚úÖ (under 5ms budget)
 *
 * üéØ MEMOIZATION DECISIONS SUMMARY:
 *
 * ‚úÖ MEMOIZED (4):
 * 1. filteredOrders - foundation, expensive
 * 2. salesTimeline - moderate cost, visual impact
 * 3. categoryBreakdown - moderate cost, visual impact
 * 4. topCustomers - sorting overhead worth avoiding
 *
 * ‚ùå NOT MEMOIZED (2):
 * 5. geoDistribution - too cheap (<1ms)
 * 6. stats - primitives, simple calc (<2ms)
 *
 * üí° WHEN TO REFACTOR:
 * - If filteredOrders > 50,000: Consider Web Workers
 * - If charts lag: Virtualize / pagination
 * - If memory issues: Reduce memo granularity
 */
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh: useMemo vs Alternatives

| Aspect           | useMemo                       | React.memo                   | Kh√¥ng Optimize          | useEffect            |
| ---------------- | ----------------------------- | ---------------------------- | ----------------------- | -------------------- |
| **M·ª•c ƒë√≠ch**     | Cache **gi√° tr·ªã** computed    | NgƒÉn **component** re-render | Compute m·ªói render      | Side effects         |
| **Khi n√†o d√πng** | Expensive calculations        | Prevent child re-renders     | Simple/cheap operations | Async, subscriptions |
| **Return**       | Cached value                  | Memoized component           | Fresh value             | Undefined            |
| **Dependencies** | Array of deps                 | Props comparison             | N/A                     | Array of deps        |
| **Overhead**     | Dependencies check            | Props shallow compare        | None                    | Cleanup + setup      |
| **Memory Cost**  | 1 cached value                | Component instance           | None                    | Cleanup functions    |
| **Best for**     | Derived data, transformations | Pure components              | Primitives, simple math | API calls, DOM       |

### Trade-offs Matrix

| Scenario                   | No useMemo           | With useMemo            | Verdict                 |
| -------------------------- | -------------------- | ----------------------- | ----------------------- |
| **Simple math** (a + b)    | ‚úÖ 0ms, 0 memory     | ‚ùå 0.1ms overhead       | ‚ùå Don't memo           |
| **Filter 100 items**       | ‚ö†Ô∏è 1-2ms each render | ‚ö†Ô∏è Save ~1ms            | ü§∑ Depends on frequency |
| **Filter 10,000 items**    | ‚ùå 15-20ms lag       | ‚úÖ Skip when possible   | ‚úÖ Memo                 |
| **Complex calculation**    | ‚ùå Blocks UI         | ‚úÖ Smooth UX            | ‚úÖ Memo                 |
| **Object for child**       | ‚ùå Breaks React.memo | ‚úÖ Stable reference     | ‚úÖ Memo                 |
| **Every keystroke change** | ‚ö†Ô∏è Runs anyway       | ‚ùå Memo overhead wasted | ‚ùå Don't memo           |

### Decision Tree

```
B·∫°n c√≥ t√≠nh to√°n n√†o ch∆∞a?
‚îÇ
‚îú‚îÄ NO ‚Üí Kh√¥ng c·∫ßn useMemo
‚îÇ
‚îî‚îÄ YES ‚Üí T√≠nh to√°n c√≥ ƒë·∫Øt kh√¥ng? (>5ms)
    ‚îÇ
    ‚îú‚îÄ NO ‚Üí Ki·ªÉm tra use case
    ‚îÇ   ‚îÇ
    ‚îÇ   ‚îú‚îÄ L√† object/array cho memoized child? ‚Üí ‚úÖ useMemo
    ‚îÇ   ‚îú‚îÄ L√† primitive value? ‚Üí ‚ùå Kh√¥ng c·∫ßn
    ‚îÇ   ‚îî‚îÄ Calculation < 1ms? ‚Üí ‚ùå Kh√¥ng c·∫ßn
    ‚îÇ
    ‚îî‚îÄ YES ‚Üí Dependencies thay ƒë·ªïi th∆∞·ªùng xuy√™n kh√¥ng?
        ‚îÇ
        ‚îú‚îÄ YES (m·ªói keystroke) ‚Üí ‚ö†Ô∏è C√¢n nh·∫Øc
        ‚îÇ   ‚îî‚îÄ N·∫øu list > 1000 items ‚Üí ‚úÖ useMemo
        ‚îÇ   ‚îî‚îÄ N·∫øu list < 100 items ‚Üí ‚ùå Kh√¥ng c·∫ßn
        ‚îÇ
        ‚îî‚îÄ NO (user actions, props change) ‚Üí ‚úÖ useMemo
            ‚îî‚îÄ Measure before/after ƒë·ªÉ confirm
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Dependencies Stale

```jsx
/**
 * üêõ BUG: Search kh√¥ng ho·∫°t ƒë·ªông ƒë√∫ng
 * Tri·ªáu ch·ª©ng: Filtered list kh√¥ng update khi search thay ƒë·ªïi
 */
function BuggySearch() {
  const [items] = useState(['Apple', 'Banana', 'Cherry']);
  const [search, setSearch] = useState('');

  // üêõ BUG: Missing search in dependencies!
  const filtered = useMemo(() => {
    return items.filter((item) =>
      item.toLowerCase().includes(search.toLowerCase()),
    );
  }, [items]); // ‚ùå Thi·∫øu search!

  return (
    <div>
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      <ul>
        {filtered.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

// üîç Debug questions:
// 1. T·∫°i sao filtered list kh√¥ng thay ƒë·ªïi khi g√µ?
// 2. ESLint warning n√≥i g√¨?
// 3. Fix nh∆∞ th·∫ø n√†o?
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * ‚úÖ FIXED: Th√™m search v√†o dependencies
 */
function FixedSearch() {
  const [items] = useState(['Apple', 'Banana', 'Cherry']);
  const [search, setSearch] = useState('');

  // ‚úÖ ƒê·∫ßy ƒë·ªß dependencies
  const filtered = useMemo(() => {
    return items.filter((item) =>
      item.toLowerCase().includes(search.toLowerCase()),
    );
  }, [items, search]); // ‚úÖ C·∫£ items V√Ä search

  return (
    <div>
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
      />
      <ul>
        {filtered.map((item) => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

/**
 * üìù GI·∫¢I TH√çCH:
 *
 * L·ªñI:
 * - useMemo ch·ªâ re-run khi items thay ƒë·ªïi
 * - search thay ƒë·ªïi ‚Üí memo KH√îNG re-run
 * - filtered gi·ªØ gi√° tr·ªã c≈© (stale)
 *
 * FIX:
 * - Th√™m search v√†o deps array
 * - B√¢y gi·ªù memo re-run khi items HO·∫∂C search thay ƒë·ªïi
 *
 * PH√íNG TR√ÅNH:
 * - B·∫≠t ESLint rule: react-hooks/exhaustive-deps
 * - Lu√¥n ƒë·ªçc warning v√† fix ngay
 */
```

</details>

### Bug 2: Over-Memoization

```jsx
/**
 * üêõ BUG: Performance kh√¥ng c·∫£i thi·ªán, th·∫≠m ch√≠ ch·∫≠m h∆°n
 * Tri·ªáu ch·ª©ng: Memoize m·ªçi th·ª© nh∆∞ng app v·∫´n lag
 */
function OverMemoized() {
  const [a, setA] = useState(1);
  const [b, setB] = useState(2);

  // üêõ Memoize nh·ªØng th·ª© qu√° ƒë∆°n gi·∫£n!
  const sum = useMemo(() => a + b, [a, b]);
  const double = useMemo(() => sum * 2, [sum]);
  const message = useMemo(() => `Result: ${double}`, [double]);
  const isEven = useMemo(() => double % 2 === 0, [double]);

  return (
    <div>
      <button onClick={() => setA(a + 1)}>A: {a}</button>
      <button onClick={() => setB(b + 1)}>B: {b}</button>
      <p>{message}</p>
      <p>{isEven ? 'Even' : 'Odd'}</p>
    </div>
  );
}

// üîç Debug questions:
// 1. T·∫°i sao over-memoization c√≥ h·∫°i?
// 2. Memos n√†o n√™n remove?
// 3. Measure overhead nh∆∞ th·∫ø n√†o?
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * ‚úÖ FIXED: Ch·ªâ compute tr·ª±c ti·∫øp (kh√¥ng c·∫ßn memo)
 */
function ProperlyOptimized() {
  const [a, setA] = useState(1);
  const [b, setB] = useState(2);

  // ‚úÖ Simple calculations - NO memo needed
  const sum = a + b;
  const double = sum * 2;
  const message = `Result: ${double}`;
  const isEven = double % 2 === 0;

  return (
    <div>
      <button onClick={() => setA(a + 1)}>A: {a}</button>
      <button onClick={() => setB(b + 1)}>B: {b}</button>
      <p>{message}</p>
      <p>{isEven ? 'Even' : 'Odd'}</p>
    </div>
  );
}

/**
 * üìù GI·∫¢I TH√çCH:
 *
 * T·∫†I SAO OVER-MEMO C√ì H·∫†I:
 * 1. Memory overhead: M·ªói memo cache 1 value
 * 2. Deps comparison cost: Check deps m·ªói render
 * 3. Code complexity: Kh√≥ ƒë·ªçc, kh√≥ maintain
 *
 * COST vs BENEFIT:
 * - Calculation: a + b ‚Üí ~0.001ms
 * - useMemo overhead ‚Üí ~0.01-0.05ms
 * ‚Üí useMemo ch·∫≠m h∆°n 10-50 l·∫ßn!
 *
 * RULE OF THUMB:
 * - Primitive operations: NEVER memo
 * - String concatenation: NEVER memo
 * - Simple math: NEVER memo
 * - Only memo when calc > 5ms consistently
 */
```

</details>

### Bug 3: Object Dependency Trap

```jsx
/**
 * üêõ BUG: useMemo re-runs m·ªói render d√π object "kh√¥ng ƒë·ªïi"
 * Tri·ªáu ch·ª©ng: Console log ch·∫°y m·ªói render
 */
function ObjectDependencyBug({ config }) {
  const [count, setCount] = useState(0);

  // üêõ config l√† object m·ªõi m·ªói render t·ª´ parent!
  const processed = useMemo(() => {
    console.log('üîÑ Processing with config...');
    return config.items.map((item) => item * config.multiplier);
  }, [config]); // ‚ùå config always new reference

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <p>Processed: {processed.join(', ')}</p>
    </div>
  );
}

// Parent component
function Parent() {
  const [value, setValue] = useState(1);

  // üêõ Config object t·∫°o m·ªõi m·ªói render!
  const config = {
    items: [1, 2, 3],
    multiplier: 2,
  };

  return <ObjectDependencyBug config={config} />;
}

// üîç Debug questions:
// 1. T·∫°i sao processed re-compute m·ªói render?
// 2. L√†m th·∫ø n√†o ƒë·ªÉ fix ·ªü Parent?
// 3. L√†m th·∫ø n√†o ƒë·ªÉ fix ·ªü Child?
```

<details>
<summary>üí° Solution</summary>

```jsx
/**
 * ‚úÖ SOLUTION 1: Memo config ·ªü Parent
 */
function ParentFixed() {
  const [value, setValue] = useState(1);

  // ‚úÖ Config stable reference
  const config = useMemo(
    () => ({
      items: [1, 2, 3],
      multiplier: 2,
    }),
    [],
  ); // Empty deps - never changes

  return <ObjectDependencyBug config={config} />;
}

/**
 * ‚úÖ SOLUTION 2: Destructure dependencies ·ªü Child
 */
function ObjectDependencyFixed({ config }) {
  const [count, setCount] = useState(0);

  // ‚úÖ Depend on primitives/arrays, not object
  const processed = useMemo(() => {
    console.log('üîÑ Processing...');
    return config.items.map((item) => item * config.multiplier);
  }, [config.items, config.multiplier]); // ‚úÖ Specific deps

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <p>Processed: {processed.join(', ')}</p>
    </div>
  );
}

/**
 * ‚úÖ SOLUTION 3: D√πng useRef n·∫øu config th·∫≠t s·ª± static
 */
function ObjectDependencyRef({ config }) {
  const [count, setCount] = useState(0);

  // ‚úÖ Ref kh√¥ng trigger re-memo
  const configRef = useRef(config);

  const processed = useMemo(() => {
    console.log('üîÑ Processing...');
    const cfg = configRef.current;
    return cfg.items.map((item) => item * cfg.multiplier);
  }, []); // Empty - truly static

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <p>Processed: {processed.join(', ')}</p>
    </div>
  );
}

/**
 * üìù GI·∫¢I TH√çCH:
 *
 * V·∫§N ƒê·ªÄ:
 * - JavaScript: {} !== {} (new reference)
 * - useMemo so s√°nh b·∫±ng Object.is()
 * - config object m·ªõi ‚Üí deps changed ‚Üí re-run
 *
 * SOLUTIONS:
 * 1. Memo config ·ªü parent (n·∫øu parent control ƒë∆∞·ª£c)
 * 2. Destructure deps (depend on values, not object)
 * 3. useRef (n·∫øu truly static v√† kh√¥ng c·∫ßn reactive)
 *
 * BEST PRACTICE:
 * - Prefer primitive dependencies
 * - If object: memo it or destructure
 * - ESLint warning s·∫Ω gi√∫p catch issues n√†y
 */
```

</details>

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

- [ ] T√¥i hi·ªÉu useMemo cache **gi√° tr·ªã**, kh√¥ng ph·∫£i component
- [ ] T√¥i bi·∫øt khi n√†o N√äN d√πng useMemo (expensive, stable deps)
- [ ] T√¥i bi·∫øt khi n√†o KH√îNG N√äN d√πng (simple calc, frequent changes)
- [ ] T√¥i bi·∫øt dependencies array ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o
- [ ] T√¥i c√≥ th·ªÉ debug stale dependencies
- [ ] T√¥i hi·ªÉu object/array dependencies trap
- [ ] T√¥i bi·∫øt measure performance tr∆∞·ªõc/sau optimize
- [ ] T√¥i hi·ªÉu trade-off gi·ªØa memory v√† speed
- [ ] T√¥i bi·∫øt useMemo kh√°c React.memo nh∆∞ th·∫ø n√†o
- [ ] T√¥i c√≥ th·ªÉ quy·∫øt ƒë·ªãnh strategy memo cho data pipeline

### Code Review Checklist

**Khi th·∫•y useMemo, ki·ªÉm tra:**

- [ ] Calculation th·∫≠t s·ª± ƒë·∫Øt ƒë·ªè? (>5ms)
- [ ] Dependencies ƒë·∫ßy ƒë·ªß? (ESLint kh√¥ng warning)
- [ ] Dependencies ·ªïn ƒë·ªãnh? (kh√¥ng t·∫°o m·ªõi m·ªói render)
- [ ] Kh√¥ng over-memoize simple operations
- [ ] Console.log ƒë·ªÉ verify memo ho·∫°t ƒë·ªông
- [ ] Comment gi·∫£i th√≠ch t·∫°i sao c·∫ßn memo

**Red flags:**

- üö© useMemo cho primitive calculations (a + b)
- üö© useMemo v·ªõi object dependencies kh√¥ng stable
- üö© Qu√° nhi·ªÅu nested useMemo (>3 levels)
- üö© Dependencies array r·ªóng nh∆∞ng d√πng props/state
- üö© Kh√¥ng c√≥ comment gi·∫£i th√≠ch t·∫°i sao c·∫ßn memo

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**Exercise: Optimize Search Results**

Cho component hi·ªÉn th·ªã k·∫øt qu·∫£ search t·ª´ 5000 articles. Optimize v·ªõi useMemo.

```jsx
function ArticleSearch() {
  const [articles] = useState(/* 5000 articles */);
  const [search, setSearch] = useState('');
  const [sortBy, setSortBy] = useState('date');

  // TODO: Optimize v·ªõi useMemo
  // - Filter by search term (title + content)
  // - Sort by date or relevance
  // - Measure performance improvement
}
```

### N√¢ng cao (60 ph√∫t)

**Exercise: Build Memo Strategy**

T·∫°o dashboard v·ªõi 3 charts t·ª´ c√πng 1 dataset:

- Line chart: Sales over time
- Bar chart: Top products
- Pie chart: Category distribution

Requirements:

- 10,000 data points
- Multiple filters (date range, category, min amount)
- Efficient memo strategy (kh√¥ng memo qu√° nhi·ªÅu/√≠t)
- Document memo decisions v·ªõi comments
- Performance budget: <50ms cho m·ªçi filter change

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. [React Docs - useMemo](https://react.dev/reference/react/useMemo)
2. [When to useMemo and useCallback](https://kentcdodds.com/blog/usememo-and-usecallback)

### ƒê·ªçc th√™m

- [React re-renders guide](https://www.developerway.com/posts/react-re-renders-guide)
- [The cost of useMemo](https://blog.logrocket.com/react-usememo-vs-usecallback/)

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn

- Ng√†y 31: React Rendering Behavior (khi n√†o re-render?)
- Ng√†y 32: React.memo (ngƒÉn component re-render)

### H∆∞·ªõng t·ªõi

- **Ng√†y 34**: useCallback (memo cho **functions** thay v√¨ values)
- Ng√†y 35: Project - T·ªïng h·ª£p optimization techniques
- Ng√†y 36: Context API (useMemo ƒë·ªÉ optimize context value)

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**Khi n√†o c·∫ßn useMemo trong production:**

1. **Data Transformations**: Filter/sort/aggregate large datasets
2. **Referential Equality**: Object/array props cho memoized children
3. **Expensive Calculations**: Complex algorithms, heavy computation
4. **Chart Data**: Transforming data cho chart libraries

**Khi n√†o KH√îNG c·∫ßn:**

1. **Premature Optimization**: Measure first, optimize later
2. **Simple Operations**: String concat, basic math, primitive checks
3. **Frequently Changing Deps**: Memo overhead > benefit
4. **Small Datasets**: < 100 items usually fine without memo

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior Level:**

```
Q: useMemo d√πng ƒë·ªÉ l√†m g√¨?
A: Cache k·∫øt qu·∫£ c·ªßa t√≠nh to√°n ƒë·∫Øt ƒë·ªè ƒë·ªÉ tr√°nh t√≠nh l·∫°i m·ªói render.

Q: Khi n√†o n√™n d√πng useMemo?
A: Khi c√≥ t√≠nh to√°n expensive v√† dependencies √≠t thay ƒë·ªïi.
```

**Mid Level:**

```
Q: useMemo kh√°c React.memo nh∆∞ th·∫ø n√†o?
A: useMemo memo VALUE (k·∫øt qu·∫£ t√≠nh to√°n), React.memo memo COMPONENT (ngƒÉn re-render).

Q: T·∫°i sao useMemo c√≥ th·ªÉ l√†m h·∫°i performance?
A: Dependencies comparison c√≥ cost. N·∫øu calc < comparison cost, useMemo l√†m ch·∫≠m h∆°n.

Q: Object dependencies trap l√† g√¨? Fix th·∫ø n√†o?
A: Object m·ªõi m·ªói render ‚Üí memo v√¥ d·ª•ng. Fix: memo object ·ªü parent ho·∫∑c destructure deps.
```

**Senior Level:**

```
Q: Thi·∫øt k·∫ø memo strategy cho complex dashboard v·ªõi 10+ derived states?
A:
- Chain useMemo (filter ‚Üí group ‚Üí sort)
- Memo expensive steps, skip cheap ones
- Measure performance v·ªõi/kh√¥ng memo
- Document decisions trong code
- Monitor v·ªõi React DevTools Profiler

Q: Trade-off gi·ªØa useMemo v√† code splitting/lazy loading?
A:
useMemo: Optimize computation trong component
Code splitting: Reduce initial bundle, load on demand
Use both: Code split routes, useMemo trong route components

Q: Khi n√†o d√πng Web Workers thay v√¨ useMemo?
A:
- T√≠nh to√°n > 100ms (block main thread)
- Independent from React lifecycle
- CPU-intensive (image processing, parsing)
useMemo v·∫´n c·∫ßn ·ªü main thread, Workers cho heavy lifting
```

### War Stories

**Story 1: The Over-Optimization Trap**

"Trong d·ª± √°n e-commerce, junior dev wrap m·ªçi th·ª© trong useMemo. Profile th·∫•y performance GI·∫¢M 20%. Nguy√™n nh√¢n: memo overhead > benefit cho 90% cases. Lesson: Measure before optimize, remove premature memos."

**Story 2: Object Dependency Hell**

"Dashboard re-render storm v√¨ config object t·ª´ Context lu√¥n m·ªõi. Fix: memo config trong Context Provider. Performance boost t·ª´ 200ms ‚Üí 20ms. Lesson: Profile component tree, t√¨m ngu·ªìn g·ªëc object changes."

**Story 3: The Right Memo Saved The Day**

"App lag n·∫∑ng khi user filter 50,000 products. Th√™m 3 strategic useMemo (filter ‚Üí group ‚Üí sort). Filter change t·ª´ 500ms ‚Üí 30ms. User happy, code clean. Lesson: useMemo brilliant khi d√πng ƒë√∫ng ch·ªó."

---

**üéØ Preview Ng√†y 34:** Ch√∫ng ta ƒë√£ h·ªçc memo **values** v·ªõi useMemo. Ng√†y mai h·ªçc memo **functions** v·ªõi useCallback - gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ inline functions ph√° v·ª° React.memo! üî•
