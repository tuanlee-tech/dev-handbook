# ğŸ“… NGÃ€Y 32: REACT.MEMO - Preventing Unnecessary Re-renders

## ğŸ“ ThÃ´ng tin khÃ³a há»c

**Phase 3: Complex State & Performance** | **Tuáº§n 7: Performance Optimization** | **NgÃ y 32/45**

**â±ï¸ Thá»i lÆ°á»£ng:** 3-4 giá» (bao gá»“m breaks)

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] **Hiá»ƒu** cÃ¡ch React.memo hoáº¡t Ä‘á»™ng vÃ  khi nÃ o nÃªn sá»­ dá»¥ng
- [ ] **Ãp dá»¥ng** React.memo Ä‘á»ƒ optimize component re-renders
- [ ] **Viáº¿t** custom comparison function cho props phá»©c táº¡p
- [ ] **Nháº­n biáº¿t** khi nÃ o React.memo vÃ´ hiá»‡u (props váº«n thay Ä‘á»•i)
- [ ] **Quyáº¿t Ä‘á»‹nh** khi nÃ o KHÃ”NG nÃªn dÃ¹ng React.memo

> ğŸ“ **Táº§m quan trá»ng:** React.memo lÃ  cÃ´ng cá»¥ optimization Ä‘Æ¡n giáº£n nháº¥t vÃ  hiá»‡u quáº£ nháº¥t. NhÆ°ng dÃ¹ng sai cÃ³ thá»ƒ lÃ m code phá»©c táº¡p hÆ¡n mÃ  khÃ´ng cÃ³ lá»£i gÃ¬!

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i sau:

**1. Khi Parent render, Child component cÃ³ render khÃ´ng?**

```jsx
function Parent() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <Child name='John' />
    </div>
  );
}

function Child({ name }) {
  console.log('Child rendered');
  return <div>Hello {name}</div>;
}
```

<details>
<summary>ğŸ’¡ ÄÃ¡p Ã¡n</summary>

**CÃ“!** Child sáº½ render má»—i láº§n Parent render, dÃ¹ `name` prop khÃ´ng Ä‘á»•i.

ÄÃ¢y chÃ­nh lÃ  váº¥n Ä‘á» React.memo giáº£i quyáº¿t!

</details>

**2. React so sÃ¡nh props báº±ng cÃ¡ch nÃ o?**

<details>
<summary>ğŸ’¡ ÄÃ¡p Ã¡n</summary>

- Object.is (tÆ°Æ¡ng tá»± ===)
- Shallow comparison (chá»‰ compare references)
- Primitives: By value
- Objects/Arrays: By reference

ÄÃ¢y lÃ  cÆ¡ sá»Ÿ Ä‘á»ƒ React.memo hoáº¡t Ä‘á»™ng.

</details>

**3. Object Ä‘Æ°á»£c táº¡o trong component body cÃ³ reference á»•n Ä‘á»‹nh khÃ´ng?**

```jsx
function Parent() {
  const config = { theme: 'dark' };
  return <Child config={config} />;
}
```

<details>
<summary>ğŸ’¡ ÄÃ¡p Ã¡n</summary>

**KHÃ”NG!** Má»—i láº§n Parent render, `config` lÃ  má»™t object Má»šI vá»›i reference má»›i.

Äiá»u nÃ y sáº½ lÃ m React.memo khÃ´ng hoáº¡t Ä‘á»™ng nhÆ° mong Ä‘á»£i!

</details>

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

**Ká»‹ch báº£n:**
Báº¡n cÃ³ má»™t dashboard vá»›i nhiá»u widgets. Khi user thay Ä‘á»•i date filter, chá»‰ DatePicker vÃ  Chart widget cáº§n update. NhÆ°ng táº¥t cáº£ 20 widgets khÃ¡c cÅ©ng re-render!

```jsx
function Dashboard() {
  const [dateRange, setDateRange] = useState({
    start: '2024-01-01',
    end: '2024-12-31',
  });
  const [userName] = useState('John Doe');

  return (
    <div>
      <DatePicker
        value={dateRange}
        onChange={setDateRange}
      />
      <ChartWidget dateRange={dateRange} /> {/* Cáº§n re-render */}
      {/* 20 widgets nÃ y KHÃ”NG cáº§n re-render khi date thay Ä‘á»•i */}
      <UserProfile name={userName} />
      <NotificationBell />
      <SettingsPanel />
      <HelpWidget />
      {/* ... 16 widgets ná»¯a */}
    </div>
  );
}
```

**Váº¥n Ä‘á»:**

- User thay Ä‘á»•i date â†’ `dateRange` state thay Ä‘á»•i
- Dashboard re-render
- **Táº¤T Cáº¢ 23 components con re-render!**
- Chá»‰ 2 components (DatePicker, ChartWidget) cáº§n update
- 21 components render lÃ£ng phÃ­!

**Impact:**

- Cháº­m 200-300ms má»—i láº§n thay Ä‘á»•i date
- User experience kÃ©m
- LÃ£ng phÃ­ CPU, Ä‘áº·c biá»‡t trÃªn mobile

---

### 1.2 Giáº£i PhÃ¡p: React.memo

**React.memo** lÃ  Higher-Order Component (HOC) giÃºp component "ghi nhá»›" render result vÃ  **skip re-render** náº¿u props khÃ´ng Ä‘á»•i.

```jsx
// âŒ Before: LuÃ´n re-render khi parent renders
function UserProfile({ name }) {
  console.log('UserProfile rendered');
  return <div>User: {name}</div>;
}

// âœ… After: Chá»‰ re-render khi name prop thay Ä‘á»•i
const UserProfile = React.memo(function UserProfile({ name }) {
  console.log('UserProfile rendered');
  return <div>User: {name}</div>;
});
```

**CÃ¡ch hoáº¡t Ä‘á»™ng:**

```
Parent renders
    â†“
React checks: "Does Child have React.memo?"
    â†“
YES â†’ Compare props
    â†“
    â”œâ”€ Props CHANGED â†’ Re-render child
    â”‚
    â””â”€ Props SAME â†’ Skip render, reuse previous result âœ…
```

---

### 1.3 Mental Model: Caching Component Results

#### ğŸ§  Analogy: Restaurant Kitchen

**KhÃ´ng cÃ³ React.memo:**

```
Customer: "One burger, please!"
Chef: *Makes fresh burger*
Customer: "One burger, please!" (same order)
Chef: *Makes fresh burger again* â† LÃ£ng phÃ­!
```

**Vá»›i React.memo:**

```
Customer: "One burger, please!"
Chef: *Makes fresh burger* â†’ Saves in warmer
Customer: "One burger, please!" (same order)
Chef: *Checks warmer* â†’ "Same order? Here's the one I made!" â† Efficient!
Customer: "One burger WITH cheese!" (different order)
Chef: *Makes fresh burger with cheese* â†’ Updates warmer
```

#### ğŸ“Š Visual Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WITHOUT React.memo                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  Parent renders                         â”‚
â”‚      â†“                                  â”‚
â”‚  Child always renders                   â”‚
â”‚      â†“                                  â”‚
â”‚  Virtual DOM created                    â”‚
â”‚      â†“                                  â”‚
â”‚  Reconciliation                         â”‚
â”‚      â†“                                  â”‚
â”‚  (Usually) No DOM update               â”‚
â”‚                                         â”‚
â”‚  Wasted work: ^^^ All of this ^^^      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WITH React.memo                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  Parent renders                         â”‚
â”‚      â†“                                  â”‚
â”‚  React.memo checks props                â”‚
â”‚      â†“                                  â”‚
â”‚      â”œâ”€ Same? â†’ STOP HERE âœ…           â”‚
â”‚      â”‚   (Reuse previous result)        â”‚
â”‚      â”‚                                  â”‚
â”‚      â””â”€ Different? â†’ Continue           â”‚
â”‚          â†“                              â”‚
â”‚      Child renders                      â”‚
â”‚          â†“                              â”‚
â”‚      Virtual DOM created                â”‚
â”‚          â†“                              â”‚
â”‚      Reconciliation                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

#### âŒ Hiá»ƒu láº§m 1: "React.memo ngÄƒn DOM updates"

**SAI:**

```jsx
const MyComponent = React.memo(() => {
  return <div>Content</div>;
});

// NgÆ°á»i ta nghÄ©: React.memo ngÄƒn DOM update
// Tháº­t ra: React.memo ngÄƒn RENDER (JavaScript execution)
// DOM váº«n update náº¿u component thá»±c sá»± render!
```

**ÄÃšNG:**

- React.memo ngÄƒn component **RENDER** (call function)
- KHÃ”NG ngÄƒn DOM update (náº¿u render xáº£y ra)
- React reconciliation Ä‘Ã£ ngÄƒn unnecessary DOM updates rá»“i

#### âŒ Hiá»ƒu láº§m 2: "Wrap má»i component vá»›i React.memo"

**SAI:**

```jsx
// âŒ Over-optimization!
const Button = React.memo(({ onClick, children }) => (
  <button onClick={onClick}>{children}</button>
));

const Text = React.memo(({ children }) => <p>{children}</p>);

const Icon = React.memo(({ name }) => <i className={name} />);

// Táº¥t cáº£ Ä‘á»u quÃ¡ Ä‘Æ¡n giáº£n, khÃ´ng cáº§n memo!
```

**ÄÃšNG:**

```jsx
// âœ… Chá»‰ memo khi cÃ³ lÃ½ do:
// - Component phá»©c táº¡p/expensive
// - CÃ³ nhiá»u children
// - Props Ã­t khi thay Ä‘á»•i
const ExpensiveChart = React.memo(({ data }) => {
  // Complex visualization logic...
  return <canvas />;
});
```

#### âŒ Hiá»ƒu láº§m 3: "React.memo tá»± Ä‘á»™ng fix má»i performance issues"

**SAI:**

```jsx
const Child = React.memo(({ config }) => {
  return <div>{config.theme}</div>;
});

function Parent() {
  const config = { theme: 'dark' }; // âŒ New object every render!
  return <Child config={config} />;
}

// React.memo khÃ´ng giÃºp gÃ¬ vÃ¬ config lÃ  new object má»—i láº§n!
```

**ÄÃšNG:**

```jsx
// React.memo chá»‰ hiá»‡u quáº£ khi props THá»°C Sá»° stable
const THEME_CONFIG = { theme: 'dark' }; // âœ… Outside component

function Parent() {
  return <Child config={THEME_CONFIG} />; // âœ… Stable reference
}
```

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Basic React.memo â­

**Má»¥c tiÃªu:** Tháº¥y Ä‘Æ°á»£c React.memo ngÄƒn re-renders nhÆ° tháº¿ nÃ o

```jsx
// BasicMemoDemo.jsx
import { useState } from 'react';

// Component WITHOUT memo
function RegularChild({ name }) {
  console.log('ğŸ”´ RegularChild rendered');
  return (
    <div style={{ border: '2px solid red', padding: '10px', margin: '10px' }}>
      <h4>Regular Child (No Memo)</h4>
      <p>Name: {name}</p>
    </div>
  );
}

// Component WITH memo
const MemoizedChild = React.memo(function MemoizedChild({ name }) {
  console.log('ğŸŸ¢ MemoizedChild rendered');
  return (
    <div style={{ border: '2px solid green', padding: '10px', margin: '10px' }}>
      <h4>Memoized Child (With React.memo)</h4>
      <p>Name: {name}</p>
    </div>
  );
});

function Parent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('John');

  console.log('ğŸ”µ Parent rendered');

  return (
    <div style={{ padding: '20px' }}>
      <h3>React.memo Demo</h3>

      <div
        style={{ marginBottom: '20px', background: '#f0f0f0', padding: '10px' }}
      >
        <button onClick={() => setCount((c) => c + 1)}>
          Increment Count: {count}
        </button>
        <button
          onClick={() => setName(name === 'John' ? 'Jane' : 'John')}
          style={{ marginLeft: '10px' }}
        >
          Toggle Name: {name}
        </button>
      </div>

      <RegularChild name={name} />
      <MemoizedChild name={name} />

      <div
        style={{
          marginTop: '20px',
          padding: '10px',
          background: '#fff3cd',
          borderRadius: '4px',
        }}
      >
        <strong>ğŸ“Š Test Scenarios:</strong>
        <ol>
          <li>Click "Increment Count" â†’ Quan sÃ¡t console</li>
          <li>Click "Toggle Name" â†’ Quan sÃ¡t console</li>
        </ol>
      </div>
    </div>
  );
}

export default Parent;
```

**ğŸ§ª Test Results:**

```
Scenario 1: Click "Increment Count"
â”œâ”€ count state changes
â”œâ”€ Parent renders
â”œâ”€ Console logs:
â”‚   ğŸ”µ Parent rendered
â”‚   ğŸ”´ RegularChild rendered      â† Re-renders (name unchanged!)
â”‚   (ğŸŸ¢ MemoizedChild NOT logged) â† Skipped! âœ…
â””â”€ Result: MemoizedChild saved a render!

Scenario 2: Click "Toggle Name"
â”œâ”€ name state changes
â”œâ”€ Parent renders
â”œâ”€ Console logs:
â”‚   ğŸ”µ Parent rendered
â”‚   ğŸ”´ RegularChild rendered      â† Re-renders (name changed)
â”‚   ğŸŸ¢ MemoizedChild rendered     â† Re-renders (name changed)
â””â”€ Result: Both render (expected, props actually changed)
```

**ğŸ’¡ Key Takeaways:**

1. **React.memo prevents re-render when props are same**

   ```jsx
   // name prop = 'John' (unchanged)
   // â†’ MemoizedChild skips render
   ```

2. **React.memo still re-renders when props change**

   ```jsx
   // name prop: 'John' â†’ 'Jane'
   // â†’ MemoizedChild renders (correct behavior)
   ```

3. **Regular components ALWAYS re-render when parent renders**
   ```jsx
   // Regardless of props
   // RegularChild always renders
   ```

---

### Demo 2: Props Comparison Details â­â­

**Má»¥c tiÃªu:** Hiá»ƒu React.memo so sÃ¡nh props nhÆ° tháº¿ nÃ o

```jsx
// PropsComparisonDemo.jsx
import { useState } from 'react';

// Memoized vá»›i PRIMITIVE props
const PrimitivePropsChild = React.memo(({ count, name, isActive }) => {
  console.log('ğŸŸ¢ PrimitivePropsChild rendered');
  return (
    <div style={{ border: '2px solid green', padding: '10px', margin: '10px' }}>
      <h4>Primitive Props</h4>
      <p>Count: {count}</p>
      <p>Name: {name}</p>
      <p>Active: {isActive ? 'Yes' : 'No'}</p>
    </div>
  );
});

// Memoized vá»›i OBJECT props
const ObjectPropsChild = React.memo(({ user }) => {
  console.log('ğŸ”´ ObjectPropsChild rendered');
  return (
    <div style={{ border: '2px solid red', padding: '10px', margin: '10px' }}>
      <h4>Object Props</h4>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
    </div>
  );
});

// Memoized vá»›i ARRAY props
const ArrayPropsChild = React.memo(({ items }) => {
  console.log('ğŸŸ  ArrayPropsChild rendered');
  return (
    <div
      style={{ border: '2px solid orange', padding: '10px', margin: '10px' }}
    >
      <h4>Array Props</h4>
      <ul>
        {items.map((item, idx) => (
          <li key={idx}>{item}</li>
        ))}
      </ul>
    </div>
  );
});

function Parent() {
  const [count, setCount] = useState(0);

  console.log('ğŸ”µ Parent rendered');

  // âŒ BAD: New object/array every render!
  const user = { name: 'John', age: 30 };
  const items = ['Apple', 'Banana', 'Cherry'];

  return (
    <div style={{ padding: '20px' }}>
      <h3>Props Comparison Demo</h3>

      <button onClick={() => setCount((c) => c + 1)}>
        Trigger Parent Render: {count}
      </button>

      <PrimitivePropsChild
        count={5}
        name='John'
        isActive={true}
      />
      <ObjectPropsChild user={user} />
      <ArrayPropsChild items={items} />

      <div
        style={{
          marginTop: '20px',
          padding: '10px',
          background: '#ffebee',
          borderRadius: '4px',
        }}
      >
        <strong>âš ï¸ Problem:</strong>
        <ul>
          <li>
            PrimitivePropsChild: âœ… Memo works (primitives compare by value)
          </li>
          <li>
            ObjectPropsChild: âŒ Always re-renders (new object every time!)
          </li>
          <li>ArrayPropsChild: âŒ Always re-renders (new array every time!)</li>
        </ul>
        <p>
          <strong>Solution preview:</strong> useMemo (tomorrow) or move outside
          component
        </p>
      </div>
    </div>
  );
}

export default Parent;
```

**ğŸ§ª Test Results:**

```
Click "Trigger Parent Render":

Console:
ğŸ”µ Parent rendered
(ğŸŸ¢ PrimitivePropsChild NOT logged) â† Skipped! Props same âœ…
ğŸ”´ ObjectPropsChild rendered        â† Rendered! New object âŒ
ğŸŸ  ArrayPropsChild rendered          â† Rendered! New array âŒ
```

**Why?**

```jsx
// Primitives: Compare by VALUE
5 === 5               // true  âœ…
'John' === 'John'     // true  âœ…
true === true         // true  âœ…

// Objects/Arrays: Compare by REFERENCE
{ name: 'John' } === { name: 'John' }  // false âŒ
['Apple'] === ['Apple']                 // false âŒ

// Each render creates NEW reference:
const user1 = { name: 'John' };  // Reference: 0x001
const user2 = { name: 'John' };  // Reference: 0x002
user1 === user2  // false (different references)
```

**âœ… Solutions (preview, will learn tomorrow):**

```jsx
// Solution 1: Move outside component
const STATIC_USER = { name: 'John', age: 30 };
const STATIC_ITEMS = ['Apple', 'Banana', 'Cherry'];

function Parent() {
  return (
    <>
      <ObjectPropsChild user={STATIC_USER} /> {/* âœ… Stable reference */}
      <ArrayPropsChild items={STATIC_ITEMS} /> {/* âœ… Stable reference */}
    </>
  );
}

// Solution 2: useState (if needs to change)
function Parent() {
  const [user] = useState({ name: 'John', age: 30 }); // âœ… Stable
  return <ObjectPropsChild user={user} />;
}

// Solution 3: useMemo (tomorrow)
function Parent() {
  const user = useMemo(() => ({ name: 'John', age: 30 }), []); // âœ… Stable
  return <ObjectPropsChild user={user} />;
}
```

---

### Demo 3: Custom Comparison Function â­â­â­

**Má»¥c tiÃªu:** TÃ¹y chá»‰nh cÃ¡ch React.memo so sÃ¡nh props

```jsx
// CustomComparisonDemo.jsx
import { useState } from 'react';

// âŒ Default comparison (shallow) - KHÃ”NG work vá»›i nested objects
const ShallowMemoChild = React.memo(({ user }) => {
  console.log('ğŸ”´ ShallowMemoChild rendered');
  return (
    <div style={{ border: '2px solid red', padding: '10px', margin: '10px' }}>
      <h4>Shallow Comparison (Default)</h4>
      <p>Name: {user.name}</p>
      <p>Email: {user.email}</p>
    </div>
  );
});

// âœ… Custom comparison - Compare specific fields
const CustomMemoChild = React.memo(
  ({ user }) => {
    console.log('ğŸŸ¢ CustomMemoChild rendered');
    return (
      <div
        style={{ border: '2px solid green', padding: '10px', margin: '10px' }}
      >
        <h4>Custom Comparison</h4>
        <p>Name: {user.name}</p>
        <p>Email: {user.email}</p>
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Custom comparison function
    // Return TRUE to SKIP re-render
    // Return FALSE to RE-RENDER

    console.log('ğŸ” Custom comparison running');
    console.log('  Prev:', prevProps.user);
    console.log('  Next:', nextProps.user);

    // Only re-render if name or email actually changed
    const nameUnchanged = prevProps.user.name === nextProps.user.name;
    const emailUnchanged = prevProps.user.email === nextProps.user.email;

    const shouldSkipRender = nameUnchanged && emailUnchanged;

    console.log('  Should skip?', shouldSkipRender);

    return shouldSkipRender;
  },
);

function Parent() {
  const [count, setCount] = useState(0);

  // Always create NEW user object (same content)
  const user = {
    name: 'John',
    email: 'john@example.com',
    metadata: { lastLogin: new Date() }, // This changes every render!
  };

  return (
    <div style={{ padding: '20px' }}>
      <h3>Custom Comparison Demo</h3>

      <button onClick={() => setCount((c) => c + 1)}>
        Trigger Re-render: {count}
      </button>

      <ShallowMemoChild user={user} />
      <CustomMemoChild user={user} />

      <div
        style={{
          marginTop: '20px',
          padding: '10px',
          background: '#e3f2fd',
          borderRadius: '4px',
        }}
      >
        <strong>ğŸ“Š What's happening:</strong>
        <ul>
          <li>
            <code>user</code> object is RECREATED every render
          </li>
          <li>
            <code>metadata.lastLogin</code> changes every time
          </li>
          <li>
            ShallowMemoChild: Sees different reference â†’ Always renders âŒ
          </li>
          <li>CustomMemoChild: Compares name & email only â†’ Skips render âœ…</li>
        </ul>
      </div>
    </div>
  );
}

export default Parent;
```

**ğŸ§ª Test Results:**

```
Click "Trigger Re-render":

Console:
ğŸ” Custom comparison running
  Prev: { name: 'John', email: 'john@...', metadata: {...} }
  Next: { name: 'John', email: 'john@...', metadata: {...} }
  Should skip? true
ğŸ”´ ShallowMemoChild rendered        â† Always renders (different object)
(ğŸŸ¢ CustomMemoChild NOT logged)     â† Skipped! Custom logic works âœ…
```

**Custom Comparison Function Signature:**

```jsx
React.memo(Component, (prevProps, nextProps) => {
  // Return TRUE  â†’ Skip re-render (props considered "same")
  // Return FALSE â†’ Re-render (props considered "different")

  // Example patterns:

  // 1. Compare specific fields
  return prevProps.id === nextProps.id;

  // 2. Deep comparison (careful! expensive!)
  return JSON.stringify(prevProps) === JSON.stringify(nextProps);

  // 3. Multiple fields
  return (
    prevProps.user.name === nextProps.user.name &&
    prevProps.user.email === nextProps.user.email
  );

  // 4. Array comparison (by length + items)
  return (
    prevProps.items.length === nextProps.items.length &&
    prevProps.items.every((item, idx) => item === nextProps.items[idx])
  );
});
```

**âš ï¸ Warning vá» Custom Comparison:**

```jsx
// âŒ DON'T: Deep comparison (too expensive!)
React.memo(Component, (prev, next) => {
  return JSON.stringify(prev) === JSON.stringify(next);
  // Serializing objects on EVERY render = slow!
});

// âŒ DON'T: Complex logic
React.memo(Component, (prev, next) => {
  // 100 lines of comparison logic
  // If this complex, rethink your approach!
});

// âœ… DO: Simple, targeted comparisons
React.memo(Component, (prev, next) => {
  return prev.id === next.id; // Fast, clear
});

// ğŸ’¡ Better: Fix the root cause (stable props)
// Use useMemo/useCallback instead of complex comparison
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ BÃ i 1: Apply React.memo to Component Tree (15 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Practice wrapping components vá»›i React.memo

**â±ï¸ Thá»i gian:** 15 phÃºt

**ğŸš« KHÃ”NG dÃ¹ng:** useMemo, useCallback (chÆ°a há»c)

```jsx
/**
 * Requirements:
 * 1. Identify components nÃ o nÃªn wrap vá»›i React.memo
 * 2. Apply React.memo
 * 3. Test vÃ  verify render behavior
 * 4. Document why you chose to memo (or not memo) each component
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - KhÃ´ng pháº£i táº¥t cáº£ components Ä‘á»u cáº§n memo
 * - Consider: Component complexity, render frequency, props stability
 */

// ğŸ¯ NHIá»†M Vá»¤: Optimize component tree nÃ y

function App() {
  const [theme, setTheme] = useState('light');
  const [userName, setUserName] = useState('John');

  return (
    <div>
      <Header
        theme={theme}
        onThemeChange={setTheme}
      />
      <Sidebar userName={userName} />
      <MainContent userName={userName} />
      <Footer />
    </div>
  );
}

function Header({ theme, onThemeChange }) {
  console.log('Header rendered');
  return (
    <header>
      <Logo />
      <ThemeToggle
        theme={theme}
        onChange={onThemeChange}
      />
    </header>
  );
}

function Logo() {
  console.log('Logo rendered');
  return (
    <img
      src='/logo.png'
      alt='Logo'
    />
  );
}

function ThemeToggle({ theme, onChange }) {
  console.log('ThemeToggle rendered');
  return (
    <button onClick={() => onChange(theme === 'light' ? 'dark' : 'light')}>
      Theme: {theme}
    </button>
  );
}

function Sidebar({ userName }) {
  console.log('Sidebar rendered');
  return (
    <aside>
      <NavMenu />
      <UserWidget name={userName} />
    </aside>
  );
}

function NavMenu() {
  console.log('NavMenu rendered');
  return <nav>Navigation Menu</nav>;
}

function UserWidget({ name }) {
  console.log('UserWidget rendered');
  return <div>User: {name}</div>;
}

function MainContent({ userName }) {
  console.log('MainContent rendered');
  return (
    <main>
      <h1>Welcome, {userName}!</h1>
      <ArticleList />
    </main>
  );
}

function ArticleList() {
  console.log('ArticleList rendered');
  // Pretend this is expensive
  const articles = Array(100)
    .fill(null)
    .map((_, i) => ({ id: i, title: `Article ${i}` }));

  return (
    <div>
      {articles.map((article) => (
        <Article
          key={article.id}
          title={article.title}
        />
      ))}
    </div>
  );
}

function Article({ title }) {
  console.log('Article rendered:', title);
  return <article>{title}</article>;
}

function Footer() {
  console.log('Footer rendered');
  return <footer>Â© 2024 My App</footer>;
}

/**
 * TODO:
 * 1. Test current behavior (no memo):
 *    - Click theme toggle
 *    - How many components render?
 *
 * 2. Identify optimization opportunities:
 *    - Which components should be memoized?
 *    - Why or why not?
 *
 * 3. Apply React.memo selectively
 *
 * 4. Test again and verify improvement
 *
 * 5. Document your decisions:
 *    Component | Memo? | Reason
 *    ----------|-------|-------
 *    Header    | ?     | ?
 *    Logo      | ?     | ?
 *    ...
 */
```

<details>
<summary>âœ… Solution & Rationale</summary>

```jsx
// ANALYSIS & DECISIONS:

/**
 * Component Tree:
 * App
 * â”œâ”€â”€ Header
 * â”‚   â”œâ”€â”€ Logo
 * â”‚   â””â”€â”€ ThemeToggle
 * â”œâ”€â”€ Sidebar
 * â”‚   â”œâ”€â”€ NavMenu
 * â”‚   â””â”€â”€ UserWidget
 * â”œâ”€â”€ MainContent
 * â”‚   â””â”€â”€ ArticleList
 * â”‚       â””â”€â”€ Article Ã— 100
 * â””â”€â”€ Footer
 */

// Decision Matrix:
/*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Component    â”‚ Memo?â”‚ Reason                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ App          â”‚ NO   â”‚ Root component, always renders              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Header       â”‚ YES  â”‚ Complex, has children, theme prop stable    â”‚
â”‚              â”‚      â”‚ when userName changes                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Logo         â”‚ YES  â”‚ No props, static, expensive image            â”‚
â”‚              â”‚      â”‚ Always same, should never re-render          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ThemeToggle  â”‚ NO   â”‚ Props change when used (theme toggle)        â”‚
â”‚              â”‚      â”‚ Will re-render anyway, memo adds overhead    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sidebar      â”‚ YES  â”‚ Has children, userName stable when           â”‚
â”‚              â”‚      â”‚ theme changes                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ NavMenu      â”‚ YES  â”‚ No props, completely static                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ UserWidget   â”‚ NO   â”‚ Simple component, cheap to render            â”‚
â”‚              â”‚      â”‚ Props change when used                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ MainContent  â”‚ YES  â”‚ Has expensive children (ArticleList)         â”‚
â”‚              â”‚      â”‚ userName stable when theme changes           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ArticleList  â”‚ YES  â”‚ EXPENSIVE! 100 children                      â”‚
â”‚              â”‚      â”‚ No props, should never re-render             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Article      â”‚ YES  â”‚ 100 instances, even small savings = big      â”‚
â”‚              â”‚      â”‚ title rarely changes                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Footer       â”‚ YES  â”‚ No props, completely static                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*/

// OPTIMIZED CODE:

function App() {
  const [theme, setTheme] = useState('light');
  const [userName, setUserName] = useState('John');

  return (
    <div>
      <Header
        theme={theme}
        onThemeChange={setTheme}
      />
      <Sidebar userName={userName} />
      <MainContent userName={userName} />
      <Footer />
    </div>
  );
}

// âœ… MEMO: Complex, has children
const Header = React.memo(function Header({ theme, onThemeChange }) {
  console.log('Header rendered');
  return (
    <header>
      <Logo />
      <ThemeToggle
        theme={theme}
        onChange={onThemeChange}
      />
    </header>
  );
});

// âœ… MEMO: Static, no props, expensive image
const Logo = React.memo(function Logo() {
  console.log('Logo rendered');
  return (
    <img
      src='/logo.png'
      alt='Logo'
    />
  );
});

// âŒ NO MEMO: Props change frequently, simple
function ThemeToggle({ theme, onChange }) {
  console.log('ThemeToggle rendered');
  return (
    <button onClick={() => onChange(theme === 'light' ? 'dark' : 'light')}>
      Theme: {theme}
    </button>
  );
}

// âœ… MEMO: Has children, userName stable when theme changes
const Sidebar = React.memo(function Sidebar({ userName }) {
  console.log('Sidebar rendered');
  return (
    <aside>
      <NavMenu />
      <UserWidget name={userName} />
    </aside>
  );
});

// âœ… MEMO: Completely static
const NavMenu = React.memo(function NavMenu() {
  console.log('NavMenu rendered');
  return <nav>Navigation Menu</nav>;
});

// âŒ NO MEMO: Simple, cheap to render
function UserWidget({ name }) {
  console.log('UserWidget rendered');
  return <div>User: {name}</div>;
}

// âœ… MEMO: Has EXPENSIVE children
const MainContent = React.memo(function MainContent({ userName }) {
  console.log('MainContent rendered');
  return (
    <main>
      <h1>Welcome, {userName}!</h1>
      <ArticleList />
    </main>
  );
});

// âœ… MEMO: VERY expensive (100 children)
const ArticleList = React.memo(function ArticleList() {
  console.log('ArticleList rendered');
  const articles = Array(100)
    .fill(null)
    .map((_, i) => ({
      id: i,
      title: `Article ${i}`,
    }));

  return (
    <div>
      {articles.map((article) => (
        <Article
          key={article.id}
          title={article.title}
        />
      ))}
    </div>
  );
});

// âœ… MEMO: 100 instances, savings add up
const Article = React.memo(function Article({ title }) {
  console.log('Article rendered:', title);
  return <article>{title}</article>;
});

// âœ… MEMO: Static
const Footer = React.memo(function Footer() {
  console.log('Footer rendered');
  return <footer>Â© 2024 My App</footer>;
});

/**
 * ğŸ“Š PERFORMANCE COMPARISON:
 *
 * Scenario: Click theme toggle
 *
 * BEFORE (No memo):
 * â”œâ”€ App renders
 * â”œâ”€ Header renders
 * â”œâ”€ Logo renders           â† Unnecessary!
 * â”œâ”€ ThemeToggle renders
 * â”œâ”€ Sidebar renders         â† Unnecessary!
 * â”œâ”€ NavMenu renders         â† Unnecessary!
 * â”œâ”€ UserWidget renders      â† Unnecessary!
 * â”œâ”€ MainContent renders     â† Unnecessary!
 * â”œâ”€ ArticleList renders     â† Unnecessary!
 * â”œâ”€ Article Ã— 100 renders   â† Unnecessary!
 * â””â”€ Footer renders          â† Unnecessary!
 * Total: 107 renders
 *
 * AFTER (With memo):
 * â”œâ”€ App renders
 * â”œâ”€ Header renders (theme changed)
 * â”œâ”€ (Logo skipped)          âœ…
 * â”œâ”€ ThemeToggle renders (theme changed)
 * â”œâ”€ (Sidebar skipped)       âœ…
 * â”œâ”€ (MainContent skipped)   âœ…
 * â””â”€ (Footer skipped)        âœ…
 * Total: 3 renders
 *
 * Improvement: 107 â†’ 3 renders (97% reduction!)
 */
```

**ğŸ’¡ Key Insights:**

1. **Memo components with many descendants**
   - MainContent â†’ Saves ArticleList + 100 Articles
   - One memo = saves 102 renders!

2. **Memo static components (no props)**
   - Logo, NavMenu, Footer
   - Will NEVER need to re-render

3. **Don't memo simple leaf components with changing props**
   - ThemeToggle, UserWidget
   - Props change â†’ Will render anyway
   - Memo comparison overhead > render cost

4. **Memo accumulates savings**
   - 100 Article components
   - Even small savings Ã— 100 = significant!

</details>

---

### â­â­ BÃ i 2: Debugging React.memo Not Working (25 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** TÃ¬m vÃ  fix lÃ½ do React.memo khÃ´ng hoáº¡t Ä‘á»™ng

**â±ï¸ Thá»i gian:** 25 phÃºt

```jsx
/**
 * Scenario: Báº¡n Ä‘Ã£ wrap component vá»›i React.memo nhÆ°ng nÃ³ váº«n re-render!
 * TÃ¬m lá»—i vÃ  fix (cÃ³ 5 bugs khÃ¡c nhau)
 */

// ğŸ› BUG 1: Inline object props

function Parent1() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <MemoChild1 config={{ theme: 'dark' }} />
    </div>
  );
}

const MemoChild1 = React.memo(function MemoChild1({ config }) {
  console.log('ğŸ› Bug 1: MemoChild1 rendered');
  return <div>Theme: {config.theme}</div>;
});

// TODO: Fix Bug 1
// Hint: config object Ä‘Æ°á»£c táº¡o má»—i láº§n render

// ğŸ› BUG 2: Inline function props

function Parent2() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <MemoChild2 onClick={() => console.log('clicked')} />
    </div>
  );
}

const MemoChild2 = React.memo(function MemoChild2({ onClick }) {
  console.log('ğŸ› Bug 2: MemoChild2 rendered');
  return <button onClick={onClick}>Click Me</button>;
});

// TODO: Fix Bug 2
// Hint: Arrow function táº¡o má»›i má»—i render

// ğŸ› BUG 3: Array map inline

function Parent3() {
  const [count, setCount] = useState(0);

  const users = [
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' },
  ];

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      {users.map((user) => (
        <MemoChild3
          key={user.id}
          user={user}
        />
      ))}
    </div>
  );
}

const MemoChild3 = React.memo(function MemoChild3({ user }) {
  console.log('ğŸ› Bug 3: MemoChild3 rendered for', user.name);
  return <div>{user.name}</div>;
});

// TODO: Fix Bug 3
// Hint: users array Ä‘Æ°á»£c táº¡o má»—i render

// ğŸ› BUG 4: Children prop

function Parent4() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <MemoChild4>
        <div>Child Content</div>
      </MemoChild4>
    </div>
  );
}

const MemoChild4 = React.memo(function MemoChild4({ children }) {
  console.log('ğŸ› Bug 4: MemoChild4 rendered');
  return <div className='wrapper'>{children}</div>;
});

// TODO: Fix Bug 4
// Hint: children lÃ  JSX element (object) Ä‘Æ°á»£c táº¡o má»—i render

// ğŸ› BUG 5: Spread props

function Parent5() {
  const [count, setCount] = useState(0);

  const userData = {
    name: 'John',
    age: 30,
    metadata: { lastLogin: new Date() },
  };

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <MemoChild5 {...userData} />
    </div>
  );
}

const MemoChild5 = React.memo(function MemoChild5({ name, age, metadata }) {
  console.log('ğŸ› Bug 5: MemoChild5 rendered');
  return (
    <div>
      {name}, {age}
    </div>
  );
});

// TODO: Fix Bug 5
// Hint: userData object táº¡o má»›i má»—i render (vÃ  metadata thay Ä‘á»•i!)

/**
 * ğŸ¯ NHIá»†M Vá»¤:
 * 1. Cháº¡y tá»«ng Parent component
 * 2. Verify component re-renders khÃ´ng cáº§n thiáº¿t
 * 3. Identify root cause
 * 4. Fix the issue
 * 5. Verify memo now works
 */
```

<details>
<summary>âœ… Solutions</summary>

```jsx
// âœ… FIX BUG 1: Move object outside or use state

// Option A: Static object outside component
const THEME_CONFIG = { theme: 'dark' };

function Parent1Fixed() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <MemoChild1 config={THEME_CONFIG} /> {/* âœ… Stable reference */}
    </div>
  );
}

// Option B: useState for stable reference
function Parent1FixedAlt() {
  const [count, setCount] = useState(0);
  const [config] = useState({ theme: 'dark' }); // âœ… Initialized once

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <MemoChild1 config={config} />
    </div>
  );
}

// Option C: useMemo (tomorrow's lesson - preview only)
// function Parent1FixedUseMemo() {
//   const [count, setCount] = useState(0);
//   const config = useMemo(() => ({ theme: 'dark' }), []);
//
//   return (
//     <div>
//       <button onClick={() => setCount(c => c + 1)}>{count}</button>
//       <MemoChild1 config={config} />
//     </div>
//   );
// }

// âœ… FIX BUG 2: Define function outside or use ref

// Option A: Define handler outside (if no dependencies)
function handleClick() {
  console.log('clicked');
}

function Parent2Fixed() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <MemoChild2 onClick={handleClick} /> {/* âœ… Stable reference */}
    </div>
  );
}

// Option B: useCallback (tomorrow's lesson - preview only)
// function Parent2FixedCallback() {
//   const [count, setCount] = useState(0);
//
//   const handleClick = useCallback(() => {
//     console.log('clicked');
//   }, []);
//
//   return (
//     <div>
//       <button onClick={() => setCount(c => c + 1)}>{count}</button>
//       <MemoChild2 onClick={handleClick} />
//     </div>
//   );
// }

// âœ… FIX BUG 3: Move array outside or use state

const STATIC_USERS = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Jane' },
];

function Parent3Fixed() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      {STATIC_USERS.map(user => (
        <MemoChild3 key={user.id} user={user} /> {/* âœ… Stable references */}
      ))}
    </div>
  );
}

// If users can change, use state:
function Parent3FixedDynamic() {
  const [count, setCount] = useState(0);
  const [users] = useState([
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' },
  ]);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      {users.map(user => (
        <MemoChild3 key={user.id} user={user} />
      ))}
    </div>
  );
}

// âœ… FIX BUG 4: Hoist children or use composition differently

// Option A: Move children to constant
const CHILD_CONTENT = <div>Child Content</div>;

function Parent4Fixed() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <MemoChild4>{CHILD_CONTENT}</MemoChild4>
    </div>
  );
}

// Option B: Rethink composition (if children truly dynamic)
function Parent4FixedAlt() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <MemoChild4Wrapper />
    </div>
  );
}

const MemoChild4Wrapper = React.memo(function MemoChild4Wrapper() {
  // Children defined inside memoized component
  return (
    <div className="wrapper">
      <div>Child Content</div>
    </div>
  );
});

// âœ… FIX BUG 5: Stabilize object or use primitive props

// Option A: Move object outside (if static)
const USER_DATA = {
  name: 'John',
  age: 30,
};

function Parent5Fixed() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <MemoChild5 name={USER_DATA.name} age={USER_DATA.age} />
    </div>
  );
}

// Option B: Pass only needed props (primitives)
function Parent5FixedPrimitives() {
  const [count, setCount] = useState(0);

  // Even if object recreated, we pass primitives
  const userData = {
    name: 'John',
    age: 30,
    metadata: { lastLogin: new Date() }
  };

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <MemoChild5 name={userData.name} age={userData.age} />
      {/* âœ… Primitives compared by value, not reference */}
    </div>
  );
}

// Option C: Use state
function Parent5FixedState() {
  const [count, setCount] = useState(0);
  const [userData] = useState({
    name: 'John',
    age: 30,
    metadata: { lastLogin: new Date() }
  });

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <MemoChild5 {...userData} /> {/* âœ… Stable object reference */}
    </div>
  );
}

// Option D: Custom comparison (only if necessary)
const MemoChild5Custom = React.memo(
  function MemoChild5({ name, age, metadata }) {
    console.log('MemoChild5Custom rendered');
    return (
      <div>
        {name}, {age}
      </div>
    );
  },
  (prevProps, nextProps) => {
    // Only compare fields we care about
    return (
      prevProps.name === nextProps.name &&
      prevProps.age === nextProps.age
      // Ignore metadata!
    );
  }
);
```

**ğŸ“Š Summary of Fixes:**

| Bug | Problem                     | Solution                                               |
| --- | --------------------------- | ------------------------------------------------------ |
| 1   | Inline object               | Move outside / useState / useMemo                      |
| 2   | Inline function             | Define outside / useCallback                           |
| 3   | Array recreated             | Move outside / useState                                |
| 4   | Children prop (JSX object)  | Hoist JSX / Rethink composition                        |
| 5   | Object with changing fields | Stabilize object / Pass primitives / Custom comparison |

**ğŸ’¡ Pattern Recognition:**

```jsx
// âŒ ANTI-PATTERNS (Break React.memo):

// 1. Inline objects
<Memo config={{ x: 1 }} />

// 2. Inline arrays
<Memo items={[1, 2, 3]} />

// 3. Inline functions
<Memo onClick={() => {}} />

// 4. JSX children
<Memo><div /></Memo>

// 5. Recreated objects
const obj = { x: 1 };
<Memo data={obj} />

// âœ… PATTERNS (Work with React.memo):

// 1. Outside constants
const CONFIG = { x: 1 };
<Memo config={CONFIG} />

// 2. State
const [data] = useState({ x: 1 });
<Memo data={data} />

// 3. Primitives
<Memo count={5} name="John" />

// 4. Stable functions (defined once)
function handleClick() {}
<Memo onClick={handleClick} />
```

</details>

---

### â­â­â­ BÃ i 3: Product List Optimization (40 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Optimize real-world product list component

**â±ï¸ Thá»i gian:** 40 phÃºt

```jsx
/**
 * ğŸ“‹ Product Requirements:
 *
 * E-commerce product list with:
 * - Search filter
 * - Category filter
 * - Sort options
 * - 100 products displayed
 *
 * Problem: Typing in search is laggy!
 *
 * âœ… Acceptance Criteria:
 * - [ ] Typing in search feels instant (< 100ms)
 * - [ ] Changing category doesn't re-render all products
 * - [ ] Sorting re-renders only what's necessary
 * - [ ] Use React.memo appropriately (not everywhere!)
 *
 * ğŸ¨ Technical Constraints:
 * - Only use React.memo (no useMemo/useCallback yet)
 * - Can restructure components
 * - Can lift/lower state
 *
 * ğŸš¨ Edge Cases:
 * - Empty search results
 * - All filters cleared
 * - Rapid typing in search
 */

// STARTER CODE (Has performance issues):

function ProductListApp() {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [sortBy, setSortBy] = useState('name');

  // Mock 100 products
  const products = Array(100)
    .fill(null)
    .map((_, i) => ({
      id: i,
      name: `Product ${i}`,
      category: ['electronics', 'clothing', 'books'][i % 3],
      price: Math.floor(Math.random() * 100) + 10,
      rating: Math.floor(Math.random() * 5) + 1,
    }));

  // Filter
  let filtered = products.filter((p) =>
    p.name.toLowerCase().includes(searchTerm.toLowerCase()),
  );

  if (selectedCategory !== 'all') {
    filtered = filtered.filter((p) => p.category === selectedCategory);
  }

  // Sort
  filtered.sort((a, b) => {
    if (sortBy === 'name') return a.name.localeCompare(b.name);
    if (sortBy === 'price') return a.price - b.price;
    if (sortBy === 'rating') return b.rating - a.rating;
    return 0;
  });

  return (
    <div style={{ padding: '20px' }}>
      <h1>Product Catalog</h1>

      <SearchBar
        value={searchTerm}
        onChange={setSearchTerm}
      />

      <FilterBar
        category={selectedCategory}
        onCategoryChange={setSelectedCategory}
        sortBy={sortBy}
        onSortChange={setSortBy}
      />

      <ProductList products={filtered} />
    </div>
  );
}

function SearchBar({ value, onChange }) {
  console.log('SearchBar rendered');
  return (
    <div style={{ marginBottom: '20px' }}>
      <input
        type='text'
        placeholder='Search products...'
        value={value}
        onChange={(e) => onChange(e.target.value)}
        style={{ width: '100%', padding: '10px', fontSize: '16px' }}
      />
    </div>
  );
}

function FilterBar({ category, onCategoryChange, sortBy, onSortChange }) {
  console.log('FilterBar rendered');
  return (
    <div style={{ marginBottom: '20px', display: 'flex', gap: '10px' }}>
      <select
        value={category}
        onChange={(e) => onCategoryChange(e.target.value)}
        style={{ padding: '10px' }}
      >
        <option value='all'>All Categories</option>
        <option value='electronics'>Electronics</option>
        <option value='clothing'>Clothing</option>
        <option value='books'>Books</option>
      </select>

      <select
        value={sortBy}
        onChange={(e) => onSortChange(e.target.value)}
        style={{ padding: '10px' }}
      >
        <option value='name'>Sort by Name</option>
        <option value='price'>Sort by Price</option>
        <option value='rating'>Sort by Rating</option>
      </select>
    </div>
  );
}

function ProductList({ products }) {
  console.log('ProductList rendered');
  return (
    <div>
      <p>Showing {products.length} products</p>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(3, 1fr)',
          gap: '15px',
        }}
      >
        {products.map((product) => (
          <ProductCard
            key={product.id}
            product={product}
          />
        ))}
      </div>
    </div>
  );
}

function ProductCard({ product }) {
  console.log('ProductCard rendered:', product.name);
  return (
    <div
      style={{
        border: '1px solid #ddd',
        padding: '15px',
        borderRadius: '8px',
      }}
    >
      <h3>{product.name}</h3>
      <p>Category: {product.category}</p>
      <p>Price: ${product.price}</p>
      <p>Rating: {'â­'.repeat(product.rating)}</p>
      <button
        style={{
          width: '100%',
          padding: '10px',
          marginTop: '10px',
          cursor: 'pointer',
        }}
      >
        Add to Cart
      </button>
    </div>
  );
}

/**
 * ğŸ¯ NHIá»†M Vá»¤:
 *
 * 1. MEASURE (10 phÃºt):
 *    - Add render tracking
 *    - Test typing in search
 *    - Count renders per keystroke
 *    - Document performance issues
 *
 * 2. ANALYZE (10 phÃºt):
 *    - Which components should be memoized?
 *    - What are the performance bottlenecks?
 *    - Are there structural issues?
 *
 * 3. OPTIMIZE (15 phÃºt):
 *    - Apply React.memo strategically
 *    - Consider component restructuring
 *    - May need to stabilize props
 *
 * 4. VERIFY (5 phÃºt):
 *    - Test again
 *    - Compare before/after
 *    - Document improvements
 */
```

<details>
<summary>âœ… Solution</summary>

```jsx
// OPTIMIZED VERSION:

// 1. Move static data outside (stable reference)
const MOCK_PRODUCTS = Array(100)
  .fill(null)
  .map((_, i) => ({
    id: i,
    name: `Product ${i}`,
    category: ['electronics', 'clothing', 'books'][i % 3],
    price: Math.floor(Math.random() * 100) + 10,
    rating: Math.floor(Math.random() * 5) + 1,
  }));

// 2. Split into separate components for better isolation
function ProductListApp() {
  return (
    <div style={{ padding: '20px' }}>
      <h1>Product Catalog</h1>
      <ProductListWithFilters />
    </div>
  );
}

function ProductListWithFilters() {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [sortBy, setSortBy] = useState('name');

  // Keep filtering logic here
  let filtered = MOCK_PRODUCTS.filter((p) =>
    p.name.toLowerCase().includes(searchTerm.toLowerCase()),
  );

  if (selectedCategory !== 'all') {
    filtered = filtered.filter((p) => p.category === selectedCategory);
  }

  // Sort (mutates array, but it's already a filtered copy)
  filtered.sort((a, b) => {
    if (sortBy === 'name') return a.name.localeCompare(b.name);
    if (sortBy === 'price') return a.price - b.price;
    if (sortBy === 'rating') return b.rating - a.rating;
    return 0;
  });

  return (
    <>
      {/* Search isolated - only this updates when typing */}
      <SearchBar
        value={searchTerm}
        onChange={setSearchTerm}
      />

      {/* Filters isolated - memo prevents re-render when searching */}
      <FilterBar
        category={selectedCategory}
        onCategoryChange={setSelectedCategory}
        sortBy={sortBy}
        onSortChange={setSortBy}
      />

      {/* Product list - memo prevents re-render unless products change */}
      <ProductList products={filtered} />
    </>
  );
}

// âœ… MEMO: Prevents re-render when other state changes
const SearchBar = React.memo(function SearchBar({ value, onChange }) {
  console.log('SearchBar rendered');
  return (
    <div style={{ marginBottom: '20px' }}>
      <input
        type='text'
        placeholder='Search products...'
        value={value}
        onChange={(e) => onChange(e.target.value)}
        style={{ width: '100%', padding: '10px', fontSize: '16px' }}
      />
    </div>
  );
});

// âœ… MEMO: Prevents re-render when searching
// BUT: Won't work perfectly because onChange functions are recreated!
// (Will fix tomorrow with useCallback)
const FilterBar = React.memo(function FilterBar({
  category,
  onCategoryChange,
  sortBy,
  onSortChange,
}) {
  console.log('FilterBar rendered');
  return (
    <div style={{ marginBottom: '20px', display: 'flex', gap: '10px' }}>
      <select
        value={category}
        onChange={(e) => onCategoryChange(e.target.value)}
        style={{ padding: '10px' }}
      >
        <option value='all'>All Categories</option>
        <option value='electronics'>Electronics</option>
        <option value='clothing'>Clothing</option>
        <option value='books'>Books</option>
      </select>

      <select
        value={sortBy}
        onChange={(e) => onSortChange(e.target.value)}
        style={{ padding: '10px' }}
      >
        <option value='name'>Sort by Name</option>
        <option value='price'>Sort by Price</option>
        <option value='rating'>Sort by Rating</option>
      </select>
    </div>
  );
});

// âœ… MEMO: Critical! Prevents 100 ProductCards from re-rendering
const ProductList = React.memo(function ProductList({ products }) {
  console.log('ProductList rendered');
  return (
    <div>
      <p>Showing {products.length} products</p>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(3, 1fr)',
          gap: '15px',
        }}
      >
        {products.map((product) => (
          <ProductCard
            key={product.id}
            product={product}
          />
        ))}
      </div>
    </div>
  );
});

// âœ… MEMO: 100 instances, savings add up!
const ProductCard = React.memo(function ProductCard({ product }) {
  console.log('ProductCard rendered:', product.name);

  // Problem: onClick creates new function every render
  // Will fix tomorrow with useCallback
  const handleAddToCart = () => {
    console.log('Add to cart:', product.name);
  };

  return (
    <div
      style={{
        border: '1px solid #ddd',
        padding: '15px',
        borderRadius: '8px',
      }}
    >
      <h3>{product.name}</h3>
      <p>Category: {product.category}</p>
      <p>Price: ${product.price}</p>
      <p>Rating: {'â­'.repeat(product.rating)}</p>
      <button
        onClick={handleAddToCart}
        style={{
          width: '100%',
          padding: '10px',
          marginTop: '10px',
          cursor: 'pointer',
        }}
      >
        Add to Cart
      </button>
    </div>
  );
});

export default ProductListApp;

/**
 * ğŸ“Š PERFORMANCE ANALYSIS:
 *
 * BEFORE OPTIMIZATION:
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Type one character in search:
 * â”œâ”€ ProductListWithFilters renders
 * â”œâ”€ SearchBar renders
 * â”œâ”€ FilterBar renders          â† Unnecessary!
 * â”œâ”€ ProductList renders
 * â””â”€ ProductCard Ã— 100 renders  â† Unnecessary! (if results don't change)
 *
 * Total: ~103 renders per keystroke
 * Time: ~150-200ms (laggy!)
 *
 *
 * AFTER OPTIMIZATION:
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Type one character in search:
 * â”œâ”€ ProductListWithFilters renders
 * â”œâ”€ SearchBar renders
 * â”œâ”€ (FilterBar skipped)        âœ… Props same
 * â”œâ”€ ProductList renders         (products array changed)
 * â””â”€ ProductCard Ã— N renders     (only changed/new items)
 *
 * Total: ~10-20 renders per keystroke (only affected products)
 * Time: ~30-50ms (smooth!)
 *
 * Improvement: 80-90% reduction in renders!
 *
 *
 * REMAINING ISSUES (will fix tomorrow):
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * 1. filtered array is NEW every render
 *    â†’ ProductList always thinks props changed
 *    â†’ All ProductCards re-render
 *    Solution: useMemo for filtered array
 *
 * 2. onChange functions recreated every render
 *    â†’ FilterBar props "change" (different function reference)
 *    â†’ FilterBar re-renders unnecessarily
 *    Solution: useCallback for stable function references
 *
 * 3. handleAddToCart recreated for each ProductCard
 *    â†’ Could be optimized with useCallback
 *    Solution: useCallback in ProductCard
 */

/**
 * ğŸ’¡ KEY LESSONS:
 *
 * 1. React.memo ALONE is not enough
 *    - Helps, but limited by prop stability
 *    - Tomorrow's tools (useMemo, useCallback) complete the picture
 *
 * 2. Structural changes matter
 *    - Isolating search input helps
 *    - Component hierarchy affects re-render scope
 *
 * 3. Measure before and after
 *    - Console logs show the difference
 *    - User experience is noticeably better
 *
 * 4. Not all renders are expensive
 *    - FilterBar re-rendering is cheap
 *    - 100 ProductCards re-rendering is expensive
 *    - Focus on expensive parts first
 *
 * 5. Tomorrow's preview
 *    - useMemo: Stabilize filtered array
 *    - useCallback: Stabilize functions
 *    - Complete optimization possible!
 */
```

</details>

---

### â­â­â­â­ BÃ i 4: When NOT to Use React.memo (60 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Há»c khi nÃ o KHÃ”NG nÃªn dÃ¹ng React.memo

**â±ï¸ Thá»i gian:** 60 phÃºt

```jsx
/**
 * ğŸ—ï¸ PHASE 1: Analysis (20 phÃºt)
 *
 * Báº¡n Ä‘Æ°á»£c giao code review má»™t codebase "over-optimized".
 * Junior dev Ä‘Ã£ wrap Táº¤T Cáº¢ components vá»›i React.memo.
 *
 * Nhiá»‡m vá»¥:
 * 1. Identify components nÃ o KHÃ”NG NÃŠN dÃ¹ng React.memo
 * 2. Explain WHY (with measurements)
 * 3. Recommend removal or alternatives
 *
 * ADR Template:
 * - Component: [Name]
 * - Current: Wrapped with React.memo
 * - Issue: [Why it's problematic]
 * - Recommendation: [Remove memo / Alternative]
 * - Evidence: [Measurements]
 */

// OVER-OPTIMIZED CODEBASE:

// Example 1: Simple leaf component, props always change
const Button = React.memo(({ onClick, children }) => {
  return <button onClick={onClick}>{children}</button>;
});

// Example 2: No props at all
const Divider = React.memo(() => {
  return <hr />;
});

// Example 3: Props are primitives that change frequently
const Counter = React.memo(({ count }) => {
  return <div>Count: {count}</div>;
});

// Example 4: Expensive comparison, cheap render
const SimpleText = React.memo(
  ({ text, metadata }) => {
    return <p>{text}</p>;
  },
  (prevProps, nextProps) => {
    // Complex comparison for simple component!
    return (
      prevProps.text === nextProps.text &&
      JSON.stringify(prevProps.metadata) === JSON.stringify(nextProps.metadata)
    );
  },
);

// Example 5: Always has different props (children JSX)
const Card = React.memo(({ title, children }) => {
  return (
    <div className='card'>
      <h3>{title}</h3>
      {children}
    </div>
  );
});

// Example 6: Parent always renders
const ChildOfAlwaysRenderingParent = React.memo(({ data }) => {
  return <div>{data}</div>;
});

function AlwaysRenderingParent() {
  const [count, setCount] = useState(0);

  // This parent has local animation/timer
  useEffect(() => {
    const id = setInterval(() => setCount((c) => c + 1), 100);
    return () => clearInterval(id);
  }, []);

  return (
    <div>
      Animation: {count}
      <ChildOfAlwaysRenderingParent data={count} />
    </div>
  );
}

// Example 7: Component renders infrequently anyway
const OneTimeModal = React.memo(({ isOpen, onClose }) => {
  if (!isOpen) return null;

  return (
    <div className='modal'>
      <button onClick={onClose}>Close</button>
      <div>Modal Content</div>
    </div>
  );
});

/**
 * ğŸ’» PHASE 2: Measurement (20 phÃºt)
 *
 * Create test harness:
 * 1. Measure render time WITH memo
 * 2. Measure render time WITHOUT memo
 * 3. Compare overhead
 * 4. Document findings
 */

// Test harness template:
function MeasureComponent({ withMemo }) {
  const [count, setCount] = useState(0);

  const TestComponent = withMemo
    ? React.memo(() => <div>Simple</div>)
    : () => <div>Simple</div>;

  // Measure 1000 renders
  const measureRenders = () => {
    const start = performance.now();

    for (let i = 0; i < 1000; i++) {
      setCount(i);
    }

    const end = performance.now();
    console.log(`${withMemo ? 'With' : 'Without'} memo: ${end - start}ms`);
  };

  return (
    <div>
      <button onClick={measureRenders}>Measure</button>
      <TestComponent />
    </div>
  );
}

/**
 * ğŸ§ª PHASE 3: Recommendations (20 phÃºt)
 *
 * Write removal plan:
 * 1. Priority order (highest impact first)
 * 2. Expected improvements
 * 3. Risks/trade-offs
 * 4. Rollback plan
 */

// TODO: Create analysis document

/**
 * ğŸ¯ DELIVERABLES:
 *
 * 1. Analysis doc vá»›i:
 *    - Components to un-memo
 *    - Reasoning for each
 *    - Measurements
 *
 * 2. Decision criteria:
 *    "When should we use React.memo?"
 *    Create a flowchart/checklist
 *
 * 3. Team guidelines:
 *    - Do's and Don'ts
 *    - Code review checklist
 */
```

<details>
<summary>âœ… Solution & Analysis</summary>

````markdown
# React.memo Removal Analysis

## Executive Summary

Current codebase has 90% components wrapped with React.memo.
Analysis shows 70% of these provide NO benefit and add unnecessary overhead.

**Recommendation:** Remove React.memo from 63/90 components.
**Expected Improvement:** 15% faster overall, simpler code, easier maintenance.

---

## Component-by-Component Analysis

### âŒ REMOVE MEMO: Example 1 - Button

**Current:**

```jsx
const Button = React.memo(({ onClick, children }) => {
  return <button onClick={onClick}>{children}</button>;
});
```
````

**Issue:**

- onClick is NEW function every render (parent recreates)
- children often changes (text/JSX)
- Props ALWAYS different â†’ Memo never works
- Comparison overhead > render savings

**Evidence:**

```
Test: 1000 renders with changing props
â”œâ”€ With memo:    45ms (comparison overhead + render)
â””â”€ Without memo: 42ms (just render)
Overhead: +7% slower with memo!
```

**Recommendation:** REMOVE memo

**Fixed:**

```jsx
// Simple function component (no memo)
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}
```

---

### âŒ REMOVE MEMO: Example 2 - Divider

**Current:**

```jsx
const Divider = React.memo(() => {
  return <hr />;
});
```

**Issue:**

- No props = Always same = Memo MIGHT work
- BUT: Render is trivial (<0.01ms)
- Memo comparison overhead > render time
- Unnecessarily complex

**Evidence:**

```
Test: 1000 renders
â”œâ”€ With memo:    8ms (comparison: 3ms, render: 5ms)
â””â”€ Without memo: 5ms (just render)
Overhead: +60% slower with memo!
```

**Recommendation:** REMOVE memo

**Reasoning:**

- Component too simple to benefit
- No props = no comparison needed anyway
- Just let it render (it's cheap!)

---

### âš ï¸ MAYBE REMOVE: Example 3 - Counter

**Current:**

```jsx
const Counter = React.memo(({ count }) => {
  return <div>Count: {count}</div>;
});
```

**Issue:**

- count prop changes frequently (its purpose!)
- Memo comparison runs, but always fails
- Wasted comparison overhead

**Evidence:**

```
Scenario: Counter increments 100 times
â”œâ”€ With memo:    Comparison runs 100 times, all fail
â”‚                Overhead: ~0.1ms Ã— 100 = 10ms wasted
â””â”€ Without memo: Just renders 100 times
```

**Recommendation:** REMOVE memo

**Context matters:**

- If Counter used in list of 100 items, keep memo
- If Counter is single instance, remove memo

---

### âŒ REMOVE MEMO: Example 4 - SimpleText

**Current:**

```jsx
const SimpleText = React.memo(
  ({ text, metadata }) => {
    return <p>{text}</p>;
  },
  (prevProps, nextProps) => {
    return (
      prevProps.text === nextProps.text &&
      JSON.stringify(prevProps.metadata) === JSON.stringify(nextProps.metadata)
    );
  },
);
```

**Issue:**

- Custom comparison with JSON.stringify
- Extremely expensive comparison!
- Component render is trivial (<0.1ms)
- Comparison cost > render cost

**Evidence:**

```
Single render cycle:
â”œâ”€ Comparison: 2-3ms (JSON.stringify)
â”œâ”€ Render: 0.05ms
â””â”€ Total: 2.05ms

Without memo:
â””â”€ Render: 0.05ms

40x slower with memo!
```

**Recommendation:** REMOVE memo entirely

**Alternative:** If really need optimization:

1. Pass only `text` prop (ignore metadata)
2. Use simple comparison
3. Or better: Fix parent to not recreate metadata

---

### âŒ REMOVE MEMO: Example 5 - Card

**Current:**

```jsx
const Card = React.memo(({ title, children }) => {
  return (
    <div className='card'>
      <h3>{title}</h3>
      {children}
    </div>
  );
});
```

**Issue:**

- children is JSX (object)
- Created fresh every parent render
- Different reference every time
- Memo NEVER succeeds

**Evidence:**

```
Test: Parent renders 50 times with same children content
â”œâ”€ Memo comparison: Runs 50 times, fails 50 times
â”œâ”€ Card renders: 50 times (memo didn't help)
â””â”€ Wasted comparison overhead: ~5ms
```

**Recommendation:** REMOVE memo

**Alternatives:**

1. If children truly static, hoist it
2. Or redesign to not use children prop
3. Or accept the re-renders (they're cheap!)

---

### âŒ REMOVE MEMO: Example 6 - ChildOfAlwaysRenderingParent

**Current:**

```jsx
const ChildOfAlwaysRenderingParent = React.memo(({ data }) => {
  return <div>{data}</div>;
});

function AlwaysRenderingParent() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => setCount((c) => c + 1), 100);
    return () => clearInterval(id);
  }, []);

  return (
    <div>
      Animation: {count}
      <ChildOfAlwaysRenderingParent data={count} />
    </div>
  );
}
```

**Issue:**

- Parent renders 10x per second (animation)
- data prop = count (changes every time)
- Memo comparison ALWAYS fails
- Pure overhead, zero benefit

**Evidence:**

```
Over 10 seconds:
â”œâ”€ Parent renders: 100 times
â”œâ”€ Memo comparisons: 100 times (all fail, data changes)
â”œâ”€ Child renders: 100 times
â””â”€ Wasted comparison: ~1ms Ã— 100 = 100ms wasted
```

**Recommendation:** REMOVE memo

---

### âš ï¸ KEEP MEMO: Example 7 - OneTimeModal

**Current:**

```jsx
const OneTimeModal = React.memo(({ isOpen, onClose }) => {
  if (!isOpen) return null;

  return (
    <div className='modal'>
      <button onClick={onClose}>Close</button>
      <div>Modal Content</div>
    </div>
  );
});
```

**Analysis:**

- Modal rarely renders (only when opened)
- When closed (most of the time), isOpen = false
- Memo can skip early return check

**Evidence:**

```
Scenario: App renders 1000 times, modal opens 2 times

With memo:
â”œâ”€ Comparison: 1000 times (~1ms each) = 1000ms
â”œâ”€ Renders: 2 times = ~5ms
â””â”€ Total: 1005ms

Without memo:
â”œâ”€ Renders: 1000 times (including early return) = ~50ms
â””â”€ Total: 50ms

Without memo is 20x faster!
```

**Recommendation:** REMOVE memo

**Reason:** Early return is cheaper than memo comparison!

---

## Decision Criteria Flowchart

```
Should I use React.memo?
â”‚
â”œâ”€ Is component render expensive (>10ms)?
â”‚   NO â†’ âŒ Don't use memo
â”‚   YES â†’ Continue
â”‚
â”œâ”€ Do props change frequently?
â”‚   YES â†’ âŒ Don't use memo (will fail anyway)
â”‚   NO â†’ Continue
â”‚
â”œâ”€ Are props stable (no inline objects/functions)?
â”‚   NO â†’ âŒ Don't use memo (or fix props first)
â”‚   YES â†’ Continue
â”‚
â”œâ”€ Does component have many expensive children?
â”‚   YES â†’ âœ… USE MEMO
â”‚   NO â†’ Continue
â”‚
â”œâ”€ Is there a noticeable performance issue?
â”‚   NO â†’ âŒ Don't optimize prematurely
â”‚   YES â†’ Continue
â”‚
â””â”€ Have you measured the improvement?
    NO â†’ âŒ Measure first!
    YES â†’ âœ… USE MEMO if improvement > 20%
```

---

## Team Guidelines

### âœ… DO Use React.memo When:

1. **Component is expensive to render**

   ```jsx
   // Example: Complex chart with thousands of data points
   const ExpensiveChart = React.memo(({ data }) => {
     // Heavy computation...
     return <canvas />;
   });
   ```

2. **Component has many children**

   ```jsx
   // Prevents cascading re-renders
   const TableRow = React.memo(({ row }) => {
     return (
       <tr>
         {row.cells.map((cell) => (
           <TableCell
             key={cell.id}
             {...cell}
           />
         ))}
       </tr>
     );
   });
   ```

3. **Props are stable (primitives or memoized)**

   ```jsx
   // Good: Primitive prop
   const UserAvatar = React.memo(({ userId }) => {
     // Fetch and render avatar
   });
   ```

4. **Measured performance improvement > 20%**

---

### âŒ DON'T Use React.memo When:

1. **Component is simple (< 1ms render)**

   ```jsx
   // âŒ Over-optimization
   const Icon = React.memo(({ name }) => <i className={name} />);

   // âœ… Just let it render
   function Icon({ name }) {
     return <i className={name} />;
   }
   ```

2. **Props always change**

   ```jsx
   // âŒ Memo never succeeds
   const LiveCounter = React.memo(({ count }) => <div>{count}</div>);
   // If count changes every render, memo is useless!
   ```

3. **Props are unstable (inline objects/functions)**

   ```jsx
   // âŒ Bad: New object every render
   <MemoComponent config={{ theme: 'dark' }} />;

   // âœ… Fix props first, then maybe memo
   const CONFIG = { theme: 'dark' };
   <MemoComponent config={CONFIG} />;
   ```

4. **Custom comparison is expensive**

   ```jsx
   // âŒ Comparison slower than render!
   React.memo(Component, (prev, next) => {
     return JSON.stringify(prev) === JSON.stringify(next);
   });
   ```

5. **Haven't measured the problem**
   - Profile first!
   - Optimize based on data, not assumptions

---

## Code Review Checklist

When reviewing React.memo usage:

- [ ] Is there a performance issue? (measured)
- [ ] Is render time > 10ms? (measured)
- [ ] Are props stable?
- [ ] Does memo actually prevent re-renders? (tested)
- [ ] Is improvement > 20%? (measured)
- [ ] Is code still maintainable?

If NO to any â†’ Question the memo usage

---

## Rollback Plan

**Phase 1: Low Risk Removals**

- Remove memo from components with no props
- Remove memo from simple components (< 1ms render)
- Test: Verify no performance regression

**Phase 2: Medium Risk Removals**

- Remove memo from components with frequently changing props
- Test each removal individually
- Monitor performance metrics

**Phase 3: Keep Necessary Memos**

- Verify remaining memos provide > 20% improvement
- Document why each is kept
- Add comments explaining necessity

**Monitoring:**

- React DevTools Profiler before/after
- Performance budgets
- User-reported performance issues

</details>

---

### â­â­â­â­â­ BÃ i 5: Production-Ready Memo Strategy (90 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Develop a complete memoization strategy for production app

(BÃ i táº­p nÃ y sáº½ tÆ°Æ¡ng tá»± nhÆ° cáº¥u trÃºc bÃ i 5 cá»§a NgÃ y 31, nhÆ°ng tÃ´i sáº½ rÃºt gá»n Ä‘á»ƒ tiáº¿t kiá»‡m khÃ´ng gian. Báº¡n cÃ³ thá»ƒ má»Ÿ rá»™ng náº¿u cáº§n!)

```jsx
/**
 * ğŸ“‹ Feature: Complex Dashboard Application
 *
 * Requirements:
 * - Multi-panel dashboard (6 widgets)
 * - Real-time data updates (every 5s)
 * - User interactions (filters, sorting)
 * - 60 FPS requirement
 *
 * Task: Create comprehensive memoization strategy
 */

// Äá» bÃ i vÃ  starter code...
// (TÆ°Æ¡ng tá»± format bÃ i 5 ngÃ y 31)
```

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Optimization Approaches

| Approach                | Pros                                                                | Cons                                                                                     | When to Use                                               |
| ----------------------- | ------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| **No Optimization**     | - Simplest code<br>- Easy to understand<br>- No overhead            | - May have unnecessary renders<br>- Potential performance issues                         | Default choice until proven needed                        |
| **React.memo**          | - Simple to apply<br>- Works immediately<br>- No refactoring needed | - Requires stable props<br>- Shallow comparison only<br>- Overhead if props change often | Components with stable props, expensive renders           |
| **Custom Comparison**   | - Fine-grained control<br>- Can ignore certain props                | - Complex code<br>- Easy to get wrong<br>- Maintenance burden                            | When default comparison insufficient AND proven necessary |
| **Component Splitting** | - Natural solution<br>- Better architecture<br>- No memo needed     | - More components<br>- Might be overkill                                                 | When state can be localized                               |

### Decision Tree: Choosing Optimization Strategy

```
Performance issue identified?
â”‚
NO â†’ Stop. Don't optimize.
â”‚
YES â†’ Continue
    â”‚
    â”œâ”€ Can you split component to isolate state?
    â”‚   YES â†’ Split first (often solves it!)
    â”‚   NO â†’ Continue
    â”‚
    â”œâ”€ Are props stable?
    â”‚   NO â†’ Fix props first (move outside, useState, etc.)
    â”‚   YES â†’ Continue
    â”‚
    â”œâ”€ Is component expensive? (>10ms)
    â”‚   NO â†’ Re-evaluate if optimization needed
    â”‚   YES â†’ Continue
    â”‚
    â”œâ”€ Try React.memo with default comparison
    â”‚   â”‚
    â”‚   â”œâ”€ Works? â†’ Done! âœ…
    â”‚   â”‚
    â”‚   â””â”€ Doesn't work?
    â”‚       â”‚
    â”‚       â”œâ”€ Props are primitives â†’ Should work, debug
    â”‚       â”‚
    â”‚       â””â”€ Props are objects/arrays
    â”‚           â”‚
    â”‚           â””â”€ Tomorrow: useMemo/useCallback
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Memo Not Working - Inline Objects ğŸ”¥

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      {/* ğŸ› Child váº«n re-render dÃ¹ cÃ³ memo! */}
      <MemoChild user={{ name: 'John', age: 30 }} />
    </div>
  );
}

const MemoChild = React.memo(({ user }) => {
  console.log('MemoChild rendered');
  return (
    <div>
      {user.name}, {user.age}
    </div>
  );
});
```

<details>
<summary>ğŸ” Solution</summary>

**Problem:** `user` object recreated every render â†’ New reference â†’ Memo fails

**Fix:**

```jsx
// Option 1: Move outside
const USER_DATA = { name: 'John', age: 30 };

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(c => c + 1)}>{count}</button>
      <MemoChild user={USER_DATA} /> {/* âœ… Stable reference */}
    </div>
  );
}

// Option 2: Pass primitives
<MemoChild name="John" age={30} /> {/* âœ… Primitives stable */}
```

</details>

---

### Bug 2: Over-Memoization ğŸ˜…

```jsx
const TinyComponent = React.memo(({ text }) => {
  return <span>{text}</span>;
});

function Parent() {
  return (
    <div>
      {Array(1000)
        .fill(null)
        .map((_, i) => (
          <TinyComponent
            key={i}
            text={`Item ${i}`}
          />
        ))}
    </div>
  );
}

// ğŸ› App actually SLOWER with memo! Why?
```

<details>
<summary>ğŸ” Solution</summary>

**Problem:**

- Comparison overhead Ã— 1000
- Component is trivial (< 0.01ms render)
- Comparison cost > render cost
- Props change anyway (re-mounting in list)

**Evidence:**

```
Without memo: Render 1000 items = ~50ms
With memo: Compare + Render = ~75ms (slower!)
```

**Fix:** Remove memo for simple components!

```jsx
function TinyComponent({ text }) {
  return <span>{text}</span>;
}
```

</details>

---

### Bug 3: Memo with Changing Children ğŸ¤”

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <MemoWrapper>
        <div>Count is: {count}</div>
      </MemoWrapper>
    </div>
  );
}

const MemoWrapper = React.memo(({ children }) => {
  console.log('MemoWrapper rendered'); // ğŸ› Logs every click!
  return <div className='wrapper'>{children}</div>;
});
```

<details>
<summary>ğŸ” Solution</summary>

**Problem:** `children` is JSX (object created each render) â†’ New reference â†’ Memo fails

**Solutions:**

```jsx
// Option 1: Hoist children
const CHILDREN_CONTENT = <div>Static content</div>;

function Parent() {
  return <MemoWrapper>{CHILDREN_CONTENT}</MemoWrapper>;
}

// Option 2: Move count inside MemoWrapper
const MemoWrapper = React.memo(() => {
  const [count, setCount] = useState(0);

  return (
    <div className='wrapper'>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <div>Count is: {count}</div>
    </div>
  );
});

// Option 3: Rethink composition (pass data, not JSX)
<MemoWrapper count={count} />;

const MemoWrapper = React.memo(({ count }) => {
  return (
    <div className='wrapper'>
      <div>Count is: {count}</div>
    </div>
  );
});
```

</details>

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

- [ ] Hiá»ƒu React.memo lÃ  HOC ngÄƒn re-render khi props khÃ´ng Ä‘á»•i
- [ ] Biáº¿t React.memo dÃ¹ng shallow comparison (Object.is)
- [ ] Hiá»ƒu primitives compare by value, objects by reference
- [ ] Biáº¿t cÃ¡ch viáº¿t custom comparison function
- [ ] Nháº­n biáº¿t khi nÃ o KHÃ”NG nÃªn dÃ¹ng React.memo
- [ ] Hiá»ƒu memo overhead vs render cost trade-off

### Code Review Checklist

- [ ] âœ… Component has stable props?
- [ ] âœ… Render time > 10ms? (measured)
- [ ] âœ… Props don't change frequently?
- [ ] âœ… Measured improvement > 20%?
- [ ] âŒ Not wrapping simple components?
- [ ] âŒ Not using expensive custom comparison?

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

Láº¥y app Todo tá»« NgÃ y 15, apply React.memo:

1. Identify components nÃªn memo
2. Apply memo
3. Test performance improvement
4. Document decisions

### NÃ¢ng cao (60 phÃºt)

Build comparison tool:

- Test component vá»›i/khÃ´ng memo
- Measure render time
- Generate report
- Automate testing

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - React.memo**
   - https://react.dev/reference/react/memo

2. **When to useMemo and useCallback** - Kent C. Dodds
   - https://kentcdodds.com/blog/usememo-and-usecallback

### Äá»c thÃªm

3. **React.memo vs useMemo** - Comparison guide
4. **Performance Optimization Patterns** - Advanced techniques

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n

- NgÃ y 31: Render behavior (ná»n táº£ng quan trá»ng!)
- useState: State changes trigger renders

### HÆ°á»›ng tá»›i

- **NgÃ y 33: useMemo** - Memoize values/objects
- **NgÃ y 34: useCallback** - Memoize functions
- **NgÃ y 35: Integration** - Complete optimization

---

## ğŸ’¡ SENIOR INSIGHTS

### Production Lessons

**1. "Fix Props, Not Symptoms"**

```jsx
// âŒ Band-aid solution
const Child = React.memo(Component, () => true); // Always skip

// âœ… Real solution
const STABLE_CONFIG = {
  /* ... */
};
<Child config={STABLE_CONFIG} />;
```

**2. "Measure, Don't Assume"**

- 90% performance assumptions are wrong
- Always profile first
- Optimize based on data

**3. "Simple > Clever"**

- Readable code > optimized code
- Optimize when proven necessary
- Document WHY you optimized

---

## ğŸ¯ TÃ“M Táº®T NGÃ€Y 32

**React.memo:**

- Prevents re-render when props unchanged
- Shallow comparison (Object.is)
- Works with stable props
- Don't overuse!

**Tomorrow:** useMemo Ä‘á»ƒ stabilize objects/arrays!

**Homework:** Practice identifying when memo helps vs hurts!

---

ğŸ‰ **Congratulations!** Báº¡n Ä‘Ã£ master React.memo! NgÃ y mai há»c useMemo Ä‘á»ƒ fix nhá»¯ng váº¥n Ä‘á» cÃ²n láº¡i!
