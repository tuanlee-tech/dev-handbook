# üìÖ NG√ÄY 28: useReducer + useEffect - Async Actions Pattern

## üìç V·ªã tr√≠: Phase 3, Tu·∫ßn 6, Ng√†y 28/45

### ‚è±Ô∏è Th·ªùi l∆∞·ª£ng: 3-4 gi·ªù

---

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:

- [ ] **K·∫øt h·ª£p ƒë∆∞·ª£c** useReducer + useEffect ƒë·ªÉ handle async operations
- [ ] **Implement ƒë∆∞·ª£c** loading/success/error states pattern v·ªõi reducer
- [ ] **X·ª≠ l√Ω ƒë∆∞·ª£c** race conditions v√† request cancellation
- [ ] **√Åp d·ª•ng ƒë∆∞·ª£c** optimistic updates cho better UX
- [ ] **Thi·∫øt k·∫ø ƒë∆∞·ª£c** retry logic v√† error recovery

---

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu, h√£y tr·∫£ l·ªùi 3 c√¢u h·ªèi sau:

1. **Reducer c√≥ ƒë∆∞·ª£c ph√©p async (await fetch) kh√¥ng? T·∫°i sao?**
   - G·ª£i √Ω: Reducer ph·∫£i pure function...

2. **useEffect cleanup function ch·∫°y khi n√†o?**
   - G·ª£i √Ω: Component unmount, dependencies change...

3. **Race condition trong data fetching l√† g√¨?**
   - V√≠ d·ª•: User search "abc" ‚Üí "abcd" nhanh ‚Üí response n√†o hi·ªÉn th·ªã?

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

H√£y t∆∞·ªüng t∆∞·ª£ng b·∫°n ƒëang build **User Profile Page** v·ªõi data t·ª´ API:

```jsx
// ‚ùå V·∫§N ƒê·ªÄ: useState cho async operations
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      setError(null); // ‚ö†Ô∏è D·ªÖ qu√™n!

      try {
        const response = await fetch(`/api/users/${userId}`);
        const data = await response.json();
        setUser(data);
        setLoading(false); // ‚ö†Ô∏è Duplicate
      } catch (err) {
        setError(err.message);
        setLoading(false); // ‚ö†Ô∏è Duplicate
        setUser(null); // ‚ö†Ô∏è D·ªÖ qu√™n!
      }
    };

    fetchUser();
  }, [userId]);

  // üò± Nhi·ªÅu edge cases kh√¥ng handle:
  // - Component unmount gi·ªØa ch·ª´ng request?
  // - userId change tr∆∞·ªõc khi request complete?
  // - Retry khi error?
  // - Optimistic update?
}
```

**V·∫•n ƒë·ªÅ:**

1. üî¥ **3 separate states** ‚Üí D·ªÖ out of sync
2. üî¥ **Duplicate logic** ‚Üí setLoading(false) ·ªü nhi·ªÅu ch·ªó
3. üî¥ **Missing cleanup** ‚Üí Race conditions
4. üî¥ **Inconsistent states** ‚Üí loading=true + error != null?
5. üî¥ **Hard to extend** ‚Üí Th√™m retry, optimistic updates?

### 1.2 Gi·∫£i Ph√°p: useReducer + useEffect Pattern

**Core Idea:**

- ‚úÖ **useReducer** qu·∫£n l√Ω state (sync)
- ‚úÖ **useEffect** handle side effects (async)
- ‚úÖ **dispatch trong useEffect** ƒë·ªÉ update state

```jsx
// ‚úÖ GI·∫¢I PH√ÅP: Centralized async state
const initialState = {
  data: null,
  loading: false,
  error: null,
};

function reducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { data: null, loading: true, error: null };

    case 'FETCH_SUCCESS':
      return { data: action.payload, loading: false, error: null };

    case 'FETCH_ERROR':
      return { data: null, loading: false, error: action.payload };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function UserProfile({ userId }) {
  const [state, dispatch] = useReducer(reducer, initialState);

  useEffect(() => {
    const controller = new AbortController();

    const fetchUser = async () => {
      dispatch({ type: 'FETCH_START' });

      try {
        const response = await fetch(`/api/users/${userId}`, {
          signal: controller.signal,
        });
        const data = await response.json();
        dispatch({ type: 'FETCH_SUCCESS', payload: data });
      } catch (err) {
        if (err.name !== 'AbortError') {
          dispatch({ type: 'FETCH_ERROR', payload: err.message });
        }
      }
    };

    fetchUser();

    return () => controller.abort(); // Cleanup!
  }, [userId]);

  // ‚úÖ Centralized state, clear transitions
}
```

**L·ª£i √≠ch:**

- ‚úÖ **State transitions r√µ r√†ng** ‚Üí idle ‚Üí loading ‚Üí success/error
- ‚úÖ **Impossible states prevented** ‚Üí Kh√¥ng th·ªÉ loading=true + data != null
- ‚úÖ **Easy to test** ‚Üí Test reducer ri√™ng
- ‚úÖ **Easy to extend** ‚Üí Add retry, optimistic updates

### 1.3 Mental Model

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              COMPONENT                          ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ    useReducer (Sync State)           ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ                                       ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  State: { data, loading, error }     ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ                                       ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  Reducer handles:                    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ FETCH_START ‚Üí loading=true        ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ FETCH_SUCCESS ‚Üí data=...          ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ FETCH_ERROR ‚Üí error=...           ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ           ‚Üë                                     ‚îÇ
‚îÇ           ‚îÇ dispatch(action)                   ‚îÇ
‚îÇ           ‚îÇ                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ    useEffect (Async Side Effects)    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ                                       ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  1. dispatch(FETCH_START)            ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  2. await fetch(...)                 ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  3. dispatch(FETCH_SUCCESS/ERROR)    ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ                                       ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ  Cleanup: abort request              ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ                                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Flow:
1. Effect runs ‚Üí dispatch FETCH_START
2. Reducer updates state ‚Üí loading=true
3. Component re-renders (loading UI)
4. Async fetch completes
5. Effect dispatches FETCH_SUCCESS/ERROR
6. Reducer updates state ‚Üí data/error
7. Component re-renders (data/error UI)
```

**Analogy:** useReducer + useEffect gi·ªëng **State Machine v·ªõi Async Transitions**

- **State Machine (Reducer):** ƒê·ªãnh nghƒ©a states & transitions
- **Async Engine (useEffect):** Trigger transitions d·ª±a tr√™n external events
- **Dispatcher:** Bridge gi·ªØa async world v√† sync state

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

‚ùå **Hi·ªÉu l·∫ßm 1:** "C√≥ th·ªÉ async trong reducer"

- ‚úÖ **S·ª± th·∫≠t:** Reducer PH·∫¢I synchronous, pure function. Async trong useEffect!

‚ùå **Hi·ªÉu l·∫ßm 2:** "Kh√¥ng c·∫ßn cleanup khi fetch data"

- ‚úÖ **S·ª± th·∫≠t:** LU√îN cleanup ƒë·ªÉ avoid race conditions, memory leaks

‚ùå **Hi·ªÉu l·∫ßm 3:** "Loading state ƒë∆°n gi·∫£n: true/false"

- ‚úÖ **S·ª± th·∫≠t:** C·∫ßn distinguish: idle, loading, success, error (4 states)

‚ùå **Hi·ªÉu l·∫ßm 4:** "dispatch trong useEffect g√¢y infinite loop"

- ‚úÖ **S·ª± th·∫≠t:** Ch·ªâ loop n·∫øu dispatch dependency. Dispatch function stable, safe!

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Basic Async Pattern - Fetch User ‚≠ê

```jsx
import { useReducer, useEffect } from 'react';

// üéØ ACTION TYPES
const ActionTypes = {
  FETCH_START: 'FETCH_START',
  FETCH_SUCCESS: 'FETCH_SUCCESS',
  FETCH_ERROR: 'FETCH_ERROR',
};

// üè≠ REDUCER
function userReducer(state, action) {
  switch (action.type) {
    case ActionTypes.FETCH_START:
      return {
        data: null,
        loading: true,
        error: null,
      };

    case ActionTypes.FETCH_SUCCESS:
      return {
        data: action.payload,
        loading: false,
        error: null,
      };

    case ActionTypes.FETCH_ERROR:
      return {
        data: null,
        loading: false,
        error: action.payload,
      };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// üéØ COMPONENT
function UserProfile({ userId }) {
  const initialState = {
    data: null,
    loading: false,
    error: null,
  };

  const [state, dispatch] = useReducer(userReducer, initialState);

  useEffect(() => {
    // ‚ö†Ô∏è CRITICAL: AbortController for cleanup
    const controller = new AbortController();

    const fetchUser = async () => {
      // 1Ô∏è‚É£ Start loading
      dispatch({ type: ActionTypes.FETCH_START });

      try {
        // 2Ô∏è‚É£ Fetch data
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/users/${userId}`,
          { signal: controller.signal }, // ‚úÖ Attach abort signal
        );

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        // 3Ô∏è‚É£ Success
        dispatch({
          type: ActionTypes.FETCH_SUCCESS,
          payload: data,
        });
      } catch (error) {
        // ‚ö†Ô∏è Don't dispatch if aborted (component unmounted)
        if (error.name !== 'AbortError') {
          dispatch({
            type: ActionTypes.FETCH_ERROR,
            payload: error.message,
          });
        }
      }
    };

    fetchUser();

    // 4Ô∏è‚É£ Cleanup: abort request if userId changes or unmount
    return () => {
      controller.abort();
    };
  }, [userId]); // Re-run khi userId thay ƒë·ªïi

  // üé® RENDER
  if (state.loading) {
    return <div>Loading user {userId}...</div>;
  }

  if (state.error) {
    return <div style={{ color: 'red' }}>Error: {state.error}</div>;
  }

  if (!state.data) {
    return <div>No data</div>;
  }

  return (
    <div>
      <h2>{state.data.name}</h2>
      <p>Email: {state.data.email}</p>
      <p>Phone: {state.data.phone}</p>
      <p>Website: {state.data.website}</p>
    </div>
  );
}

// üéØ DEMO APP
function App() {
  const [userId, setUserId] = useState(1);

  return (
    <div>
      <h1>User Profile</h1>

      <div>
        <button onClick={() => setUserId(1)}>User 1</button>
        <button onClick={() => setUserId(2)}>User 2</button>
        <button onClick={() => setUserId(3)}>User 3</button>
      </div>

      <UserProfile userId={userId} />
    </div>
  );
}
```

**üéØ Key Points:**

1. **State Transitions:**

   ```
   Initial: { data: null, loading: false, error: null }
        ‚Üì FETCH_START
   Loading: { data: null, loading: true, error: null }
        ‚Üì FETCH_SUCCESS
   Success: { data: {...}, loading: false, error: null }
        ‚Üì FETCH_ERROR (if error)
   Error:   { data: null, loading: false, error: "..." }
   ```

2. **AbortController:**
   - Prevents race conditions
   - Cancels in-flight requests
   - Essential for cleanup!

3. **Error Handling:**
   - Check `error.name !== 'AbortError'`
   - Don't dispatch if request was aborted

### Demo 2: Advanced Pattern - Search with Debounce ‚≠ê‚≠ê

```jsx
import { useReducer, useEffect, useState, useRef } from 'react';

// üéØ ACTION TYPES
const ActionTypes = {
  SEARCH_START: 'SEARCH_START',
  SEARCH_SUCCESS: 'SEARCH_SUCCESS',
  SEARCH_ERROR: 'SEARCH_ERROR',
  CLEAR_RESULTS: 'CLEAR_RESULTS',
};

// üè≠ REDUCER
function searchReducer(state, action) {
  switch (action.type) {
    case ActionTypes.SEARCH_START:
      return {
        ...state,
        loading: true,
        error: null,
      };

    case ActionTypes.SEARCH_SUCCESS:
      return {
        ...state,
        results: action.payload,
        loading: false,
        error: null,
      };

    case ActionTypes.SEARCH_ERROR:
      return {
        ...state,
        results: [],
        loading: false,
        error: action.payload,
      };

    case ActionTypes.CLEAR_RESULTS:
      return {
        results: [],
        loading: false,
        error: null,
      };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// üîç SEARCH COMPONENT
function UserSearch() {
  const [searchTerm, setSearchTerm] = useState('');

  const initialState = {
    results: [],
    loading: false,
    error: null,
  };

  const [state, dispatch] = useReducer(searchReducer, initialState);

  // ‚úÖ Debounce search
  useEffect(() => {
    // Clear results n·∫øu search term r·ªóng
    if (!searchTerm.trim()) {
      dispatch({ type: ActionTypes.CLEAR_RESULTS });
      return;
    }

    // Debounce: Ch·ªù 500ms sau khi user ng·ª´ng typing
    const debounceTimer = setTimeout(() => {
      const controller = new AbortController();

      const searchUsers = async () => {
        dispatch({ type: ActionTypes.SEARCH_START });

        try {
          const response = await fetch(
            `https://jsonplaceholder.typicode.com/users?name_like=${searchTerm}`,
            { signal: controller.signal },
          );

          const data = await response.json();

          dispatch({
            type: ActionTypes.SEARCH_SUCCESS,
            payload: data,
          });
        } catch (error) {
          if (error.name !== 'AbortError') {
            dispatch({
              type: ActionTypes.SEARCH_ERROR,
              payload: error.message,
            });
          }
        }
      };

      searchUsers();

      // Cleanup debounce timer
      return () => {
        controller.abort();
      };
    }, 500); // 500ms debounce

    // Cleanup timer n·∫øu searchTerm thay ƒë·ªïi tr∆∞·ªõc 500ms
    return () => {
      clearTimeout(debounceTimer);
    };
  }, [searchTerm]);

  return (
    <div>
      <h2>Search Users</h2>

      <input
        type='text'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder='Search users...'
      />

      {state.loading && <p>Searching...</p>}

      {state.error && <p style={{ color: 'red' }}>Error: {state.error}</p>}

      {state.results.length > 0 && (
        <ul>
          {state.results.map((user) => (
            <li key={user.id}>
              {user.name} ({user.email})
            </li>
          ))}
        </ul>
      )}

      {!state.loading && state.results.length === 0 && searchTerm && (
        <p>No results found</p>
      )}
    </div>
  );
}
```

**üéØ Advanced Concepts:**

1. **Debouncing:**
   - Wait 500ms after user stops typing
   - Reduces API calls
   - Better UX + performance

2. **Cleanup Chain:**

   ```
   User types "a" ‚Üí setTimeout(500ms)
   User types "ab" (before 500ms) ‚Üí clearTimeout + new setTimeout
   ‚Üí Only final "ab" triggers API call
   ```

3. **Empty State Handling:**
   - Clear results khi searchTerm r·ªóng
   - Show "No results" khi c√≥ search nh∆∞ng kh√¥ng t√¨m th·∫•y

### Demo 3: Optimistic Updates ‚≠ê‚≠ê‚≠ê

```jsx
import { useReducer, useEffect, useState } from 'react';

// üéØ ACTION TYPES
const ActionTypes = {
  // Fetch
  FETCH_START: 'FETCH_START',
  FETCH_SUCCESS: 'FETCH_SUCCESS',
  FETCH_ERROR: 'FETCH_ERROR',

  // Optimistic
  ADD_TODO_OPTIMISTIC: 'ADD_TODO_OPTIMISTIC',
  ADD_TODO_CONFIRMED: 'ADD_TODO_CONFIRMED',
  ADD_TODO_FAILED: 'ADD_TODO_FAILED',

  TOGGLE_TODO_OPTIMISTIC: 'TOGGLE_TODO_OPTIMISTIC',
  TOGGLE_TODO_CONFIRMED: 'TOGGLE_TODO_CONFIRMED',
  TOGGLE_TODO_FAILED: 'TOGGLE_TODO_FAILED',
};

// üè≠ REDUCER
function todosReducer(state, action) {
  switch (action.type) {
    case ActionTypes.FETCH_START:
      return { ...state, loading: true };

    case ActionTypes.FETCH_SUCCESS:
      return {
        todos: action.payload,
        loading: false,
        error: null,
      };

    case ActionTypes.FETCH_ERROR:
      return { ...state, loading: false, error: action.payload };

    // ‚úÖ Optimistic Add
    case ActionTypes.ADD_TODO_OPTIMISTIC: {
      const optimisticTodo = {
        id: `temp-${Date.now()}`, // Temporary ID
        title: action.payload.title,
        completed: false,
        _optimistic: true, // Flag ƒë·ªÉ track
      };

      return {
        ...state,
        todos: [...state.todos, optimisticTodo],
      };
    }

    case ActionTypes.ADD_TODO_CONFIRMED: {
      // Replace temporary todo v·ªõi real todo from server
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload.tempId
            ? { ...action.payload.todo, _optimistic: false }
            : todo,
        ),
      };
    }

    case ActionTypes.ADD_TODO_FAILED: {
      // Rollback: Remove optimistic todo
      return {
        ...state,
        todos: state.todos.filter((todo) => todo.id !== action.payload.tempId),
        error: action.payload.error,
      };
    }

    // ‚úÖ Optimistic Toggle
    case ActionTypes.TOGGLE_TODO_OPTIMISTIC: {
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed, _optimistic: true }
            : todo,
        ),
      };
    }

    case ActionTypes.TOGGLE_TODO_CONFIRMED: {
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload.id
            ? { ...todo, _optimistic: false }
            : todo,
        ),
      };
    }

    case ActionTypes.TOGGLE_TODO_FAILED: {
      // Rollback: Toggle back
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed, _optimistic: false }
            : todo,
        ),
        error: action.payload.error,
      };
    }

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// üéØ COMPONENT
function OptimisticTodos() {
  const initialState = {
    todos: [],
    loading: false,
    error: null,
  };

  const [state, dispatch] = useReducer(todosReducer, initialState);
  const [inputValue, setInputValue] = useState('');

  // Fetch initial todos
  useEffect(() => {
    const fetchTodos = async () => {
      dispatch({ type: ActionTypes.FETCH_START });

      try {
        const response = await fetch(
          'https://jsonplaceholder.typicode.com/todos?_limit=5',
        );
        const data = await response.json();
        dispatch({ type: ActionTypes.FETCH_SUCCESS, payload: data });
      } catch (error) {
        dispatch({ type: ActionTypes.FETCH_ERROR, payload: error.message });
      }
    };

    fetchTodos();
  }, []);

  // ‚úÖ Optimistic Add Todo
  const handleAddTodo = async (title) => {
    const tempId = `temp-${Date.now()}`;

    // 1Ô∏è‚É£ Optimistic update (instant UI update)
    dispatch({
      type: ActionTypes.ADD_TODO_OPTIMISTIC,
      payload: { title },
    });

    try {
      // 2Ô∏è‚É£ API call (background)
      const response = await fetch(
        'https://jsonplaceholder.typicode.com/todos',
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, completed: false }),
        },
      );

      const newTodo = await response.json();

      // 3Ô∏è‚É£ Confirm (replace temp with real)
      dispatch({
        type: ActionTypes.ADD_TODO_CONFIRMED,
        payload: { tempId, todo: newTodo },
      });
    } catch (error) {
      // 4Ô∏è‚É£ Rollback on error
      dispatch({
        type: ActionTypes.ADD_TODO_FAILED,
        payload: { tempId, error: error.message },
      });
    }
  };

  // ‚úÖ Optimistic Toggle
  const handleToggle = async (id) => {
    const todo = state.todos.find((t) => t.id === id);

    // 1Ô∏è‚É£ Optimistic update
    dispatch({
      type: ActionTypes.TOGGLE_TODO_OPTIMISTIC,
      payload: { id },
    });

    try {
      // 2Ô∏è‚É£ API call
      await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ completed: !todo.completed }),
      });

      // 3Ô∏è‚É£ Confirm
      dispatch({
        type: ActionTypes.TOGGLE_TODO_CONFIRMED,
        payload: { id },
      });
    } catch (error) {
      // 4Ô∏è‚É£ Rollback
      dispatch({
        type: ActionTypes.TOGGLE_TODO_FAILED,
        payload: { id, error: error.message },
      });
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      handleAddTodo(inputValue);
      setInputValue('');
    }
  };

  return (
    <div>
      <h2>Optimistic Todos</h2>

      {state.error && (
        <div style={{ color: 'red', padding: '10px', background: '#fee' }}>
          Error: {state.error}
        </div>
      )}

      <form onSubmit={handleSubmit}>
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder='Add todo...'
        />
        <button type='submit'>Add</button>
      </form>

      {state.loading ? (
        <p>Loading...</p>
      ) : (
        <ul>
          {state.todos.map((todo) => (
            <li
              key={todo.id}
              style={{
                opacity: todo._optimistic ? 0.5 : 1, // Visual feedback
                transition: 'opacity 0.3s',
              }}
            >
              <input
                type='checkbox'
                checked={todo.completed}
                onChange={() => handleToggle(todo.id)}
              />
              <span
                style={{
                  textDecoration: todo.completed ? 'line-through' : 'none',
                }}
              >
                {todo.title}
              </span>
              {todo._optimistic && <span> (saving...)</span>}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

**üéØ Optimistic Updates Pattern:**

1. **Flow:**

   ```
   User action
       ‚Üì
   Dispatch optimistic update (instant UI)
       ‚Üì
   API call (background)
       ‚Üì
   Success ‚Üí Confirm (replace temp with real)
   Error ‚Üí Rollback (revert to previous state)
   ```

2. **Benefits:**
   - ‚úÖ Instant feedback (no loading spinners)
   - ‚úÖ Better UX (feels faster)
   - ‚úÖ Graceful error handling (rollback visible)

3. **Trade-offs:**
   - ‚ûñ More complex code
   - ‚ûñ Need rollback logic
   - ‚ûñ Temporary IDs management

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Level 1: √Åp D·ª•ng Concept (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Implement basic async pattern
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: Custom hooks, Context
 *
 * Requirements:
 * 1. Fetch posts from API khi component mount
 * 2. Hi·ªÉn th·ªã loading state
 * 3. Hi·ªÉn th·ªã error state n·∫øu c√≥
 * 4. Hi·ªÉn th·ªã list posts khi success
 * 5. Cleanup request khi component unmount
 *
 * API: https://jsonplaceholder.typicode.com/posts?_limit=10
 *
 * üí° G·ª£i √Ω:
 * - State shape: { posts: [], loading: false, error: null }
 * - Actions: FETCH_START, FETCH_SUCCESS, FETCH_ERROR
 * - useEffect v·ªõi AbortController
 */

// TODO: Implement PostsList component

// Starter Code:
function PostsList() {
  // TODO: Setup reducer
  // TODO: Setup useEffect
  // TODO: Render UI

  return <div>Implement me!</div>;
}

// Expected UI:
// Loading: "Loading posts..."
// Error: "Error: [error message]"
// Success: List of 10 post titles
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * PostsList component
 * Fetch v√† hi·ªÉn th·ªã danh s√°ch 10 b√†i post t·ª´ JSONPlaceholder
 * S·ª≠ d·ª•ng useReducer + useEffect v·ªõi AbortController ƒë·ªÉ tr√°nh race condition
 */
import { useReducer, useEffect } from 'react';

const initialState = {
  posts: [],
  loading: false,
  error: null,
};

const ActionTypes = {
  FETCH_START: 'FETCH_START',
  FETCH_SUCCESS: 'FETCH_SUCCESS',
  FETCH_ERROR: 'FETCH_ERROR',
};

function postsReducer(state, action) {
  switch (action.type) {
    case ActionTypes.FETCH_START:
      return {
        posts: [],
        loading: true,
        error: null,
      };

    case ActionTypes.FETCH_SUCCESS:
      return {
        posts: action.payload,
        loading: false,
        error: null,
      };

    case ActionTypes.FETCH_ERROR:
      return {
        posts: [],
        loading: false,
        error: action.payload,
      };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function PostsList() {
  const [state, dispatch] = useReducer(postsReducer, initialState);

  useEffect(() => {
    const controller = new AbortController();

    const fetchPosts = async () => {
      dispatch({ type: ActionTypes.FETCH_START });

      try {
        const response = await fetch(
          'https://jsonplaceholder.typicode.com/posts?_limit=10',
          { signal: controller.signal },
        );

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();
        dispatch({ type: ActionTypes.FETCH_SUCCESS, payload: data });
      } catch (err) {
        // Kh√¥ng dispatch error n·∫øu request b·ªã abort
        if (err.name !== 'AbortError') {
          dispatch({
            type: ActionTypes.FETCH_ERROR,
            payload: err.message || 'Failed to fetch posts',
          });
        }
      }
    };

    fetchPosts();

    // Cleanup: hu·ª∑ request khi component unmount ho·∫∑c effect ch·∫°y l·∫°i
    return () => {
      controller.abort();
    };
  }, []); // Ch·ªâ fetch 1 l·∫ßn khi mount

  if (state.loading) {
    return <div>Loading posts...</div>;
  }

  if (state.error) {
    return <div style={{ color: 'red' }}>Error: {state.error}</div>;
  }

  if (state.posts.length === 0) {
    return <div>No posts found</div>;
  }

  return (
    <div>
      <h3>Posts (10 latest)</h3>
      <ul>
        {state.posts.map((post) => (
          <li key={post.id}>
            <strong>{post.title}</strong>
            <p>{post.body.substring(0, 120)}...</p>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default PostsList;

/* 
K·∫øt qu·∫£ v√≠ d·ª• khi render th√†nh c√¥ng:

Posts (10 latest)
‚Ä¢ sunt aut facere repellat provident occaecati excepturi optio reprehenderit
  quia et suscipit...
‚Ä¢ qui est esse
  est rerum tempore vitae sequi sint nihil reprehenderit...
‚Ä¢ ea molestias quasi exercitationem repellat qui ipsa sit aut
  et iusto sed quo iure...
(v√† 7 b√†i ti·∫øp theo)
*/
```

</details>

### ‚≠ê‚≠ê Level 2: Nh·∫≠n Bi·∫øt Pattern (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Implement pagination v·ªõi useReducer + useEffect
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: User List v·ªõi pagination
 *
 * Requirements:
 * - Display 5 users per page
 * - Previous/Next buttons
 * - Fetch data khi page thay ƒë·ªïi
 * - Loading state cho m·ªói page change
 * - Disable Previous ·ªü page 1
 * - Disable Next ·ªü page cu·ªëi (page 4)
 *
 * API: https://jsonplaceholder.typicode.com/users?_page=${page}&_limit=5
 *
 * State shape:
 * {
 *   users: [],
 *   loading: false,
 *   error: null,
 *   currentPage: 1,
 *   totalPages: 4
 * }
 *
 * Actions:
 * - FETCH_START
 * - FETCH_SUCCESS
 * - FETCH_ERROR
 * - SET_PAGE
 *
 * ü§î CHALLENGE:
 * - L√†m sao tr√°nh fetch duplicate khi spam click Next?
 * - Cleanup request khi page change nhanh?
 */

// TODO: Implement PaginatedUsers component
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * PaginatedUsers component
 * Hi·ªÉn th·ªã danh s√°ch users v·ªõi ph√¢n trang (5 users/trang)
 * S·ª≠ d·ª•ng useReducer + useEffect + AbortController
 * X·ª≠ l√Ω loading, error, disable n√∫t khi ·ªü trang ƒë·∫ßu/cu·ªëi
 * NgƒÉn fetch tr√πng l·∫∑p khi click nhanh (d√πng flag isFetching)
 */
import { useReducer, useEffect, useRef } from 'react';

const USERS_PER_PAGE = 5;
const TOTAL_USERS = 10; // jsonplaceholder c√≥ 10 users ‚Üí 2 trang th·ª±c t·∫ø, gi·∫£ s·ª≠ 4 trang

const initialState = {
  users: [],
  loading: false,
  error: null,
  currentPage: 1,
  totalPages: 4, // gi·∫£ ƒë·ªãnh, th·ª±c t·∫ø s·∫Ω t√≠nh t·ª´ header ho·∫∑c total count
};

const ActionTypes = {
  FETCH_START: 'FETCH_START',
  FETCH_SUCCESS: 'FETCH_SUCCESS',
  FETCH_ERROR: 'FETCH_ERROR',
  SET_PAGE: 'SET_PAGE',
};

function usersReducer(state, action) {
  switch (action.type) {
    case ActionTypes.FETCH_START:
      return {
        ...state,
        loading: true,
        error: null,
      };

    case ActionTypes.FETCH_SUCCESS:
      return {
        ...state,
        users: action.payload,
        loading: false,
        error: null,
      };

    case ActionTypes.FETCH_ERROR:
      return {
        ...state,
        loading: false,
        error: action.payload,
      };

    case ActionTypes.SET_PAGE:
      return {
        ...state,
        currentPage: action.payload,
        users: [], // clear c≈© ƒë·ªÉ tr√°nh flash content c≈©
      };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function PaginatedUsers() {
  const [state, dispatch] = useReducer(usersReducer, initialState);
  const isFetching = useRef(false); // ngƒÉn fetch tr√πng khi click nhanh

  const fetchUsers = async (page, signal) => {
    if (isFetching.current) return;
    isFetching.current = true;

    dispatch({ type: ActionTypes.FETCH_START });

    try {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com/users?_page=${page}&_limit=${USERS_PER_PAGE}`,
        { signal },
      );

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const data = await response.json();
      dispatch({ type: ActionTypes.FETCH_SUCCESS, payload: data });
    } catch (err) {
      if (err.name !== 'AbortError') {
        dispatch({
          type: ActionTypes.FETCH_ERROR,
          payload: err.message || 'Failed to load users',
        });
      }
    } finally {
      isFetching.current = false;
    }
  };

  useEffect(() => {
    const controller = new AbortController();

    fetchUsers(state.currentPage, controller.signal);

    return () => {
      controller.abort();
    };
  }, [state.currentPage]);

  const handlePageChange = (newPage) => {
    if (newPage < 1 || newPage > state.totalPages || state.loading) return;
    dispatch({ type: ActionTypes.SET_PAGE, payload: newPage });
  };

  const prevDisabled = state.currentPage === 1 || state.loading;
  const nextDisabled = state.currentPage === state.totalPages || state.loading;

  return (
    <div>
      <h3>
        Users - Page {state.currentPage} of {state.totalPages}
      </h3>

      {state.loading && <div>Loading users...</div>}

      {state.error && <div style={{ color: 'red' }}>Error: {state.error}</div>}

      {!state.loading && !state.error && state.users.length === 0 && (
        <div>No users found</div>
      )}

      {state.users.length > 0 && (
        <ul>
          {state.users.map((user) => (
            <li key={user.id}>
              {user.name}
              <br />
              <small>
                {user.email} ‚Ä¢ {user.company.name}
              </small>
            </li>
          ))}
        </ul>
      )}

      <div style={{ marginTop: '20px' }}>
        <button
          onClick={() => handlePageChange(state.currentPage - 1)}
          disabled={prevDisabled}
        >
          Previous
        </button>
        <span style={{ margin: '0 16px' }}>Page {state.currentPage}</span>
        <button
          onClick={() => handlePageChange(state.currentPage + 1)}
          disabled={nextDisabled}
        >
          Next
        </button>
      </div>
    </div>
  );
}

export default PaginatedUsers;

/*
K·∫øt qu·∫£ v√≠ d·ª• khi render:

Users - Page 1 of 4
‚Ä¢ Leanne Graham 
  sincere@april.biz ‚Ä¢ Romaguera-Crona
‚Ä¢ Ervin Howell 
  shanna@melissa.tv ‚Ä¢ Deckow-Crist
‚Ä¢ Clementine Bauch 
  nathan@yesenia.net ‚Ä¢ Romaguera-Jacobson
‚Ä¢ Patricia Lebsack 
  julianne.OConner@kory.org ‚Ä¢ Robel-Corkery
‚Ä¢ Chelsey Dietrich 
  lucio_Hettinger@annie.ca ‚Ä¢ Keebler LLC

[Previous]  Page 1  [Next]

Khi click Next ‚Üí loading ‚Üí hi·ªÉn th·ªã users trang 2, v.v.
N√∫t Previous b·ªã disable ·ªü trang 1, Next disable ·ªü trang 4 (gi·∫£ ƒë·ªãnh)
*/
```

</details>

### ‚≠ê‚≠ê‚≠ê Level 3: K·ªãch B·∫£n Th·ª±c T·∫ø (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Build Image Gallery v·ªõi Infinite Scroll
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën scroll xu·ªëng ƒë·ªÉ load th√™m ·∫£nh"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Display 10 photos initially
 * - [ ] Load more (10 photos) khi scroll ƒë·∫øn cu·ªëi
 * - [ ] Show loading indicator khi fetching
 * - [ ] Handle errors gracefully
 * - [ ] Prevent duplicate requests
 * - [ ] Stop loading when no more photos
 *
 * üé® Technical Details:
 * API: https://jsonplaceholder.typicode.com/photos?_start=${start}&_limit=10
 * Total photos: 100
 *
 * State shape:
 * {
 *   photos: [],
 *   loading: false,
 *   error: null,
 *   page: 0,
 *   hasMore: true
 * }
 *
 * Actions:
 * - FETCH_START
 * - FETCH_SUCCESS (append photos)
 * - FETCH_ERROR
 * - NO_MORE_DATA
 *
 * üö® Edge Cases:
 * - User scrolls nhanh ‚Üí multiple requests?
 * - Last page c√≥ √≠t h∆°n 10 photos
 * - Network error ‚Üí retry mechanism
 * - Component unmount gi·ªØa request
 *
 * üí° Hints:
 * - D√πng useRef ƒë·ªÉ track isLoading (prevent duplicate)
 * - Scroll detection: window.addEventListener('scroll', ...)
 * - Check scroll position: window.innerHeight + window.scrollY >= document.body.offsetHeight - 500
 *
 * üìù Implementation Checklist:
 * - [ ] Reducer v·ªõi 4 actions
 * - [ ] useEffect fetch initial data
 * - [ ] useEffect setup scroll listener
 * - [ ] Cleanup scroll listener
 * - [ ] Prevent duplicate requests
 * - [ ] Display loading indicator at bottom
 * - [ ] Handle "No more data" state
 */

// TODO: Implement InfiniteScrollGallery component

// Starter:
function InfiniteScrollGallery() {
  // TODO: Implement

  return (
    <div>
      {/* Photo grid */}
      {/* Loading indicator */}
      {/* Error message */}
      {/* "No more photos" message */}
    </div>
  );
}
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * InfiniteScrollGallery component
 * Image gallery v·ªõi infinite scroll s·ª≠ d·ª•ng JSONPlaceholder photos API
 * Load 10 ·∫£nh m·ªói l·∫ßn, t·ª± ƒë·ªông fetch khi scroll g·∫ßn bottom
 * X·ª≠ l√Ω loading, error, hasMore, prevent duplicate requests
 * S·ª≠ d·ª•ng useReducer + useEffect + IntersectionObserver (thay v√¨ window scroll event)
 */
import { useReducer, useEffect, useRef, useCallback } from 'react';

const PHOTOS_PER_PAGE = 10;
const API_BASE = 'https://jsonplaceholder.typicode.com/photos';

const initialState = {
  photos: [],
  loading: false,
  error: null,
  page: 0, // b·∫Øt ƒë·∫ßu t·ª´ 0 ‚Üí _start=0
  hasMore: true,
};

const ActionTypes = {
  FETCH_START: 'FETCH_START',
  FETCH_SUCCESS: 'FETCH_SUCCESS',
  FETCH_ERROR: 'FETCH_ERROR',
  NO_MORE_DATA: 'NO_MORE_DATA',
};

function galleryReducer(state, action) {
  switch (action.type) {
    case ActionTypes.FETCH_START:
      return { ...state, loading: true, error: null };

    case ActionTypes.FETCH_SUCCESS:
      return {
        ...state,
        photos: [...state.photos, ...action.payload],
        loading: false,
        page: state.page + 1,
        hasMore: action.payload.length === PHOTOS_PER_PAGE,
      };

    case ActionTypes.FETCH_ERROR:
      return { ...state, loading: false, error: action.payload };

    case ActionTypes.NO_MORE_DATA:
      return { ...state, hasMore: false, loading: false };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function InfiniteScrollGallery() {
  const [state, dispatch] = useReducer(galleryReducer, initialState);
  const observerTarget = useRef(null);
  const isFetching = useRef(false);

  const fetchPhotos = useCallback(
    async (page, signal) => {
      if (isFetching.current || !state.hasMore) return;
      isFetching.current = true;

      dispatch({ type: ActionTypes.FETCH_START });

      try {
        const start = page * PHOTOS_PER_PAGE;
        const response = await fetch(
          `${API_BASE}?_start=${start}&_limit=${PHOTOS_PER_PAGE}`,
          { signal },
        );

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();

        if (data.length === 0) {
          dispatch({ type: ActionTypes.NO_MORE_DATA });
        } else {
          dispatch({ type: ActionTypes.FETCH_SUCCESS, payload: data });
        }
      } catch (err) {
        if (err.name !== 'AbortError') {
          dispatch({
            type: ActionTypes.FETCH_ERROR,
            payload: err.message || 'Failed to load photos',
          });
        }
      } finally {
        isFetching.current = false;
      }
    },
    [state.hasMore],
  );

  // Initial fetch
  useEffect(() => {
    const controller = new AbortController();
    fetchPhotos(0, controller.signal);

    return () => controller.abort();
  }, [fetchPhotos]);

  // Infinite scroll v·ªõi IntersectionObserver
  useEffect(() => {
    if (!state.hasMore || state.loading) return;

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          const controller = new AbortController();
          fetchPhotos(state.page, controller.signal);

          // Cleanup cho request n√†y
          return () => controller.abort();
        }
      },
      { rootMargin: '200px' }, // trigger s·ªõm h∆°n 200px
    );

    const currentTarget = observerTarget.current;
    if (currentTarget) {
      observer.observe(currentTarget);
    }

    return () => {
      if (currentTarget) {
        observer.unobserve(currentTarget);
      }
    };
  }, [state.page, state.hasMore, state.loading, fetchPhotos]);

  return (
    <div>
      <h3>Infinite Scroll Photo Gallery</h3>

      {state.error && (
        <div style={{ color: 'red', padding: '16px', background: '#ffebee' }}>
          Error: {state.error}
        </div>
      )}

      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
          gap: '16px',
          padding: '16px',
        }}
      >
        {state.photos.map((photo) => (
          <div
            key={photo.id}
            style={{
              border: '1px solid #ddd',
              borderRadius: '8px',
              overflow: 'hidden',
            }}
          >
            <img
              src={photo.thumbnailUrl}
              alt={photo.title}
              style={{ width: '100%', height: 'auto', display: 'block' }}
              loading='lazy'
            />
            <div style={{ padding: '8px', fontSize: '0.9em' }}>
              {photo.title.substring(0, 60)}
              {photo.title.length > 60 ? '...' : ''}
            </div>
          </div>
        ))}
      </div>

      {state.loading && (
        <div style={{ textAlign: 'center', padding: '32px' }}>
          Loading more photos...
        </div>
      )}

      {!state.hasMore && state.photos.length > 0 && (
        <div style={{ textAlign: 'center', padding: '32px', color: '#666' }}>
          No more photos to load
        </div>
      )}

      {state.photos.length === 0 && !state.loading && !state.error && (
        <div style={{ textAlign: 'center', padding: '32px' }}>
          No photos found
        </div>
      )}

      {/* Sentinel element ƒë·ªÉ observer theo d√µi */}
      <div
        ref={observerTarget}
        style={{ height: '20px' }}
      />
    </div>
  );
}

export default InfiniteScrollGallery;

/*
K·∫øt qu·∫£ v√≠ d·ª• khi render:

- Ban ƒë·∫ßu hi·ªÉn th·ªã 10 ·∫£nh ƒë·∫ßu ti√™n (id 1-10)
- Khi scroll xu·ªëng g·∫ßn cu·ªëi ‚Üí t·ª± ƒë·ªông load th√™m 10 ·∫£nh (11-20)
- Loading indicator "Loading more photos..." xu·∫•t hi·ªán ·ªü d∆∞·ªõi
- Khi ƒë·∫°t ~100 ·∫£nh (t·ªïng c·ªßa jsonplaceholder) ‚Üí hi·ªÉn th·ªã "No more photos to load"
- N·∫øu c√≥ l·ªói m·∫°ng ‚Üí hi·ªÉn th·ªã th√¥ng b√°o ƒë·ªè "Error: ..."
- ·∫¢nh d√πng thumbnailUrl ƒë·ªÉ load nhanh, lazy loading
*/
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê Level 4: Quy·∫øt ƒê·ªãnh Ki·∫øn Tr√∫c (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Design Retry Logic v·ªõi Exponential Backoff
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Context: API th∆∞·ªùng xuy√™n fail (flaky network, rate limits)
 * C·∫ßn retry mechanism th√¥ng minh.
 *
 * Retry Strategy Options:
 *
 * Option A: Simple Retry (fixed delay)
 * - Retry 3 l·∫ßn
 * - M·ªói l·∫ßn c√°ch nhau 1s
 * Pros: ƒê∆°n gi·∫£n
 * Cons: C√≥ th·ªÉ overwhelm server
 *
 * Option B: Exponential Backoff
 * - Retry 1: wait 1s
 * - Retry 2: wait 2s
 * - Retry 3: wait 4s
 * Pros: Gi·∫£m server load
 * Cons: Ph·ª©c t·∫°p h∆°n
 *
 * Option C: Exponential Backoff + Jitter
 * - Random delay: baseDelay * 2^attempt + random(0-1000ms)
 * Pros: Tr√°nh thundering herd
 * Cons: Most complex
 *
 * Nhi·ªám v·ª•:
 * 1. So s√°nh 3 options
 * 2. Choose best approach
 * 3. Document quy·∫øt ƒë·ªãnh
 *
 * üìù Decision Doc:
 *
 * ## Context
 * API c√≥ rate limit 100 req/min. Khi exceed, tr·∫£ v·ªÅ 429.
 * C·∫ßn retry ƒë·ªÉ tƒÉng success rate nh∆∞ng kh√¥ng spam server.
 *
 * ## Decision
 * Ch·ªçn Option B: Exponential Backoff
 *
 * ## Rationale
 * - Balance gi·ªØa simplicity v√† effectiveness
 * - Gi·∫£m server load (delays tƒÉng d·∫ßn)
 * - ƒê·ªß cho most use cases
 * - Option C overkill cho app nh·ªè
 *
 * ## Implementation
 * - Max retries: 3
 * - Base delay: 1000ms
 * - Formula: delay = baseDelay * 2^attempt
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 *
 * State shape:
 * {
 *   data: null,
 *   loading: false,
 *   error: null,
 *   retryCount: 0,
 *   isRetrying: false
 * }
 *
 * Actions:
 * - FETCH_START
 * - FETCH_SUCCESS
 * - FETCH_ERROR
 * - RETRY_START
 * - RETRY_FAILED (sau max retries)
 *
 * Requirements:
 * - T·ª± ƒë·ªông retry khi API fail
 * - Max 3 retries
 * - Exponential backoff delays
 * - Show retry status: "Retrying... (attempt 2/3)"
 * - Manual retry button sau max retries failed
 *
 * üß™ PHASE 3: Testing (10 ph√∫t)
 *
 * Test cases:
 * - Success on first try ‚Üí no retries
 * - Fail ‚Üí Retry 1 (wait 1s) ‚Üí Success
 * - Fail ‚Üí Retry 1,2,3 ‚Üí Show error + manual retry button
 * - Manual retry ‚Üí Reset count ‚Üí Start over
 *
 * Mock API for testing:
 * - Random fail with 50% chance
 * - Return 429 for rate limit
 */

// TODO: Implement v·ªõi retry logic

// Starter:
const fetchWithRetry = async (url, retryCount, maxRetries, dispatch) => {
  const baseDelay = 1000;

  try {
    // TODO: Implement fetch
    // TODO: Handle retry logic
  } catch (error) {
    // TODO: Exponential backoff
    // TODO: Dispatch retry actions
  }
};
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * RetryFetchDemo component
 * Implement retry logic v·ªõi Exponential Backoff
 * T·ª± ƒë·ªông retry t·ªëi ƒëa 3 l·∫ßn khi fetch th·∫•t b·∫°i
 * Hi·ªÉn th·ªã tr·∫°ng th√°i retry (attempt X/3)
 * C√≥ n√∫t Retry th·ªß c√¥ng sau khi h·∫øt l∆∞·ª£t retry
 * S·ª≠ d·ª•ng random fail simulation (50% chance) ƒë·ªÉ test
 */
import { useReducer, useEffect, useCallback } from 'react';

const MAX_RETRIES = 3;
const BASE_DELAY_MS = 1000;

const initialState = {
  data: null,
  loading: false,
  error: null,
  retryCount: 0,
  isRetrying: false,
};

const ActionTypes = {
  FETCH_START: 'FETCH_START',
  FETCH_SUCCESS: 'FETCH_SUCCESS',
  FETCH_ERROR: 'FETCH_ERROR',
  RETRY_START: 'RETRY_START',
  RESET: 'RESET',
};

function retryReducer(state, action) {
  switch (action.type) {
    case ActionTypes.FETCH_START:
      return {
        ...state,
        loading: true,
        error: null,
        isRetrying: false,
      };

    case ActionTypes.FETCH_SUCCESS:
      return {
        ...state,
        data: action.payload,
        loading: false,
        error: null,
        retryCount: 0,
        isRetrying: false,
      };

    case ActionTypes.FETCH_ERROR:
      return {
        ...state,
        loading: false,
        error: action.payload,
        isRetrying: false,
      };

    case ActionTypes.RETRY_START:
      return {
        ...state,
        loading: true,
        error: null,
        retryCount: state.retryCount + 1,
        isRetrying: true,
      };

    case ActionTypes.RESET:
      return { ...initialState };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function RetryFetchDemo() {
  const [state, dispatch] = useReducer(retryReducer, initialState);

  const fetchWithRetry = useCallback(async (attempt = 1) => {
    // Reset state khi b·∫Øt ƒë·∫ßu attempt ƒë·∫ßu ti√™n
    if (attempt === 1) {
      dispatch({ type: ActionTypes.FETCH_START });
    } else {
      dispatch({ type: ActionTypes.RETRY_START });
    }

    try {
      // Simulation API flaky (50% fail)
      await new Promise((resolve) => setTimeout(resolve, 800));

      // 50% chance fail
      if (Math.random() < 0.5) {
        throw new Error('Network error or server timeout');
      }

      // Gi·∫£ l·∫≠p data th√†nh c√¥ng
      const mockData = {
        id: Date.now(),
        title: `Successful fetch on attempt ${attempt}`,
        timestamp: new Date().toLocaleTimeString(),
      };

      dispatch({
        type: ActionTypes.FETCH_SUCCESS,
        payload: mockData,
      });
    } catch (err) {
      const errorMessage = err.message || 'Failed to fetch data';

      if (attempt >= MAX_RETRIES) {
        // H·∫øt l∆∞·ª£t retry ‚Üí show error + manual retry
        dispatch({
          type: ActionTypes.FETCH_ERROR,
          payload: `${errorMessage} (after ${MAX_RETRIES} attempts)`,
        });
      } else {
        // Exponential backoff
        const delay = BASE_DELAY_MS * Math.pow(2, attempt - 1);

        // Hi·ªÉn th·ªã th√¥ng b√°o retry (UI s·∫Ω c·∫≠p nh·∫≠t sau delay)
        setTimeout(() => {
          fetchWithRetry(attempt + 1);
        }, delay);
      }
    }
  }, []);

  // Initial fetch khi mount
  useEffect(() => {
    fetchWithRetry(1);
  }, [fetchWithRetry]);

  const handleManualRetry = () => {
    dispatch({ type: ActionTypes.RESET });
    fetchWithRetry(1);
  };

  const getStatusMessage = () => {
    if (state.loading) {
      if (state.isRetrying) {
        return `Retrying... (attempt ${state.retryCount}/${MAX_RETRIES})`;
      }
      return 'Loading...';
    }
    if (state.error) {
      return `Error: ${state.error}`;
    }
    if (state.data) {
      return `Success! ${state.data.title} at ${state.data.timestamp}`;
    }
    return 'Idle';
  };

  return (
    <div style={{ padding: '20px', maxWidth: '500px', margin: '0 auto' }}>
      <h3>Retry with Exponential Backoff Demo</h3>
      <p>
        API ƒë∆∞·ª£c simulate v·ªõi 50% chance fail ƒë·ªÉ test retry.
        <br />
        Base delay: 1s ‚Üí 2s ‚Üí 4s
      </p>

      <div
        style={{
          padding: '16px',
          background: state.error
            ? '#ffebee'
            : state.data
              ? '#e8f5e9'
              : '#f5f5f5',
          borderRadius: '8px',
          minHeight: '80px',
          margin: '16px 0',
        }}
      >
        <strong>Status:</strong> {getStatusMessage()}
      </div>

      {state.error && (
        <button
          onClick={handleManualRetry}
          style={{
            padding: '10px 20px',
            background: '#1976d2',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          Retry Manually
        </button>
      )}

      <button
        onClick={handleManualRetry}
        style={{
          marginLeft: '12px',
          padding: '10px 20px',
          background: '#f57c00',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
        }}
      >
        Refresh / New Attempt
      </button>

      {state.data && (
        <div style={{ marginTop: '20px' }}>
          <pre
            style={{
              background: '#f0f0f0',
              padding: '12px',
              borderRadius: '4px',
            }}
          >
            {JSON.stringify(state.data, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
}

export default RetryFetchDemo;

/*
K·∫øt qu·∫£ v√≠ d·ª• khi ch·∫°y:

Tr∆∞·ªùng h·ª£p th√†nh c√¥ng ngay l·∫ßn 1:
Status: Success! Successful fetch on attempt 1 at 14:35:22

Tr∆∞·ªùng h·ª£p fail ‚Üí retry:
Status: Retrying... (attempt 1/3)   ‚Üí sau ~1s
‚Üí Retrying... (attempt 2/3)         ‚Üí sau ~2s
‚Üí Success! Successful fetch on attempt 3 at 14:35:28

Tr∆∞·ªùng h·ª£p fail h·∫øt 3 l·∫ßn:
Status: Error: Network error or server timeout (after 3 attempts)
‚Üí N√∫t "Retry Manually" xu·∫•t hi·ªán
*/
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Level 5: Production Challenge (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Build Production-Ready Data Table
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 *
 * "GitHub Issues Explorer" - Browse GitHub issues v·ªõi advanced features
 *
 * Features:
 * 1. Fetch issues from GitHub API
 * 2. Search by title/description
 * 3. Filter by state (open/closed/all)
 * 4. Sort by (created, updated, comments)
 * 5. Pagination (30 per page)
 * 6. Loading states (initial, pagination, search)
 * 7. Error handling v·ªõi retry
 * 8. Cache previous pages (don't re-fetch)
 * 9. URL sync (filters in query params)
 *
 * üèóÔ∏è Technical Design:
 *
 * 1. State Architecture:
 * {
 *   // Data
 *   issues: [],
 *   cache: { 'page-1-open-created': [...], ... },
 *
 *   // UI State
 *   loading: false,
 *   error: null,
 *
 *   // Filters
 *   filters: {
 *     state: 'open',
 *     sort: 'created',
 *     search: '',
 *     page: 1
 *   },
 *
 *   // Metadata
 *   totalCount: 0,
 *   hasMore: true
 * }
 *
 * 2. Actions (15+):
 * - FETCH_START
 * - FETCH_SUCCESS
 * - FETCH_ERROR
 * - SET_FILTER
 * - SET_SORT
 * - SET_SEARCH
 * - SET_PAGE
 * - CLEAR_FILTERS
 * - RETRY
 * - CACHE_HIT
 *
 * 3. API:
 * GitHub Issues API: https://api.github.com/repos/facebook/react/issues
 * Query params: ?state={state}&sort={sort}&page={page}&per_page=30
 *
 * 4. Caching Strategy:
 * - Cache key: `${page}-${state}-${sort}-${search}`
 * - Max cache size: 10 pages
 * - Check cache before fetch
 * - LRU eviction when cache full
 *
 * 5. URL Sync:
 * - Read initial state from URL
 * - Update URL when filters change
 * - Browser back/forward works
 *
 * 6. Performance:
 * - Debounce search (500ms)
 * - Cancel previous requests
 * - Show cached data immediately
 *
 * ‚úÖ Production Checklist:
 * - [ ] Reducer handles all 15+ actions
 * - [ ] useEffect fetch data on filter change
 * - [ ] useEffect sync URL
 * - [ ] Cache implementation (check ‚Üí fetch ‚Üí store)
 * - [ ] Debounced search
 * - [ ] AbortController cleanup
 * - [ ] Loading states:
 *   - [ ] Initial load (skeleton)
 *   - [ ] Pagination (button loading)
 *   - [ ] Search (inline spinner)
 * - [ ] Error states:
 *   - [ ] Network error (retry button)
 *   - [ ] Rate limit (wait message)
 *   - [ ] No results (empty state)
 * - [ ] Edge cases:
 *   - [ ] Rapid filter changes
 *   - [ ] Cache hit ‚Üí instant display
 *   - [ ] Browser back ‚Üí restore from cache
 * - [ ] Code quality:
 *   - [ ] Constants extracted
 *   - [ ] Helper functions (getCacheKey, etc.)
 *   - [ ] Comments for complex logic
 *
 * üìù Documentation:
 * - State shape explained
 * - Caching strategy diagram
 * - Action reference
 *
 * üîç Self-Review:
 * - [ ] No memory leaks (cleanup all effects)
 * - [ ] No race conditions (abort old requests)
 * - [ ] Efficient re-renders (check deps)
 * - [ ] Accessible (loading announcements, error focus)
 */

// TODO: Full implementation

// Starter: Helper functions
const getCacheKey = (filters) => {
  return `${filters.page}-${filters.state}-${filters.sort}-${filters.search}`;
};

const buildApiUrl = (filters) => {
  const params = new URLSearchParams({
    state: filters.state,
    sort: filters.sort,
    page: filters.page,
    per_page: 30,
  });

  if (filters.search) {
    // GitHub search API different endpoint
    return `https://api.github.com/search/issues?q=${filters.search}+repo:facebook/react&${params}`;
  }

  return `https://api.github.com/repos/facebook/react/issues?${params}`;
};

// TODO: Implement GitHubIssuesExplorer component
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * GitHubIssuesExplorer - Production-ready issues browser
 * Features:
 *   - Fetch issues from facebook/react repo
 *   - Search (debounced), filter by state, sort, pagination
 *   - Loading states (initial + pagination + search)
 *   - Error handling with retry
 *   - Simple in-memory cache (max 10 entries)
 *   - URL sync using URLSearchParams + history.pushState
 *   - AbortController to cancel outdated requests
 */
import { useReducer, useEffect, useRef, useCallback } from 'react';

const PER_PAGE = 30;
const CACHE_MAX_SIZE = 10;
const DEBOUNCE_DELAY = 500;

const initialState = {
  issues: [],
  cache: {}, // key ‚Üí {issues, totalCount}
  loading: false,
  error: null,
  filters: {
    state: 'open',
    sort: 'created',
    search: '',
    page: 1,
  },
  totalCount: 0,
  hasMore: true,
};

const ActionTypes = {
  FETCH_START: 'FETCH_START',
  FETCH_SUCCESS: 'FETCH_SUCCESS',
  FETCH_ERROR: 'FETCH_ERROR',
  SET_FILTER: 'SET_FILTER',
  SET_PAGE: 'SET_PAGE',
  CACHE_HIT: 'CACHE_HIT',
  RETRY: 'RETRY',
  CLEAR_ERROR: 'CLEAR_ERROR',
};

function issuesReducer(state, action) {
  switch (action.type) {
    case ActionTypes.FETCH_START:
      return { ...state, loading: true, error: null };

    case ActionTypes.FETCH_SUCCESS:
      return {
        ...state,
        issues: action.payload.issues,
        totalCount: action.payload.totalCount,
        hasMore: action.payload.issues.length === PER_PAGE,
        cache: {
          ...state.cache,
          [action.payload.cacheKey]: {
            issues: action.payload.issues,
            totalCount: action.payload.totalCount,
          },
        },
        loading: false,
        error: null,
      };

    case ActionTypes.CACHE_HIT:
      return {
        ...state,
        issues: action.payload.issues,
        totalCount: action.payload.totalCount,
        hasMore: action.payload.issues.length === PER_PAGE,
        loading: false,
        error: null,
      };

    case ActionTypes.FETCH_ERROR:
      return { ...state, loading: false, error: action.payload };

    case ActionTypes.SET_FILTER:
      return {
        ...state,
        filters: { ...state.filters, ...action.payload, page: 1 },
      };

    case ActionTypes.SET_PAGE:
      return {
        ...state,
        filters: { ...state.filters, page: action.payload },
      };

    case ActionTypes.RETRY:
      return { ...state, error: null };

    case ActionTypes.CLEAR_ERROR:
      return { ...state, error: null };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function getCacheKey(filters) {
  return `${filters.page}-${filters.state}-${filters.sort}-${filters.search.trim().toLowerCase()}`;
}

function buildApiUrl(filters) {
  const params = new URLSearchParams({
    state: filters.state,
    sort: filters.sort,
    direction: 'desc',
    per_page: PER_PAGE,
    page: filters.page,
  });

  let url = `https://api.github.com/repos/facebook/react/issues?${params}`;

  if (filters.search.trim()) {
    // Switch to search endpoint when there's a query
    const q = `${filters.search} repo:facebook/react type:issue state:${filters.state}`;
    url = `https://api.github.com/search/issues?q=${encodeURIComponent(q)}&sort=${filters.sort}&order=desc&page=${filters.page}&per_page=${PER_PAGE}`;
  }

  return url;
}

function GitHubIssuesExplorer() {
  const [state, dispatch] = useReducer(issuesReducer, initialState);
  const abortControllerRef = useRef(null);
  const debounceTimerRef = useRef(null);
  const isInitialMount = useRef(true);

  // Read initial filters from URL
  useEffect(() => {
    if (isInitialMount.current) {
      const params = new URLSearchParams(window.location.search);
      const initialFilters = {
        state: params.get('state') || 'open',
        sort: params.get('sort') || 'created',
        search: params.get('search') || '',
        page: Number(params.get('page')) || 1,
      };

      dispatch({ type: ActionTypes.SET_FILTER, payload: initialFilters });
      isInitialMount.current = false;
    }
  }, []);

  // Sync filters ‚Üí URL
  const syncUrl = useCallback(() => {
    const params = new URLSearchParams();
    if (state.filters.state !== 'open')
      params.set('state', state.filters.state);
    if (state.filters.sort !== 'created')
      params.set('sort', state.filters.sort);
    if (state.filters.search) params.set('search', state.filters.search);
    if (state.filters.page !== 1) params.set('page', state.filters.page);

    const query = params.toString();
    const newUrl = query ? `?${query}` : window.location.pathname;
    window.history.replaceState(null, '', newUrl);
  }, [state.filters]);

  useEffect(() => {
    if (!isInitialMount.current) {
      syncUrl();
    }
  }, [state.filters, syncUrl]);

  const fetchIssues = useCallback(async () => {
    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    const cacheKey = getCacheKey(state.filters);

    // Check cache first
    if (state.cache[cacheKey]) {
      dispatch({
        type: ActionTypes.CACHE_HIT,
        payload: {
          issues: state.cache[cacheKey].issues,
          totalCount: state.cache[cacheKey].totalCount,
        },
      });
      return;
    }

    dispatch({ type: ActionTypes.FETCH_START });

    try {
      const url = buildApiUrl(state.filters);
      const response = await fetch(url, { signal });

      if (!response.ok) {
        if (response.status === 403 || response.status === 429) {
          throw new Error('Rate limit exceeded. Please try again later.');
        }
        throw new Error(`GitHub API error: ${response.status}`);
      }

      let issues = [];
      let totalCount = 0;

      if (state.filters.search.trim()) {
        // Search endpoint returns different shape
        const data = await response.json();
        issues = data.items || [];
        totalCount = data.total_count || 0;
      } else {
        issues = await response.json();
        // For regular issues endpoint, total count from Link header or assume hasMore
        const linkHeader = response.headers.get('Link');
        totalCount = linkHeader?.includes('rel="last"') ? 9999 : issues.length; // approximation
      }

      // Limit cache size (simple LRU-like)
      const newCache = { ...state.cache };
      if (Object.keys(newCache).length >= CACHE_MAX_SIZE) {
        const oldestKey = Object.keys(newCache)[0];
        delete newCache[oldestKey];
      }

      dispatch({
        type: ActionTypes.FETCH_SUCCESS,
        payload: {
          issues,
          totalCount,
          cacheKey,
        },
      });
    } catch (err) {
      if (err.name !== 'AbortError') {
        dispatch({
          type: ActionTypes.FETCH_ERROR,
          payload: err.message || 'Failed to load issues',
        });
      }
    }
  }, [state.filters, state.cache]);

  // Debounced fetch for search + immediate for other filters/page
  useEffect(() => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }

    // Search ‚Üí debounce
    if (state.filters.search !== initialState.filters.search) {
      debounceTimerRef.current = setTimeout(() => {
        fetchIssues();
      }, DEBOUNCE_DELAY);
    } else {
      // Page / state / sort change ‚Üí immediate
      fetchIssues();
    }

    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, [state.filters, fetchIssues]);

  const handleFilterChange = (key, value) => {
    dispatch({
      type: ActionTypes.SET_FILTER,
      payload: { [key]: value },
    });
  };

  const handlePageChange = (newPage) => {
    if (
      newPage < 1 ||
      (newPage > Math.ceil(state.totalCount / PER_PAGE) && state.totalCount > 0)
    )
      return;
    dispatch({ type: ActionTypes.SET_PAGE, payload: newPage });
  };

  const handleRetry = () => {
    dispatch({ type: ActionTypes.RETRY });
    fetchIssues();
  };

  const totalPages =
    state.totalCount > 0 ? Math.ceil(state.totalCount / PER_PAGE) : 1;

  return (
    <div style={{ padding: '20px', maxWidth: '1200px', margin: '0 auto' }}>
      <h2>React Repository Issues Explorer</h2>

      {/* Controls */}
      <div
        style={{
          display: 'flex',
          gap: '16px',
          flexWrap: 'wrap',
          marginBottom: '24px',
        }}
      >
        <div>
          <label>State: </label>
          <select
            value={state.filters.state}
            onChange={(e) => handleFilterChange('state', e.target.value)}
          >
            <option value='open'>Open</option>
            <option value='closed'>Closed</option>
            <option value='all'>All</option>
          </select>
        </div>

        <div>
          <label>Sort: </label>
          <select
            value={state.filters.sort}
            onChange={(e) => handleFilterChange('sort', e.target.value)}
          >
            <option value='created'>Created</option>
            <option value='updated'>Updated</option>
            <option value='comments'>Comments</option>
          </select>
        </div>

        <div style={{ flex: '1', minWidth: '200px' }}>
          <input
            type='text'
            placeholder='Search issues...'
            value={state.filters.search}
            onChange={(e) => handleFilterChange('search', e.target.value)}
            style={{ width: '100%', padding: '8px' }}
          />
        </div>
      </div>

      {/* Loading / Error */}
      {state.loading && (
        <div style={{ textAlign: 'center', padding: '40px 0' }}>
          Loading issues...
        </div>
      )}

      {state.error && (
        <div
          style={{
            padding: '16px',
            background: '#ffebee',
            color: '#c62828',
            borderRadius: '8px',
            marginBottom: '16px',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
          }}
        >
          <span>Error: {state.error}</span>
          <button
            onClick={handleRetry}
            style={{
              padding: '8px 16px',
              background: '#c62828',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Retry
          </button>
        </div>
      )}

      {/* Issues List */}
      {!state.loading && !state.error && (
        <>
          {state.issues.length === 0 ? (
            <div
              style={{ textAlign: 'center', padding: '40px', color: '#666' }}
            >
              No issues found matching your criteria
            </div>
          ) : (
            <>
              <div style={{ marginBottom: '16px' }}>
                Showing {state.issues.length} of ~{state.totalCount} issues
              </div>

              <ul style={{ listStyle: 'none', padding: 0 }}>
                {state.issues.map((issue) => (
                  <li
                    key={issue.id}
                    style={{
                      padding: '16px',
                      borderBottom: '1px solid #eee',
                      display: 'flex',
                      flexDirection: 'column',
                      gap: '8px',
                    }}
                  >
                    <div
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: '12px',
                      }}
                    >
                      <span
                        style={{
                          fontWeight: 'bold',
                          color: issue.state === 'open' ? '#2e7d32' : '#d32f2f',
                        }}
                      >
                        #{issue.number}
                      </span>
                      <a
                        href={issue.html_url}
                        target='_blank'
                        rel='noopener noreferrer'
                        style={{
                          fontSize: '1.1em',
                          textDecoration: 'none',
                          color: '#1976d2',
                        }}
                      >
                        {issue.title}
                      </a>
                    </div>

                    <div style={{ color: '#555', fontSize: '0.95em' }}>
                      Opened by <strong>{issue.user.login}</strong> ‚Ä¢{' '}
                      {new Date(issue.created_at).toLocaleDateString()} ‚Ä¢{' '}
                      {issue.comments} comments
                    </div>

                    {issue.labels.length > 0 && (
                      <div
                        style={{
                          display: 'flex',
                          gap: '8px',
                          flexWrap: 'wrap',
                        }}
                      >
                        {issue.labels.map((label) => (
                          <span
                            key={label.id}
                            style={{
                              background: `#${label.color}22`,
                              color: '#000',
                              padding: '2px 8px',
                              borderRadius: '12px',
                              fontSize: '0.85em',
                              border: `1px solid #${label.color}`,
                            }}
                          >
                            {label.name}
                          </span>
                        ))}
                      </div>
                    )}
                  </li>
                ))}
              </ul>

              {/* Pagination */}
              <div
                style={{
                  display: 'flex',
                  justifyContent: 'center',
                  gap: '16px',
                  marginTop: '32px',
                  alignItems: 'center',
                }}
              >
                <button
                  onClick={() => handlePageChange(state.filters.page - 1)}
                  disabled={state.filters.page === 1 || state.loading}
                  style={{ padding: '8px 16px' }}
                >
                  Previous
                </button>

                <span>
                  Page {state.filters.page}{' '}
                  {state.totalCount > 0
                    ? `of ~${Math.ceil(state.totalCount / PER_PAGE)}`
                    : ''}
                </span>

                <button
                  onClick={() => handlePageChange(state.filters.page + 1)}
                  disabled={!state.hasMore || state.loading}
                  style={{ padding: '8px 16px' }}
                >
                  Next
                </button>
              </div>
            </>
          )}
        </>
      )}
    </div>
  );
}

export default GitHubIssuesExplorer;

/*
K·∫øt qu·∫£ v√≠ d·ª• khi ch·∫°y:

- M·ªü component ‚Üí load open issues, sort by created, page 1
- URL: ?state=open&sort=created&page=1 (n·∫øu thay ƒë·ªïi)
- G√µ search "useEffect" ‚Üí sau 500ms load k·∫øt qu·∫£ search
- Chuy·ªÉn sang Closed ‚Üí load closed issues
- Click Next ‚Üí page 2, cache trang 1 v·∫´n gi·ªØ
- N·∫øu rate limit ho·∫∑c m·∫°ng l·ªói ‚Üí hi·ªÉn th·ªã error + n√∫t Retry
- Quay l·∫°i page 1 b·∫±ng n√∫t Previous ho·∫∑c browser back ‚Üí l·∫•y t·ª´ cache (instant)
*/
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh: Async State Management Patterns

| Pattern                | Code Complexity | Performance            | Use Case            | Winner                |
| ---------------------- | --------------- | ---------------------- | ------------------- | --------------------- |
| **Multiple useState**  | ‚úÖ Simple       | ‚ùå C√≥ th·ªÉ inconsistent | Simple fetches      | Small apps            |
| **useReducer**         | ‚ö†Ô∏è Medium       | ‚úÖ Consistent state    | Complex async flows | Medium-Large apps     |
| **useReducer + Cache** | ‚ùå Complex      | ‚úÖ‚úÖ Very fast         | Repeated fetches    | High-traffic features |
| **Optimistic Updates** | ‚ùå Complex      | ‚úÖ‚úÖ Feels instant     | User interactions   | Social apps           |

### Decision Tree: Async Pattern Selection

```
START: C·∫ßn fetch data?
‚îÇ
‚îú‚îÄ Simple one-time fetch?
‚îÇ  ‚îî‚îÄ YES ‚Üí useState + useEffect ‚úÖ
‚îÇ     Example: Fetch user profile once
‚îÇ
‚îú‚îÄ Multiple related async states?
‚îÇ  ‚îî‚îÄ YES ‚Üí useReducer + useEffect ‚úÖ
‚îÇ     Example: loading, data, error, retryCount
‚îÇ
‚îú‚îÄ Need retry logic?
‚îÇ  ‚îî‚îÄ YES ‚Üí useReducer v·ªõi retry actions ‚úÖ
‚îÇ     Actions: FETCH_START, RETRY_START, MAX_RETRIES_REACHED
‚îÇ
‚îú‚îÄ Filters/Pagination (repeated fetches)?
‚îÇ  ‚îî‚îÄ YES ‚Üí useReducer + Caching ‚úÖ
‚îÇ     Cache previous pages/filters
‚îÇ
‚îú‚îÄ User mutations (create/update/delete)?
‚îÇ  ‚îî‚îÄ YES
‚îÇ     ‚îÇ
‚îÇ     ‚îú‚îÄ Can tolerate delay?
‚îÇ     ‚îÇ  ‚îî‚îÄ Normal pattern (wait for API)
‚îÇ     ‚îÇ
‚îÇ     ‚îî‚îÄ Need instant feedback?
‚îÇ        ‚îî‚îÄ Optimistic Updates ‚úÖ
‚îÇ
‚îú‚îÄ Real-time updates (WebSocket, polling)?
‚îÇ  ‚îî‚îÄ YES ‚Üí useReducer + useEffect subscription
‚îÇ     Actions: CONNECTED, DISCONNECTED, MESSAGE_RECEIVED
‚îÇ
‚îî‚îÄ Complex workflows (multi-step forms, wizards)?
   ‚îî‚îÄ useReducer state machine + async actions
```

### Loading States Best Practices

**‚ùå Bad: Boolean loading**

```jsx
const [loading, setLoading] = useState(false);
// Problem: Can't distinguish initial vs refresh
```

**‚úÖ Good: State machine**

```jsx
const states = {
  idle: 'idle',
  loading: 'loading',
  success: 'success',
  error: 'error',
};

// Can show different UI for each state
```

**‚úÖ Better: Multiple loading states**

```jsx
{
  initialLoading: false,  // First load ‚Üí skeleton
  refreshing: false,      // Pull to refresh ‚Üí inline spinner
  loadingMore: false,     // Pagination ‚Üí button spinner
}
```

### Error Handling Strategies

| Strategy               | When to Use           | Example                                  |
| ---------------------- | --------------------- | ---------------------------------------- |
| **Show error + retry** | Recoverable errors    | Network timeout ‚Üí "Retry" button         |
| **Silent retry**       | Transient errors      | 429 rate limit ‚Üí auto retry with backoff |
| **Fallback UI**        | Non-critical features | Image load fail ‚Üí placeholder            |
| **Error boundary**     | Critical errors       | Component crash ‚Üí error page             |
| **Toast notification** | Background operations | "Failed to save draft" toast             |

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Race Condition üêõ

```jsx
// ‚ùå CODE B·ªä L·ªñI
function UserSearch() {
  const [searchTerm, setSearchTerm] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    const fetchResults = async () => {
      const response = await fetch(`/api/search?q=${searchTerm}`);
      const data = await response.json();
      setResults(data); // üêõ Always sets results, even if outdated!
    };

    if (searchTerm) {
      fetchResults();
    }
  }, [searchTerm]);

  // Scenario:
  // 1. User types "react"
  // 2. Request A starts (takes 2s)
  // 3. User types "reactjs"
  // 4. Request B starts (takes 0.5s)
  // 5. Request B completes ‚Üí setResults(results for "reactjs") ‚úÖ
  // 6. Request A completes ‚Üí setResults(results for "react") ‚ùå
  // Result: UI shows results for "react" but search term is "reactjs"!
}
```

**‚ùì C√¢u h·ªèi:**

1. V·∫•n ƒë·ªÅ g√¨ v·ªõi code?
2. Khi n√†o bug x·∫£y ra?
3. L√†m sao fix?

**üí° Gi·∫£i th√≠ch:**

- Multiple requests in-flight
- Slower request completes last ‚Üí overwrites newer results
- User sees wrong data!

**‚úÖ Fix:**

```jsx
// ‚úÖ SOLUTION 1: AbortController
function UserSearch() {
  const [searchTerm, setSearchTerm] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    const controller = new AbortController();

    const fetchResults = async () => {
      try {
        const response = await fetch(`/api/search?q=${searchTerm}`, {
          signal: controller.signal, // ‚úÖ Attach signal
        });
        const data = await response.json();
        setResults(data);
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error(error);
        }
      }
    };

    if (searchTerm) {
      fetchResults();
    }

    return () => {
      controller.abort(); // ‚úÖ Cancel previous request
    };
  }, [searchTerm]);
}

// ‚úÖ SOLUTION 2: Ignore stale results
function UserSearch() {
  const [searchTerm, setSearchTerm] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    let isCurrentRequest = true; // ‚úÖ Flag

    const fetchResults = async () => {
      const response = await fetch(`/api/search?q=${searchTerm}`);
      const data = await response.json();

      if (isCurrentRequest) {
        // ‚úÖ Only set if still current
        setResults(data);
      }
    };

    if (searchTerm) {
      fetchResults();
    }

    return () => {
      isCurrentRequest = false; // ‚úÖ Mark as stale
    };
  }, [searchTerm]);
}
```

### Bug 2: Infinite Loop v·ªõi Dispatch üêõ

```jsx
// ‚ùå CODE B·ªä L·ªñI
function TodoList() {
  const [state, dispatch] = useReducer(reducer, initialState);

  useEffect(() => {
    const fetchTodos = async () => {
      const response = await fetch('/api/todos');
      const data = await response.json();
      dispatch({ type: 'SET_TODOS', payload: data });
    };

    fetchTodos();
  }, [dispatch]); // üêõ dispatch in dependencies!

  // Result: Infinite loop!
  // dispatch stable? V·∫≠y t·∫°i sao loop?
}
```

**‚ùì C√¢u h·ªèi:**

1. Code c√≥ v·∫ª ƒë√∫ng, t·∫°i sao infinite loop?
2. dispatch c√≥ stable kh√¥ng?
3. L√†m sao fix?

**üí° Gi·∫£i th√≠ch:**

- `dispatch` IS stable (React guarantees)
- BUG th·ª±c s·ª±: Linter y√™u c·∫ßu include `dispatch` (exhaustive-deps)
- Nh∆∞ng dispatch stable ‚Üí kh√¥ng g√¢y re-run
- **Th·ª±c t·∫ø kh√¥ng loop!** ƒê√¢y l√† trick question üòÑ
- Tuy nhi√™n best practice: Kh√¥ng c·∫ßn dispatch trong deps

**‚úÖ Fix:**

```jsx
// ‚úÖ C√°ch 1: B·ªè dispatch kh·ªèi deps (safe v√¨ stable)
useEffect(() => {
  const fetchTodos = async () => {
    const response = await fetch('/api/todos');
    const data = await response.json();
    dispatch({ type: 'SET_TODOS', payload: data });
  };

  fetchTodos();
}, []); // Empty deps OK

// ‚úÖ C√°ch 2: Disable linter cho d√≤ng n√†y
useEffect(() => {
  const fetchTodos = async () => {
    const response = await fetch('/api/todos');
    const data = await response.json();
    dispatch({ type: 'SET_TODOS', payload: data });
  };

  fetchTodos();
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

### Bug 3: Forgotten Cleanup üêõ

```jsx
// ‚ùå CODE B·ªä L·ªñI
function CountdownTimer({ duration }) {
  const [state, dispatch] = useReducer(timerReducer, { seconds: duration });

  useEffect(() => {
    dispatch({ type: 'START' });

    const interval = setInterval(() => {
      dispatch({ type: 'TICK' });
    }, 1000);

    // üêõ No cleanup!
    // Khi component unmount ‚Üí interval v·∫´n ch·∫°y!
  }, []);

  // Memory leak: interval continues, dispatch sau unmount ‚Üí warning
}
```

**‚ùì C√¢u h·ªèi:**

1. V·∫•n ƒë·ªÅ g√¨ x·∫£y ra khi component unmount?
2. Console warning g√¨?
3. L√†m sao fix?

**üí° Gi·∫£i th√≠ch:**

- setInterval continues after unmount
- dispatch v√†o unmounted component ‚Üí React warning
- Memory leak (interval kh√¥ng clear)

**‚úÖ Fix:**

```jsx
function CountdownTimer({ duration }) {
  const [state, dispatch] = useReducer(timerReducer, { seconds: duration });

  useEffect(() => {
    dispatch({ type: 'START' });

    const interval = setInterval(() => {
      dispatch({ type: 'TICK' });
    }, 1000);

    // ‚úÖ Cleanup interval
    return () => {
      clearInterval(interval);
    };
  }, []);
}
```

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

ƒê√°nh d·∫•u ‚úÖ khi b·∫°n t·ª± tin:

**Async Basics:**

- [ ] T√¥i hi·ªÉu reducer ph·∫£i synchronous
- [ ] T√¥i bi·∫øt c√°ch dispatch trong useEffect
- [ ] T√¥i hi·ªÉu flow: effect ‚Üí dispatch ‚Üí reducer ‚Üí re-render
- [ ] T√¥i bi·∫øt 3 action pattern: START, SUCCESS, ERROR

**Request Management:**

- [ ] T√¥i bi·∫øt c√°ch d√πng AbortController
- [ ] T√¥i hi·ªÉu race condition l√† g√¨
- [ ] T√¥i bi·∫øt khi n√†o c·∫ßn cleanup
- [ ] T√¥i bi·∫øt c√°ch ignore stale results

**Advanced Patterns:**

- [ ] T√¥i hi·ªÉu optimistic updates pattern
- [ ] T√¥i bi·∫øt c√°ch implement retry logic
- [ ] T√¥i bi·∫øt c√°ch debounce requests
- [ ] T√¥i hi·ªÉu caching strategy

**Error Handling:**

- [ ] T√¥i bi·∫øt c√°ch handle network errors
- [ ] T√¥i bi·∫øt c√°ch check AbortError
- [ ] T√¥i bi·∫øt c√°ch implement retry
- [ ] T√¥i bi·∫øt c√°ch rollback optimistic updates

### Code Review Checklist

**useEffect:**

- [ ] C√≥ cleanup function (AbortController, clear timers)
- [ ] Dependencies ch√≠nh x√°c
- [ ] Kh√¥ng dispatch n·∫øu request aborted

**Reducer:**

- [ ] C√≥ actions cho START, SUCCESS, ERROR
- [ ] State transitions r√µ r√†ng
- [ ] Immutable updates
- [ ] Default case

**Error Handling:**

- [ ] Try-catch cho async operations
- [ ] Check `error.name !== 'AbortError'`
- [ ] User-friendly error messages
- [ ] Retry options n·∫øu recoverable

**Performance:**

- [ ] Debounce search inputs
- [ ] Cancel previous requests
- [ ] Cache when appropriate
- [ ] Prevent duplicate requests

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**B√†i 1: Implement Auto-Save**

Requirements:

1. Form v·ªõi multiple fields (title, description, tags)
2. Auto-save 2 gi√¢y sau khi user ng·ª´ng typing
3. Show save status: "Saved", "Saving...", "Error"
4. Retry n·∫øu save fails
5. Don't save n·∫øu no changes

State shape:

```jsx
{
  formData: { title: '', description: '', tags: [] },
  saveStatus: 'idle', // 'idle' | 'saving' | 'saved' | 'error'
  lastSaved: null, // timestamp
  hasUnsavedChanges: false
}
```

Actions:

- UPDATE_FIELD
- SAVE_START
- SAVE_SUCCESS
- SAVE_ERROR
- RESET_CHANGES

<details><summary>üí° Solution</summary>

```jsx
/**
 * AutoSaveForm component
 * Form v·ªõi auto-save sau 2 gi√¢y khi user ng·ª´ng typing
 * Hi·ªÉn th·ªã tr·∫°ng th√°i: idle, saving, saved, error
 * Ch·ªâ save khi c√≥ thay ƒë·ªïi (hasUnsavedChanges)
 * C√≥ retry khi save th·∫•t b·∫°i
 * S·ª≠ d·ª•ng useReducer ƒë·ªÉ qu·∫£n l√Ω form state & save state
 */
import { useReducer, useEffect, useRef } from 'react';

const AUTO_SAVE_DELAY = 2000; // 2 gi√¢y
const MAX_RETRY = 2;

const initialState = {
  formData: {
    title: '',
    description: '',
    tags: '',
  },
  saveStatus: 'idle', // 'idle' | 'saving' | 'saved' | 'error'
  lastSaved: null,
  hasUnsavedChanges: false,
  retryCount: 0,
  errorMessage: null,
};

const ActionTypes = {
  UPDATE_FIELD: 'UPDATE_FIELD',
  SAVE_START: 'SAVE_START',
  SAVE_SUCCESS: 'SAVE_SUCCESS',
  SAVE_ERROR: 'SAVE_ERROR',
  RESET_CHANGES: 'RESET_CHANGES',
  RETRY: 'RETRY',
};

function formReducer(state, action) {
  switch (action.type) {
    case ActionTypes.UPDATE_FIELD:
      return {
        ...state,
        formData: {
          ...state.formData,
          [action.payload.field]: action.payload.value,
        },
        hasUnsavedChanges: true,
        saveStatus: 'idle',
        errorMessage: null,
      };

    case ActionTypes.SAVE_START:
      return {
        ...state,
        saveStatus: 'saving',
        errorMessage: null,
        retryCount: action.payload?.isRetry ? state.retryCount : 0,
      };

    case ActionTypes.SAVE_SUCCESS:
      return {
        ...state,
        saveStatus: 'saved',
        lastSaved: Date.now(),
        hasUnsavedChanges: false,
        retryCount: 0,
        errorMessage: null,
      };

    case ActionTypes.SAVE_ERROR:
      return {
        ...state,
        saveStatus: 'error',
        errorMessage: action.payload,
        retryCount: state.retryCount + 1,
      };

    case ActionTypes.RESET_CHANGES:
      return {
        ...state,
        hasUnsavedChanges: false,
        saveStatus: 'idle',
      };

    case ActionTypes.RETRY:
      return {
        ...state,
        saveStatus: 'saving',
        errorMessage: null,
      };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function AutoSaveForm() {
  const [state, dispatch] = useReducer(formReducer, initialState);
  const debounceTimerRef = useRef(null);
  const abortControllerRef = useRef(null);

  // Cleanup khi unmount
  useEffect(() => {
    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  // Auto-save logic
  useEffect(() => {
    if (!state.hasUnsavedChanges || state.saveStatus === 'saving') {
      return;
    }

    // Clear timer c≈© n·∫øu c√≥
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }

    debounceTimerRef.current = setTimeout(() => {
      saveFormData();
    }, AUTO_SAVE_DELAY);

    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, [state.formData, state.hasUnsavedChanges, state.saveStatus]);

  const saveFormData = async (isRetry = false) => {
    // Cancel request c≈© n·∫øu c√≥
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    dispatch({ type: ActionTypes.SAVE_START, payload: { isRetry } });

    try {
      // Simulate API call (thay b·∫±ng fetch th·∫≠t trong production)
      await new Promise((resolve, reject) => {
        setTimeout(() => {
          // 20% chance fail ƒë·ªÉ test retry
          if (Math.random() < 0.2 && !isRetry) {
            reject(new Error('Server timeout'));
          } else {
            resolve();
          }
        }, 1200);
      });

      console.log('Saved:', state.formData);

      dispatch({ type: ActionTypes.SAVE_SUCCESS });
    } catch (err) {
      if (err.name === 'AbortError') return;

      const message = err.message || 'Failed to save';

      if (state.retryCount < MAX_RETRY) {
        // T·ª± ƒë·ªông retry sau 2s
        setTimeout(() => {
          saveFormData(true);
        }, 2000);
      }

      dispatch({
        type: ActionTypes.SAVE_ERROR,
        payload: message,
      });
    }
  };

  const handleChange = (field, value) => {
    dispatch({
      type: ActionTypes.UPDATE_FIELD,
      payload: { field, value },
    });
  };

  const handleManualRetry = () => {
    dispatch({ type: ActionTypes.RETRY });
    saveFormData(true);
  };

  const getStatusDisplay = () => {
    switch (state.saveStatus) {
      case 'saving':
        return 'Saving...';
      case 'saved':
        return state.lastSaved
          ? `Saved at ${new Date(state.lastSaved).toLocaleTimeString()}`
          : 'Saved';
      case 'error':
        return `Error: ${state.errorMessage}`;
      default:
        return state.hasUnsavedChanges ? 'Unsaved changes' : 'All saved';
    }
  };

  return (
    <div style={{ maxWidth: '600px', margin: '40px auto', padding: '20px' }}>
      <h2>Auto-Save Form</h2>

      <div
        style={{
          marginBottom: '20px',
          padding: '12px',
          background:
            state.saveStatus === 'saving'
              ? '#fff3e0'
              : state.saveStatus === 'saved'
                ? '#e8f5e9'
                : state.saveStatus === 'error'
                  ? '#ffebee'
                  : '#f5f5f5',
          borderRadius: '8px',
          fontWeight: state.hasUnsavedChanges ? 'bold' : 'normal',
        }}
      >
        {getStatusDisplay()}
        {state.saveStatus === 'error' && state.retryCount <= MAX_RETRY && (
          <span>
            {' '}
            (Retrying {state.retryCount}/{MAX_RETRY})
          </span>
        )}
      </div>

      <div style={{ marginBottom: '16px' }}>
        <label>Title</label>
        <input
          type='text'
          value={state.formData.title}
          onChange={(e) => handleChange('title', e.target.value)}
          placeholder='Enter title...'
          style={{ width: '100%', padding: '10px', marginTop: '6px' }}
        />
      </div>

      <div style={{ marginBottom: '16px' }}>
        <label>Description</label>
        <textarea
          value={state.formData.description}
          onChange={(e) => handleChange('description', e.target.value)}
          placeholder='Enter description...'
          rows={4}
          style={{ width: '100%', padding: '10px', marginTop: '6px' }}
        />
      </div>

      <div style={{ marginBottom: '16px' }}>
        <label>Tags (comma separated)</label>
        <input
          type='text'
          value={state.formData.tags}
          onChange={(e) => handleChange('tags', e.target.value)}
          placeholder='react, javascript, hooks...'
          style={{ width: '100%', padding: '10px', marginTop: '6px' }}
        />
      </div>

      {state.saveStatus === 'error' && (
        <button
          onClick={handleManualRetry}
          style={{
            padding: '10px 20px',
            background: '#d32f2f',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            marginTop: '12px',
          }}
        >
          Retry Save
        </button>
      )}
    </div>
  );
}

export default AutoSaveForm;

/*
K·∫øt qu·∫£ v√≠ d·ª• khi s·ª≠ d·ª•ng:

- G√µ title ‚Üí sau 2 gi√¢y: "Saving..." ‚Üí "Saved at 14:35:22"
- G√µ ti·∫øp description ‚Üí "Unsaved changes" ‚Üí sau 2s: "Saving..." ‚Üí "Saved at 14:35:28"
- N·∫øu API fail (simulate 20%): "Error: Server timeout (Retrying 1/2)" ‚Üí t·ª± retry
- Sau max retry v·∫´n fail ‚Üí hi·ªÉn th·ªã error + n√∫t "Retry Save"
- Tags ƒë∆∞·ª£c l∆∞u d∆∞·ªõi d·∫°ng string (c√≥ th·ªÉ split sau)
*/
```

</details>

### N√¢ng cao (60 ph√∫t)

**B√†i 2: Build Real-time Chat v·ªõi Polling**

Requirements:

1. Fetch messages m·ªói 5 gi√¢y (polling)
2. Display messages with timestamps
3. Send message (optimistic update)
4. Stop polling khi user inactive (5 ph√∫t)
5. Resume polling khi user active
6. Handle errors gracefully

State shape:

```jsx
{
  messages: [],
  loading: false,
  error: null,
  isPolling: true,
  lastActivity: Date.now()
}
```

Actions:

- FETCH_MESSAGES_SUCCESS
- SEND_MESSAGE_OPTIMISTIC
- SEND_MESSAGE_CONFIRMED
- SEND_MESSAGE_FAILED
- START_POLLING
- STOP_POLLING
- UPDATE_ACTIVITY

Challenges:

- Detect user activity (mouse move, keypress)
- Clear polling interval on inactivity
- Resume on activity
- Don't duplicate messages (check message IDs)

<details><summary>üí° Solution</summary>

```jsx
/**
 * RealTimeChat component
 * Real-time chat v·ªõi polling (fetch messages m·ªói 5s)
 * Send message v·ªõi optimistic update
 * Stop polling sau 5 ph√∫t inactive, resume khi active
 * Detect activity: mouse move, key press
 * Handle errors, avoid duplicate messages (by id)
 * S·ª≠ d·ª•ng mock API (local state ho·∫∑c JSONPlaceholder simulate)
 */
import { useReducer, useEffect, useRef, useState } from 'react';

// Mock API (simulate server v·ªõi localStorage ƒë·ªÉ persist)
const MOCK_SERVER_DELAY = 1000;
const POLLING_INTERVAL = 5000; // 5s
const INACTIVITY_TIMEOUT = 5 * 60 * 1000; // 5 ph√∫t
let mockMessages = JSON.parse(localStorage.getItem('mockChatMessages')) || [];

const mockFetchMessages = async () => {
  await new Promise((resolve) => setTimeout(resolve, MOCK_SERVER_DELAY));
  return [...mockMessages];
};

const mockSendMessage = async (newMessage) => {
  await new Promise((resolve) => setTimeout(resolve, MOCK_SERVER_DELAY));
  const sentMessage = {
    ...newMessage,
    id: Date.now().toString(), // Real ID from server
    timestamp: Date.now(),
  };
  mockMessages.push(sentMessage);
  localStorage.setItem('mockChatMessages', JSON.stringify(mockMessages));
  return sentMessage;
};

const initialState = {
  messages: [],
  loading: false,
  error: null,
  isPolling: true,
  lastActivity: Date.now(),
};

const ActionTypes = {
  FETCH_MESSAGES_SUCCESS: 'FETCH_MESSAGES_SUCCESS',
  SEND_MESSAGE_OPTIMISTIC: 'SEND_MESSAGE_OPTIMISTIC',
  SEND_MESSAGE_CONFIRMED: 'SEND_MESSAGE_CONFIRMED',
  SEND_MESSAGE_FAILED: 'SEND_MESSAGE_FAILED',
  START_POLLING: 'START_POLLING',
  STOP_POLLING: 'STOP_POLLING',
  UPDATE_ACTIVITY: 'UPDATE_ACTIVITY',
  SET_ERROR: 'SET_ERROR',
  CLEAR_ERROR: 'CLEAR_ERROR',
};

function chatReducer(state, action) {
  switch (action.type) {
    case ActionTypes.FETCH_MESSAGES_SUCCESS:
      // Merge messages, tr√°nh duplicate b·∫±ng id
      const newMessages = action.payload;
      const messageMap = new Map(state.messages.map((msg) => [msg.id, msg]));
      newMessages.forEach((msg) => {
        if (!messageMap.has(msg.id)) {
          messageMap.set(msg.id, msg);
        }
      });
      return {
        ...state,
        messages: Array.from(messageMap.values()).sort(
          (a, b) => a.timestamp - b.timestamp,
        ),
        loading: false,
        error: null,
      };

    case ActionTypes.SEND_MESSAGE_OPTIMISTIC:
      return {
        ...state,
        messages: [
          ...state.messages,
          {
            ...action.payload,
            id: `temp-${Date.now()}`,
            isOptimistic: true,
          },
        ],
      };

    case ActionTypes.SEND_MESSAGE_CONFIRMED:
      return {
        ...state,
        messages: state.messages.map((msg) =>
          msg.id === action.payload.tempId
            ? { ...action.payload.message, isOptimistic: false }
            : msg,
        ),
      };

    case ActionTypes.SEND_MESSAGE_FAILED:
      return {
        ...state,
        messages: state.messages.filter(
          (msg) => msg.id !== action.payload.tempId,
        ),
        error: action.payload.error,
      };

    case ActionTypes.START_POLLING:
      return {
        ...state,
        isPolling: true,
      };

    case ActionTypes.STOP_POLLING:
      return {
        ...state,
        isPolling: false,
      };

    case ActionTypes.UPDATE_ACTIVITY:
      return {
        ...state,
        lastActivity: Date.now(),
        isPolling: true,
      };

    case ActionTypes.SET_ERROR:
      return {
        ...state,
        error: action.payload,
        loading: false,
      };

    case ActionTypes.CLEAR_ERROR:
      return {
        ...state,
        error: null,
      };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

function RealTimeChat() {
  const [state, dispatch] = useReducer(chatReducer, initialState);
  const [inputMessage, setInputMessage] = useState('');
  const pollingIntervalRef = useRef(null);
  const inactivityTimeoutRef = useRef(null);
  const abortControllerRef = useRef(null);

  // Fetch messages
  const fetchMessages = async () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();

    try {
      const messages = await mockFetchMessages();
      dispatch({ type: ActionTypes.FETCH_MESSAGES_SUCCESS, payload: messages });
    } catch (err) {
      if (err.name !== 'AbortError') {
        dispatch({
          type: ActionTypes.SET_ERROR,
          payload: err.message || 'Failed to fetch messages',
        });
      }
    }
  };

  // Polling setup
  useEffect(() => {
    if (state.isPolling) {
      fetchMessages(); // Initial fetch
      pollingIntervalRef.current = setInterval(fetchMessages, POLLING_INTERVAL);
    } else {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
      }
    }

    return () => {
      if (pollingIntervalRef.current) {
        clearInterval(pollingIntervalRef.current);
      }
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [state.isPolling]);

  // Inactivity detection
  useEffect(() => {
    const checkInactivity = () => {
      const timeSinceLastActivity = Date.now() - state.lastActivity;
      if (timeSinceLastActivity >= INACTIVITY_TIMEOUT && state.isPolling) {
        dispatch({ type: ActionTypes.STOP_POLLING });
      }
    };

    inactivityTimeoutRef.current = setInterval(checkInactivity, 1000); // Check m·ªói gi√¢y

    return () => {
      if (inactivityTimeoutRef.current) {
        clearInterval(inactivityTimeoutRef.current);
      }
    };
  }, [state.lastActivity, state.isPolling]);

  // Detect user activity
  useEffect(() => {
    const handleActivity = () => {
      dispatch({ type: ActionTypes.UPDATE_ACTIVITY });
    };

    window.addEventListener('mousemove', handleActivity);
    window.addEventListener('keypress', handleActivity);

    return () => {
      window.removeEventListener('mousemove', handleActivity);
      window.removeEventListener('keypress', handleActivity);
    };
  }, []);

  // Send message
  const handleSendMessage = async () => {
    if (!inputMessage.trim()) return;

    const tempId = `temp-${Date.now()}`;
    const optimisticMessage = {
      content: inputMessage,
      timestamp: Date.now(),
      id: tempId,
    };

    dispatch({
      type: ActionTypes.SEND_MESSAGE_OPTIMISTIC,
      payload: optimisticMessage,
    });

    setInputMessage('');

    try {
      const confirmedMessage = await mockSendMessage({
        content: inputMessage,
        timestamp: Date.now(),
      });

      dispatch({
        type: ActionTypes.SEND_MESSAGE_CONFIRMED,
        payload: { tempId, message: confirmedMessage },
      });
    } catch (err) {
      dispatch({
        type: ActionTypes.SEND_MESSAGE_FAILED,
        payload: { tempId, error: err.message || 'Failed to send message' },
      });
    }
  };

  return (
    <div
      style={{
        maxWidth: '600px',
        margin: '40px auto',
        padding: '20px',
        border: '1px solid #ddd',
        borderRadius: '8px',
      }}
    >
      <h2>Real-Time Chat</h2>

      <div
        style={{
          marginBottom: '16px',
          color: state.isPolling ? 'green' : 'orange',
        }}
      >
        Status:{' '}
        {state.isPolling ? 'Polling active' : 'Polling paused (inactive)'}
      </div>

      {state.error && (
        <div
          style={{
            padding: '12px',
            background: '#ffebee',
            color: '#c62828',
            borderRadius: '8px',
            marginBottom: '16px',
          }}
        >
          Error: {state.error}
          <button
            onClick={() => {
              dispatch({ type: ActionTypes.CLEAR_ERROR });
              fetchMessages();
            }}
            style={{ marginLeft: '12px', padding: '4px 8px' }}
          >
            Retry
          </button>
        </div>
      )}

      <div
        style={{
          height: '300px',
          overflowY: 'auto',
          border: '1px solid #eee',
          padding: '12px',
          marginBottom: '16px',
          borderRadius: '4px',
        }}
      >
        {state.messages.length === 0 && !state.loading && (
          <div style={{ textAlign: 'center', color: '#888' }}>
            No messages yet
          </div>
        )}

        {state.messages.map((msg) => (
          <div
            key={msg.id}
            style={{
              marginBottom: '12px',
              opacity: msg.isOptimistic ? 0.6 : 1,
              fontStyle: msg.isOptimistic ? 'italic' : 'normal',
            }}
          >
            <strong>{new Date(msg.timestamp).toLocaleTimeString()}</strong>:{' '}
            {msg.content}
            {msg.isOptimistic && <span> (sending...)</span>}
          </div>
        ))}
      </div>

      <div style={{ display: 'flex', gap: '8px' }}>
        <input
          type='text'
          value={inputMessage}
          onChange={(e) => setInputMessage(e.target.value)}
          placeholder='Type a message...'
          style={{ flex: 1, padding: '10px' }}
          onKeyPress={(e) => {
            if (e.key === 'Enter') {
              handleSendMessage();
            }
          }}
        />
        <button
          onClick={handleSendMessage}
          style={{
            padding: '10px 20px',
            background: '#1976d2',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
          }}
        >
          Send
        </button>
      </div>
    </div>
  );
}

export default RealTimeChat;

/*
K·∫øt qu·∫£ v√≠ d·ª• khi s·ª≠ d·ª•ng:

- Mount ‚Üí fetch initial messages ‚Üí display with timestamps
- Send message ‚Üí optimistic add (opacity 0.6, "sending...") ‚Üí confirmed (opacity 1)
- M·ªói 5s ‚Üí poll new messages, merge without duplicates
- Kh√¥ng active 5 ph√∫t (no mouse/key) ‚Üí stop polling
- Mouse move ho·∫∑c keypress ‚Üí resume polling
- Error ‚Üí hi·ªÉn th·ªã message + Retry button
- Messages persist qua localStorage (mock server)
*/
```

</details>

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - useEffect:**
   - https://react.dev/reference/react/useEffect
   - Ph·∫ßn "Fetching data with Effects"

2. **AbortController:**
   - https://developer.mozilla.org/en-US/docs/Web/API/AbortController
   - Essential cho request cancellation

### ƒê·ªçc th√™m

3. **Race Conditions in React:**
   - https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect
   - Real-world examples

4. **Optimistic UI Updates:**
   - https://www.apollographql.com/docs/react/performance/optimistic-ui/
   - Pattern t·ª´ Apollo (√°p d·ª•ng cho fetch)

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (ƒê√£ h·ªçc)

- **Ng√†y 16-20:** useEffect
  - H√¥m nay apply cho async operations
  - Dependencies, cleanup critical!

- **Ng√†y 21-22:** useRef
  - Track previous values
  - Flags for ignoring stale results

- **Ng√†y 26-27:** useReducer
  - Foundation cho async state management
  - Actions cho state transitions

### H∆∞·ªõng t·ªõi (S·∫Ω h·ªçc)

- **Ng√†y 29:** Custom Hooks
  - useFetch, useAsync hooks
  - Reusable async logic
  - Encapsulate patterns from today

- **Ng√†y 31-34:** Performance
  - useMemo for expensive computations
  - useCallback for stable callbacks
  - Optimize re-renders

- **Phase 5:** Context
  - Global async state
  - Context + useReducer pattern
  - Share loading states

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**1. Request Priority:**

```jsx
// ‚úÖ Cancel low-priority requests for high-priority
useEffect(() => {
  const controller = new AbortController();

  // Low priority: analytics
  fetch('/api/analytics', { signal: controller.signal });

  return () => controller.abort(); // Cancel if user navigates
}, []);
```

**2. Error Categorization:**

```jsx
const handleError = (error) => {
  if (error.status === 429) {
    // Rate limit ‚Üí retry with backoff
    dispatch({ type: 'RETRY_WITH_BACKOFF' });
  } else if (error.status >= 500) {
    // Server error ‚Üí retry
    dispatch({ type: 'RETRY_SERVER_ERROR' });
  } else if (error.status === 401) {
    // Auth error ‚Üí redirect to login
    redirectToLogin();
  } else {
    // Client error ‚Üí show to user
    dispatch({ type: 'SHOW_ERROR', payload: error.message });
  }
};
```

**3. Offline Support:**

```jsx
// Queue requests khi offline
const [state, dispatch] = useReducer(reducer, {
  queue: [], // Pending requests
  isOnline: navigator.onLine,
});

useEffect(() => {
  const handleOnline = () => {
    dispatch({ type: 'ONLINE' });
    // Process queue
    state.queue.forEach((request) => {
      fetch(request.url, request.options);
    });
  };

  window.addEventListener('online', handleOnline);
  return () => window.removeEventListener('online', handleOnline);
}, []);
```

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior Level:**

1. **Q:** "T·∫°i sao c·∫ßn AbortController khi fetch data?"

   **Expected:**
   - Prevent race conditions
   - Cancel old requests
   - Cleanup on unmount
   - Example: userId changes ‚Üí abort previous request

2. **Q:** "useEffect cleanup function ch·∫°y khi n√†o?"

   **Expected:**
   - Before effect re-runs (deps change)
   - Component unmount
   - Example: clear interval, abort fetch

**Mid Level:**

3. **Q:** "L√†m sao handle race condition trong search?"

   **Expected:**
   - Problem: Slower request overwrites faster one
   - Solution 1: AbortController
   - Solution 2: Ignore stale flag
   - Debouncing c≈©ng helps
   - Code example

4. **Q:** "Optimistic updates l√† g√¨? Trade-offs?"

   **Expected:**
   - Update UI instantly, confirm later
   - Pros: Fast UX, no loading
   - Cons: Need rollback, complex
   - When: User interactions (likes, posts)
   - When not: Critical data (payments)

**Senior Level:**

5. **Q:** "Design data fetching layer cho large app. Explain caching, retry, error handling strategies."

   **Expected:**
   - Normalized state for data
   - Cache layer (LRU, TTL)
   - Retry with exponential backoff
   - Error categorization (retry vs show vs ignore)
   - Request deduplication
   - Prefetching strategies
   - Offline queue
   - Performance monitoring

### War Stories

**Story 1: Race Condition in Production**

> "Ecommerce app c√≥ search. Users type nhanh ‚Üí multiple requests. Bug: Search 'iphone' ‚Üí shows 'ip' results v√¨ request 'ip' ch·∫≠m h∆°n. M·∫•t 2 ng√†y debug v√¨ ch·ªâ x·∫£y ra v·ªõi slow network. Fix: AbortController + timestamp check. Lesson: Always cleanup async operations!" - Senior Engineer

**Story 2: Optimistic Updates Gone Wrong**

> "Social app implement optimistic likes. Bug: User spam like ‚Üí count tƒÉng 10, nh∆∞ng API ch·ªâ nh·∫≠n 1. V√¨ kh√¥ng handle duplicate requests. Fix: Debounce + prevent multiple optimistic updates cho c√πng item. Lesson: Optimistic updates c·∫ßn deduplication logic." - Tech Lead

**Story 3: Silent Retry Saved Us**

> "API c√≥ 10% flaky rate. Users th·∫•y errors li√™n t·ª•c. Implement silent retry (max 2): l·∫ßn 1 fail ‚Üí wait 1s ‚Üí retry ‚Üí l·∫ßn 2 fail ‚Üí show error. Error rate visible cho users gi·∫£m 90%. Lesson: Not all errors c·∫ßn show ngay, retry first!" - Engineering Manager

---

## üéØ PREVIEW NG√ÄY MAI

**Ng√†y 29: Custom Hooks v·ªõi useReducer**

B·∫°n s·∫Ω h·ªçc:

- ‚ú® Extract reusable async logic
- ‚ú® Build useFetch, useAsync, useForm hooks
- ‚ú® Hook composition patterns
- ‚ú® Share logic across components
- ‚ú® Test custom hooks

Chu·∫©n b·ªã:

- Ho√†n th√†nh b√†i t·∫≠p h√¥m nay
- Review patterns ƒë√£ h·ªçc (normalization, async)
- Nghƒ© v·ªÅ logic n√†o c√≥ th·ªÉ reuse
- Read: https://react.dev/learn/reusing-logic-with-custom-hooks

---

**üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh Ng√†y 28!**

B·∫°n gi·ªù ƒë√£ master:

- ‚úÖ useReducer + useEffect pattern
- ‚úÖ Async state management
- ‚úÖ Race condition handling
- ‚úÖ Optimistic updates
- ‚úÖ Retry logic

Tomorrow: Reusable custom hooks! üí™
