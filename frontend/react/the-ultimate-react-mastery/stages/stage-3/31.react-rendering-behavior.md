# ğŸ“… NGÃ€Y 31: REACT RENDERING BEHAVIOR - Hiá»ƒu CÃ¡ch React Re-render

## ğŸ“ ThÃ´ng tin khÃ³a há»c

**Phase 3: Complex State & Performance** | **Tuáº§n 7: Performance Optimization** | **NgÃ y 31/45**

**â±ï¸ Thá»i lÆ°á»£ng:** 3-4 giá» (bao gá»“m breaks)

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] **Hiá»ƒu rÃµ** render cycle cá»§a React (Render phase vs Commit phase)
- [ ] **Nháº­n biáº¿t** Ä‘Æ°á»£c khi nÃ o vÃ  táº¡i sao má»™t component re-render
- [ ] **Sá»­ dá»¥ng** React DevTools Profiler Ä‘á»ƒ phÃ¢n tÃ­ch performance
- [ ] **XÃ¡c Ä‘á»‹nh** Ä‘Æ°á»£c unnecessary re-renders trong á»©ng dá»¥ng
- [ ] **Ãp dá»¥ng** ká»¹ thuáº­t Ä‘o lÆ°á»ng vÃ  tracking render counts

> ğŸ“ **Táº§m quan trá»ng:** NgÃ y hÃ´m nay lÃ  ná»n táº£ng cho tuáº§n Performance Optimization. Náº¿u khÃ´ng hiá»ƒu cÃ¡ch React render, báº¡n sáº½ khÃ´ng biáº¿t cáº§n optimize cÃ¡i gÃ¬!

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i sau:

**1. Component nÃ o sáº½ re-render khi state thay Ä‘á»•i?**

```jsx
function Parent() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <Child1 count={count} />
      <Child2 />
    </div>
  );
}
```

<details>
<summary>ğŸ’¡ ÄÃ¡p Ã¡n</summary>

**Cáº£ 3 components Ä‘á»u re-render!**

- `Parent` re-render vÃ¬ state thay Ä‘á»•i
- `Child1` re-render vÃ¬ parent render
- `Child2` re-render vÃ¬ parent render (dÃ¹ khÃ´ng nháº­n props!)

ÄÃ¢y chÃ­nh lÃ  Ä‘iá»u chÃºng ta sáº½ há»c hÃ´m nay.

</details>

**2. Khi nÃ o useEffect cleanup function cháº¡y?**

<details>
<summary>ğŸ’¡ ÄÃ¡p Ã¡n</summary>

- TrÆ°á»›c má»—i láº§n effect cháº¡y láº¡i (náº¿u dependencies thay Ä‘á»•i)
- Khi component unmount

LiÃªn quan Ä‘áº¿n render cycle!

</details>

**3. Báº¡n Ä‘Ã£ tá»«ng gáº·p app React cháº¡y cháº­m chÆ°a? NguyÃªn nhÃ¢n lÃ  gÃ¬?**

<details>
<summary>ğŸ’¡ Suy nghÄ©</summary>

ThÆ°á»ng lÃ  do:

- Re-render quÃ¡ nhiá»u
- Re-render khÃ´ng cáº§n thiáº¿t
- TÃ­nh toÃ¡n náº·ng trong render
- KhÃ´ng biáº¿t cÃ¡ch Ä‘o lÆ°á»ng performance

HÃ´m nay sáº½ giáº£i quyáº¿t táº¥t cáº£!

</details>

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

**Ká»‹ch báº£n:**
Báº¡n build má»™t app Todo list Ä‘Æ¡n giáº£n. CÃ³ 100 todos, má»—i todo lÃ  1 component. Khi báº¡n gÃµ vÃ o input Ä‘á»ƒ thÃªm todo má»›i, app bá»‹ giáº­t lag!

```jsx
function TodoApp() {
  const [todos, setTodos] = useState([
    /* 100 todos */
  ]);
  const [newTodo, setNewTodo] = useState('');

  return (
    <div>
      <input
        value={newTodo}
        onChange={(e) => setNewTodo(e.target.value)}
      />
      <div>
        {todos.map((todo) => (
          <TodoItem
            key={todo.id}
            todo={todo}
          />
        ))}
      </div>
    </div>
  );
}
```

**Váº¥n Ä‘á»:**

- Má»—i láº§n gÃµ 1 kÃ½ tá»± â†’ `newTodo` state thay Ä‘á»•i
- `TodoApp` re-render
- **Táº¤T Cáº¢ 100 `TodoItem` components cÅ©ng re-render!**
- DÃ¹ todos khÃ´ng há» thay Ä‘á»•i!

**CÃ¢u há»i:** Táº¡i sao 100 components re-render khi chá»‰ cÃ³ input thay Ä‘á»•i?

---

### 1.2 Giáº£i PhÃ¡p: Hiá»ƒu React Rendering

React rendering hoáº¡t Ä‘á»™ng theo nguyÃªn táº¯c:

> **"When a component renders, all of its children render too"**
>
> Khi component cha render, Táº¤T Cáº¢ component con cÅ©ng render theo.

**NHÆ¯NG:**

- "Render" â‰  "Update DOM"
- React ráº¥t thÃ´ng minh trong viá»‡c update DOM
- Váº¥n Ä‘á» lÃ  viá»‡c TÃNH TOÃN render cÃ³ thá»ƒ tá»‘n kÃ©m

**HÃ´m nay há»c:**

1. Hiá»ƒu CHI TIáº¾T cÃ¡ch React render
2. ÄO LÆ¯á»œNG performance
3. NHáº¬N BIáº¾T váº¥n Ä‘á»
4. NgÃ y mai há»c GIáº¢I QUYáº¾T (React.memo, useMemo, useCallback)

---

### 1.3 Mental Model: React Render Cycle

#### ğŸ¬ The Two-Phase Rendering Process

```
USER ACTION (click, type, etc.)
    â†“
STATE CHANGE
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 1: RENDER PHASE              â”‚
â”‚  (Pure, can be interrupted)         â”‚
â”‚                                     â”‚
â”‚  1. Call component functions        â”‚
â”‚  2. Execute JSX                     â”‚
â”‚  3. Create Virtual DOM tree         â”‚
â”‚  4. Compare with previous tree      â”‚
â”‚     (Reconciliation)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PHASE 2: COMMIT PHASE              â”‚
â”‚  (Cannot be interrupted)            â”‚
â”‚                                     â”‚
â”‚  1. Apply changes to Real DOM       â”‚
â”‚  2. Run useLayoutEffect             â”‚
â”‚  3. Browser paints screen           â”‚
â”‚  4. Run useEffect                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
USER SEES UPDATES
```

#### ğŸ§  Analogy: Restaurant Kitchen

**Render Phase = Preparing the order**

- Chef reads the order (component function)
- Prepares ingredients (creates Virtual DOM)
- Compares with previous order (reconciliation)
- Can cancel if customer changes mind (can be interrupted)

**Commit Phase = Serving the food**

- Put food on plate (update Real DOM)
- Bring to customer (browser paint)
- Cannot be undone once served (cannot be interrupted)

---

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

#### âŒ Hiá»ƒu láº§m 1: "Render = DOM update"

**SAI:**

```jsx
// Nhiá»u ngÆ°á»i nghÄ© má»—i láº§n render = DOM update
function Counter() {
  const [count, setCount] = useState(0);
  console.log('Component rendered!'); // Cháº¡y má»—i láº§n render
  return <div>{count}</div>;
}
```

**ÄÃšNG:**

- Render = Gá»i component function + táº¡o Virtual DOM
- DOM update = Chá»‰ khi Virtual DOM khÃ¡c previous Virtual DOM
- React chá»‰ update pháº§n DOM thay Ä‘á»•i (ráº¥t hiá»‡u quáº£!)

#### âŒ Hiá»ƒu láº§m 2: "Props khÃ´ng Ä‘á»•i = KhÃ´ng re-render"

**SAI:**

```jsx
function Parent() {
  const [count, setCount] = useState(0);
  return <Child name='John' />; // name khÃ´ng Ä‘á»•i
}

function Child({ name }) {
  console.log('Child rendered!'); // VáºªN cháº¡y má»—i láº§n Parent render!
  return <div>{name}</div>;
}
```

**ÄÃšNG:**

- Khi Parent render â†’ Child LUÃ”N render (máº·c Ä‘á»‹nh)
- DÃ¹ props khÃ´ng thay Ä‘á»•i
- ÄÃ¢y lÃ  behavior máº·c Ä‘á»‹nh cá»§a React (sáº½ optimize ngÃ y mai)

#### âŒ Hiá»ƒu láº§m 3: "setState vá»›i giÃ¡ trá»‹ giá»‘ng nhau = KhÃ´ng render"

**PHá»¨C Táº P:**

```jsx
function Component() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(0); // Set cÃ¹ng giÃ¡ trá»‹
  };

  console.log('Rendered');
  return <button onClick={handleClick}>Click</button>;
}
```

**Thá»±c táº¿:**

- Láº§n Ä‘áº§u click: Re-render (React kiá»ƒm tra sau)
- Láº§n sau: KHÃ”NG re-render (React phÃ¡t hiá»‡n giÃ¡ trá»‹ giá»‘ng nhau)
- Gá»i lÃ  "Bailout optimization"

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Visualizing Render Behavior â­

**Má»¥c tiÃªu:** Tháº¥y Ä‘Æ°á»£c khi nÃ o components render

```jsx
// RenderTracker.jsx
// Simple component to track renders

import { useState, useRef } from 'react';

function RenderCounter() {
  const renderCount = useRef(0);
  renderCount.current += 1;

  return (
    <span
      style={{
        background: 'yellow',
        padding: '2px 6px',
        borderRadius: '4px',
        fontSize: '12px',
      }}
    >
      Renders: {renderCount.current}
    </span>
  );
}

function Parent() {
  const [parentCount, setParentCount] = useState(0);

  console.log('ğŸ”´ Parent rendered');

  return (
    <div style={{ border: '2px solid red', padding: '20px', margin: '10px' }}>
      <h3>
        Parent <RenderCounter />
      </h3>
      <button onClick={() => setParentCount((c) => c + 1)}>
        Parent Count: {parentCount}
      </button>

      <Child1 />
      <Child2 count={parentCount} />
    </div>
  );
}

function Child1() {
  console.log('ğŸ”µ Child1 rendered');

  return (
    <div style={{ border: '2px solid blue', padding: '15px', margin: '10px' }}>
      <h4>
        Child1 (No props) <RenderCounter />
      </h4>
      <p>I don't receive any props</p>
    </div>
  );
}

function Child2({ count }) {
  console.log('ğŸŸ¢ Child2 rendered');

  return (
    <div style={{ border: '2px solid green', padding: '15px', margin: '10px' }}>
      <h4>
        Child2 (With props) <RenderCounter />
      </h4>
      <p>Parent count: {count}</p>
    </div>
  );
}

export default Parent;
```

**ğŸ§ª ThÃ­ nghiá»‡m:**

1. Click "Parent Count" button
2. Quan sÃ¡t console
3. Quan sÃ¡t render counters

**ğŸ“Š Káº¿t quáº£:**

```
Click 1:
ğŸ”´ Parent rendered
ğŸ”µ Child1 rendered  â† KhÃ´ng cÃ³ props váº«n render!
ğŸŸ¢ Child2 rendered

Click 2:
ğŸ”´ Parent rendered
ğŸ”µ Child1 rendered  â† Váº«n render!
ğŸŸ¢ Child2 rendered
```

**ğŸ’¡ Insight:**

- **Child1** render DÃ™ khÃ´ng nháº­n props
- **Child2** render vÃ¬ props thay Ä‘á»•i (há»£p lÃ½)
- **Parent render â†’ Children render** (default behavior)

---

### Demo 2: Props Change Detection â­â­

**Má»¥c tiÃªu:** Hiá»ƒu React so sÃ¡nh props nhÆ° tháº¿ nÃ o

```jsx
// PropsComparisonDemo.jsx

import { useState } from 'react';

// âŒ ANTI-PATTERN: Creating new objects/arrays in render
function BadParent() {
  const [count, setCount] = useState(0);

  // ğŸš¨ NEW object má»—i láº§n render!
  const user = { name: 'John', age: 30 };

  // ğŸš¨ NEW array má»—i láº§n render!
  const items = ['a', 'b', 'c'];

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Increment: {count}</button>
      <ChildWithObject user={user} />
      <ChildWithArray items={items} />
    </div>
  );
}

function ChildWithObject({ user }) {
  console.log('ChildWithObject rendered');
  return <div>User: {user.name}</div>;
}

function ChildWithArray({ items }) {
  console.log('ChildWithArray rendered');
  return <div>Items: {items.join(', ')}</div>;
}

// âœ… GOOD PATTERN: Stable references
function GoodParent() {
  const [count, setCount] = useState(0);

  // âœ… Defined outside component or in state/ref
  const user = useState({ name: 'John', age: 30 })[0];
  const items = useState(['a', 'b', 'c'])[0];

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Increment: {count}</button>
      <ChildWithObject user={user} />
      <ChildWithArray items={items} />
    </div>
  );
}

// ğŸ¯ DEMONSTRATION Component
export default function PropsComparisonDemo() {
  return (
    <div>
      <h3>âŒ Bad: New objects every render</h3>
      <BadParent />

      <hr />

      <h3>âœ… Good: Stable references</h3>
      <GoodParent />
    </div>
  );
}
```

**ğŸ§ª So sÃ¡nh:**

**Bad Parent:**

```
Click button â†’ count changes
â”œâ”€ Parent renders
â”œâ”€ user = NEW object (different reference)
â”œâ”€ items = NEW array (different reference)
â””â”€ Children see "different" props â†’ render

Má»—i láº§n click:
- ChildWithObject renders (user reference changed)
- ChildWithArray renders (items reference changed)
```

**Good Parent:**

```
Click button â†’ count changes
â”œâ”€ Parent renders
â”œâ”€ user = SAME object (stable reference)
â”œâ”€ items = SAME array (stable reference)
â””â”€ Children might skip render (vá»›i React.memo - ngÃ y mai há»c)

NHÆ¯NG hiá»‡n táº¡i:
- Váº«n render vÃ¬ khÃ´ng cÃ³ optimization
- Chá»‰ lÃ  chuáº©n bá»‹ cho ngÃ y mai!
```

**ğŸ’¡ Key Takeaway:**

```jsx
// React compares props using Object.is (similar to ===)

// Primitives: Compare by value
5 === 5 // true â†’ same prop
'hello' === 'hello' // true â†’ same prop

// Objects/Arrays: Compare by reference
{ name: 'John' } === { name: 'John' } // false â†’ different prop!
['a', 'b'] === ['a', 'b'] // false â†’ different prop!

const obj1 = { name: 'John' };
const obj2 = obj1;
obj1 === obj2 // true â†’ same prop
```

---

### Demo 3: State Updates & Bailout Optimization â­â­â­

**Má»¥c tiÃªu:** React's bailout optimization khi setState giÃ¡ trá»‹ giá»‘ng nhau

```jsx
// BailoutDemo.jsx

import { useState, useRef } from 'react';

function BailoutDemo() {
  const [count, setCount] = useState(0);
  const [user, setUser] = useState({ name: 'John' });

  const renderCount = useRef(0);
  renderCount.current += 1;

  console.log('ğŸ¨ Component rendered:', renderCount.current);

  return (
    <div style={{ padding: '20px', border: '2px solid blue' }}>
      <h3>Bailout Optimization Demo</h3>
      <p>Render count: {renderCount.current}</p>

      <hr />

      <h4>Test 1: Primitive Value (Number)</h4>
      <p>Count: {count}</p>
      <button onClick={() => setCount(0)}>Set to 0 (same value)</button>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>

      <hr />

      <h4>Test 2: Object Value</h4>
      <p>Name: {user.name}</p>

      {/* âŒ Creates NEW object â†’ Always re-renders */}
      <button onClick={() => setUser({ name: 'John' })}>
        Set NEW object (same content)
      </button>

      {/* âœ… Same object reference â†’ Bailout */}
      <button onClick={() => setUser(user)}>Set SAME object</button>

      {/* âœ… Different content â†’ Re-renders */}
      <button onClick={() => setUser({ name: 'Jane' })}>
        Set different content
      </button>
    </div>
  );
}

export default BailoutDemo;
```

**ğŸ§ª Test Cases:**

**Test 1: Primitive (Number)**

```
Initial render: Render count = 1

Click "Set to 0":
â”œâ”€ First time: Re-renders! (count = 2)
â”‚  React checks AFTER render
â”œâ”€ Second time: NO re-render! (count stays 2)
â”‚  React: "0 === 0, skip render"
â””â”€ Subsequent clicks: NO re-render

Click "Increment":
â””â”€ Always re-renders (value actually changes)
```

**Test 2: Object**

```
Click "Set NEW object":
â”œâ”€ ALWAYS re-renders!
â”‚  { name: 'John' } !== { name: 'John' }
â””â”€ Different reference â†’ React re-renders

Click "Set SAME object":
â”œâ”€ First time: Re-renders!
â”œâ”€ Second time: NO re-render!
â”‚  user === user (same reference)
â””â”€ Bailout works!

Click "Set different content":
â””â”€ ALWAYS re-renders (expected)
```

**ğŸ’¡ Bailout Rules:**

```jsx
// âœ… Bailout WORKS (after first check):
setCount(0); // If count is already 0
setCount((prevCount) => prevCount); // Return same value
setUser(user); // Same object reference

// âŒ Bailout DOESN'T WORK:
setCount(0); // First time (React checks after render)
setUser({ ...user }); // New object (different reference)
setUser({ name: 'John' }); // New object (different reference)
```

---

### ğŸ› ï¸ React DevTools Profiler

**CÃ¡ch sá»­ dá»¥ng:**

1. **CÃ i Ä‘áº·t:** React DevTools extension (Chrome/Firefox)

2. **Má»Ÿ Profiler tab:**
   - F12 â†’ React DevTools â†’ Profiler
   - Click "Record" button (âºï¸)

3. **Thá»±c hiá»‡n actions:**
   - Click buttons, type, etc.
   - Stop recording (â¹ï¸)

4. **PhÃ¢n tÃ­ch:**
   - **Flamegraph:** Tháº¥y components nÃ o render
   - **Ranked:** Components render lÃ¢u nháº¥t
   - **Timeline:** Render theo thá»i gian

**VÃ­ dá»¥ Ä‘á»c Profiler:**

```
Flamegraph view:

App (12ms)
â”œâ”€â”€ Header (2ms)
â”œâ”€â”€ Sidebar (1ms)
â””â”€â”€ Content (9ms)
    â”œâ”€â”€ TodoList (8ms)     â† ğŸ”¥ Tá»‘n thá»i gian nháº¥t!
    â”‚   â”œâ”€â”€ TodoItem (1ms) Ã— 100  â† ğŸ”¥ 100 items render!
    â”‚   â””â”€â”€ ...
    â””â”€â”€ Footer (0.5ms)

ğŸ’¡ Insight: TodoList re-render 100 items má»—i láº§n!
```

**Highlight Updates:**

```jsx
// In React DevTools â†’ Settings
â˜‘ï¸ Highlight updates when components render

// BÃ¢y giá» khi component render:
// â†’ Border mÃ u flash xung quanh component
// â†’ MÃ u xanh: Render nhanh
// â†’ MÃ u vÃ ng: Render trung bÃ¬nh
// â†’ MÃ u Ä‘á»: Render cháº­m â† ğŸš¨ Cáº§n optimize!
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ BÃ i 1: Tracking Renders (15 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** Táº¡o component tracking sá»‘ láº§n render

**â±ï¸ Thá»i gian:** 15 phÃºt

**ğŸš« KHÃ”NG dÃ¹ng:** useMemo, useCallback, React.memo (chÆ°a há»c)

```jsx
/**
 * Requirements:
 * 1. Táº¡o custom hook `useRenderCount()` return sá»‘ láº§n component render
 * 2. Sá»­ dá»¥ng useRef Ä‘á»ƒ persist count across renders
 * 3. Táº¡o component `RenderLogger` log má»—i láº§n render vá»›i timestamp
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - useRef khÃ´ng trigger re-render khi update
 * - renderCount.current += 1 trong component body
 * - console.log vá»›i timestamp: new Date().toLocaleTimeString()
 */

// âŒ CÃ¡ch SAI: DÃ¹ng state
function WrongRenderCount() {
  const [renderCount, setRenderCount] = useState(0);

  // ğŸš¨ INFINITE LOOP!
  setRenderCount(renderCount + 1); // State update â†’ Re-render â†’ Update â†’ ...

  return <div>Renders: {renderCount}</div>;
}

// âœ… CÃ¡ch ÄÃšNG: DÃ¹ng useRef
function useRenderCount() {
  const renderCount = useRef(0);

  // Safe: KhÃ´ng trigger re-render
  renderCount.current += 1;

  return renderCount.current;
}

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:

// TODO: Implement useRenderCount hook
function useRenderCount() {
  // Your code here
}

// TODO: Implement RenderLogger component
// Should log: "Component rendered at HH:MM:SS - Render #N"
function RenderLogger({ componentName }) {
  // Your code here
  return null; // or some UI
}

// TODO: Test component
function TestComponent() {
  const [count, setCount] = useState(0);
  const renderCount = useRenderCount();

  return (
    <div>
      <RenderLogger componentName='TestComponent' />
      <p>State: {count}</p>
      <p>Renders: {renderCount}</p>
      <button onClick={() => setCount((c) => c + 1)}>Update</button>
    </div>
  );
}
```

<details>
<summary>âœ… Solution</summary>

```jsx
// useRenderCount.js
import { useRef } from 'react';

function useRenderCount() {
  const renderCount = useRef(0);
  renderCount.current += 1;
  return renderCount.current;
}

export default useRenderCount;

// RenderLogger.jsx
import { useEffect } from 'react';
import useRenderCount from './useRenderCount';

function RenderLogger({ componentName = 'Component' }) {
  const renderCount = useRenderCount();

  useEffect(() => {
    const timestamp = new Date().toLocaleTimeString();
    console.log(
      `ğŸ¨ ${componentName} rendered at ${timestamp} - Render #${renderCount}`
    );
  });

  return (
    <div style={{
      background: '#f0f0f0',
      padding: '5px',
      fontSize: '12px',
      borderRadius: '4px',
      marginBottom: '10px'
    }}>
      <strong>{componentName}</strong> - Render #{renderCount}
    </div>
  );
}

export default RenderLogger;
```

**ğŸ’¡ Giáº£i thÃ­ch:**

- useRef persists value across renders WITHOUT triggering re-render
- useEffect vá»›i no deps cháº¡y má»—i láº§n render (perfect for logging)
- Component name tá»« props Ä‘á»ƒ tÃ¡i sá»­ dá»¥ng
</details>

---

### â­â­ BÃ i 2: Render Behavior Analysis (25 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** PhÃ¢n tÃ­ch vÃ  predict render behavior

**â±ï¸ Thá»i gian:** 25 phÃºt

```jsx
/**
 * Scenario: Báº¡n Ä‘Æ°á»£c giao má»™t codebase cáº§n tá»‘i Æ°u performance.
 * Äá»c code dÆ°á»›i Ä‘Ã¢y vÃ  tráº£ lá»i cÃ¢u há»i.
 */

function App() {
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedId, setSelectedId] = useState(null);

  return (
    <div>
      <SearchBar
        value={searchTerm}
        onChange={setSearchTerm}
      />
      <ProductList
        searchTerm={searchTerm}
        onSelect={setSelectedId}
      />
      <ProductDetail productId={selectedId} />
    </div>
  );
}

function SearchBar({ value, onChange }) {
  console.log('SearchBar rendered');
  return (
    <input
      value={value}
      onChange={(e) => onChange(e.target.value)}
    />
  );
}

function ProductList({ searchTerm, onSelect }) {
  console.log('ProductList rendered');
  const products = [
    /* 100 products */
  ];

  const filtered = products.filter((p) =>
    p.name.toLowerCase().includes(searchTerm.toLowerCase()),
  );

  return (
    <div>
      {filtered.map((product) => (
        <ProductItem
          key={product.id}
          product={product}
          onSelect={onSelect}
        />
      ))}
    </div>
  );
}

function ProductItem({ product, onSelect }) {
  console.log('ProductItem rendered:', product.id);
  return (
    <div onClick={() => onSelect(product.id)}>
      {product.name} - ${product.price}
    </div>
  );
}

function ProductDetail({ productId }) {
  console.log('ProductDetail rendered');
  if (!productId) return <div>Select a product</div>;

  // Fetch product details...
  return <div>Details for product {productId}</div>;
}

/**
 * ğŸ¤” PHÃ‚N TÃCH:
 *
 * 1. User gÃµ vÃ o SearchBar. Components nÃ o render?
 *    A. Chá»‰ SearchBar
 *    B. SearchBar + ProductList
 *    C. Táº¥t cáº£ components
 *    D. SearchBar + ProductList + ProductItems
 *
 * 2. User click vÃ o má»™t ProductItem. Components nÃ o render?
 *    A. Chá»‰ ProductItem Ä‘Æ°á»£c click
 *    B. ProductDetail + ProductItem
 *    C. Táº¥t cáº£ components
 *    D. App + ProductDetail
 *
 * 3. Váº¥n Ä‘á» performance lá»›n nháº¥t lÃ  gÃ¬?
 *    A. SearchBar re-render nhiá»u
 *    B. ProductList filter láº¡i má»—i láº§n search
 *    C. Táº¥t cáº£ ProductItems re-render khi search
 *    D. ProductDetail fetch data nhiá»u láº§n
 *
 * ğŸ’­ Báº N CHá»ŒN GÃŒ VÃ€ Táº I SAO?
 * Viáº¿t phÃ¢n tÃ­ch cá»§a báº¡n:
 * - Approach hiá»‡n táº¡i cÃ³ váº¥n Ä‘á» gÃ¬?
 * - Components nÃ o render khÃ´ng cáº§n thiáº¿t?
 * - Sáº½ optimize nhÆ° tháº¿ nÃ o? (chá»‰ describe, chÆ°a implement)
 */

// ğŸ¯ NHIá»†M Vá»¤:
// 1. Copy code trÃªn vÃ o editor
// 2. ThÃªm RenderLogger vÃ o má»—i component
// 3. Test cÃ¡c scenarios:
//    - GÃµ vÃ o search (má»—i kÃ½ tá»±)
//    - Click vÃ o product
//    - Clear search
// 4. Document sá»‘ láº§n render má»—i component
// 5. Viáº¿t phÃ¢n tÃ­ch performance issues
```

<details>
<summary>âœ… Solution & Analysis</summary>

**CÃ¢u 1: User gÃµ vÃ o SearchBar**
**ÄÃ¡p Ã¡n: C - Táº¥t cáº£ components**

```
User types "a":
â”œâ”€ searchTerm state changes in App
â”œâ”€ App renders
â”‚  â”œâ”€ SearchBar renders (props.value changed)
â”‚  â”œâ”€ ProductList renders (props.searchTerm changed)
â”‚  â”‚  â”œâ”€ ProductItem renders Ã— N (parent renders)
â”‚  â”‚  â””â”€ (Filtered array is NEW array)
â”‚  â””â”€ ProductDetail renders (parent renders, props.productId unchanged)
```

**CÃ¢u 2: User click ProductItem**
**ÄÃ¡p Ã¡n: C - Táº¥t cáº£ components**

```
User clicks ProductItem:
â”œâ”€ selectedId state changes in App
â”œâ”€ App renders
â”‚  â”œâ”€ SearchBar renders (parent renders)
â”‚  â”œâ”€ ProductList renders (parent renders)
â”‚  â”‚  â”œâ”€ ProductItem renders Ã— N (parent renders)
â”‚  â”‚  â””â”€ onSelect is NEW function reference each render!
â”‚  â””â”€ ProductDetail renders (props.productId changed)
```

**CÃ¢u 3: Váº¥n Ä‘á» performance**
**ÄÃ¡p Ã¡n: C - Táº¥t cáº£ ProductItems re-render khi search**

**PhÃ¢n tÃ­ch chi tiáº¿t:**

```jsx
// Problem 1: Táº¥t cáº£ ProductItems re-render khÃ´ng cáº§n thiáº¿t
// Má»—i láº§n search:
// - ProductList renders
// - filtered = NEW array (different reference)
// - 100 ProductItems render láº¡i (dÃ¹ content khÃ´ng Ä‘á»•i!)

// Problem 2: onSelect lÃ  NEW function má»—i láº§n
<ProductItem onSelect={onSelect} />;
// onSelect tá»« props lÃ  setSelectedId
// Reference khÃ´ng Ä‘á»•i NHÆ¯NG ProductItem váº«n render vÃ¬ parent render

// Problem 3: ProductList filter má»—i láº§n render
const filtered = products.filter(/* ... */);
// Cháº¡y láº¡i má»—i láº§n render dÃ¹ searchTerm khÃ´ng Ä‘á»•i
// (VD: Click product â†’ App renders â†’ ProductList renders â†’ Filter again!)

// Problem 4: ProductDetail render khÃ´ng cáº§n thiáº¿t
// Khi search thay Ä‘á»•i, ProductDetail render dÃ¹ productId khÃ´ng Ä‘á»•i
```

**Optimization Plan (sáº½ implement ngÃ y mai):**

```jsx
// 1. Memo ProductItem (React.memo)
const ProductItem = React.memo(({ product, onSelect }) => {
  // Only re-render if product or onSelect actually changes
});

// 2. Memoize filtered results (useMemo)
const filtered = useMemo(
  () =>
    products.filter((p) =>
      p.name.toLowerCase().includes(searchTerm.toLowerCase()),
    ),
  [products, searchTerm],
);

// 3. Memoize callback (useCallback)
const handleSelect = useCallback((id) => {
  setSelectedId(id);
}, []); // Stable reference

// 4. Memo ProductDetail (React.memo)
const ProductDetail = React.memo(({ productId }) => {
  // Only re-render if productId changes
});
```

**ğŸ“Š Performance Impact:**

```
BEFORE optimization:
User types "apple" (5 characters):
â”œâ”€ 5 Ã— App renders
â”œâ”€ 5 Ã— SearchBar renders
â”œâ”€ 5 Ã— ProductList renders
â”œâ”€ 500 Ã— ProductItem renders (100 items Ã— 5 times)
â””â”€ 5 Ã— ProductDetail renders
Total: 515 renders for typing 5 characters!

AFTER optimization (ngÃ y mai):
â”œâ”€ 5 Ã— App renders (necessary)
â”œâ”€ 5 Ã— SearchBar renders (necessary)
â”œâ”€ 5 Ã— ProductList renders (necessary)
â”œâ”€ 20-30 Ã— ProductItem renders (only items that changed)
â””â”€ 0 Ã— ProductDetail renders (productId unchanged)
Total: ~40 renders - Giáº£m 90%!
```

</details>

---

### â­â­â­ BÃ i 3: Performance Profiling Dashboard (40 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** XÃ¢y dá»±ng dashboard Ä‘á»ƒ track render performance

**â±ï¸ Thá»i gian:** 40 phÃºt

```jsx
/**
 * ğŸ“‹ Product Requirements:
 *
 * User Story:
 * "LÃ  developer, tÃ´i muá»‘n cÃ³ dashboard hiá»ƒn thá»‹ performance metrics
 * Ä‘á»ƒ tÃ´i cÃ³ thá»ƒ identify components render nhiá»u nháº¥t"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Hiá»ƒn thá»‹ danh sÃ¡ch components vÃ  sá»‘ láº§n render cá»§a má»—i component
 * - [ ] Highlight components render > 10 láº§n (mÃ u Ä‘á»)
 * - [ ] Button "Reset Counters" Ä‘á»ƒ reset táº¥t cáº£ counts vá» 0
 * - [ ] Real-time update (khÃ´ng cáº§n reload page)
 * - [ ] Sáº¯p xáº¿p theo sá»‘ láº§n render (nhiá»u nháº¥t trÆ°á»›c)
 *
 * ğŸ¨ Technical Constraints:
 * - Sá»­ dá»¥ng Context Ä‘á»ƒ share render counts (optional, cÃ³ thá»ƒ dÃ¹ng props)
 * - Custom hook `useRenderTracking(componentName)` cho má»—i component
 * - Dashboard component tÃ¡ch biá»‡t, cÃ³ thá»ƒ toggle on/off
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Component unmount (nÃªn xÃ³a khá»i danh sÃ¡ch khÃ´ng?)
 * - Multiple instances cá»§a cÃ¹ng component name
 * - Performance cá»§a chÃ­nh dashboard (khÃ´ng Ä‘Æ°á»£c lÃ m cháº­m app!)
 */

// ğŸ¯ NHIá»†M Vá»¤:

// TODO 1: Create PerformanceTracker context
// Hint: Context.Provider value should contain:
// - renderCounts: { [componentName]: count }
// - trackRender: (name) => void
// - resetCounts: () => void

// TODO 2: Create useRenderTracking hook
// Hint:
// - Call trackRender in useEffect (má»—i láº§n render)
// - Return nothing hoáº·c render count

// TODO 3: Create PerformanceDashboard component
// Requirements:
// - List all components with render counts
// - Sort by count (descending)
// - Highlight if count > 10
// - Reset button

// TODO 4: Test vá»›i app cÃ³ multiple components
// Create test app with:
// - Counter component (updates frequently)
// - Display component (updates less frequently)
// - Static component (rarely updates)

// ğŸ“ Starter Code:

import { createContext, useState, useContext, useEffect, useRef } from 'react';

// TODO: Implement PerformanceContext
const PerformanceContext = createContext(null);

export function PerformanceProvider({ children }) {
  // Your code here
  return (
    <PerformanceContext.Provider value={/* ... */}>
      {children}
    </PerformanceContext.Provider>
  );
}

// TODO: Implement useRenderTracking hook
export function useRenderTracking(componentName) {
  // Your code here
}

// TODO: Implement PerformanceDashboard
export function PerformanceDashboard() {
  // Your code here
}

// TODO: Test components
function CounterComponent() {
  useRenderTracking('Counter');
  const [count, setCount] = useState(0);

  return (
    <div>
      <h3>Counter: {count}</h3>
      <button onClick={() => setCount(c => c + 1)}>+1</button>
    </div>
  );
}

function DisplayComponent({ value }) {
  useRenderTracking('Display');
  return <div>Display: {value}</div>;
}

function StaticComponent() {
  useRenderTracking('Static');
  return <div>I am static</div>;
}

export function TestApp() {
  const [globalCount, setGlobalCount] = useState(0);

  return (
    <PerformanceProvider>
      <div>
        <PerformanceDashboard />
        <hr />
        <CounterComponent />
        <DisplayComponent value={globalCount} />
        <StaticComponent />
        <button onClick={() => setGlobalCount(c => c + 1)}>
          Update Global
        </button>
      </div>
    </PerformanceProvider>
  );
}
```

<details>
<summary>âœ… Solution</summary>

```jsx
// PerformanceTracker.jsx
import { createContext, useState, useContext, useEffect, useRef } from 'react';

// Performance Context
const PerformanceContext = createContext(null);

export function PerformanceProvider({ children }) {
  const [renderCounts, setRenderCounts] = useState({});

  const trackRender = (componentName) => {
    setRenderCounts((prev) => ({
      ...prev,
      [componentName]: (prev[componentName] || 0) + 1,
    }));
  };

  const resetCounts = () => {
    setRenderCounts({});
  };

  return (
    <PerformanceContext.Provider
      value={{ renderCounts, trackRender, resetCounts }}
    >
      {children}
    </PerformanceContext.Provider>
  );
}

// Custom hook
export function useRenderTracking(componentName) {
  const context = useContext(PerformanceContext);
  const renderCount = useRef(0);

  useEffect(() => {
    renderCount.current += 1;

    if (context) {
      context.trackRender(componentName);
    } else {
      console.warn(
        `Component "${componentName}" tracked but no PerformanceProvider found`,
      );
    }
  });

  return renderCount.current;
}

// Dashboard Component
export function PerformanceDashboard() {
  const { renderCounts, resetCounts } = useContext(PerformanceContext);
  const [isVisible, setIsVisible] = useState(true);

  // Sort by render count (descending)
  const sortedComponents = Object.entries(renderCounts).sort(
    ([, countA], [, countB]) => countB - countA,
  );

  if (!isVisible) {
    return (
      <button onClick={() => setIsVisible(true)}>
        Show Performance Dashboard
      </button>
    );
  }

  return (
    <div
      style={{
        position: 'fixed',
        top: '10px',
        right: '10px',
        background: 'white',
        border: '2px solid #333',
        borderRadius: '8px',
        padding: '15px',
        maxWidth: '300px',
        maxHeight: '400px',
        overflow: 'auto',
        boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
        zIndex: 9999,
      }}
    >
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '10px',
        }}
      >
        <h3 style={{ margin: 0, fontSize: '16px' }}>
          ğŸ¯ Performance Dashboard
        </h3>
        <button
          onClick={() => setIsVisible(false)}
          style={{
            background: 'none',
            border: 'none',
            cursor: 'pointer',
            fontSize: '18px',
          }}
        >
          âœ•
        </button>
      </div>

      <button
        onClick={resetCounts}
        style={{
          width: '100%',
          padding: '8px',
          marginBottom: '10px',
          cursor: 'pointer',
          borderRadius: '4px',
        }}
      >
        ğŸ”„ Reset Counters
      </button>

      {sortedComponents.length === 0 ? (
        <p style={{ color: '#666', fontSize: '14px' }}>
          No renders tracked yet
        </p>
      ) : (
        <div>
          {sortedComponents.map(([name, count]) => (
            <div
              key={name}
              style={{
                padding: '8px',
                marginBottom: '5px',
                borderRadius: '4px',
                background: count > 10 ? '#ffebee' : '#f5f5f5',
                border: count > 10 ? '1px solid #ef5350' : '1px solid #ddd',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
              }}
            >
              <span style={{ fontSize: '14px' }}>
                {name}
                {count > 10 && ' ğŸ”¥'}
              </span>
              <span
                style={{
                  fontWeight: 'bold',
                  fontSize: '14px',
                  color: count > 10 ? '#c62828' : '#333',
                }}
              >
                {count}
              </span>
            </div>
          ))}
        </div>
      )}

      <div
        style={{
          marginTop: '10px',
          paddingTop: '10px',
          borderTop: '1px solid #ddd',
          fontSize: '12px',
          color: '#666',
        }}
      >
        <div>Total components: {sortedComponents.length}</div>
        <div>
          Total renders:{' '}
          {Object.values(renderCounts).reduce((a, b) => a + b, 0)}
        </div>
      </div>
    </div>
  );
}

// Test Components
function CounterComponent() {
  useRenderTracking('Counter');
  const [count, setCount] = useState(0);

  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px' }}>
      <h3>Counter Component</h3>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
    </div>
  );
}

function DisplayComponent({ value }) {
  useRenderTracking('Display');

  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px' }}>
      <h3>Display Component</h3>
      <p>Value: {value}</p>
    </div>
  );
}

function StaticComponent() {
  useRenderTracking('Static');

  return (
    <div style={{ border: '1px solid #ccc', padding: '10px', margin: '10px' }}>
      <h3>Static Component</h3>
      <p>I rarely update</p>
    </div>
  );
}

// Test App
export function TestApp() {
  const [globalCount, setGlobalCount] = useState(0);

  return (
    <PerformanceProvider>
      <div style={{ padding: '20px', paddingRight: '350px' }}>
        <h1>Performance Tracking Demo</h1>

        <PerformanceDashboard />

        <div style={{ marginTop: '20px' }}>
          <button
            onClick={() => setGlobalCount((c) => c + 1)}
            style={{ padding: '10px 20px', fontSize: '16px' }}
          >
            Update Global Count: {globalCount}
          </button>
        </div>

        <CounterComponent />
        <DisplayComponent value={globalCount} />
        <StaticComponent />
      </div>
    </PerformanceProvider>
  );
}

export default TestApp;
```

**ğŸ’¡ Key Concepts:**

1. **Context for Global State:**

```jsx
// Táº¥t cáº£ components share same render tracking state
// KhÃ´ng cáº§n props drilling
```

2. **useEffect without deps:**

```jsx
useEffect(() => {
  // Runs on EVERY render - perfect for tracking!
  trackRender(componentName);
});
```

3. **Sorting & Highlighting:**

```jsx
// Sort Ä‘á»ƒ tháº¥y components render nhiá»u nháº¥t
const sorted = Object.entries(counts)
  .sort(([, a], [, b]) => b - a);

// Highlight náº¿u > threshold
style={{ background: count > 10 ? 'red' : 'white' }}
```

**ğŸ“Š Expected Behavior:**

```
Click "Increment" in Counter 15 times:
â”œâ”€ Counter: 16 renders (initial + 15) ğŸ”¥
â”œâ”€ Display: 1 render (khÃ´ng Ä‘á»•i)
â””â”€ Static: 1 render (khÃ´ng Ä‘á»•i)

Click "Update Global" 5 times:
â”œâ”€ Counter: 16 renders (khÃ´ng Ä‘á»•i)
â”œâ”€ Display: 6 renders (initial + 5)
â””â”€ Static: 6 renders (parent renders) â† Unnecessary!
```

</details>

---

### â­â­â­â­ BÃ i 4: Render Optimization Decision Tree (60 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** PhÃ¢n tÃ­ch codebase vÃ  quyáº¿t Ä‘á»‹nh optimization strategy

**â±ï¸ Thá»i gian:** 60 phÃºt

```jsx
/**
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Báº¡n Ä‘Æ°á»£c giao má»™t E-commerce product page:
 * - Header: Logo, search, cart (static)
 * - ProductGallery: 5 images vá»›i thumbnails
 * - ProductInfo: Name, price, description
 * - Reviews: List of 50 customer reviews
 * - RecommendedProducts: 10 related products
 *
 * User actions:
 * - Click thumbnail â†’ Change main image
 * - Click "Add to Cart" â†’ Update cart count
 * - Scroll reviews â†’ Load more
 *
 * Nhiá»‡m vá»¥:
 * 1. Váº½ component tree
 * 2. Identify which components render when:
 *    a. User clicks thumbnail
 *    b. User adds to cart
 *    c. User loads more reviews
 * 3. List unnecessary re-renders
 * 4. Propose optimization strategy (chá»‰ describe, chÆ°a code)
 *
 * ADR Template:
 *
 * ## Context
 * - Current performance issue: [MÃ´ táº£]
 * - Impact: [Users experience...]
 * - Measurement: [Current render counts...]
 *
 * ## Decision
 * - Components to optimize: [List]
 * - Techniques to apply: [React.memo, useMemo, useCallback]
 *
 * ## Rationale
 * Why optimize these specific components:
 * 1. [Component A]: Because...
 * 2. [Component B]: Because...
 *
 * ## Consequences
 * Accepted trade-offs:
 * - More complex code (memoization logic)
 * - Slightly more memory (memoized values)
 * - Better UX (faster interactions)
 *
 * ## Alternatives Considered
 * - Option 1: [Describe]
 *   Pros: ...
 *   Cons: ...
 * - Option 2: [Describe]
 *   Pros: ...
 *   Cons: ...
 */

// ğŸ’» PHASE 2: Implementation (30 phÃºt)

// Current implementation (cÃ³ performance issues):

function ProductPage() {
  const [selectedImage, setSelectedImage] = useState(0);
  const [cartCount, setCartCount] = useState(0);
  const [reviewPage, setReviewPage] = useState(1);

  const product = {
    name: 'Premium Headphones',
    price: 299,
    description: 'High-quality wireless headphones...',
    images: [
      /* 5 image URLs */
    ],
    reviews: [
      /* 50 reviews */
    ],
  };

  const relatedProducts = [
    /* 10 products */
  ];

  const handleAddToCart = () => {
    setCartCount((prev) => prev + 1);
    // API call...
  };

  const loadMoreReviews = () => {
    setReviewPage((prev) => prev + 1);
    // Fetch more reviews...
  };

  return (
    <div>
      <Header cartCount={cartCount} />

      <ProductGallery
        images={product.images}
        selectedIndex={selectedImage}
        onSelectImage={setSelectedImage}
      />

      <ProductInfo
        name={product.name}
        price={product.price}
        description={product.description}
        onAddToCart={handleAddToCart}
      />

      <Reviews
        reviews={product.reviews}
        page={reviewPage}
        onLoadMore={loadMoreReviews}
      />

      <RecommendedProducts products={relatedProducts} />
    </div>
  );
}

function Header({ cartCount }) {
  console.log('Header rendered');
  return (
    <header>
      <Logo />
      <SearchBar />
      <CartIcon count={cartCount} />
    </header>
  );
}

function Logo() {
  console.log('Logo rendered');
  return (
    <img
      src='/logo.png'
      alt='Logo'
    />
  );
}

function SearchBar() {
  console.log('SearchBar rendered');
  const [query, setQuery] = useState('');
  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
    />
  );
}

function CartIcon({ count }) {
  console.log('CartIcon rendered');
  return <div>ğŸ›’ {count}</div>;
}

function ProductGallery({ images, selectedIndex, onSelectImage }) {
  console.log('ProductGallery rendered');
  return (
    <div>
      <MainImage src={images[selectedIndex]} />
      <Thumbnails
        images={images}
        selectedIndex={selectedIndex}
        onSelect={onSelectImage}
      />
    </div>
  );
}

function MainImage({ src }) {
  console.log('MainImage rendered');
  return (
    <img
      src={src}
      alt='Product'
      style={{ width: '500px' }}
    />
  );
}

function Thumbnails({ images, selectedIndex, onSelect }) {
  console.log('Thumbnails rendered');
  return (
    <div>
      {images.map((img, index) => (
        <Thumbnail
          key={index}
          src={img}
          isSelected={index === selectedIndex}
          onClick={() => onSelect(index)}
        />
      ))}
    </div>
  );
}

function Thumbnail({ src, isSelected, onClick }) {
  console.log('Thumbnail rendered:', src);
  return (
    <img
      src={src}
      alt='Thumbnail'
      style={{
        width: '100px',
        border: isSelected ? '2px solid blue' : 'none',
        cursor: 'pointer',
      }}
      onClick={onClick}
    />
  );
}

function ProductInfo({ name, price, description, onAddToCart }) {
  console.log('ProductInfo rendered');
  return (
    <div>
      <h1>{name}</h1>
      <p>${price}</p>
      <p>{description}</p>
      <button onClick={onAddToCart}>Add to Cart</button>
    </div>
  );
}

function Reviews({ reviews, page, onLoadMore }) {
  console.log('Reviews rendered');
  const displayedReviews = reviews.slice(0, page * 10);

  return (
    <div>
      <h2>Customer Reviews</h2>
      {displayedReviews.map((review) => (
        <ReviewItem
          key={review.id}
          review={review}
        />
      ))}
      {displayedReviews.length < reviews.length && (
        <button onClick={onLoadMore}>Load More</button>
      )}
    </div>
  );
}

function ReviewItem({ review }) {
  console.log('ReviewItem rendered:', review.id);
  return (
    <div>
      <strong>{review.author}</strong>
      <p>{review.text}</p>
      <div>Rating: {'â­'.repeat(review.rating)}</div>
    </div>
  );
}

function RecommendedProducts({ products }) {
  console.log('RecommendedProducts rendered');
  return (
    <div>
      <h2>You May Also Like</h2>
      {products.map((product) => (
        <ProductCard
          key={product.id}
          product={product}
        />
      ))}
    </div>
  );
}

function ProductCard({ product }) {
  console.log('ProductCard rendered:', product.id);
  return (
    <div>
      <img
        src={product.image}
        alt={product.name}
      />
      <h3>{product.name}</h3>
      <p>${product.price}</p>
    </div>
  );
}

/**
 * ğŸ¯ NHIá»†M Vá»¤:
 *
 * 1. Sá»­ dá»¥ng useRenderTracking cho táº¥t cáº£ components
 * 2. Test 3 scenarios vÃ  ghi láº¡i sá»‘ láº§n render:
 *    - Scenario A: Click 5 thumbnails
 *    - Scenario B: Add to cart 3 times
 *    - Scenario C: Load more reviews 2 times
 * 3. Identify top 5 components vá»›i unnecessary renders
 * 4. Viáº¿t optimization plan (sáº½ implement ngÃ y mai):
 *    - Which components cáº§n React.memo?
 *    - Which values cáº§n useMemo?
 *    - Which callbacks cáº§n useCallback?
 */

// ğŸ§ª PHASE 3: Testing (10 phÃºt)
// Test vá»›i React DevTools Profiler vÃ  verify:
// - [ ] Identified all unnecessary renders
// - [ ] Prioritized optimizations by impact
// - [ ] Documented expected improvements
```

<details>
<summary>âœ… Solution & Analysis</summary>

**ğŸ“Š PHASE 1: Analysis Results**

**Component Tree:**

```
ProductPage
â”œâ”€â”€ Header
â”‚   â”œâ”€â”€ Logo
â”‚   â”œâ”€â”€ SearchBar
â”‚   â””â”€â”€ CartIcon
â”œâ”€â”€ ProductGallery
â”‚   â”œâ”€â”€ MainImage
â”‚   â””â”€â”€ Thumbnails
â”‚       â””â”€â”€ Thumbnail Ã— 5
â”œâ”€â”€ ProductInfo
â”œâ”€â”€ Reviews
â”‚   â””â”€â”€ ReviewItem Ã— (page * 10)
â””â”€â”€ RecommendedProducts
    â””â”€â”€ ProductCard Ã— 10
```

**Render Analysis:**

**Scenario A: Click thumbnail (5 times)**

```
Click thumbnail 1:
âœ… ProductPage (state: selectedImage)
âœ… ProductGallery (props: selectedIndex changed)
âœ… MainImage (props: src changed)
âœ… Thumbnails (props: selectedIndex changed)
âœ… Thumbnail Ã— 5 (props: isSelected changed for 2 items)

âŒ Header (parent renders) - UNNECESSARY!
âŒ Logo (parent renders) - UNNECESSARY!
âŒ SearchBar (parent renders) - UNNECESSARY!
âŒ CartIcon (props unchanged) - UNNECESSARY!
âŒ ProductInfo (props unchanged) - UNNECESSARY!
âŒ Reviews (props unchanged) - UNNECESSARY!
âŒ ReviewItem Ã— N (parent renders) - UNNECESSARY!
âŒ RecommendedProducts (props unchanged) - UNNECESSARY!
âŒ ProductCard Ã— 10 (parent renders) - UNNECESSARY!

Total: ~30 renders
Necessary: ~7 renders
Wasted: ~23 renders (77%)!
```

**Scenario B: Add to cart (3 times)**

```
Click "Add to Cart":
âœ… ProductPage (state: cartCount)
âœ… Header (props: cartCount changed)
âœ… CartIcon (props: count changed)

âŒ Logo (parent renders) - UNNECESSARY!
âŒ SearchBar (parent renders) - UNNECESSARY!
âŒ ProductGallery (props unchanged) - UNNECESSARY!
âŒ MainImage (parent renders) - UNNECESSARY!
âŒ Thumbnails (parent renders) - UNNECESSARY!
âŒ Thumbnail Ã— 5 (parent renders) - UNNECESSARY!
âŒ ProductInfo (props unchanged but onAddToCart is NEW function!) - UNNECESSARY!
âŒ Reviews - UNNECESSARY!
âŒ RecommendedProducts - UNNECESSARY!

Total: ~25 renders
Necessary: ~3 renders
Wasted: ~22 renders (88%)!
```

**Scenario C: Load more reviews (2 times)**

```
Click "Load More":
âœ… ProductPage (state: reviewPage)
âœ… Reviews (props: page changed)
âœ… ReviewItem Ã— 10 (NEW items added)

âŒ ALL other components - UNNECESSARY!

Total: ~30 renders
Necessary: ~12 renders
Wasted: ~18 renders (60%)
```

**ADR (Architecture Decision Record):**

````markdown
# ADR-001: Product Page Performance Optimization

## Context

Current State:

- Product page renders 25-30 components on EVERY state change
- 60-88% of renders are unnecessary (components with unchanged props)
- User interactions feel sluggish (>100ms response time)
- Particularly bad when clicking thumbnails repeatedly

Impact:

- Poor UX on mobile devices (limited CPU)
- High battery consumption
- Frustrated users (reported in support tickets)

Measurements:

- Thumbnail click: 23/30 renders wasted (77%)
- Add to cart: 22/25 renders wasted (88%)
- Load reviews: 18/30 renders wasted (60%)
- Average: 21/28 renders wasted (75%)

## Decision

We will implement selective memoization using:

1. React.memo for leaf components
2. useMemo for expensive computations
3. useCallback for event handlers passed to memoized children

Priority Order (by impact):

1. HIGH: Memo components with many children (Header, ProductGallery, Reviews)
2. MEDIUM: Memo leaf components (Logo, ReviewItem, ProductCard)
3. LOW: Memoize callbacks and computed values

## Rationale

**Components to Optimize:**

1. **Header + children (HIGH)**
   - Why: 4 components render on EVERY action
   - Impact: cartCount only changes occasionally
   - Solution: React.memo on Header, Logo, SearchBar

2. **ProductGallery + Thumbnails (HIGH)**
   - Why: 7 components render when cart/reviews update
   - Impact: Expensive image rendering
   - Solution: React.memo + useCallback for onSelectImage

3. **Reviews + ReviewItem Ã— N (HIGH)**
   - Why: All N items re-render on unrelated actions
   - Impact: N can be 50+ (expensive!)
   - Solution: React.memo on ReviewItem

4. **RecommendedProducts + Cards (MEDIUM)**
   - Why: 11 components always re-render
   - Impact: Less critical (below fold)
   - Solution: React.memo on both

5. **ProductInfo (LOW)**
   - Why: Simple component, cheap to render
   - Impact: Minimal performance gain
   - Solution: Maybe skip or useCallback for button

**NOT Optimizing:**

- ProductPage: Must render (state holder)
- MainImage: Props actually change
- CartIcon: Props actually change

## Consequences

**Accepted Trade-offs:**

âœ… Pros:

- 75% reduction in wasted renders (21 â†’ ~5 renders)
- Faster user interactions (<16ms response)
- Better mobile performance
- Improved user satisfaction

âŒ Cons:

- Slightly more complex code (memo wrappers)
- Need to maintain callback stability (useCallback)
- More memory usage (memoized values)
- Developer must understand memoization

**Risks Mitigated:**

- Over-optimization: Only memo components that actually re-render unnecessarily
- Premature optimization: Have measurements first
- Incorrect deps: Will use ESLint exhaustive-deps

## Alternatives Considered

**Option 1: Component Splitting**

```jsx
// Split ProductPage into multiple state containers
function ProductPage() {
  return (
    <>
      <GalleryContainer />
      <CartContainer />
      <ReviewsContainer />
    </>
  );
}
```
````

Pros:

- Isolates state changes
- No memoization needed
  Cons:
- Need Context for shared state
- More boilerplate
- Harder to understand data flow

**Decision:** Rejected. Too much refactoring for this page.

**Option 2: Virtual Scrolling for Reviews**

```jsx
// Use react-window for long lists
import { FixedSizeList } from 'react-window';
```

Pros:

- Only renders visible items
- Great for very long lists
  Cons:
- External dependency
- Overkill for 50 items
- More complex implementation

**Decision:** Consider for future if reviews > 100.

**Option 3: No Optimization**

```
Do nothing, accept current performance
```

Pros:

- Simplest code
- No maintenance burden
  Cons:
- Poor UX
- User complaints
- Competitive disadvantage

**Decision:** Rejected. Must optimize.

## Implementation Plan

**Phase 1 (Day 32):** Learn React.memo

- Implement on simple components (Logo, CartIcon)
- Verify with DevTools Profiler

**Phase 2 (Day 33):** Learn useMemo

- Optimize expensive computations
- Reviews pagination calculation

**Phase 3 (Day 34):** Learn useCallback

- Stabilize event handlers
- Apply to all memoized components

**Phase 4 (Day 35):** Integration

- Apply all optimizations to ProductPage
- Measure improvements
- Document lessons learned

## Success Metrics

Before:

- Avg renders per action: 28
- Wasted renders: 21 (75%)
- Response time: 120ms

Target After:

- Avg renders per action: 7
- Wasted renders: <2 (< 30%)
- Response time: <16ms

## Status

- [x] Analysis completed (Day 31)
- [ ] React.memo learned (Day 32)
- [ ] useMemo learned (Day 33)
- [ ] useCallback learned (Day 34)
- [ ] Full optimization (Day 35)

````

**ğŸ“ Optimization Plan Summary:**

```jsx
// HIGH PRIORITY

// 1. Header tree
const Header = React.memo(({ cartCount }) => { /* ... */ });
const Logo = React.memo(() => { /* ... */ });
const SearchBar = React.memo(() => { /* ... */ });

// 2. Gallery tree
const ProductGallery = React.memo(({ images, selectedIndex, onSelectImage }) => {
  // onSelectImage MUST be stable (useCallback)
});
const Thumbnail = React.memo(({ src, isSelected, onClick }) => {
  // onClick MUST be stable
});

// 3. Reviews tree
const Reviews = React.memo(({ reviews, page, onLoadMore }) => {
  // displayedReviews should use useMemo
  const displayedReviews = useMemo(
    () => reviews.slice(0, page * 10),
    [reviews, page]
  );
});
const ReviewItem = React.memo(({ review }) => { /* ... */ });

// MEDIUM PRIORITY

// 4. Recommended products
const RecommendedProducts = React.memo(({ products }) => { /* ... */ });
const ProductCard = React.memo(({ product }) => { /* ... */ });

// IN ProductPage:

// Stable callbacks
const handleAddToCart = useCallback(() => {
  setCartCount(prev => prev + 1);
}, []);

const handleSelectImage = useCallback((index) => {
  setSelectedImage(index);
}, []);

const loadMoreReviews = useCallback(() => {
  setReviewPage(prev => prev + 1);
}, []);
````

**Expected Improvements:**

```
After Optimization:

Scenario A (Click thumbnail):
â”œâ”€ ProductPage (necessary)
â”œâ”€ ProductGallery (necessary)
â”œâ”€ MainImage (necessary)
â”œâ”€ Thumbnails (necessary)
â”œâ”€ Thumbnail Ã— 2 (only changed ones)
â””â”€ Total: 6 renders (was 30) - 80% reduction!

Scenario B (Add to cart):
â”œâ”€ ProductPage (necessary)
â”œâ”€ Header (necessary)
â”œâ”€ CartIcon (necessary)
â””â”€ Total: 3 renders (was 25) - 88% reduction!

Scenario C (Load reviews):
â”œâ”€ ProductPage (necessary)
â”œâ”€ Reviews (necessary)
â”œâ”€ ReviewItem Ã— 10 (new items)
â””â”€ Total: 12 renders (was 30) - 60% reduction!

Overall: 7 average renders (was 28) - 75% reduction!
```

</details>

---

### â­â­â­â­â­ BÃ i 5: Production-Ready Render Performance Monitor (90 phÃºt)

**ğŸ¯ Má»¥c tiÃªu:** XÃ¢y dá»±ng cÃ´ng cá»¥ monitoring cÃ³ thá»ƒ dÃ¹ng trong production

**â±ï¸ Thá»i gian:** 90 phÃºt

```jsx
/**
 * ğŸ“‹ Feature Specification:
 *
 * Build a developer tool that:
 * 1. Tracks render performance in development
 * 2. Can be toggled on/off via keyboard shortcut
 * 3. Shows real-time metrics
 * 4. Exports performance report
 * 5. Warns about performance issues
 *
 * Requirements:
 * - Minimal performance impact (< 1ms overhead)
 * - Only active in development mode
 * - Persist settings to localStorage
 * - Keyboard shortcuts (Ctrl+Shift+P to toggle)
 * - Export to JSON/CSV
 */

// ğŸ—ï¸ Technical Design Doc:

/**
 * 1. Component Architecture:
 *
 * PerformanceMonitor (root)
 * â”œâ”€â”€ MonitorProvider (context)
 * â”œâ”€â”€ MonitorDashboard (UI)
 * â”‚   â”œâ”€â”€ MetricsPanel
 * â”‚   â”œâ”€â”€ ComponentList
 * â”‚   â”œâ”€â”€ WarningsPanel
 * â”‚   â””â”€â”€ ExportButton
 * â””â”€â”€ usePerformanceTracking (hook)
 *
 * 2. State Management:
 *
 * State structure:
 * {
 *   isEnabled: boolean,
 *   metrics: {
 *     [componentName]: {
 *       renderCount: number,
 *       totalTime: number,
 *       avgTime: number,
 *       lastRenderTime: number,
 *       firstRender: timestamp,
 *       lastRender: timestamp
 *     }
 *   },
 *   warnings: Array<{
 *     componentName: string,
 *     type: 'high_count' | 'slow_render',
 *     value: number,
 *     timestamp: timestamp
 *   }>
 * }
 *
 * 3. Performance Thresholds:
 *
 * - HIGH_RENDER_COUNT: 10 renders
 * - SLOW_RENDER_TIME: 16ms
 * - WARNING_RETENTION: 50 warnings max
 *
 * 4. Features:
 *
 * âœ… Real-time tracking
 * âœ… Keyboard toggle (Ctrl+Shift+P)
 * âœ… Performance warnings
 * âœ… Export to JSON/CSV
 * âœ… LocalStorage persistence
 * âœ… Dev-only mode
 *
 * 5. Edge Cases:
 *
 * - Component unmount â†’ Keep data or clear?
 * - Very fast renders (< 1ms) â†’ Still track
 * - Many warnings â†’ Limit to 50, FIFO
 * - localStorage full â†’ Graceful degradation
 * - Production build â†’ Completely disabled
 */

// âœ… Production Checklist:

/**
 * - [ ] TypeScript types complete
 * - [ ] Unit tests (coverage > 80%)
 * - [ ] Integration tests
 * - [ ] Error boundaries
 * - [ ] Loading states (N/A for this feature)
 * - [ ] Error states (localStorage failure)
 * - [ ] A11y: Keyboard navigation, ARIA labels
 * - [ ] Performance: < 1ms overhead
 * - [ ] SEO: N/A
 * - [ ] Security: No sensitive data logged
 * - [ ] Mobile responsive
 * - [ ] Cross-browser (Chrome, Firefox, Safari)
 */

// ğŸ¯ IMPLEMENTATION:

// TODO 1: MonitorContext vá»›i advanced state management
// TODO 2: Performance measuring vá»›i high-precision timing
// TODO 3: Warning system vá»›i thresholds
// TODO 4: Export functionality (JSON + CSV)
// TODO 5: Keyboard shortcuts
// TODO 6: localStorage persistence
// TODO 7: Production guard (process.env.NODE_ENV)

// Starter code provided below...
```

<details>
<summary>ğŸ“ Full Implementation Code</summary>

```jsx
// PerformanceMonitor.jsx
import {
  createContext,
  useContext,
  useState,
  useEffect,
  useRef,
  useCallback,
} from 'react';

// ============================================
// CONSTANTS & TYPES
// ============================================

const THRESHOLDS = {
  HIGH_RENDER_COUNT: 10,
  SLOW_RENDER_TIME: 16, // ms
  WARNING_RETENTION: 50,
};

const STORAGE_KEY = 'react-performance-monitor';

const IS_DEV = process.env.NODE_ENV === 'development';

// ============================================
// CONTEXT
// ============================================

const MonitorContext = createContext(null);

export function PerformanceMonitorProvider({ children }) {
  const [isEnabled, setIsEnabled] = useState(() => {
    if (!IS_DEV) return false;
    try {
      const stored = localStorage.getItem(STORAGE_KEY);
      return stored ? JSON.parse(stored).isEnabled : false;
    } catch {
      return false;
    }
  });

  const [metrics, setMetrics] = useState({});
  const [warnings, setWarnings] = useState([]);

  // Persist enabled state
  useEffect(() => {
    if (!IS_DEV) return;
    try {
      localStorage.setItem(
        STORAGE_KEY,
        JSON.stringify({ isEnabled, timestamp: Date.now() }),
      );
    } catch (err) {
      console.warn('Failed to persist monitor state:', err);
    }
  }, [isEnabled]);

  // Keyboard shortcut: Ctrl+Shift+P
  useEffect(() => {
    if (!IS_DEV) return;

    const handleKeyDown = (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'P') {
        e.preventDefault();
        setIsEnabled((prev) => !prev);
        console.log('ğŸ¯ Performance Monitor:', !isEnabled ? 'ON' : 'OFF');
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isEnabled]);

  const trackRender = useCallback(
    (componentName, renderTime) => {
      if (!isEnabled) return;

      setMetrics((prev) => {
        const existing = prev[componentName] || {
          renderCount: 0,
          totalTime: 0,
          avgTime: 0,
          lastRenderTime: 0,
          firstRender: Date.now(),
          lastRender: Date.now(),
        };

        const newCount = existing.renderCount + 1;
        const newTotalTime = existing.totalTime + renderTime;
        const newAvgTime = newTotalTime / newCount;

        // Check for warnings
        if (newCount > THRESHOLDS.HIGH_RENDER_COUNT) {
          setWarnings((prevWarnings) => {
            const newWarning = {
              componentName,
              type: 'high_count',
              value: newCount,
              timestamp: Date.now(),
            };

            const updated = [...prevWarnings, newWarning];
            return updated.slice(-THRESHOLDS.WARNING_RETENTION);
          });
        }

        if (renderTime > THRESHOLDS.SLOW_RENDER_TIME) {
          setWarnings((prevWarnings) => {
            const newWarning = {
              componentName,
              type: 'slow_render',
              value: renderTime,
              timestamp: Date.now(),
            };

            const updated = [...prevWarnings, newWarning];
            return updated.slice(-THRESHOLDS.WARNING_RETENTION);
          });
        }

        return {
          ...prev,
          [componentName]: {
            renderCount: newCount,
            totalTime: newTotalTime,
            avgTime: newAvgTime,
            lastRenderTime: renderTime,
            firstRender: existing.firstRender,
            lastRender: Date.now(),
          },
        };
      });
    },
    [isEnabled],
  );

  const resetMetrics = useCallback(() => {
    setMetrics({});
    setWarnings([]);
  }, []);

  const exportData = useCallback(
    (format = 'json') => {
      const data = {
        exportedAt: new Date().toISOString(),
        metrics,
        warnings,
        summary: {
          totalComponents: Object.keys(metrics).length,
          totalRenders: Object.values(metrics).reduce(
            (sum, m) => sum + m.renderCount,
            0,
          ),
          totalWarnings: warnings.length,
        },
      };

      if (format === 'json') {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: 'application/json',
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `performance-report-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      } else if (format === 'csv') {
        const rows = [
          [
            'Component',
            'Renders',
            'Avg Time (ms)',
            'Total Time (ms)',
            'Last Render (ms)',
          ],
          ...Object.entries(metrics).map(([name, m]) => [
            name,
            m.renderCount,
            m.avgTime.toFixed(2),
            m.totalTime.toFixed(2),
            m.lastRenderTime.toFixed(2),
          ]),
        ];

        const csv = rows.map((row) => row.join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `performance-report-${Date.now()}.csv`;
        a.click();
        URL.revokeObjectURL(url);
      }
    },
    [metrics, warnings],
  );

  const value = {
    isEnabled,
    setIsEnabled,
    metrics,
    warnings,
    trackRender,
    resetMetrics,
    exportData,
  };

  return (
    <MonitorContext.Provider value={value}>{children}</MonitorContext.Provider>
  );
}

// ============================================
// HOOK
// ============================================

export function usePerformanceTracking(componentName) {
  const context = useContext(MonitorContext);
  const startTimeRef = useRef(0);

  useEffect(() => {
    if (!IS_DEV || !context || !context.isEnabled) return;

    // Measure render time
    const renderTime = performance.now() - startTimeRef.current;
    context.trackRender(componentName, renderTime);
  });

  // Record start time BEFORE render
  startTimeRef.current = performance.now();
}

// ============================================
// DASHBOARD COMPONENT
// ============================================

export function PerformanceMonitorDashboard() {
  const context = useContext(MonitorContext);

  if (!IS_DEV || !context) {
    return null;
  }

  const {
    isEnabled,
    setIsEnabled,
    metrics,
    warnings,
    resetMetrics,
    exportData,
  } = context;

  const [isVisible, setIsVisible] = useState(true);

  if (!isEnabled) {
    return (
      <div
        style={{
          position: 'fixed',
          bottom: '20px',
          right: '20px',
          zIndex: 9999,
        }}
      >
        <button
          onClick={() => setIsEnabled(true)}
          style={{
            padding: '10px 15px',
            background: '#333',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '14px',
          }}
        >
          ğŸ¯ Enable Monitor (Ctrl+Shift+P)
        </button>
      </div>
    );
  }

  if (!isVisible) {
    return (
      <div
        style={{
          position: 'fixed',
          bottom: '20px',
          right: '20px',
          zIndex: 9999,
        }}
      >
        <button
          onClick={() => setIsVisible(true)}
          style={{
            padding: '10px 15px',
            background: '#4caf50',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '14px',
          }}
        >
          ğŸ“Š Show Dashboard
        </button>
      </div>
    );
  }

  const sortedMetrics = Object.entries(metrics).sort(
    ([, a], [, b]) => b.renderCount - a.renderCount,
  );

  const totalRenders = Object.values(metrics).reduce(
    (sum, m) => sum + m.renderCount,
    0,
  );

  const slowComponents = sortedMetrics.filter(
    ([, m]) => m.avgTime > THRESHOLDS.SLOW_RENDER_TIME,
  );

  const frequentComponents = sortedMetrics.filter(
    ([, m]) => m.renderCount > THRESHOLDS.HIGH_RENDER_COUNT,
  );

  return (
    <div
      style={{
        position: 'fixed',
        top: '20px',
        right: '20px',
        width: '400px',
        maxHeight: '80vh',
        overflow: 'auto',
        background: 'white',
        border: '2px solid #333',
        borderRadius: '8px',
        padding: '15px',
        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
        zIndex: 9999,
        fontFamily: 'monospace',
        fontSize: '13px',
      }}
    >
      {/* Header */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '15px',
          paddingBottom: '10px',
          borderBottom: '2px solid #eee',
        }}
      >
        <h3 style={{ margin: 0, fontSize: '16px' }}>ğŸ¯ Performance Monitor</h3>
        <div>
          <button
            onClick={() => setIsVisible(false)}
            style={{
              background: 'none',
              border: 'none',
              cursor: 'pointer',
              fontSize: '18px',
              marginLeft: '10px',
            }}
            title='Minimize'
          >
            â–
          </button>
          <button
            onClick={() => setIsEnabled(false)}
            style={{
              background: 'none',
              border: 'none',
              cursor: 'pointer',
              fontSize: '18px',
              marginLeft: '5px',
            }}
            title='Close (Ctrl+Shift+P)'
          >
            âœ•
          </button>
        </div>
      </div>

      {/* Summary */}
      <div
        style={{
          background: '#f5f5f5',
          padding: '10px',
          borderRadius: '4px',
          marginBottom: '15px',
        }}
      >
        <div
          style={{
            display: 'grid',
            gridTemplateColumns: '1fr 1fr',
            gap: '10px',
          }}
        >
          <div>
            <div style={{ color: '#666', fontSize: '11px' }}>
              Total Components
            </div>
            <div style={{ fontSize: '20px', fontWeight: 'bold' }}>
              {Object.keys(metrics).length}
            </div>
          </div>
          <div>
            <div style={{ color: '#666', fontSize: '11px' }}>Total Renders</div>
            <div style={{ fontSize: '20px', fontWeight: 'bold' }}>
              {totalRenders}
            </div>
          </div>
          <div>
            <div style={{ color: '#666', fontSize: '11px' }}>Warnings</div>
            <div
              style={{ fontSize: '20px', fontWeight: 'bold', color: '#f44336' }}
            >
              {warnings.length}
            </div>
          </div>
          <div>
            <div style={{ color: '#666', fontSize: '11px' }}>
              Slow Components
            </div>
            <div
              style={{ fontSize: '20px', fontWeight: 'bold', color: '#ff9800' }}
            >
              {slowComponents.length}
            </div>
          </div>
        </div>
      </div>

      {/* Warnings */}
      {warnings.length > 0 && (
        <div style={{ marginBottom: '15px' }}>
          <h4 style={{ margin: '0 0 10px 0', fontSize: '14px' }}>
            âš ï¸ Recent Warnings
          </h4>
          <div style={{ maxHeight: '150px', overflow: 'auto' }}>
            {warnings
              .slice(-5)
              .reverse()
              .map((warning, idx) => (
                <div
                  key={idx}
                  style={{
                    padding: '8px',
                    background:
                      warning.type === 'slow_render' ? '#fff3e0' : '#ffebee',
                    border: `1px solid ${warning.type === 'slow_render' ? '#ff9800' : '#f44336'}`,
                    borderRadius: '4px',
                    marginBottom: '5px',
                    fontSize: '12px',
                  }}
                >
                  <div style={{ fontWeight: 'bold' }}>
                    {warning.componentName}
                  </div>
                  <div style={{ color: '#666' }}>
                    {warning.type === 'slow_render'
                      ? `Slow render: ${warning.value.toFixed(2)}ms`
                      : `High count: ${warning.value} renders`}
                  </div>
                  <div style={{ color: '#999', fontSize: '11px' }}>
                    {new Date(warning.timestamp).toLocaleTimeString()}
                  </div>
                </div>
              ))}
          </div>
        </div>
      )}

      {/* Component List */}
      <div style={{ marginBottom: '15px' }}>
        <h4 style={{ margin: '0 0 10px 0', fontSize: '14px' }}>
          ğŸ“Š Components
        </h4>
        <div style={{ maxHeight: '300px', overflow: 'auto' }}>
          {sortedMetrics.map(([name, m]) => {
            const isWarning = m.renderCount > THRESHOLDS.HIGH_RENDER_COUNT;
            const isSlow = m.avgTime > THRESHOLDS.SLOW_RENDER_TIME;

            return (
              <div
                key={name}
                style={{
                  padding: '10px',
                  background: isWarning || isSlow ? '#fff3e0' : '#f9f9f9',
                  border: `1px solid ${isWarning || isSlow ? '#ff9800' : '#ddd'}`,
                  borderRadius: '4px',
                  marginBottom: '8px',
                }}
              >
                <div
                  style={{
                    display: 'flex',
                    justifyContent: 'space-between',
                    marginBottom: '5px',
                  }}
                >
                  <strong>{name}</strong>
                  <span style={{ color: isWarning ? '#f44336' : '#333' }}>
                    {m.renderCount} renders
                  </span>
                </div>
                <div
                  style={{
                    display: 'grid',
                    gridTemplateColumns: '1fr 1fr 1fr',
                    gap: '5px',
                    fontSize: '11px',
                    color: '#666',
                  }}
                >
                  <div>
                    Avg:{' '}
                    <strong style={{ color: isSlow ? '#ff9800' : '#333' }}>
                      {m.avgTime.toFixed(2)}ms
                    </strong>
                  </div>
                  <div>
                    Last: <strong>{m.lastRenderTime.toFixed(2)}ms</strong>
                  </div>
                  <div>
                    Total: <strong>{m.totalTime.toFixed(2)}ms</strong>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </div>

      {/* Actions */}
      <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>
        <button
          onClick={resetMetrics}
          style={{
            flex: 1,
            padding: '8px',
            background: '#f44336',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '12px',
          }}
        >
          ğŸ”„ Reset
        </button>
        <button
          onClick={() => exportData('json')}
          style={{
            flex: 1,
            padding: '8px',
            background: '#2196f3',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '12px',
          }}
        >
          ğŸ“¥ Export JSON
        </button>
        <button
          onClick={() => exportData('csv')}
          style={{
            flex: 1,
            padding: '8px',
            background: '#4caf50',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            fontSize: '12px',
          }}
        >
          ğŸ“Š Export CSV
        </button>
      </div>

      {/* Footer */}
      <div
        style={{
          marginTop: '15px',
          paddingTop: '10px',
          borderTop: '1px solid #eee',
          fontSize: '11px',
          color: '#999',
          textAlign: 'center',
        }}
      >
        Press <kbd>Ctrl+Shift+P</kbd> to toggle monitor
      </div>
    </div>
  );
}

// ============================================
// EXAMPLE USAGE
// ============================================

// In your app root:
/*
function App() {
  return (
    <PerformanceMonitorProvider>
      <YourApp />
      <PerformanceMonitorDashboard />
    </PerformanceMonitorProvider>
  );
}

// In components you want to track:
function MyComponent() {
  usePerformanceTracking('MyComponent');
  
  return <div>...</div>;
}
*/
```

**ğŸ“– Documentation (README.md):**

# React Performance Monitor

Production-ready performance monitoring tool for React applications.

## Installation

```jsx
// 1. Wrap your app
import {
  PerformanceMonitorProvider,
  PerformanceMonitorDashboard,
} from './PerformanceMonitor';

function App() {
  return (
    <PerformanceMonitorProvider>
      <YourApp />
      <PerformanceMonitorDashboard />
    </PerformanceMonitorProvider>
  );
}

// 2. Track components
import { usePerformanceTracking } from './PerformanceMonitor';

function MyComponent() {
  usePerformanceTracking('MyComponent');
  // ...
}
```

## Features

- âœ… Real-time render tracking
- âœ… Performance warnings (slow renders, high counts)
- âœ… Keyboard shortcut (Ctrl+Shift+P)
- âœ… Export to JSON/CSV
- âœ… localStorage persistence
- âœ… Development-only (zero production overhead)

## Keyboard Shortcuts

- `Ctrl+Shift+P` - Toggle monitor on/off

## Thresholds

- High render count: > 10 renders
- Slow render: > 16ms

## API

### `usePerformanceTracking(componentName: string)`

Track renders for a component.

```jsx
function MyComponent() {
  usePerformanceTracking('MyComponent');
  return <div>...</div>;
}
```

### Export Data

Click "Export JSON" or "Export CSV" to download performance report.

```json
{
  "exportedAt": "2024-03-15T10:30:00.000Z",
  "metrics": {
    "MyComponent": {
      "renderCount": 15,
      "totalTime": 240.5,
      "avgTime": 16.03,
      "lastRenderTime": 18.2
    }
  },
  "warnings": [...]
}

```

## Performance Impact

- Development: < 1ms overhead per render
- Production: 0ms (completely disabled)

## Browser Support

- Chrome âœ…
- Firefox âœ…
- Safari âœ…
- Edge âœ…

## Limitations

- Development mode only
- Requires `performance.now()` API
- localStorage for persistence (optional)

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Tracking Render Behavior

| Approach                        | Pros                                                                            | Cons                                                                      | When to Use                              |
| ------------------------------- | ------------------------------------------------------------------------------- | ------------------------------------------------------------------------- | ---------------------------------------- |
| **console.log trong component** | - ÄÆ¡n giáº£n nháº¥t<br>- KhÃ´ng cáº§n setup                                            | - Nhiá»u noise<br>- KhÃ³ theo dÃµi<br>- KhÃ´ng cÃ³ metrics                     | Quick debugging má»™t component            |
| **useRef counter**              | - Lightweight<br>- KhÃ´ng re-render<br>- Easy to implement                       | - Manual tracking<br>- KhÃ´ng cÃ³ visualization<br>- Má»—i component riÃªng láº» | Khi cáº§n Ä‘áº¿m renders cá»§a 1 component      |
| **React DevTools Profiler**     | - Built-in React<br>- Visual flamegraph<br>- Timeline view<br>- No code changes | - Chá»‰ khi DevTools má»Ÿ<br>- KhÃ´ng persist data<br>- KhÃ³ automate           | Development analysis, one-time profiling |
| **Custom Performance Monitor**  | - Programmable<br>- Persist data<br>- Export reports<br>- Automation friendly   | - Phá»©c táº¡p implement<br>- Overhead nhá»<br>- Maintenance burden            | Production-ready apps, CI/CD integration |

### Decision Tree: Chá»n Tracking Approach

```

START: Cáº§n track render performance
â”‚
â”œâ”€ Quick debug 1 component?
â”‚ â””â”€ YES â†’ console.log hoáº·c useRef counter
â”‚
â”œâ”€ Visual analysis 1 láº§n?
â”‚ â””â”€ YES â†’ React DevTools Profiler
â”‚
â”œâ”€ Continuous monitoring?
â”‚ â””â”€ YES â†’ Custom Performance Monitor
â”‚
â””â”€ Production monitoring?
â””â”€ YES â†’ Performance API + Analytics
(BÃ i há»c nÃ¢ng cao - khÃ´ng trong scope ngÃ y nÃ y)

```

### So SÃ¡nh: State Updates & Re-renders

| Trigger             | Component Re-renders       | Children Re-render       | DOM Updates                    |
| ------------------- | -------------------------- | ------------------------ | ------------------------------ |
| **useState update** | âœ… Always (unless bailout) | âœ… Always (default)      | âš ï¸ Only if Virtual DOM differs |
| **Props change**    | âœ… Always                  | âœ… Always                | âš ï¸ Only if Virtual DOM differs |
| **Parent renders**  | N/A                        | âœ… Always (default)      | âš ï¸ Only if Virtual DOM differs |
| **Context change**  | âœ… All consumers           | âœ… Children of consumers | âš ï¸ Only if Virtual DOM differs |
| **forceUpdate()**   | âœ… Always                  | âœ… Always                | âš ï¸ Only if Virtual DOM differs |

**ğŸ’¡ Key Insight:**

- Render â‰  DOM update
- React is smart about DOM (only updates what changed)
- Problem is JavaScript execution time, not DOM time!

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Infinite Render Loop ğŸ”¥

```jsx
function BuggyCounter() {
  const [count, setCount] = useState(0);
  const renderCount = useRef(0);

  // ğŸ› BUG: Táº¡i sao component re-render vÃ´ háº¡n?
  renderCount.current += 1;
  console.log('Render #', renderCount.current);

  if (renderCount.current > 5) {
    setCount(count + 1);
  }

  return <div>Count: {count}</div>;
}
```

**â“ CÃ¢u há»i:**

1. Component nÃ y render bao nhiÃªu láº§n?
2. Táº¡i sao infinite loop?
3. Fix nhÆ° tháº¿ nÃ o?

<details>
<summary>ğŸ” Debug Steps</summary>

**PhÃ¢n tÃ­ch:**

```jsx
Initial render:
â”œâ”€ renderCount.current = 1
â”œâ”€ count = 0
â””â”€ No setState

Render 2-5:
â”œâ”€ renderCount.current = 2, 3, 4, 5
â””â”€ No setState

Render 6:
â”œâ”€ renderCount.current = 6
â”œâ”€ Condition true (6 > 5)
â”œâ”€ setCount(0 + 1) â†’ count = 1
â””â”€ State change â†’ Re-render!

Render 7:
â”œâ”€ renderCount.current = 7
â”œâ”€ Condition true (7 > 5)
â”œâ”€ setCount(1 + 1) â†’ count = 2
â””â”€ State change â†’ Re-render!

Infinite loop! ğŸ”¥
```

**Root Cause:**

```jsx
// setState trong render phase (component body) â†’ FORBIDDEN!
if (renderCount.current > 5) {
  setCount(count + 1); // âŒ setState má»—i láº§n render!
}
```

**âœ… Solution:**

```jsx
// Option 1: Move to useEffect
useEffect(() => {
  if (renderCount.current > 5) {
    setCount(count + 1);
  }
}, []); // Chá»‰ cháº¡y once!

// Option 2: Event handler
const handleClick = () => {
  if (renderCount.current > 5) {
    setCount(count + 1);
  }
};

// Option 3: Remove conditional setState
// (KhÃ´ng cÃ³ lÃ½ do há»£p lÃ½ Ä‘á»ƒ setState based on render count!)
```

**ğŸ’¡ Rule:**

> NEVER call setState directly in component body!
> Only in:
>
> - Event handlers
> - useEffect
> - setTimeout/setInterval callbacks
> - Promise callbacks

</details>

---

### Bug 2: Missing Re-render ğŸ¤”

```jsx
function UserProfile() {
  const user = { name: 'John', age: 30 };

  const updateAge = () => {
    user.age = 31; // ğŸ› Táº¡i sao khÃ´ng re-render?
    console.log('User age updated:', user.age);
  };

  return (
    <div>
      <p>Age: {user.age}</p>
      <button onClick={updateAge}>Update Age</button>
    </div>
  );
}
```

**â“ CÃ¢u há»i:**

1. Click button, component cÃ³ re-render khÃ´ng?
2. Táº¡i sao?
3. Fix nhÆ° tháº¿ nÃ o?

<details>
<summary>ğŸ” Debug Steps</summary>

**PhÃ¢n tÃ­ch:**

```jsx
Click button:
â”œâ”€ updateAge() runs
â”œâ”€ user.age = 31 (mutation)
â”œâ”€ console.log shows 31 (value did change!)
â”œâ”€ BUT: No state update
â””â”€ React doesn't know to re-render! âŒ

Why?
â”œâ”€ user is a regular variable (not state)
â”œâ”€ Mutation doesn't trigger re-render
â””â”€ React only re-renders on:
    - setState
    - Props change
    - Context change
    - forceUpdate (khÃ´ng nÃªn dÃ¹ng)
```

**Root Cause:**

```jsx
// Regular variable mutation â‰  State update
const user = { name: 'John', age: 30 }; // âŒ Not state!
user.age = 31; // âŒ Mutation, no trigger!
```

**âœ… Solution:**

```jsx
// Option 1: Use useState
function UserProfile() {
  const [user, setUser] = useState({ name: 'John', age: 30 });

  const updateAge = () => {
    // Immutable update
    setUser((prevUser) => ({
      ...prevUser,
      age: 31,
    }));
  };

  return (
    <div>
      <p>Age: {user.age}</p>
      <button onClick={updateAge}>Update Age</button>
    </div>
  );
}

// Option 2: Separate state for age
function UserProfile() {
  const [age, setAge] = useState(30);

  const updateAge = () => {
    setAge(31);
  };

  return (
    <div>
      <p>Age: {age}</p>
      <button onClick={updateAge}>Update Age</button>
    </div>
  );
}
```

**ğŸ’¡ Rule:**

> React state must be treated as IMMUTABLE!
>
> - Never mutate objects/arrays directly
> - Always create new object/array
> - Use spread operator or methods that return new values

</details>

---

### Bug 3: Unexpected Re-renders ğŸ˜±

```jsx
function ParentComponent() {
  const [parentCount, setParentCount] = useState(0);

  const childData = {
    name: 'Static Data',
    value: 100,
  };

  return (
    <div>
      <button onClick={() => setParentCount((c) => c + 1)}>
        Parent Count: {parentCount}
      </button>
      <ExpensiveChild data={childData} />
    </div>
  );
}

const ExpensiveChild = React.memo(({ data }) => {
  console.log('ExpensiveChild rendered'); // ğŸ› Log má»—i láº§n parent render!

  // Expensive computation
  const result = Array(1000000)
    .fill(0)
    .reduce((sum, _, i) => sum + i, 0);

  return (
    <div>
      Child: {data.name} - {data.value}
      <br />
      Result: {result}
    </div>
  );
});
```

**â“ CÃ¢u há»i:**

1. ExpensiveChild cÃ³ React.memo, táº¡i sao váº«n re-render?
2. Váº¥n Ä‘á» á»Ÿ Ä‘Ã¢u?
3. Fix nhÆ° tháº¿ nÃ o?

<details>
<summary>ğŸ” Debug Steps</summary>

**PhÃ¢n tÃ­ch:**

```jsx
Every Parent render:
â”œâ”€ ParentComponent function runs
â”œâ”€ childData = { name: '...', value: 100 }
â”‚   â””â”€ NEW object created! (different reference)
â”œâ”€ <ExpensiveChild data={childData} />
â”‚   â””â”€ React.memo compares:
â”‚       - prev data: { name: '...', value: 100 } @ 0x001
â”‚       - new data:  { name: '...', value: 100 } @ 0x002
â”‚       - 0x001 !== 0x002 â†’ Different!
â”‚       - Re-render child! âŒ
â””â”€ ExpensiveChild renders (and does expensive computation!)

Why memo doesn't work?
â”œâ”€ React.memo uses Object.is (shallow comparison)
â”œâ”€ Objects compared by reference
â”œâ”€ NEW object every render = different reference
â””â”€ Memo thinks props changed!
```

**Root Cause:**

```jsx
// Creating object in render
const childData = {
  /* ... */
}; // âŒ NEW object má»—i láº§n!

// React.memo comparison:
const prevData = { name: 'Static Data', value: 100 };
const nextData = { name: 'Static Data', value: 100 };
prevData === nextData; // false! (different references)
```

**âœ… Solution:**

```jsx
// Option 1: Move outside component (if truly static)
const STATIC_CHILD_DATA = {
  name: 'Static Data',
  value: 100,
};

function ParentComponent() {
  const [parentCount, setParentCount] = useState(0);

  return (
    <div>
      <button onClick={() => setParentCount((c) => c + 1)}>
        Parent Count: {parentCount}
      </button>
      <ExpensiveChild data={STATIC_CHILD_DATA} />
    </div>
  );
}

// Option 2: useMemo (ngÃ y mai há»c!)
function ParentComponent() {
  const [parentCount, setParentCount] = useState(0);

  const childData = useMemo(
    () => ({
      name: 'Static Data',
      value: 100,
    }),
    [],
  ); // Stable reference

  return (
    <div>
      <button onClick={() => setParentCount((c) => c + 1)}>
        Parent Count: {parentCount}
      </button>
      <ExpensiveChild data={childData} />
    </div>
  );
}

// Option 3: useState (if actually state)
function ParentComponent() {
  const [parentCount, setParentCount] = useState(0);
  const [childData] = useState({
    name: 'Static Data',
    value: 100,
  }); // Initialized once, stable reference

  return (
    <div>
      <button onClick={() => setParentCount((c) => c + 1)}>
        Parent Count: {parentCount}
      </button>
      <ExpensiveChild data={childData} />
    </div>
  );
}
```

**ğŸ’¡ Rule:**

> When using React.memo:
>
> - Props MUST have stable references
> - Objects/arrays created in render = new references
> - Use useMemo, useState, or define outside component
> - Tomorrow we learn useMemo properly!

</details>

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u âœ… náº¿u báº¡n hiá»ƒu:

**Render Basics:**

- [ ] PhÃ¢n biá»‡t Render phase vs Commit phase
- [ ] Hiá»ƒu khi nÃ o component re-render
- [ ] Hiá»ƒu parent render â†’ children render
- [ ] Biáº¿t render â‰  DOM update

**Props & State:**

- [ ] React so sÃ¡nh props báº±ng Object.is
- [ ] Primitives so sÃ¡nh by value
- [ ] Objects/arrays so sÃ¡nh by reference
- [ ] setState vá»›i giÃ¡ trá»‹ giá»‘ng nhau â†’ bailout (sau láº§n Ä‘áº§u)

**Debugging:**

- [ ] Sá»­ dá»¥ng useRef Ä‘á»ƒ Ä‘áº¿m renders
- [ ] Sá»­ dá»¥ng React DevTools Profiler
- [ ] Highlight updates trong DevTools
- [ ] Äá»c Flamegraph view

**Common Pitfalls:**

- [ ] KhÃ´ng setState trong component body
- [ ] KhÃ´ng mutate state trá»±c tiáº¿p
- [ ] Objects trong render = new reference
- [ ] React.memo cáº§n stable props

### Code Review Checklist

Khi review code React, check:

**Performance Red Flags:**

- [ ] âŒ Creating objects/arrays trong render

```jsx
// Bad
const config = {
  /* ... */
}; // New object má»—i render!
<Child config={config} />;

// Good
const CONFIG = {
  /* ... */
}; // Outside component
<Child config={CONFIG} />;
```

- [ ] âŒ setState trong component body

```jsx
// Bad
if (condition) {
  setCount(count + 1); // Infinite loop potential!
}

// Good
useEffect(() => {
  if (condition) {
    setCount(count + 1);
  }
}, [condition, count]);
```

- [ ] âŒ Inline functions lÃ m props cho memoized children

```jsx
// Bad
<MemoizedChild onClick={() => doSomething()} />;
// onClick is NEW function every render!

// Good (will learn tomorrow)
const handleClick = useCallback(() => doSomething(), []);
<MemoizedChild onClick={handleClick} />;
```

**Äo lÆ°á»ng trÆ°á»›c khi optimize:**

- [ ] âœ… Profile vá»›i DevTools trÆ°á»›c
- [ ] âœ… Identify actual bottlenecks
- [ ] âœ… Measure impact sau optimize
- [ ] âœ… Don't optimize prematurely!

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**Exercise: Render Audit**

1. Láº¥y 1 app React cÅ© cá»§a báº¡n (hoáº·c create new náº¿u chÆ°a cÃ³)
2. ThÃªm render tracking vÃ o 5-10 components
3. Thá»±c hiá»‡n thao tÃ¡c thÃ´ng thÆ°á»ng (click, type, navigate)
4. Ghi láº¡i:
   - Component nÃ o render nhiá»u nháº¥t?
   - CÃ³ renders khÃ´ng cáº§n thiáº¿t khÃ´ng?
   - Táº¡i sao chÃºng render?
5. Viáº¿t ngáº¯n gá»n (200-300 tá»«) phÃ¢n tÃ­ch findings

**Deliverable:** Document vá»›i:

- Screenshots DevTools Profiler
- Render count table
- Top 3 optimization opportunities

### NÃ¢ng cao (60 phÃºt)

**Exercise: Performance Comparison**

Implement cÃ¹ng 1 feature theo 2 cÃ¡ch:

**Feature:** Todo list vá»›i search filter

**Version A: KhÃ´ng optimize**

```jsx
function TodoApp() {
  const [todos, setTodos] = useState([
    /* 50 todos */
  ]);
  const [searchTerm, setSearchTerm] = useState('');

  const filtered = todos.filter((todo) =>
    todo.text.toLowerCase().includes(searchTerm.toLowerCase()),
  );

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      {filtered.map((todo) => (
        <TodoItem
          key={todo.id}
          todo={todo}
        />
      ))}
    </div>
  );
}
```

**Version B: ÄÃ£ chuáº©n bá»‹ cho optimize (ngÃ y mai)**

```jsx
// Tá»• chá»©c code sao cho:
// - Dá»… thÃªm React.memo
// - Dá»… thÃªm useMemo
// - Dá»… thÃªm useCallback
// (ChÆ°a dÃ¹ng nhá»¯ng thá»© nÃ y, chá»‰ structure!)
```

**So sÃ¡nh:**

1. Render counts (use tracking)
2. DevTools Profiler results
3. User experience (subjective)
4. Sáºµn sÃ ng cho optimization ngÃ y mai

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - Render and Commit**
   - https://react.dev/learn/render-and-commit
   - Äá»c 2-3 láº§n cho tháº­t hiá»ƒu!

2. **React Docs - Preserving and Resetting State**
   - https://react.dev/learn/preserving-and-resetting-state
   - Hiá»ƒu khi nÃ o state giá»¯ láº¡i, khi nÃ o reset

### Äá»c thÃªm

3. **A (Mostly) Complete Guide to React Rendering Behavior** by Mark Erikson
   - https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/
   - Deep dive xuáº¥t sáº¯c!

4. **Before You memo()** by Dan Abramov
   - https://overreacted.io/before-you-memo/
   - Quan Ä‘iá»ƒm cÃ¢n báº±ng vá» optimization

5. **React DevTools Profiler Tutorial**
   - https://react.dev/learn/react-developer-tools
   - Official guide

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (Ä‘Ã£ há»c)

**NgÃ y 11-14: useState**

- State changes trigger re-renders
- Functional updates Ä‘á»ƒ trÃ¡nh stale closure

**NgÃ y 16-20: useEffect**

- Cháº¡y AFTER render (Commit phase)
- Dependencies áº£nh hÆ°á»Ÿng re-render behavior

**NgÃ y 21-22: useRef**

- Persist values WITHOUT re-render
- Perfect cho render tracking!

**NgÃ y 26-29: useReducer**

- Complex state cÅ©ng trigger re-renders
- Same render rules nhÆ° useState

### HÆ°á»›ng tá»›i (sáº½ há»c)

**NgÃ y 32: React.memo**

- Prevent unnecessary child re-renders
- Shallow props comparison

**NgÃ y 33: useMemo**

- Memoize expensive computations
- Stable object/array references

**NgÃ y 34: useCallback**

- Memoize functions
- Stable callback references

**NgÃ y 35: Integration Project**

- Apply táº¥t cáº£ optimization techniques
- Real-world performance tuning

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. Premature Optimization is the Root of All Evil**

```jsx
// âŒ KHÃ”NG NÃŠN: Optimize ngay tá»« Ä‘áº§u
const MyComponent = React.memo(() => {
  const value = useMemo(() => computeSomething(), []);
  const callback = useCallback(() => doSomething(), []);
  // ... more memoization ...
});

// âœ… NÃŠN: Viáº¿t code Ä‘Æ¡n giáº£n trÆ°á»›c
const MyComponent = () => {
  const value = computeSomething();
  const callback = () => doSomething();
  // ...
};

// Chá»‰ optimize KHI:
// 1. Äo lÆ°á»ng tháº¥y váº¥n Ä‘á»
// 2. Profiler chá»‰ ra bottleneck
// 3. User experience bá»‹ áº£nh hÆ°á»Ÿng
```

**Táº¡i sao?**

- Optimization code phá»©c táº¡p hÆ¡n
- Harder to maintain
- Performance gain cÃ³ thá»ƒ khÃ´ng Ä‘Ã¡ng ká»ƒ
- CÃ³ thá»ƒ introduce bugs

**2. Not All Re-renders Are Bad**

```jsx
// Component nÃ y render má»—i giÃ¢y, cÃ³ sao khÃ´ng?
function Clock() {
  const [time, setTime] = useState(new Date());

  useEffect(() => {
    const id = setInterval(() => setTime(new Date()), 1000);
    return () => clearInterval(id);
  }, []);

  return <div>{time.toLocaleTimeString()}</div>;
}

// Absolutely fine!
// - Render nhanh (< 1ms)
// - User expects update má»—i giÃ¢y
// - No complex children
// â†’ KHÃ”NG Cáº¦N OPTIMIZE!
```

**Rules of thumb:**

- Render < 16ms â†’ Probably OK
- No user complaints â†’ Don't optimize
- Simple components â†’ Re-render is cheap

**3. Context is King**

Performance optimization phá»¥ thuá»™c context:

```jsx
// E-commerce product page:
// - ProductImage: Optimize! (large images, expensive)
// - ProductPrice: Maybe (updates frequently)
// - ProductReviews: Definitely! (100+ items)
// - AddToCartButton: Probably not (simple, cheap)

// Real-time chat app:
// - MessageList: Optimize! (hundreds of messages)
// - ChatInput: Don't optimize (user typing, expects updates)
// - TypingIndicator: Don't optimize (animates frequently)
```

**4. Mobile Matters More**

```jsx
// Desktop: 60 FPS, powerful CPU
// â†’ Can tolerate more renders

// Mobile: Battery, slower CPU, thermal throttling
// â†’ Be more aggressive with optimization

// Testing strategy:
// 1. Profile on low-end mobile (old iPhone/Android)
// 2. Use DevTools CPU throttling (6x slowdown)
// 3. Test on 3G network simulation
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

**Q1: "Khi nÃ o React component re-render?"**

Expected answer:

- Khi state thay Ä‘á»•i (useState, useReducer)
- Khi props thay Ä‘á»•i
- Khi parent component re-render
- Khi Context value thay Ä‘á»•i (sáº½ há»c sau)

**Q2: "Render phase vÃ  Commit phase khÃ¡c nhau tháº¿ nÃ o?"**

Expected answer:

- Render: Gá»i component function, táº¡o Virtual DOM, reconciliation
- Commit: Update Real DOM, run useLayoutEffect, browser paint, run useEffect
- Render cÃ³ thá»ƒ interrupt, Commit khÃ´ng thá»ƒ

**Mid Level:**

**Q3: "React so sÃ¡nh props nhÆ° tháº¿ nÃ o?"**

Expected answer:

- Sá»­ dá»¥ng Object.is (tÆ°Æ¡ng tá»± ===)
- Shallow comparison (chá»‰ compare references, khÃ´ng deep equal)
- Primitives: Compare by value
- Objects/arrays: Compare by reference
- Example: { name: 'John' } !== { name: 'John' } (different references)

**Q4: "LÃ m sao debug performance issues trong React app?"**

Expected answer:

1. React DevTools Profiler
2. useRef Ä‘á»ƒ track render counts
3. console.log (cÃ³ thá»ƒ dÃ¹ng highlight updates)
4. Performance API (performance.now())
5. Identify unnecessary renders
6. Check expensive computations
7. Verify stable object/array references

**Senior Level:**

**Q5: "Explain React's bailout optimization. Khi nÃ o nÃ³ work, khi nÃ o khÃ´ng?"**

Expected answer:

- React bails out (skips re-render) khi setState vá»›i cÃ¹ng value
- Object.is comparison: setState(5) khi state = 5 â†’ bailout
- NHÆ¯NG: Chá»‰ sau láº§n check Ä‘áº§u tiÃªn
- Example:
  ```jsx
  setCount(0); // First time: Re-renders (React checks after)
  setCount(0); // Second time: Bailout! (React: "0 === 0, skip")
  ```
- Doesn't work vá»›i new object: setUser({ name: 'John' })
- Objects compared by reference, not content

**Q6: "Khi nÃ o báº¡n quyáº¿t Ä‘á»‹nh optimize React component? Walk me through your process."**

Expected answer:

1. **Measure First**
   - React DevTools Profiler
   - Identify slow renders (> 16ms)
   - Find unnecessary renders

2. **Prioritize**
   - Components with many children
   - Expensive computations
   - High render frequency

3. **Choose Technique**
   - React.memo for components
   - useMemo for values
   - useCallback for functions
   - Split components
   - Lazy loading

4. **Verify**
   - Profile again
   - Measure improvement
   - Check trade-offs (code complexity, memory)

5. **Document**
   - Why optimized
   - Expected benefit
   - Maintenance notes

### War Stories

**Story 1: The 10,000 Item List** ğŸ”¥

```
Scenario:
- Dashboard vá»›i table 10,000 rows
- Má»—i láº§n search â†’ Re-render táº¥t cáº£ rows
- App freeze 2-3 giÃ¢y!

Root Cause:
- ProductRow component khÃ´ng memo
- Table re-render â†’ 10,000 ProductRow re-render
- Má»—i row cÃ³ expensive computation (price calculations)

Solution:
- React.memo on ProductRow
- useMemo for price calculation
- Virtualization (react-window) cho visible rows only

Result:
- 2-3 seconds â†’ < 100ms
- Smooth 60 FPS scrolling
- Happy users, happy PM!

Lesson:
- Sá»‘ lÆ°á»£ng quan trá»ng hÆ¡n Ä‘á»™ phá»©c táº¡p
- 10,000 simple components > 10 complex components
- Consider virtualization for long lists
```

**Story 2: The Mysterious Lag** ğŸ¤”

```
Scenario:
- Simple form input lag khi typing
- DevTools shows parent re-rendering 100+ components
- BUT: Form input khÃ´ng cÃ³ children!

Root Cause:
- Input trong top-level App component
- App state change â†’ Entire app re-renders
- Táº¥t cáº£ routes, modals, sidebars re-render!

Solution:
- Move input state to separate component
- Prevent state hoisting quÃ¡ cao
- Use Context (há»c sau) cho shared state

Result:
- Typing lag gone
- App feels snappy
- Code actually simpler!

Lesson:
- State cÃ ng cao â†’ Re-render cÃ ng rá»™ng
- Keep state as low as possible
- "Lift state up" cÃ³ giá»›i háº¡n
- Sometimes need Context/Redux
```

**Story 3: Over-Optimization Backfire** ğŸ˜…

```
Scenario:
- Junior dev learn vá» React.memo
- Wrap EVERYTHING vá»›i memo, useMemo, useCallback
- Code become nightmare to maintain
- NO performance improvement!

Problem:
- Simple components (< 1ms render)
- Memoization overhead > render cost
- Dependencies change often â†’ Memo useless
- Code phá»©c táº¡p 3x, no benefit

Solution:
- REMOVE most memoization
- Keep only where measured improvement
- Focus on actual bottlenecks
- Profile before & after

Result:
- Code simpler
- Same (or better!) performance
- Team happier

Lesson:
- "If in doubt, leave it out"
- Measure first, optimize second
- Simple code > premature optimization
- Trust React's default behavior
```

---

## ğŸ¯ TÃ“M Táº®T NGÃ€Y 31

### Nhá»¯ng Ä‘iá»u quan trá»ng nháº¥t:

1. **React Render Cycle:**
   - Render Phase: Call functions, create Virtual DOM, reconcile
   - Commit Phase: Update DOM, run effects
   - Render â‰  DOM update!

2. **Re-render Triggers:**
   - State change (useState, useReducer)
   - Props change
   - Parent renders â†’ Children render (default)
   - Context change (sáº½ há»c)

3. **Props Comparison:**
   - Object.is (shallow, reference-based)
   - Primitives: By value
   - Objects/arrays: By reference
   - NEW object !== NEW object (even same content)

4. **Debugging Tools:**
   - React DevTools Profiler (visual)
   - useRef counter (programmatic)
   - console.log (quick)
   - Custom monitoring (production)

5. **Common Pitfalls:**
   - Creating objects/arrays in render
   - setState in component body
   - Mutating state directly
   - Premature optimization

### Chuáº©n bá»‹ cho ngÃ y mai:

NgÃ y 32 sáº½ há»c **React.memo** - cÃ´ng cá»¥ Ä‘áº§u tiÃªn Ä‘á»ƒ optimize renders!

Preview:

```jsx
// Today: All children re-render
function Parent() {
  const [count, setCount] = useState(0);
  return (
    <>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <Child /> {/* Re-renders when count changes! */}
    </>
  );
}

// Tomorrow: Prevent unnecessary re-renders
const Child = React.memo(() => {
  return <div>I only render when MY props change!</div>;
});
```

**Homework trÆ°á»›c NgÃ y 32:**

- Ã”n láº¡i props comparison (Object.is)
- Review stable references concept
- LÃ m bÃ i táº­p vá» nhÃ  (render audit)
- Suy nghÄ©: Components nÃ o trong project cá»§a báº¡n render quÃ¡ nhiá»u?

---

**ğŸ‰ Congratulations!** Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 31 - ná»n táº£ng cho Performance Optimization! NgÃ y mai sáº½ há»c cÃ¡ch FIX nhá»¯ng váº¥n Ä‘á» mÃ¬nh vá»«a discover hÃ´m nay.

**ğŸ’ª Keep going!** Performance optimization lÃ  skill quan trá»ng nháº¥t Ä‘á»ƒ tá»« Mid lÃªn Senior React Developer!
