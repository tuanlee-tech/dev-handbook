# üìÖ NG√ÄY 26: useReducer - Qu·∫£n L√Ω State Ph·ª©c T·∫°p v·ªõi Reducer Pattern

## üìç V·ªã tr√≠: Phase 3, Tu·∫ßn 6, Ng√†y 26/45

### ‚è±Ô∏è Th·ªùi l∆∞·ª£ng: 3-4 gi·ªù

---

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:

- [ ] **Hi·ªÉu ƒë∆∞·ª£c** reducer pattern l√† g√¨ v√† t·∫°i sao n√≥ quan tr·ªçng
- [ ] **Vi·∫øt ƒë∆∞·ª£c** reducer function thu·∫ßn t√∫y (pure function)
- [ ] **S·ª≠ d·ª•ng ƒë∆∞·ª£c** useReducer hook ƒë·ªÉ qu·∫£n l√Ω complex state
- [ ] **Quy·∫øt ƒë·ªãnh ƒë∆∞·ª£c** khi n√†o d√πng useState vs useReducer d·ª±a tr√™n trade-offs
- [ ] **Thi·∫øt k·∫ø ƒë∆∞·ª£c** actions v√† action creators chu·∫©n m·ª±c

---

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu, h√£y tr·∫£ l·ªùi 3 c√¢u h·ªèi sau:

1. **useState c√≥ v·∫•n ƒë·ªÅ g√¨ khi state logic ph·ª©c t·∫°p?**
   - G·ª£i √Ω: Nghƒ© v·ªÅ form c√≥ 10+ fields, m·ªói field c√≥ validation...

2. **Pure function l√† g√¨? Cho v√≠ d·ª•.**
   - G·ª£i √Ω: Function kh√¥ng side effects, same input ‚Üí same output

3. **B·∫°n ƒë√£ t·ª´ng g·∫∑p tr∆∞·ªùng h·ª£p state updates ph·ª• thu·ªôc v√†o nhau ch∆∞a?**
   - V√≠ d·ª•: Submit form ‚Üí loading true ‚Üí data fetched ‚Üí loading false, data updated

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

H√£y t∆∞·ªüng t∆∞·ª£ng b·∫°n ƒëang build form ƒëƒÉng k√Ω user v·ªõi requirements sau:

```jsx
// ‚ùå V·∫§N ƒê·ªÄ: useState cho complex state
function RegistrationForm() {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [touched, setTouched] = useState({});
  const [validationErrors, setValidationErrors] = useState({});

  const handleSubmit = async (e) => {
    e.preventDefault();

    // üò± Logic ph·ª©c t·∫°p v·ªõi nhi·ªÅu state updates
    setIsLoading(true);
    setError(null);

    try {
      // Validation
      const errors = {};
      if (!username) errors.username = 'Required';
      if (!email) errors.email = 'Required';
      if (password !== confirmPassword) {
        errors.password = 'Passwords must match';
      }

      if (Object.keys(errors).length > 0) {
        setValidationErrors(errors);
        setIsLoading(false); // ‚ö†Ô∏è D·ªÖ qu√™n!
        return;
      }

      // API call
      await registerUser({ username, email, password });

      // Success - reset form
      setUsername('');
      setEmail('');
      setPassword('');
      setConfirmPassword('');
      setTouched({});
      setValidationErrors({});
      setIsLoading(false);
    } catch (err) {
      setError(err.message);
      setIsLoading(false); // ‚ö†Ô∏è Duplicate logic!
    }
  };

  // ... üò∞ C√≤n handleBlur, handleChange, etc.
}
```

**V·∫•n ƒë·ªÅ:**

1. üî¥ **Qu√° nhi·ªÅu useState** ‚Üí kh√≥ tracking
2. üî¥ **State updates r·∫£i r√°c** ‚Üí d·ªÖ miss, duplicate logic
3. üî¥ **Kh√≥ test** ‚Üí ph·∫£i mock t·ª´ng setter
4. üî¥ **Kh√≥ debug** ‚Üí kh√¥ng bi·∫øt state thay ƒë·ªïi b·ªüi action n√†o

### 1.2 Gi·∫£i Ph√°p: Reducer Pattern

**Reducer Pattern** l√† pattern t·∫≠p trung t·∫•t c·∫£ state logic v√†o 1 ch·ªó:

```
Current State + Action ‚Üí Reducer ‚Üí Next State
```

**Core Idea:**

```jsx
// Thay v√¨:
setUsername('john');
setEmail('john@example.com');
setIsLoading(true);

// Ta c√≥:
dispatch({ type: 'UPDATE_FIELD', field: 'username', value: 'john' });
dispatch({ type: 'UPDATE_FIELD', field: 'email', value: 'john@example.com' });
dispatch({ type: 'SUBMIT_START' });
```

**L·ª£i √≠ch:**

- ‚úÖ **Centralized logic** ‚Üí t·∫•t c·∫£ state transitions ·ªü 1 ch·ªó
- ‚úÖ **Predictable** ‚Üí same action + same state = same result
- ‚úÖ **Testable** ‚Üí test reducer nh∆∞ function thu·∫ßn
- ‚úÖ **Debuggable** ‚Üí log actions ƒë·ªÉ bi·∫øt "what happened"

### 1.3 Mental Model

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  COMPONENT                       ‚îÇ
‚îÇ                                                  ‚îÇ
‚îÇ  User Event                                      ‚îÇ
‚îÇ      ‚Üì                                           ‚îÇ
‚îÇ  dispatch(action) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ      ‚Üì                            ‚îÇ              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  Current State   ‚îÇ             ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ  { count: 5 }    ‚îÇ             ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ              ‚îÇ
‚îÇ           ‚îÇ                       ‚îÇ              ‚îÇ
‚îÇ           ‚Üì                       ‚Üì              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îÇ
‚îÇ  ‚îÇ         REDUCER (Pure Function)      ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ                                      ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  (state, action) => {                ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ    switch(action.type) {             ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ      case 'INCREMENT':               ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ        return { count: state.count+1 }‚îÇ        ‚îÇ
‚îÇ  ‚îÇ    }                                 ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  }                                   ‚îÇ        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îÇ
‚îÇ           ‚îÇ                                      ‚îÇ
‚îÇ           ‚Üì                                      ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îÇ
‚îÇ  ‚îÇ   Next State     ‚îÇ                           ‚îÇ
‚îÇ  ‚îÇ  { count: 6 }    ‚îÇ                           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ
‚îÇ           ‚îÇ                                      ‚îÇ
‚îÇ           ‚Üì                                      ‚îÇ
‚îÇ      Re-render                                   ‚îÇ
‚îÇ                                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Analogy:** Reducer gi·ªëng nh∆∞ **m√°y b√°n h√†ng t·ª± ƒë·ªông**

- **State**: S·ªë ti·ªÅn trong m√°y
- **Action**: Ng∆∞·ªùi b·∫•m n√∫t "Coke"
- **Reducer**: Logic "n·∫øu b·∫•m Coke V√Ä ƒë·ªß ti·ªÅn ‚Üí tr·∫£ Coke, gi·∫£m ti·ªÅn"
- **Next State**: Ti·ªÅn sau khi mua

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

‚ùå **Hi·ªÉu l·∫ßm 1:** "Reducer ch·ªâ d√πng khi state ph·ª©c t·∫°p"

- ‚úÖ **S·ª± th·∫≠t:** Reducer gi√∫p code **d·ªÖ ƒë·ªçc** h∆°n, k·ªÉ c·∫£ state ƒë∆°n gi·∫£n

‚ùå **Hi·ªÉu l·∫ßm 2:** "Reducer ph·∫£i return object m·ªõi ho√†n to√†n"

- ‚úÖ **S·ª± th·∫≠t:** Reducer ch·ªâ c·∫ßn return **immutable update**, c√≥ th·ªÉ spread

‚ùå **Hi·ªÉu l·∫ßm 3:** "useReducer thay th·∫ø useState ho√†n to√†n"

- ‚úÖ **S·ª± th·∫≠t:** M·ªói c√°i c√≥ use case ri√™ng (s·∫Ω so s√°nh sau)

‚ùå **Hi·ªÉu l·∫ßm 4:** "Reducer c√≥ th·ªÉ mutate state"

- ‚úÖ **S·ª± th·∫≠t:** Reducer PH·∫¢I pure, kh√¥ng side effects

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Pattern C∆° B·∫£n - Counter v·ªõi useReducer ‚≠ê

```jsx
import { useReducer } from 'react';

// 1Ô∏è‚É£ ƒê·ªäNH NGHƒ®A REDUCER
// Reducer l√† pure function: (currentState, action) => nextState
function counterReducer(state, action) {
  // state: current state value
  // action: object m√¥ t·∫£ "what happened"

  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };

    case 'DECREMENT':
      return { count: state.count - 1 };

    case 'RESET':
      return { count: 0 };

    case 'SET':
      return { count: action.payload };

    default:
      // ‚ö†Ô∏è QUAN TR·ªåNG: Lu√¥n c√≥ default case
      // Throw error n·∫øu action kh√¥ng h·ª£p l·ªá
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// 2Ô∏è‚É£ S·ª¨ D·ª§NG useReducer TRONG COMPONENT
function Counter() {
  // useReducer(reducer, initialState)
  // Returns: [state, dispatch]
  const [state, dispatch] = useReducer(
    counterReducer,
    { count: 0 }, // initial state
  );

  return (
    <div>
      <h1>Count: {state.count}</h1>

      {/* 3Ô∏è‚É£ DISPATCH ACTIONS */}
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+1</button>

      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-1</button>

      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>

      <button onClick={() => dispatch({ type: 'SET', payload: 10 })}>
        Set to 10
      </button>
    </div>
  );
}
```

**üìù Gi·∫£i th√≠ch:**

1. **Reducer Function:**
   - Pure function, kh√¥ng side effects
   - Input: `(state, action)`
   - Output: new state (immutable)

2. **useReducer Hook:**
   - `const [state, dispatch] = useReducer(reducer, initialState)`
   - `state`: current state (gi·ªëng useState)
   - `dispatch`: function ƒë·ªÉ g·ª≠i actions

3. **Action Object:**
   - `{ type: 'ACTION_NAME' }` - required
   - `{ type: 'ACTION_NAME', payload: data }` - v·ªõi data

**üîç So s√°nh useState vs useReducer:**

```jsx
// ‚ùå V·ªöI useState
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>+1</button>
      <button onClick={() => setCount(count - 1)}>-1</button>
      <button onClick={() => setCount(0)}>Reset</button>
      <button onClick={() => setCount(10)}>Set to 10</button>
    </div>
  );
}

// ‚úÖ V·ªöI useReducer
// Logic t·∫≠p trung, d·ªÖ ƒë·ªçc, d·ªÖ test
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+1</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-1</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
      <button onClick={() => dispatch({ type: 'SET', payload: 10 })}>
        Set to 10
      </button>
    </div>
  );
}
```

### Demo 2: K·ªãch B·∫£n Th·ª±c T·∫ø - Todo App ‚≠ê‚≠ê

```jsx
// üìã TODO REDUCER
function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now(),
            text: action.payload.text,
            completed: false,
          },
        ],
      };

    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo,
        ),
      };

    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter((todo) => todo.id !== action.payload.id),
      };

    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload.filter,
      };

    case 'CLEAR_COMPLETED':
      return {
        ...state,
        todos: state.todos.filter((todo) => !todo.completed),
      };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// üéØ COMPONENT
function TodoApp() {
  const initialState = {
    todos: [],
    filter: 'all', // 'all' | 'active' | 'completed'
  };

  const [state, dispatch] = useReducer(todoReducer, initialState);
  const [inputValue, setInputValue] = useState('');

  // ‚úÖ Event handlers g·ªçi dispatch
  const handleAddTodo = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      dispatch({
        type: 'ADD_TODO',
        payload: { text: inputValue },
      });
      setInputValue('');
    }
  };

  const handleToggle = (id) => {
    dispatch({
      type: 'TOGGLE_TODO',
      payload: { id },
    });
  };

  const handleDelete = (id) => {
    dispatch({
      type: 'DELETE_TODO',
      payload: { id },
    });
  };

  // ‚úÖ Derived state (computed from state)
  const filteredTodos = state.todos.filter((todo) => {
    if (state.filter === 'active') return !todo.completed;
    if (state.filter === 'completed') return todo.completed;
    return true; // 'all'
  });

  const activeCount = state.todos.filter((t) => !t.completed).length;
  const completedCount = state.todos.filter((t) => t.completed).length;

  return (
    <div>
      <h1>Todo App</h1>

      {/* Form */}
      <form onSubmit={handleAddTodo}>
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder='What needs to be done?'
        />
        <button type='submit'>Add</button>
      </form>

      {/* Filters */}
      <div>
        <button
          onClick={() =>
            dispatch({ type: 'SET_FILTER', payload: { filter: 'all' } })
          }
          disabled={state.filter === 'all'}
        >
          All ({state.todos.length})
        </button>
        <button
          onClick={() =>
            dispatch({ type: 'SET_FILTER', payload: { filter: 'active' } })
          }
          disabled={state.filter === 'active'}
        >
          Active ({activeCount})
        </button>
        <button
          onClick={() =>
            dispatch({ type: 'SET_FILTER', payload: { filter: 'completed' } })
          }
          disabled={state.filter === 'completed'}
        >
          Completed ({completedCount})
        </button>
      </div>

      {/* Todo List */}
      <ul>
        {filteredTodos.map((todo) => (
          <li key={todo.id}>
            <input
              type='checkbox'
              checked={todo.completed}
              onChange={() => handleToggle(todo.id)}
            />
            <span
              style={{
                textDecoration: todo.completed ? 'line-through' : 'none',
              }}
            >
              {todo.text}
            </span>
            <button onClick={() => handleDelete(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>

      {/* Actions */}
      {completedCount > 0 && (
        <button onClick={() => dispatch({ type: 'CLEAR_COMPLETED' })}>
          Clear Completed
        </button>
      )}
    </div>
  );
}
```

**üéØ T·∫°i sao useReducer t·ªët h∆°n ·ªü ƒë√¢y?**

1. **State shape ph·ª©c t·∫°p:** `{ todos: [], filter: 'all' }`
2. **Multiple related updates:** Toggle todo ‚Üí update todos array
3. **Predictable state transitions:** M·ªói action c√≥ logic r√µ r√†ng
4. **Easy to test:** Test reducer nh∆∞ pure function

### Demo 3: Edge Cases - Validation & Error Handling ‚≠ê‚≠ê‚≠ê

```jsx
// üîê FORM REDUCER v·ªõi Validation
function formReducer(state, action) {
  switch (action.type) {
    case 'UPDATE_FIELD':
      // ‚úÖ Validate on field update
      const errors = { ...state.errors };

      // Clear error khi user s·ª≠a
      if (errors[action.payload.field]) {
        delete errors[action.payload.field];
      }

      return {
        ...state,
        values: {
          ...state.values,
          [action.payload.field]: action.payload.value,
        },
        errors,
        touched: {
          ...state.touched,
          [action.payload.field]: true,
        },
      };

    case 'SUBMIT_START':
      // ‚ö†Ô∏è EDGE CASE: Kh√¥ng submit n·∫øu ƒëang loading
      if (state.isLoading) {
        console.warn('Already submitting');
        return state;
      }

      return {
        ...state,
        isLoading: true,
        submitError: null,
      };

    case 'SUBMIT_SUCCESS':
      // ‚úÖ Reset form after success
      return {
        values: { username: '', email: '', password: '' },
        errors: {},
        touched: {},
        isLoading: false,
        submitError: null,
      };

    case 'SUBMIT_ERROR':
      return {
        ...state,
        isLoading: false,
        submitError: action.payload.error,
      };

    case 'SET_ERRORS':
      // ‚ö†Ô∏è EDGE CASE: Validation errors
      return {
        ...state,
        errors: action.payload.errors,
        isLoading: false,
      };

    case 'RESET_FORM':
      // ‚úÖ Reset v·ªÅ initial state
      return action.payload.initialState;

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// üéØ COMPONENT v·ªõi Error Handling
function RegistrationForm() {
  const initialState = {
    values: {
      username: '',
      email: '',
      password: '',
    },
    errors: {},
    touched: {},
    isLoading: false,
    submitError: null,
  };

  const [state, dispatch] = useReducer(formReducer, initialState);

  // ‚úÖ Validation logic (pure function)
  const validate = (values) => {
    const errors = {};

    if (!values.username) {
      errors.username = 'Username is required';
    } else if (values.username.length < 3) {
      errors.username = 'Username must be at least 3 characters';
    }

    if (!values.email) {
      errors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Email is invalid';
    }

    if (!values.password) {
      errors.password = 'Password is required';
    } else if (values.password.length < 6) {
      errors.password = 'Password must be at least 6 characters';
    }

    return errors;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    // Validate
    const validationErrors = validate(state.values);

    if (Object.keys(validationErrors).length > 0) {
      dispatch({
        type: 'SET_ERRORS',
        payload: { errors: validationErrors },
      });
      return;
    }

    // Submit
    dispatch({ type: 'SUBMIT_START' });

    try {
      await registerUser(state.values);
      dispatch({ type: 'SUBMIT_SUCCESS' });
      alert('Registration successful!');
    } catch (error) {
      dispatch({
        type: 'SUBMIT_ERROR',
        payload: { error: error.message },
      });
    }
  };

  const handleChange = (field) => (e) => {
    dispatch({
      type: 'UPDATE_FIELD',
      payload: {
        field,
        value: e.target.value,
      },
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Username */}
      <div>
        <input
          type='text'
          value={state.values.username}
          onChange={handleChange('username')}
          placeholder='Username'
        />
        {state.touched.username && state.errors.username && (
          <span style={{ color: 'red' }}>{state.errors.username}</span>
        )}
      </div>

      {/* Email */}
      <div>
        <input
          type='email'
          value={state.values.email}
          onChange={handleChange('email')}
          placeholder='Email'
        />
        {state.touched.email && state.errors.email && (
          <span style={{ color: 'red' }}>{state.errors.email}</span>
        )}
      </div>

      {/* Password */}
      <div>
        <input
          type='password'
          value={state.values.password}
          onChange={handleChange('password')}
          placeholder='Password'
        />
        {state.touched.password && state.errors.password && (
          <span style={{ color: 'red' }}>{state.errors.password}</span>
        )}
      </div>

      {/* Submit Error */}
      {state.submitError && (
        <div style={{ color: 'red', fontWeight: 'bold' }}>
          {state.submitError}
        </div>
      )}

      {/* Buttons */}
      <button
        type='submit'
        disabled={state.isLoading}
      >
        {state.isLoading ? 'Submitting...' : 'Register'}
      </button>

      <button
        type='button'
        onClick={() =>
          dispatch({
            type: 'RESET_FORM',
            payload: { initialState },
          })
        }
      >
        Reset
      </button>
    </form>
  );
}

// Mock API
const registerUser = (data) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (data.username === 'error') {
        reject(new Error('Username already exists'));
      } else {
        resolve({ success: true });
      }
    }, 1000);
  });
};
```

**üéØ Key Takeaways:**

1. **Edge cases handled:**
   - ‚úÖ Prevent double submit (isLoading check)
   - ‚úÖ Clear errors on field change
   - ‚úÖ Validation before submit
   - ‚úÖ Reset form after success

2. **State transitions r√µ r√†ng:**
   - SUBMIT_START ‚Üí isLoading = true
   - SUBMIT_SUCCESS ‚Üí reset form
   - SUBMIT_ERROR ‚Üí show error, isLoading = false

3. **Pure functions:**
   - validate() l√† pure function
   - Reducer kh√¥ng c√≥ side effects

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Level 1: √Åp D·ª•ng Concept (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Chuy·ªÉn ƒë·ªïi useState sang useReducer
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: Context, useEffect (ch∆∞a c·∫ßn)
 *
 * Requirements:
 * 1. Chuy·ªÉn component d∆∞·ªõi t·ª´ useState ‚Üí useReducer
 * 2. Implement 3 actions: LIKE, UNLIKE, RESET
 * 3. Reducer ph·∫£i c√≥ default case throw error
 *
 * üí° G·ª£i √Ω:
 * - T·∫°o reducer function tr∆∞·ªõc
 * - ƒê·ªãnh nghƒ©a action types
 * - Thay useState b·∫±ng useReducer
 */

// ‚ùå C√ÅCH SAI: Kh√¥ng validate action type
function likeReducer(state, action) {
  // üö´ Missing default case
  if (action.type === 'LIKE') {
    return { likes: state.likes + 1 };
  }
  if (action.type === 'UNLIKE') {
    return { likes: Math.max(0, state.likes - 1) };
  }
  // ‚ö†Ô∏è Typo "RESETT" s·∫Ω kh√¥ng throw error!
  return state; // Silent fail
}

// ‚úÖ C√ÅCH ƒê√öNG: Lu√¥n c√≥ default case
function likeReducer(state, action) {
  switch (action.type) {
    case 'LIKE':
      return { likes: state.likes + 1 };
    case 'UNLIKE':
      return { likes: Math.max(0, state.likes - 1) };
    case 'RESET':
      return { likes: 0 };
    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N: Chuy·ªÉn component n√†y sang useReducer
function LikeButton() {
  const [likes, setLikes] = useState(0);

  return (
    <div>
      <h2>‚ù§Ô∏è {likes} likes</h2>
      <button onClick={() => setLikes(likes + 1)}>Like</button>
      <button onClick={() => setLikes(Math.max(0, likes - 1))}>Unlike</button>
      <button onClick={() => setLikes(0)}>Reset</button>
    </div>
  );
}

// TODO: Vi·∫øt l·∫°i component tr√™n v·ªõi useReducer
// function LikeButton() {
//   // Your code here
// }
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * LikeButton component using useReducer instead of multiple useState calls
 * Manages like count with actions: LIKE, UNLIKE, RESET
 */
import { useReducer } from 'react';

// 1. Reducer function - pure, predictable state transitions
function likeReducer(state, action) {
  switch (action.type) {
    case 'LIKE':
      return { likes: state.likes + 1 };

    case 'UNLIKE':
      return { likes: Math.max(0, state.likes - 1) };

    case 'RESET':
      return { likes: 0 };

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

function LikeButton() {
  const [state, dispatch] = useReducer(likeReducer, { likes: 0 });

  return (
    <div>
      <h2>‚ù§Ô∏è {state.likes} likes</h2>
      <button onClick={() => dispatch({ type: 'LIKE' })}>Like</button>
      <button onClick={() => dispatch({ type: 'UNLIKE' })}>Unlike</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
    </div>
  );
}

export default LikeButton;

/*
V√≠ d·ª• k·∫øt qu·∫£ khi t∆∞∆°ng t√°c:
Ban ƒë·∫ßu:          ‚ù§Ô∏è 0 likes
Nh·∫•n Like √ó3:     ‚ù§Ô∏è 3 likes
Nh·∫•n Unlike √ó2:   ‚ù§Ô∏è 1 like
Nh·∫•n Unlike √ó2:   ‚ù§Ô∏è 0 likes (kh√¥ng √¢m)
Nh·∫•n Reset:       ‚ù§Ô∏è 0 likes
Nh·∫•n Unlike khi 0: v·∫´n ‚ù§Ô∏è 0 likes (Math.max b·∫£o v·ªá)
*/
```

</details>

### ‚≠ê‚≠ê Level 2: Nh·∫≠n Bi·∫øt Pattern (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Quy·∫øt ƒë·ªãnh useState vs useReducer
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: B·∫°n c·∫ßn build Shopping Cart
 *
 * State c·∫ßn qu·∫£n l√Ω:
 * - items: [{ id, name, price, quantity }]
 * - totalPrice: number
 * - discountCode: string
 * - discountAmount: number
 *
 * Actions:
 * - ADD_ITEM
 * - REMOVE_ITEM
 * - UPDATE_QUANTITY
 * - APPLY_DISCOUNT
 * - CLEAR_CART
 *
 * ü§î PH√ÇN T√çCH:
 *
 * Approach A: Multiple useState
 * const [items, setItems] = useState([]);
 * const [totalPrice, setTotalPrice] = useState(0);
 * const [discountCode, setDiscountCode] = useState('');
 * const [discountAmount, setDiscountAmount] = useState(0);
 *
 * Pros:
 * - ƒê∆°n gi·∫£n v·ªõi state nh·ªè
 * - M·ªói state ƒë·ªôc l·∫≠p
 *
 * Cons:
 * - Ph·∫£i t√≠nh totalPrice manually m·ªói l·∫ßn items thay ƒë·ªïi
 * - Updates r·∫£i r√°c, d·ªÖ s√≥t
 * - Kh√≥ sync gi·ªØa items v√† totalPrice
 *
 * Approach B: useReducer
 * const [state, dispatch] = useReducer(cartReducer, initialState);
 *
 * Pros:
 * - State updates t·∫≠p trung
 * - totalPrice t·ª± ƒë·ªông update trong reducer
 * - D·ªÖ test, d·ªÖ debug
 * - Predictable state transitions
 *
 * Cons:
 * - Boilerplate code nhi·ªÅu h∆°n
 * - C·∫ßn hi·ªÉu reducer pattern
 *
 * üí≠ B·∫†N CH·ªåN G√å V√Ä T·∫†I SAO?
 * (Vi·∫øt 3-5 c√¢u gi·∫£i th√≠ch quy·∫øt ƒë·ªãnh)
 *
 * Sau ƒë√≥ implement approach b·∫°n ch·ªçn v·ªõi:
 * - Reducer function (n·∫øu ch·ªçn useReducer)
 * - Component v·ªõi 3 actions: ADD_ITEM, REMOVE_ITEM, CLEAR_CART
 * - Display total price
 */

// TODO: Vi·∫øt gi·∫£i th√≠ch + implementation
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Shopping Cart component - Decision: use useReducer
 * L√Ω do ch·ªçn useReducer thay v√¨ multiple useState:
 *
 * 1. State c√≥ nhi·ªÅu ph·∫ßn li√™n quan ch·∫∑t ch·∫Ω: items ‚Üí ·∫£nh h∆∞·ªüng tr·ª±c ti·∫øp ƒë·∫øn totalPrice
 * 2. C·∫ßn t√≠nh to√°n totalPrice m·ªói khi items thay ƒë·ªïi (ADD, REMOVE, UPDATE_QUANTITY)
 * 3. Nhi·ªÅu h√†nh ƒë·ªông ph·ª©c t·∫°p (APPLY_DISCOUNT, CLEAR_CART) c·∫ßn c·∫≠p nh·∫≠t nhi·ªÅu field c√πng l√∫c
 * 4. Logic t√≠nh to√°n v√† validation n√™n ƒë∆∞·ª£c t·∫≠p trung trong reducer ‚Üí d·ªÖ test, d·ªÖ debug
 * 5. Khi app m·ªü r·ªông (th√™m tax, shipping, coupons, persistence), useReducer d·ªÖ m·ªü r·ªông h∆°n
 *
 * Trade-off: boilerplate nhi·ªÅu h∆°n, nh∆∞ng maintainability cao h∆°n r·∫•t nhi·ªÅu
 */
import { useReducer, useState } from 'react';

// ================= REDUCER =================
function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM': {
      const existingItem = state.items.find(
        (item) => item.id === action.payload.id,
      );

      let newItems;
      if (existingItem) {
        // TƒÉng quantity n·∫øu ƒë√£ c√≥
        newItems = state.items.map((item) =>
          item.id === action.payload.id
            ? { ...item, quantity: item.quantity + 1 }
            : item,
        );
      } else {
        // Th√™m m·ªõi
        newItems = [...state.items, { ...action.payload, quantity: 1 }];
      }

      return {
        ...state,
        items: newItems,
        totalPrice: calculateTotal(newItems, state.discountAmount),
      };
    }

    case 'REMOVE_ITEM': {
      const newItems = state.items.filter(
        (item) => item.id !== action.payload.id,
      );
      return {
        ...state,
        items: newItems,
        totalPrice: calculateTotal(newItems, state.discountAmount),
      };
    }

    case 'UPDATE_QUANTITY': {
      const { id, quantity } = action.payload;
      if (quantity < 1) return state; // Kh√¥ng cho quantity < 1

      const newItems = state.items.map((item) =>
        item.id === id ? { ...item, quantity } : item,
      );

      return {
        ...state,
        items: newItems,
        totalPrice: calculateTotal(newItems, state.discountAmount),
      };
    }

    case 'APPLY_DISCOUNT': {
      const discountAmount = action.payload.amount; // gi·∫£ s·ª≠ ƒë√£ validate
      return {
        ...state,
        discountCode: action.payload.code,
        discountAmount,
        totalPrice: calculateTotal(state.items, discountAmount),
      };
    }

    case 'CLEAR_CART':
      return {
        ...state,
        items: [],
        totalPrice: 0,
        discountCode: '',
        discountAmount: 0,
      };

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// Helper function - t√≠nh t·ªïng ti·ªÅn (c√≥ th·ªÉ t√°ch ra custom hook sau n√†y)
function calculateTotal(items, discountAmount) {
  const subtotal = items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0,
  );
  return Math.max(0, subtotal - discountAmount);
}

// ================= COMPONENT =================
function ShoppingCart() {
  const initialState = {
    items: [],
    totalPrice: 0,
    discountCode: '',
    discountAmount: 0,
  };

  const [state, dispatch] = useReducer(cartReducer, initialState);
  const [newItemInput, setNewItemInput] = useState(''); // ch·ªâ d√πng t·∫°m ƒë·ªÉ demo

  // V√≠ d·ª• item m·∫´u (trong th·ª±c t·∫ø s·∫Ω t·ª´ API ho·∫∑c form)
  const sampleItems = [
    { id: 1, name: 'Laptop', price: 1200 },
    { id: 2, name: 'Mouse', price: 25 },
    { id: 3, name: 'Keyboard', price: 80 },
  ];

  const handleAddSample = (item) => {
    dispatch({ type: 'ADD_ITEM', payload: item });
  };

  const handleRemove = (id) => {
    dispatch({ type: 'REMOVE_ITEM', payload: { id } });
  };

  const handleUpdateQty = (id, quantity) => {
    dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } });
  };

  const handleClear = () => {
    dispatch({ type: 'CLEAR_CART' });
  };

  const handleApplyDiscount = () => {
    // Gi·∫£ l·∫≠p discount 10% cho v√≠ d·ª•
    const subtotal = state.items.reduce(
      (sum, i) => sum + i.price * i.quantity,
      0,
    );
    const discount = Math.round(subtotal * 0.1);
    dispatch({
      type: 'APPLY_DISCOUNT',
      payload: { code: 'SAVE10', amount: discount },
    });
  };

  return (
    <div>
      <h2>Shopping Cart</h2>

      {/* Danh s√°ch s·∫£n ph·∫©m m·∫´u ƒë·ªÉ th√™m */}
      <div style={{ marginBottom: '1rem' }}>
        <strong>Add sample items:</strong>{' '}
        {sampleItems.map((item) => (
          <button
            key={item.id}
            onClick={() => handleAddSample(item)}
            style={{ marginRight: '0.5rem' }}
          >
            + {item.name} (${item.price})
          </button>
        ))}
      </div>

      {/* Cart items */}
      {state.items.length === 0 ? (
        <p>Your cart is empty.</p>
      ) : (
        <>
          <ul style={{ listStyle: 'none', padding: 0 }}>
            {state.items.map((item) => (
              <li
                key={item.id}
                style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  marginBottom: '0.5rem',
                  padding: '0.5rem',
                  borderBottom: '1px solid #eee',
                }}
              >
                <div>
                  {item.name} √ó {item.quantity}
                </div>
                <div>
                  ${(item.price * item.quantity).toFixed(2)}
                  <button
                    onClick={() => handleUpdateQty(item.id, item.quantity + 1)}
                    style={{ marginLeft: '1rem' }}
                  >
                    +
                  </button>
                  <button
                    onClick={() => handleUpdateQty(item.id, item.quantity - 1)}
                    disabled={item.quantity <= 1}
                    style={{ marginLeft: '0.5rem' }}
                  >
                    -
                  </button>
                  <button
                    onClick={() => handleRemove(item.id)}
                    style={{ marginLeft: '1rem', color: 'red' }}
                  >
                    Remove
                  </button>
                </div>
              </li>
            ))}
          </ul>

          <div style={{ marginTop: '1rem', fontWeight: 'bold' }}>
            Subtotal: $
            {state.items
              .reduce((sum, i) => sum + i.price * i.quantity, 0)
              .toFixed(2)}
          </div>

          {state.discountAmount > 0 && (
            <div style={{ color: 'green' }}>
              Discount ({state.discountCode}): -$
              {state.discountAmount.toFixed(2)}
            </div>
          )}

          <div style={{ fontSize: '1.2rem', marginTop: '0.5rem' }}>
            Total: ${state.totalPrice.toFixed(2)}
          </div>

          <div style={{ marginTop: '1.5rem' }}>
            <button
              onClick={handleApplyDiscount}
              disabled={state.items.length === 0}
            >
              Apply 10% Discount
            </button>
            <button
              onClick={handleClear}
              style={{ marginLeft: '1rem', color: 'red' }}
              disabled={state.items.length === 0}
            >
              Clear Cart
            </button>
          </div>
        </>
      )}
    </div>
  );
}

export default ShoppingCart;

/*
V√≠ d·ª• k·∫øt qu·∫£ khi t∆∞∆°ng t√°c:
1. Nh·∫•n "+ Laptop" ‚Üí items: 1 Laptop, total: $1200
2. Nh·∫•n "+ Mouse" ‚Üí items: Laptop + Mouse, total: $1225
3. Nh·∫•n "+1" b√™n Laptop ‚Üí quantity Laptop = 2, total: $2425
4. Nh·∫•n "Apply 10% Discount" ‚Üí discount $242.5, total: $2182.50
5. Nh·∫•n "Clear Cart" ‚Üí gi·ªè h√†ng tr·ªëng, total: $0
*/
```

</details>

### ‚≠ê‚≠ê‚≠ê Level 3: K·ªãch B·∫£n Th·ª±c T·∫ø (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Build Multi-Step Form v·ªõi useReducer
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën ƒëi·ªÅn form ƒëƒÉng k√Ω 3 b∆∞·ªõc ƒë·ªÉ t·∫°o account"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Step 1: Personal Info (name, email)
 * - [ ] Step 2: Address (street, city, zipcode)
 * - [ ] Step 3: Review & Submit
 * - [ ] C√≥ n√∫t Next/Previous ƒë·ªÉ navigate
 * - [ ] Validate m·ªói step tr∆∞·ªõc khi Next
 * - [ ] Hi·ªÉn th·ªã progress (Step 1/3, 2/3, 3/3)
 * - [ ] Submit ·ªü step cu·ªëi
 *
 * üé® Technical Constraints:
 * - D√πng useReducer cho state management
 * - State shape: { currentStep, formData, errors, isSubmitting }
 * - Actions: NEXT_STEP, PREV_STEP, UPDATE_FIELD, SET_ERRORS, SUBMIT_START, SUBMIT_SUCCESS
 *
 * üö® Edge Cases c·∫ßn handle:
 * - Kh√¥ng Next n·∫øu c√≥ validation errors
 * - Kh√¥ng Previous t·ª´ step 1
 * - Kh√¥ng submit n·∫øu ƒëang isSubmitting
 * - Clear errors khi user s·ª≠a field
 *
 * üìù Implementation Checklist:
 * - [ ] Reducer v·ªõi 6 actions
 * - [ ] Validation function cho m·ªói step
 * - [ ] StepIndicator component
 * - [ ] Form fields cho 3 steps
 * - [ ] Navigation buttons v·ªõi disabled states
 */

// TODO: Implement Multi-Step Form

// G·ª£i √Ω State Shape:
const initialState = {
  currentStep: 1,
  formData: {
    // Step 1
    name: '',
    email: '',
    // Step 2
    street: '',
    city: '',
    zipcode: '',
  },
  errors: {},
  isSubmitting: false,
};

// G·ª£i √Ω Reducer:
// function multiStepReducer(state, action) {
//   switch (action.type) {
//     case 'NEXT_STEP': ...
//     case 'PREV_STEP': ...
//     case 'UPDATE_FIELD': ...
//     case 'SET_ERRORS': ...
//     case 'SUBMIT_START': ...
//     case 'SUBMIT_SUCCESS': ...
//   }
// }
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Multi-Step Registration Form using useReducer
 * 3 steps: Personal Info ‚Üí Address ‚Üí Review & Submit
 * Handles validation per step, navigation, and submission flow
 */
import { useReducer, useState } from 'react';

// ================= STATE & TYPES =================
const initialState = {
  currentStep: 1,
  formData: {
    // Step 1
    name: '',
    email: '',
    // Step 2
    street: '',
    city: '',
    zipcode: '',
  },
  errors: {},
  isSubmitting: false,
};

// ================= VALIDATION =================
const validateStep = (step, values) => {
  const errors = {};

  if (step === 1) {
    if (!values.name.trim()) {
      errors.name = 'Name is required';
    } else if (values.name.trim().length < 2) {
      errors.name = 'Name must be at least 2 characters';
    }

    if (!values.email) {
      errors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Please enter a valid email';
    }
  }

  if (step === 2) {
    if (!values.street.trim()) {
      errors.street = 'Street address is required';
    }
    if (!values.city.trim()) {
      errors.city = 'City is required';
    }
    if (!values.zipcode.trim()) {
      errors.zipcode = 'Zip code is required';
    } else if (!/^\d{5}(-\d{4})?$/.test(values.zipcode)) {
      errors.zipcode =
        'Please enter a valid zip code (e.g. 12345 or 12345-6789)';
    }
  }

  return errors;
};

// ================= REDUCER =================
function multiStepReducer(state, action) {
  switch (action.type) {
    case 'UPDATE_FIELD': {
      const { field, value } = action.payload;
      // Clear error for this field when user types
      const newErrors = { ...state.errors };
      if (newErrors[field]) delete newErrors[field];

      return {
        ...state,
        formData: {
          ...state.formData,
          [field]: value,
        },
        errors: newErrors,
      };
    }

    case 'SET_ERRORS':
      return {
        ...state,
        errors: action.payload.errors,
      };

    case 'NEXT_STEP': {
      const errors = validateStep(state.currentStep, state.formData);
      if (Object.keys(errors).length > 0) {
        return {
          ...state,
          errors,
        };
      }

      if (state.currentStep < 3) {
        return {
          ...state,
          currentStep: state.currentStep + 1,
          errors: {},
        };
      }
      return state;
    }

    case 'PREV_STEP':
      if (state.currentStep > 1) {
        return {
          ...state,
          currentStep: state.currentStep - 1,
          errors: {},
        };
      }
      return state;

    case 'SUBMIT_START':
      if (state.isSubmitting) return state;
      return {
        ...state,
        isSubmitting: true,
        errors: {},
      };

    case 'SUBMIT_SUCCESS':
      return {
        ...initialState,
        currentStep: 4, // success page
      };

    case 'SUBMIT_ERROR':
      return {
        ...state,
        isSubmitting: false,
        errors: { submit: action.payload.message },
      };

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// ================= COMPONENT =================
function MultiStepForm() {
  const [state, dispatch] = useReducer(multiStepReducer, initialState);

  const handleChange = (field) => (e) => {
    dispatch({
      type: 'UPDATE_FIELD',
      payload: { field, value: e.target.value },
    });
  };

  const handleNext = () => {
    dispatch({ type: 'NEXT_STEP' });
  };

  const handlePrev = () => {
    dispatch({ type: 'PREV_STEP' });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    // Final validation (though already checked on step 2 ‚Üí next)
    const finalErrors = validateStep(2, state.formData);
    if (Object.keys(finalErrors).length > 0) {
      dispatch({ type: 'SET_ERRORS', payload: { errors: finalErrors } });
      return;
    }

    dispatch({ type: 'SUBMIT_START' });

    // Simulate API call
    try {
      await new Promise((resolve) => setTimeout(resolve, 1500));
      // Uncomment to test error:
      // throw new Error('Server is down');

      dispatch({ type: 'SUBMIT_SUCCESS' });
    } catch (err) {
      dispatch({
        type: 'SUBMIT_ERROR',
        payload: { message: err.message || 'Something went wrong' },
      });
    }
  };

  const StepIndicator = () => (
    <div style={{ marginBottom: '2rem', textAlign: 'center' }}>
      <strong>Step {state.currentStep} of 3</strong>
      <div style={{ marginTop: '0.5rem' }}>
        {[1, 2, 3].map((step) => (
          <span
            key={step}
            style={{
              display: 'inline-block',
              width: '30px',
              height: '30px',
              lineHeight: '30px',
              borderRadius: '50%',
              background: state.currentStep >= step ? '#4CAF50' : '#ddd',
              color: 'white',
              margin: '0 8px',
              fontWeight: 'bold',
            }}
          >
            {step}
          </span>
        ))}
      </div>
    </div>
  );

  if (state.currentStep === 4) {
    return (
      <div style={{ textAlign: 'center', padding: '2rem' }}>
        <h2>Registration Successful! üéâ</h2>
        <p>Thank you for signing up.</p>
        <p>Name: {state.formData.name}</p>
        <p>Email: {state.formData.email}</p>
        <p>
          Address: {state.formData.street}, {state.formData.city}{' '}
          {state.formData.zipcode}
        </p>
      </div>
    );
  }

  return (
    <div style={{ maxWidth: '500px', margin: '0 auto', padding: '2rem' }}>
      <h1>Register</h1>
      <StepIndicator />

      <form onSubmit={handleSubmit}>
        {state.currentStep === 1 && (
          <>
            <h3>Personal Information</h3>
            <div style={{ marginBottom: '1rem' }}>
              <label>Name:</label>
              <input
                type='text'
                value={state.formData.name}
                onChange={handleChange('name')}
                placeholder='John Doe'
                style={{ width: '100%', padding: '8px', marginTop: '4px' }}
              />
              {state.errors.name && (
                <span style={{ color: 'red' }}>{state.errors.name}</span>
              )}
            </div>

            <div style={{ marginBottom: '1rem' }}>
              <label>Email:</label>
              <input
                type='email'
                value={state.formData.email}
                onChange={handleChange('email')}
                placeholder='john@example.com'
                style={{ width: '100%', padding: '8px', marginTop: '4px' }}
              />
              {state.errors.email && (
                <span style={{ color: 'red' }}>{state.errors.email}</span>
              )}
            </div>
          </>
        )}

        {state.currentStep === 2 && (
          <>
            <h3>Address</h3>
            <div style={{ marginBottom: '1rem' }}>
              <label>Street:</label>
              <input
                type='text'
                value={state.formData.street}
                onChange={handleChange('street')}
                placeholder='123 Main St'
                style={{ width: '100%', padding: '8px', marginTop: '4px' }}
              />
              {state.errors.street && (
                <span style={{ color: 'red' }}>{state.errors.street}</span>
              )}
            </div>

            <div style={{ marginBottom: '1rem' }}>
              <label>City:</label>
              <input
                type='text'
                value={state.formData.city}
                onChange={handleChange('city')}
                placeholder='New York'
                style={{ width: '100%', padding: '8px', marginTop: '4px' }}
              />
              {state.errors.city && (
                <span style={{ color: 'red' }}>{state.errors.city}</span>
              )}
            </div>

            <div style={{ marginBottom: '1rem' }}>
              <label>Zip Code:</label>
              <input
                type='text'
                value={state.formData.zipcode}
                onChange={handleChange('zipcode')}
                placeholder='10001'
                style={{ width: '100%', padding: '8px', marginTop: '4px' }}
              />
              {state.errors.zipcode && (
                <span style={{ color: 'red' }}>{state.errors.zipcode}</span>
              )}
            </div>
          </>
        )}

        {state.currentStep === 3 && (
          <>
            <h3>Review & Submit</h3>
            <div style={{ marginBottom: '1rem' }}>
              <strong>Name:</strong> {state.formData.name || '‚Äî'}
            </div>
            <div style={{ marginBottom: '1rem' }}>
              <strong>Email:</strong> {state.formData.email || '‚Äî'}
            </div>
            <div style={{ marginBottom: '1rem' }}>
              <strong>Address:</strong> {state.formData.street || '‚Äî'},{' '}
              {state.formData.city || '‚Äî'} {state.formData.zipcode || '‚Äî'}
            </div>

            {state.errors.submit && (
              <div style={{ color: 'red', margin: '1rem 0' }}>
                {state.errors.submit}
              </div>
            )}
          </>
        )}

        <div
          style={{
            marginTop: '2rem',
            display: 'flex',
            gap: '1rem',
            justifyContent: 'space-between',
          }}
        >
          <button
            type='button'
            onClick={handlePrev}
            disabled={state.currentStep === 1 || state.isSubmitting}
            style={{ padding: '10px 20px', minWidth: '100px' }}
          >
            Previous
          </button>

          {state.currentStep < 3 ? (
            <button
              type='button'
              onClick={handleNext}
              disabled={state.isSubmitting}
              style={{
                padding: '10px 20px',
                minWidth: '100px',
                background: '#4CAF50',
                color: 'white',
              }}
            >
              Next
            </button>
          ) : (
            <button
              type='submit'
              disabled={state.isSubmitting}
              style={{
                padding: '10px 20px',
                minWidth: '120px',
                background: state.isSubmitting ? '#999' : '#2196F3',
                color: 'white',
              }}
            >
              {state.isSubmitting ? 'Submitting...' : 'Submit'}
            </button>
          )}
        </div>
      </form>
    </div>
  );
}

export default MultiStepForm;

/*
V√≠ d·ª• k·∫øt qu·∫£ khi t∆∞∆°ng t√°c:
1. Step 1 ‚Üí nh·∫≠p name & email h·ª£p l·ªá ‚Üí Next ‚Üí Step 2
2. Step 2 ‚Üí nh·∫≠p address h·ª£p l·ªá ‚Üí Next ‚Üí Step 3 (Review)
3. Step 3 ‚Üí th·∫•y to√†n b·ªô th√¥ng tin ‚Üí Submit
   ‚Üí isSubmitting = true (n√∫t disable)
   ‚Üí sau 1.5s ‚Üí Success screen v·ªõi d·ªØ li·ªáu ƒë√£ nh·∫≠p
4. Tr∆∞·ªùng h·ª£p l·ªói:
   - Step 1 thi·∫øu name ‚Üí Next ‚Üí hi·ªÉn th·ªã l·ªói ƒë·ªè, kh√¥ng chuy·ªÉn step
   - Submit th·∫•t b·∫°i (n·∫øu throw error) ‚Üí hi·ªÉn th·ªã th√¥ng b√°o l·ªói
*/
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê Level 4: Quy·∫øt ƒê·ªãnh Ki·∫øn Tr√∫c (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Thi·∫øt k·∫ø State Management cho Complex Feature
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Context: B·∫°n ƒëang build Kanban Board (nh∆∞ Trello)
 *
 * Requirements:
 * - 3 columns: Todo, In Progress, Done
 * - M·ªói column c√≥ nhi·ªÅu cards
 * - Drag & drop cards gi·ªØa columns
 * - Add/Edit/Delete cards
 * - Filter cards by tag
 * - Search cards by title
 *
 * State Shape Options:
 *
 * Option A: Normalized State
 * {
 *   columns: { 'todo': {...}, 'inProgress': {...}, 'done': {...} },
 *   cards: { 'card1': {...}, 'card2': {...} },
 *   columnOrder: ['todo', 'inProgress', 'done'],
 *   filter: { tag: null, searchText: '' }
 * }
 *
 * Option B: Nested State
 * {
 *   columns: [
 *     { id: 'todo', title: 'Todo', cards: [...] },
 *     { id: 'inProgress', title: 'In Progress', cards: [...] },
 *     { id: 'done', title: 'Done', cards: [...] }
 *   ],
 *   filter: { tag: null, searchText: '' }
 * }
 *
 * Option C: Separate Reducers
 * - columnsReducer
 * - cardsReducer
 * - filterReducer
 * (Combine v·ªõi combineReducers pattern - t·ª± research)
 *
 * Nhi·ªám v·ª•:
 * 1. So s√°nh 3 approaches
 * 2. Document pros/cons
 * 3. Ch·ªçn approach t·ªët nh·∫•t
 * 4. Vi·∫øt ADR
 *
 * üìù ADR Template:
 *
 * ## Context
 * Kanban Board c·∫ßn qu·∫£n l√Ω columns, cards, filters. Drag & drop y√™u c·∫ßu
 * c·∫≠p nh·∫≠t positions nhanh...
 *
 * ## Decision
 * Ch·ªçn Option A: Normalized State
 *
 * ## Rationale
 * - Performance: Update card kh√¥ng c·∫ßn clone entire column
 * - Flexibility: D·ªÖ reference card t·ª´ multiple places
 * - Scalability: D·ªÖ add features (card comments, attachments)
 *
 * ## Consequences
 * Trade-offs:
 * + Fast updates
 * + Easy to find card by ID
 * - More complex queries (need to join data)
 * - Need utility functions to denormalize
 *
 * ## Alternatives Considered
 * - Option B: Simpler but slow for large datasets
 * - Option C: Over-engineering for this scale
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 * Implement reducer v·ªõi approach ƒë√£ ch·ªçn
 * - At least 5 actions: MOVE_CARD, ADD_CARD, DELETE_CARD, UPDATE_FILTER, CLEAR_FILTER
 * - Helper functions n·∫øu c·∫ßn (denormalize, etc.)
 *
 * üß™ PHASE 3: Testing (10 ph√∫t)
 * Manual test cases:
 * - [ ] Move card from Todo to In Progress
 * - [ ] Move card back
 * - [ ] Delete card updates column
 * - [ ] Filter by tag
 * - [ ] Search by title
 */

// TODO: Vi·∫øt ADR + Implementation
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Kanban Board Architecture Decision & Implementation using useReducer
 * Level 4: Quy·∫øt ƒê·ªãnh Ki·∫øn Tr√∫c - Ch·ªçn Normalized State (Option A)
 *
 * ## Context
 * X√¢y d·ª±ng Kanban Board gi·ªëng Trello v·ªõi drag & drop, add/edit/delete cards,
 * filter by tag, search by title. Y√™u c·∫ßu performance t·ªët khi c√≥ nhi·ªÅu cards,
 * d·ªÖ update v·ªã tr√≠ khi drag, v√† d·ªÖ m·ªü r·ªông (comments, attachments, assignees).
 *
 * ## Decision
 * Ch·ªçn Option A: Normalized State (flat structure)
 * {
 *   columns: { [columnId]: { id, title, cardIds: string[] } },
 *   cards: { [cardId]: { id, title, description, tags, columnId } },
 *   columnOrder: string[],
 *   filters: { tag: null | string, searchText: '' }
 * }
 *
 * ## Rationale
 * - Performance: Khi drag & drop ch·ªâ c·∫ßn c·∫≠p nh·∫≠t cardIds array c·ªßa 2 columns ‚Üí kh√¥ng clone to√†n b·ªô state
 * - Flexibility: D·ªÖ truy xu·∫•t card b·∫±ng ID t·ª´ b·∫•t k·ª≥ ƒë√¢u (filter, search, edit)
 * - Scalability: D·ªÖ th√™m fields cho card (comments, dueDate, attachments) m√† kh√¥ng l√†m nested state s√¢u
 * - Drag & drop: Ch·ªâ c·∫ßn thay ƒë·ªïi cardIds v√† columnId ‚Üí immutable update nhanh
 * - Filter/Search: Duy·ªát cards object thay v√¨ nested arrays ‚Üí d·ªÖ implement
 *
 * ## Consequences (Trade-offs)
 * + Update nhanh, kh√¥ng c·∫ßn deep clone
 * + D·ªÖ t√¨m card theo ID
 * + D·ªÖ serialize cho localStorage ho·∫∑c API
 * - C·∫ßn helper functions ƒë·ªÉ "denormalize" khi render (k·∫øt h·ª£p cards + columns)
 * - Query ph·ª©c t·∫°p h∆°n m·ªôt ch√∫t so v·ªõi nested (nh∆∞ng ch·∫•p nh·∫≠n ƒë∆∞·ª£c)
 *
 * ## Alternatives Considered
 * - Option B (Nested): D·ªÖ ƒë·ªçc ban ƒë·∫ßu, nh∆∞ng drag & drop ch·∫≠m khi clone arrays l·ªõn
 * - Option C (Separate Reducers): Over-engineering cho feature n√†y, ph·ª©c t·∫°p h∆°n c·∫ßn thi·∫øt
 */

/**
 * Kanban Board component with normalized state + useReducer
 */
import { useReducer } from 'react';

// ================= TYPES & INITIAL STATE =================
const initialState = {
  columns: {
    todo: { id: 'todo', title: 'Todo', cardIds: [] },
    inprogress: { id: 'inprogress', title: 'In Progress', cardIds: [] },
    done: { id: 'done', title: 'Done', cardIds: [] },
  },
  cards: {},
  columnOrder: ['todo', 'inprogress', 'done'],
  filters: {
    tag: null, // null = all
    searchText: '',
  },
};

// ================= HELPER FUNCTIONS =================
const denormalizeColumn = (state, columnId) => {
  const column = state.columns[columnId];
  const cards = column.cardIds
    .map((id) => state.cards[id])
    .filter((card) => {
      if (state.filters.searchText) {
        return card.title
          .toLowerCase()
          .includes(state.filters.searchText.toLowerCase());
      }
      if (state.filters.tag) {
        return card.tags?.includes(state.filters.tag);
      }
      return true;
    });
  return { ...column, cards };
};

const getFilteredColumns = (state) => {
  return state.columnOrder.map((colId) => denormalizeColumn(state, colId));
};

// ================= REDUCER =================
function kanbanReducer(state, action) {
  switch (action.type) {
    case 'ADD_CARD': {
      const { title, columnId } = action.payload;
      const cardId = `card-${Date.now()}`;
      const newCard = {
        id: cardId,
        title,
        description: '',
        tags: [],
        columnId,
      };

      return {
        ...state,
        cards: {
          ...state.cards,
          [cardId]: newCard,
        },
        columns: {
          ...state.columns,
          [columnId]: {
            ...state.columns[columnId],
            cardIds: [...state.columns[columnId].cardIds, cardId],
          },
        },
      };
    }

    case 'DELETE_CARD': {
      const { cardId } = action.payload;
      const card = state.cards[cardId];
      if (!card) return state;

      const { [cardId]: removed, ...remainingCards } = state.cards;
      const column = state.columns[card.columnId];
      const newCardIds = column.cardIds.filter((id) => id !== cardId);

      return {
        ...state,
        cards: remainingCards,
        columns: {
          ...state.columns,
          [card.columnId]: {
            ...column,
            cardIds: newCardIds,
          },
        },
      };
    }

    case 'MOVE_CARD': {
      const { cardId, sourceColumnId, targetColumnId, newIndex } =
        action.payload;
      const card = state.cards[cardId];
      if (!card) return state;

      // Remove from source
      const sourceColumn = state.columns[sourceColumnId];
      const sourceCardIds = sourceColumn.cardIds.filter((id) => id !== cardId);

      // Add to target at new position
      const targetColumn = state.columns[targetColumnId];
      const targetCardIds = [...targetColumn.cardIds];
      targetCardIds.splice(newIndex, 0, cardId);

      return {
        ...state,
        cards: {
          ...state.cards,
          [cardId]: { ...card, columnId: targetColumnId },
        },
        columns: {
          ...state.columns,
          [sourceColumnId]: { ...sourceColumn, cardIds: sourceCardIds },
          [targetColumnId]: { ...targetColumn, cardIds: targetCardIds },
        },
      };
    }

    case 'UPDATE_FILTER': {
      return {
        ...state,
        filters: {
          ...state.filters,
          ...action.payload,
        },
      };
    }

    case 'CLEAR_FILTER':
      return {
        ...state,
        filters: { tag: null, searchText: '' },
      };

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// ================= COMPONENT =================
function KanbanBoard() {
  const [state, dispatch] = useReducer(kanbanReducer, initialState);

  const filteredColumns = getFilteredColumns(state);

  const handleAddCard = (columnId) => {
    const title = prompt('Enter card title:');
    if (title?.trim()) {
      dispatch({
        type: 'ADD_CARD',
        payload: { title: title.trim(), columnId },
      });
    }
  };

  const handleDeleteCard = (cardId) => {
    if (window.confirm('Delete this card?')) {
      dispatch({ type: 'DELETE_CARD', payload: { cardId } });
    }
  };

  // Drag & Drop handlers (gi·∫£ l·∫≠p b·∫±ng buttons cho demo)
  const handleMoveCard = (cardId, sourceColumnId, targetColumnId, index) => {
    dispatch({
      type: 'MOVE_CARD',
      payload: { cardId, sourceColumnId, targetColumnId, newIndex: index },
    });
  };

  const handleSearch = (e) => {
    dispatch({
      type: 'UPDATE_FILTER',
      payload: { searchText: e.target.value },
    });
  };

  const handleFilterTag = (tag) => {
    dispatch({
      type: 'UPDATE_FILTER',
      payload: { tag: tag || null },
    });
  };

  return (
    <div style={{ padding: '2rem' }}>
      <h1>Kanban Board</h1>

      {/* Controls */}
      <div
        style={{
          marginBottom: '2rem',
          display: 'flex',
          gap: '1rem',
          alignItems: 'center',
        }}
      >
        <input
          type='text'
          placeholder='Search cards...'
          onChange={handleSearch}
          style={{ padding: '8px', flex: 1, maxWidth: '300px' }}
        />
        <select
          onChange={(e) => handleFilterTag(e.target.value)}
          defaultValue=''
        >
          <option value=''>All Tags</option>
          <option value='urgent'>Urgent</option>
          <option value='feature'>Feature</option>
          <option value='bug'>Bug</option>
        </select>
        <button onClick={() => dispatch({ type: 'CLEAR_FILTER' })}>
          Clear Filters
        </button>
      </div>

      {/* Board */}
      <div style={{ display: 'flex', gap: '1.5rem', overflowX: 'auto' }}>
        {filteredColumns.map((column) => (
          <div
            key={column.id}
            style={{
              background: '#f4f5f7',
              borderRadius: '8px',
              padding: '1rem',
              minWidth: '300px',
            }}
          >
            <h3>
              {column.title} ({column.cards.length})
            </h3>

            <button
              onClick={() => handleAddCard(column.id)}
              style={{ marginBottom: '1rem', width: '100%' }}
            >
              + Add Card
            </button>

            <div style={{ minHeight: '200px' }}>
              {column.cards.map((card, index) => (
                <div
                  key={card.id}
                  style={{
                    background: 'white',
                    padding: '1rem',
                    marginBottom: '0.8rem',
                    borderRadius: '6px',
                    boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
                  }}
                >
                  <strong>{card.title}</strong>
                  <div style={{ marginTop: '0.5rem', fontSize: '0.9rem' }}>
                    Tags: {card.tags?.join(', ') || '‚Äî'}
                  </div>
                  <div
                    style={{
                      marginTop: '0.8rem',
                      display: 'flex',
                      gap: '0.5rem',
                    }}
                  >
                    <button
                      onClick={() => handleDeleteCard(card.id)}
                      style={{ color: 'red', fontSize: '0.9rem' }}
                    >
                      Delete
                    </button>
                    {/* Drag & drop demo buttons */}
                    {column.id !== 'todo' && (
                      <button
                        onClick={() =>
                          handleMoveCard(card.id, column.id, 'todo', 0)
                        }
                        style={{ fontSize: '0.9rem' }}
                      >
                        ‚Üê To Todo
                      </button>
                    )}
                    {column.id !== 'done' && (
                      <button
                        onClick={() =>
                          handleMoveCard(card.id, column.id, 'done', 0)
                        }
                        style={{ fontSize: '0.9rem' }}
                      >
                        ‚Üí To Done
                      </button>
                    )}
                  </div>
                </div>
              ))}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

export default KanbanBoard;

/*
V√≠ d·ª• k·∫øt qu·∫£ khi t∆∞∆°ng t√°c:
1. Nh·∫•n "+ Add Card" ·ªü Todo ‚Üí nh·∫≠p "Implement login" ‚Üí card xu·∫•t hi·ªán ·ªü Todo
2. Nh·∫•n "‚Üí To Done" ‚Üí card di chuy·ªÉn sang Done column
3. G√µ "login" v√†o search ‚Üí ch·ªâ hi·ªÉn th·ªã card c√≥ "login" trong title
4. Ch·ªçn tag "urgent" ‚Üí ch·ªâ hi·ªÉn th·ªã cards c√≥ tag urgent
5. Nh·∫•n "Delete" ‚Üí card bi·∫øn m·∫•t, column card count gi·∫£m
6. Nh·∫•n "Clear Filters" ‚Üí tr·ªü l·∫°i hi·ªÉn th·ªã t·∫•t c·∫£
*/
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Level 5: Production Challenge (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Build Production-Ready Feature
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 *
 * Build "E-commerce Product Listing v·ªõi Advanced Filters"
 *
 * Features:
 * 1. Display products grid (from API)
 * 2. Filters:
 *    - Category (Electronics, Clothing, Books)
 *    - Price range (slider)
 *    - Rating (1-5 stars)
 *    - In stock only (checkbox)
 * 3. Sorting:
 *    - Price: Low to High / High to Low
 *    - Rating: High to Low
 *    - Name: A-Z
 * 4. Pagination:
 *    - 12 items per page
 *    - Next/Previous buttons
 * 5. Search by product name
 * 6. URL sync (filters should be in URL query params)
 *
 * üèóÔ∏è Technical Design Doc:
 *
 * 1. Component Architecture:
 *    - ProductListing (container)
 *    - FilterPanel
 *    - ProductGrid
 *    - ProductCard
 *    - Pagination
 *
 * 2. State Management Strategy:
 *    - useReducer cho filter state
 *    - useState cho products data (ho·∫∑c useReducer)
 *    - Decision: T·∫°i sao?
 *
 * 3. API Integration:
 *    - Mock API: https://fakestoreapi.com/products
 *    - Client-side filtering (API kh√¥ng support filters)
 *
 * 4. Performance Considerations:
 *    - useMemo cho filtered/sorted products
 *    - Debounce search input
 *    - Lazy load images
 *
 * 5. Error Handling Strategy:
 *    - API errors
 *    - No results state
 *    - Loading states
 *
 * ‚úÖ Production Checklist:
 * - [ ] TypeScript types (optional, nh∆∞ng document types)
 * - [ ] Error boundaries (optional, nh∆∞ng mention)
 * - [ ] Loading states (skeleton UI)
 * - [ ] Empty states ("No products found")
 * - [ ] Error states ("Failed to load")
 * - [ ] Mobile responsive (basic)
 * - [ ] Accessibility:
 *   - [ ] Keyboard navigation
 *   - [ ] ARIA labels cho filters
 *   - [ ] Focus management
 * - [ ] Performance:
 *   - [ ] Memoize expensive calculations
 *   - [ ] Debounce search
 * - [ ] Code quality:
 *   - [ ] Reducer tests (pseudo-code OK)
 *   - [ ] Helper functions documented
 *   - [ ] Clear naming
 *
 * üìù Documentation:
 * - README v·ªõi setup instructions
 * - Reducer actions documentation
 * - State shape documentation
 *
 * üîç Code Review Self-Checklist:
 * - [ ] Reducer is pure function
 * - [ ] No missing default case
 * - [ ] Actions have clear names
 * - [ ] State updates are immutable
 * - [ ] Edge cases handled
 * - [ ] Comments cho complex logic
 */

// TODO: Full implementation

// Starter Code:

// Mock API call
const fetchProducts = async () => {
  const response = await fetch('https://fakestoreapi.com/products');
  return response.json();
};

// State Shape (g·ª£i √Ω):
const initialState = {
  filters: {
    category: 'all',
    priceRange: [0, 1000],
    rating: 0,
    inStock: false,
    searchText: '',
  },
  sort: {
    field: 'name', // 'name' | 'price' | 'rating'
    order: 'asc', // 'asc' | 'desc'
  },
  pagination: {
    currentPage: 1,
    itemsPerPage: 12,
  },
};

// Reducer Actions:
// - SET_CATEGORY
// - SET_PRICE_RANGE
// - SET_RATING
// - TOGGLE_IN_STOCK
// - SET_SEARCH
// - SET_SORT
// - SET_PAGE
// - RESET_FILTERS
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * E-commerce Product Listing with Advanced Filters & Pagination
 * Production-ready version using useReducer for filter + sort + pagination state
 * Client-side filtering & sorting from Fake Store API
 */
import { useReducer, useEffect, useState, useMemo, useCallback } from 'react';

// ================= TYPES & INITIAL STATE =================
const initialState = {
  products: [],
  filteredProducts: [],
  filters: {
    category: 'all',
    priceRange: [0, 1000],
    rating: 0,
    inStock: false, // FakeStore has no real stock ‚Üí simulate with random
    searchText: '',
  },
  sort: {
    field: 'title', // 'title' | 'price' | 'rating'
    order: 'asc', // 'asc' | 'desc'
  },
  pagination: {
    currentPage: 1,
    itemsPerPage: 12,
  },
  loading: true,
  error: null,
};

// ================= REDUCER =================
function productReducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };

    case 'FETCH_SUCCESS':
      return {
        ...state,
        products: action.payload,
        loading: false,
        error: null,
      };

    case 'FETCH_ERROR':
      return {
        ...state,
        loading: false,
        error: action.payload,
      };

    case 'SET_CATEGORY':
    case 'SET_PRICE_RANGE':
    case 'SET_RATING':
    case 'TOGGLE_IN_STOCK':
    case 'SET_SEARCH':
    case 'SET_SORT':
    case 'SET_PAGE':
      return {
        ...state,
        [action.payload.key]: action.payload.value,
        pagination:
          action.type === 'SET_PAGE'
            ? { ...state.pagination, currentPage: action.payload.value }
            : state.pagination,
      };

    case 'RESET_FILTERS':
      return {
        ...state,
        filters: initialState.filters,
        sort: initialState.sort,
        pagination: { ...state.pagination, currentPage: 1 },
      };

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// ================= HELPER: APPLY FILTERS & SORT =================
const applyFiltersAndSort = (products, filters, sort) => {
  let result = [...products];

  // Search
  if (filters.searchText) {
    const search = filters.searchText.toLowerCase();
    result = result.filter(
      (p) =>
        p.title.toLowerCase().includes(search) ||
        p.description.toLowerCase().includes(search),
    );
  }

  // Category
  if (filters.category !== 'all') {
    result = result.filter((p) => p.category === filters.category);
  }

  // Price range
  result = result.filter(
    (p) => p.price >= filters.priceRange[0] && p.price <= filters.priceRange[1],
  );

  // Rating
  if (filters.rating > 0) {
    result = result.filter((p) => p.rating.rate >= filters.rating);
  }

  // In stock (simulated)
  if (filters.inStock) {
    result = result.filter(() => Math.random() > 0.3); // ~70% in stock
  }

  // Sorting
  result.sort((a, b) => {
    let aVal =
      sort.field === 'title'
        ? a.title
        : sort.field === 'price'
          ? a.price
          : a.rating.rate;
    let bVal =
      sort.field === 'title'
        ? b.title
        : sort.field === 'price'
          ? b.price
          : b.rating.rate;

    if (typeof aVal === 'string') {
      return sort.order === 'asc'
        ? aVal.localeCompare(bVal)
        : bVal.localeCompare(aVal);
    }

    return sort.order === 'asc' ? aVal - bVal : bVal - aVal;
  });

  return result;
};

// ================= COMPONENT =================
function ProductListing() {
  const [state, dispatch] = useReducer(productReducer, initialState);
  const [debouncedSearch, setDebouncedSearch] = useState(
    state.filters.searchText,
  );

  // Fetch products
  useEffect(() => {
    const fetchProducts = async () => {
      dispatch({ type: 'FETCH_START' });
      try {
        const res = await fetch('https://fakestoreapi.com/products');
        if (!res.ok) throw new Error('Failed to fetch products');
        const data = await res.json();
        dispatch({ type: 'FETCH_SUCCESS', payload: data });
      } catch (err) {
        dispatch({ type: 'FETCH_ERROR', payload: err.message });
      }
    };
    fetchProducts();
  }, []);

  // Debounce search
  useEffect(() => {
    const timer = setTimeout(() => {
      dispatch({
        type: 'SET_SEARCH',
        payload: {
          key: 'filters',
          value: { ...state.filters, searchText: debouncedSearch },
        },
      });
    }, 400);

    return () => clearTimeout(timer);
  }, [debouncedSearch]);

  // Computed filtered & sorted products
  const processedProducts = useMemo(() => {
    return applyFiltersAndSort(state.products, state.filters, state.sort);
  }, [state.products, state.filters, state.sort]);

  // Pagination slice
  const paginatedProducts = useMemo(() => {
    const start =
      (state.pagination.currentPage - 1) * state.pagination.itemsPerPage;
    return processedProducts.slice(
      start,
      start + state.pagination.itemsPerPage,
    );
  }, [processedProducts, state.pagination]);

  const totalPages = Math.ceil(
    processedProducts.length / state.pagination.itemsPerPage,
  );

  // Handlers
  const handleCategoryChange = (e) => {
    dispatch({
      type: 'SET_CATEGORY',
      payload: {
        key: 'filters',
        value: { ...state.filters, category: e.target.value },
      },
    });
    dispatch({ type: 'SET_PAGE', payload: { key: 'pagination', value: 1 } });
  };

  const handlePriceChange = (e, bound) => {
    const newRange = [...state.filters.priceRange];
    newRange[bound] = Number(e.target.value);
    dispatch({
      type: 'SET_PRICE_RANGE',
      payload: {
        key: 'filters',
        value: { ...state.filters, priceRange: newRange },
      },
    });
    dispatch({ type: 'SET_PAGE', payload: { key: 'pagination', value: 1 } });
  };

  const handleRatingChange = (e) => {
    dispatch({
      type: 'SET_RATING',
      payload: {
        key: 'filters',
        value: { ...state.filters, rating: Number(e.target.value) },
      },
    });
    dispatch({ type: 'SET_PAGE', payload: { key: 'pagination', value: 1 } });
  };

  const toggleInStock = () => {
    dispatch({
      type: 'TOGGLE_IN_STOCK',
      payload: {
        key: 'filters',
        value: { ...state.filters, inStock: !state.filters.inStock },
      },
    });
    dispatch({ type: 'SET_PAGE', payload: { key: 'pagination', value: 1 } });
  };

  const handleSearchChange = (e) => {
    setDebouncedSearch(e.target.value);
  };

  const handleSortChange = (field) => {
    const newSort = {
      field,
      order:
        state.sort.field === field && state.sort.order === 'asc'
          ? 'desc'
          : 'asc',
    };
    dispatch({
      type: 'SET_SORT',
      payload: { key: 'sort', value: newSort },
    });
  };

  const goToPage = (page) => {
    if (page >= 1 && page <= totalPages) {
      dispatch({
        type: 'SET_PAGE',
        payload: { key: 'pagination', value: page },
      });
    }
  };

  if (state.loading)
    return (
      <div style={{ textAlign: 'center', padding: '4rem' }}>
        Loading products...
      </div>
    );
  if (state.error)
    return (
      <div style={{ color: 'red', textAlign: 'center', padding: '4rem' }}>
        Error: {state.error}
      </div>
    );

  return (
    <div style={{ padding: '2rem', maxWidth: '1400px', margin: '0 auto' }}>
      <h1>Products</h1>

      {/* Filters Panel */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
          gap: '1.5rem',
          marginBottom: '2rem',
          background: '#f9f9f9',
          padding: '1.5rem',
          borderRadius: '8px',
        }}
      >
        <div>
          <label>Search</label>
          <input
            type='text'
            value={debouncedSearch}
            onChange={handleSearchChange}
            placeholder='Search by name or description...'
            style={{ width: '100%', padding: '8px', marginTop: '4px' }}
          />
        </div>

        <div>
          <label>Category</label>
          <select
            value={state.filters.category}
            onChange={handleCategoryChange}
            style={{ width: '100%', padding: '8px', marginTop: '4px' }}
          >
            <option value='all'>All Categories</option>
            <option value="men's clothing">Men's Clothing</option>
            <option value="women's clothing">Women's Clothing</option>
            <option value='jewelery'>Jewelry</option>
            <option value='electronics'>Electronics</option>
          </select>
        </div>

        <div>
          <label>Min Price: ${state.filters.priceRange[0]}</label>
          <input
            type='range'
            min='0'
            max='1000'
            value={state.filters.priceRange[0]}
            onChange={(e) => handlePriceChange(e, 0)}
            style={{ width: '100%' }}
          />
        </div>

        <div>
          <label>Max Price: ${state.filters.priceRange[1]}</label>
          <input
            type='range'
            min='0'
            max='1000'
            value={state.filters.priceRange[1]}
            onChange={(e) => handlePriceChange(e, 1)}
            style={{ width: '100%' }}
          />
        </div>

        <div>
          <label>Minimum Rating</label>
          <select
            value={state.filters.rating}
            onChange={handleRatingChange}
            style={{ width: '100%', padding: '8px', marginTop: '4px' }}
          >
            <option value={0}>Any</option>
            {[1, 2, 3, 4].map((r) => (
              <option
                key={r}
                value={r}
              >
                {r}+ Stars
              </option>
            ))}
          </select>
        </div>

        <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
          <input
            type='checkbox'
            checked={state.filters.inStock}
            onChange={toggleInStock}
            id='instock'
          />
          <label htmlFor='instock'>In Stock Only (simulated)</label>
        </div>

        <div style={{ gridColumn: '1 / -1', textAlign: 'right' }}>
          <button
            onClick={() => dispatch({ type: 'RESET_FILTERS' })}
            style={{
              padding: '8px 16px',
              background: '#e74c3c',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
            }}
          >
            Reset Filters
          </button>
        </div>
      </div>

      {/* Sort Controls */}
      <div
        style={{
          marginBottom: '1.5rem',
          display: 'flex',
          gap: '1rem',
          flexWrap: 'wrap',
        }}
      >
        <strong>Sort by:</strong>
        {['title', 'price', 'rating'].map((field) => (
          <button
            key={field}
            onClick={() => handleSortChange(field)}
            style={{
              padding: '6px 12px',
              background: state.sort.field === field ? '#3498db' : '#ecf0f1',
              color: state.sort.field === field ? 'white' : 'black',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            {field.charAt(0).toUpperCase() + field.slice(1)}
            {state.sort.field === field &&
              (state.sort.order === 'asc' ? ' ‚Üë' : ' ‚Üì')}
          </button>
        ))}
      </div>

      {/* Products Grid */}
      {paginatedProducts.length === 0 ? (
        <div
          style={{ textAlign: 'center', padding: '4rem', fontSize: '1.2rem' }}
        >
          No products match your filters.
        </div>
      ) : (
        <div
          style={{
            display: 'grid',
            gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
            gap: '1.5rem',
          }}
        >
          {paginatedProducts.map((product) => (
            <div
              key={product.id}
              style={{
                border: '1px solid #ddd',
                borderRadius: '8px',
                overflow: 'hidden',
                background: 'white',
                boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
              }}
            >
              <img
                src={product.image}
                alt={product.title}
                style={{
                  width: '100%',
                  height: '220px',
                  objectFit: 'contain',
                  padding: '1rem',
                }}
                loading='lazy'
              />
              <div style={{ padding: '1rem' }}>
                <h3 style={{ fontSize: '1.1rem', margin: '0 0 0.5rem' }}>
                  {product.title}
                </h3>
                <div
                  style={{
                    fontWeight: 'bold',
                    color: '#e67e22',
                    marginBottom: '0.5rem',
                  }}
                >
                  ${product.price.toFixed(2)}
                </div>
                <div style={{ fontSize: '0.9rem', color: '#7f8c8d' }}>
                  Rating: {product.rating.rate} ‚òÖ ({product.rating.count})
                </div>
                <div
                  style={{
                    fontSize: '0.85rem',
                    marginTop: '0.5rem',
                    color: '#95a5a6',
                  }}
                >
                  {product.category}
                </div>
              </div>
            </div>
          ))}
        </div>
      )}

      {/* Pagination */}
      {totalPages > 1 && (
        <div
          style={{
            marginTop: '2rem',
            display: 'flex',
            justifyContent: 'center',
            gap: '0.5rem',
            flexWrap: 'wrap',
          }}
        >
          <button
            onClick={() => goToPage(state.pagination.currentPage - 1)}
            disabled={state.pagination.currentPage === 1}
            style={{ padding: '8px 16px', minWidth: '80px' }}
          >
            Previous
          </button>

          {[...Array(totalPages)].map((_, i) => {
            const page = i + 1;
            return (
              <button
                key={page}
                onClick={() => goToPage(page)}
                style={{
                  padding: '8px 12px',
                  background:
                    state.pagination.currentPage === page
                      ? '#3498db'
                      : '#ecf0f1',
                  color:
                    state.pagination.currentPage === page ? 'white' : 'black',
                  border: 'none',
                  borderRadius: '4px',
                  minWidth: '40px',
                }}
              >
                {page}
              </button>
            );
          })}

          <button
            onClick={() => goToPage(state.pagination.currentPage + 1)}
            disabled={state.pagination.currentPage === totalPages}
            style={{ padding: '8px 16px', minWidth: '80px' }}
          >
            Next
          </button>
        </div>
      )}

      {/* Results count */}
      <div style={{ textAlign: 'center', marginTop: '1rem', color: '#7f8c8d' }}>
        Showing {paginatedProducts.length} of {processedProducts.length}{' '}
        products
      </div>
    </div>
  );
}

export default ProductListing;

/*
V√≠ d·ª• k·∫øt qu·∫£ khi t∆∞∆°ng t√°c:
1. Trang load ‚Üí hi·ªÉn th·ªã 12 s·∫£n ph·∫©m ƒë·∫ßu ti√™n
2. G√µ "ring" v√†o search ‚Üí ch·ªâ hi·ªÉn th·ªã s·∫£n ph·∫©m c√≥ "ring" trong title/description
3. Ch·ªçn category "jewelery" ‚Üí ch·ªâ jewelry, search v·∫´n ho·∫°t ƒë·ªông
4. K√©o min price l√™n 100 ‚Üí l·ªçc s·∫£n ph·∫©m >= $100
5. Ch·ªçn min rating 4 ‚Üí ch·ªâ s·∫£n ph·∫©m >= 4 sao
6. Nh·∫•n sort "Price" ‚Üí s·∫Øp x·∫øp tƒÉng d·∫ßn, nh·∫•n l·∫°i ‚Üí gi·∫£m d·∫ßn
7. Chuy·ªÉn sang page 2 ‚Üí hi·ªÉn th·ªã s·∫£n ph·∫©m 13-24
8. Nh·∫•n Reset Filters ‚Üí tr·ªü v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
*/
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh Trade-offs: useState vs useReducer

| Ti√™u ch√≠                 | useState                             | useReducer                             | Winner     |
| ------------------------ | ------------------------------------ | -------------------------------------- | ---------- |
| **Setup Complexity**     | ‚úÖ ƒê∆°n gi·∫£n, 1 d√≤ng                  | ‚ùå C·∫ßn reducer function + actions      | useState   |
| **Code Length**          | ‚úÖ √çt code h∆°n                       | ‚ùå Nhi·ªÅu boilerplate                   | useState   |
| **State Complexity**     | ‚ùå Kh√≥ qu·∫£n l√Ω khi >3 related states | ‚úÖ T·ªët v·ªõi complex state               | useReducer |
| **Logic Centralization** | ‚ùå Logic r·∫£i r√°c trong handlers      | ‚úÖ Logic t·∫≠p trung trong reducer       | useReducer |
| **Testability**          | ‚ùå Ph·∫£i test component               | ‚úÖ Test reducer nh∆∞ pure function      | useReducer |
| **Debugging**            | ‚ùå Kh√≥ track "what happened"         | ‚úÖ Log actions = clear history         | useReducer |
| **Performance**          | ‚úÖ Nh·∫π h∆°n (√≠t overhead)             | ‚ö†Ô∏è Overhead nh·ªè (th∆∞·ªùng kh√¥ng ƒë√°ng k·ªÉ) | useState   |
| **Learning Curve**       | ‚úÖ D·ªÖ h·ªçc                            | ‚ùå C·∫ßn hi·ªÉu reducer pattern            | useState   |
| **Type Safety**          | ‚ö†Ô∏è D·ªÖ typo setter names              | ‚úÖ Action types d·ªÖ type-check          | useReducer |
| **Refactoring**          | ‚ùå Kh√≥ refactor khi app grows        | ‚úÖ D·ªÖ add actions m·ªõi                  | useReducer |

### Decision Tree: Khi n√†o d√πng c√°i n√†o?

```
START: C·∫ßn qu·∫£n l√Ω state?
‚îÇ
‚îú‚îÄ State ƒë∆°n gi·∫£n (1-2 primitives)?
‚îÇ  ‚îî‚îÄ YES ‚Üí useState ‚úÖ
‚îÇ     Example: toggle, counter, input value
‚îÇ
‚îú‚îÄ State l√† object nh·ªè, kh√¥ng c√≥ logic ph·ª©c t·∫°p?
‚îÇ  ‚îî‚îÄ YES ‚Üí useState ‚úÖ
‚îÇ     Example: { isOpen: false, selectedId: null }
‚îÇ
‚îú‚îÄ State updates ph·ª• thu·ªôc v√†o current state?
‚îÇ  ‚îî‚îÄ YES
‚îÇ     ‚îÇ
‚îÇ     ‚îú‚îÄ Ch·ªâ 1-2 dependencies?
‚îÇ     ‚îÇ  ‚îî‚îÄ useState v·ªõi functional updates ‚úÖ
‚îÇ     ‚îÇ     Example: setCount(prev => prev + 1)
‚îÇ     ‚îÇ
‚îÇ     ‚îî‚îÄ Multiple complex dependencies?
‚îÇ        ‚îî‚îÄ useReducer ‚úÖ
‚îÇ           Example: Form v·ªõi nhi·ªÅu fields + validation
‚îÇ
‚îú‚îÄ C·∫ßn update nhi·ªÅu related states c√πng l√∫c?
‚îÇ  ‚îî‚îÄ YES ‚Üí useReducer ‚úÖ
‚îÇ     Example: Fetch data ‚Üí update loading, data, error
‚îÇ
‚îú‚îÄ State transitions c√≥ logic r√µ r√†ng (state machine)?
‚îÇ  ‚îî‚îÄ YES ‚Üí useReducer ‚úÖ
‚îÇ     Example: Todo: idle ‚Üí loading ‚Üí success/error
‚îÇ
‚îú‚îÄ C·∫ßn d·ªÖ test logic ri√™ng bi·ªát kh·ªèi UI?
‚îÇ  ‚îî‚îÄ YES ‚Üí useReducer ‚úÖ
‚îÇ     Test reducer function ƒë·ªôc l·∫≠p
‚îÇ
‚îú‚îÄ Team ƒë√£ quen v·ªõi Redux pattern?
‚îÇ  ‚îî‚îÄ YES ‚Üí useReducer ‚úÖ
‚îÇ     Familiar pattern, easy onboarding
‚îÇ
‚îî‚îÄ NOT SURE?
   ‚îî‚îÄ Start with useState
      If it gets messy ‚Üí Refactor to useReducer
```

### Real-World Use Cases

**‚úÖ useState - Perfect for:**

1. **Toggle/Boolean states:**

```jsx
const [isOpen, setIsOpen] = useState(false);
```

2. **Simple input fields:**

```jsx
const [email, setEmail] = useState('');
```

3. **Independent states:**

```jsx
const [count, setCount] = useState(0);
const [name, setName] = useState('');
```

**‚úÖ useReducer - Perfect for:**

1. **Forms v·ªõi nhi·ªÅu fields:**

```jsx
// Thay v√¨ 10 useState, d√πng 1 useReducer
const [formState, dispatch] = useReducer(formReducer, initialFormState);
```

2. **Data fetching v·ªõi loading/error:**

```jsx
// State: { data, loading, error }
// Actions: FETCH_START, FETCH_SUCCESS, FETCH_ERROR
```

3. **Shopping cart, todo list, etc:**

```jsx
// Complex state v·ªõi nhi·ªÅu operations
// M·ªói operation = 1 action
```

4. **State machines:**

```jsx
// idle ‚Üí loading ‚Üí success/error
// M·ªói transition r√µ r√†ng
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Infinite Re-renders üêõ

```jsx
// ‚ùå CODE B·ªä L·ªñI
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  // üêõ BUG: Infinite loop!
  dispatch({ type: 'INCREMENT' });

  return <div>{state.count}</div>;
}
```

**‚ùì C√¢u h·ªèi:**

1. T·∫°i sao code tr√™n g√¢y infinite loop?
2. L√†m sao fix?

**üí° Gi·∫£i th√≠ch:**

- `dispatch` trigger re-render
- Component re-render ‚Üí `dispatch` l·∫°i ƒë∆∞·ª£c g·ªçi
- ‚Üí Re-render l·∫°i ‚Üí infinite loop!

**‚úÖ Fix:**

```jsx
function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  // ‚úÖ Ch·ªâ dispatch trong event handler ho·∫∑c useEffect
  const handleClick = () => {
    dispatch({ type: 'INCREMENT' });
  };

  return (
    <div>
      {state.count}
      <button onClick={handleClick}>+1</button>
    </div>
  );
}
```

### Bug 2: Mutating State üêõ

```jsx
// ‚ùå CODE B·ªä L·ªñI
function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      // üêõ BUG: Mutate state tr·ª±c ti·∫øp!
      state.todos.push(action.payload);
      return state;

    case 'TOGGLE_TODO':
      // üêõ BUG: Mutate nested object!
      const todo = state.todos.find((t) => t.id === action.payload.id);
      todo.completed = !todo.completed;
      return state;

    default:
      return state;
  }
}
```

**‚ùì C√¢u h·ªèi:**

1. T·∫°i sao code tr√™n sai?
2. H·∫≠u qu·∫£ l√† g√¨?
3. L√†m sao fix?

**üí° Gi·∫£i th√≠ch:**

- Reducer PH·∫¢I pure function
- Mutate state ‚Üí React kh√¥ng detect change ‚Üí kh√¥ng re-render
- Ho·∫∑c re-render nh∆∞ng UI kh√¥ng sync v·ªõi state

**‚úÖ Fix:**

```jsx
function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      // ‚úÖ Return new array
      return {
        ...state,
        todos: [...state.todos, action.payload],
      };

    case 'TOGGLE_TODO':
      // ‚úÖ Return new array v·ªõi new object
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload.id
            ? { ...todo, completed: !todo.completed }
            : todo,
        ),
      };

    default:
      return state;
  }
}
```

### Bug 3: Missing Default Case üêõ

```jsx
// ‚ùå CODE B·ªä L·ªñI
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    // üêõ BUG: No default case!
  }
}

// S·ª≠ d·ª•ng:
dispatch({ type: 'RESET' }); // Typo: should be 'RESET'
// ‚Üí Kh√¥ng throw error, silent fail!
// ‚Üí Tr·∫£ v·ªÅ undefined ‚Üí App crash
```

**‚ùì C√¢u h·ªèi:**

1. T·∫°i sao c·∫ßn default case?
2. N√™n l√†m g√¨ trong default case?

**üí° Gi·∫£i th√≠ch:**

- Typo action type ‚Üí silent fail
- Return undefined ‚Üí React error "Cannot read property of undefined"
- Kh√≥ debug v√¨ kh√¥ng bi·∫øt action n√†o g√¢y l·ªói

**‚úÖ Fix:**

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };

    // ‚úÖ Lu√¥n c√≥ default case
    default:
      // Throw error r√µ r√†ng
      throw new Error(`Unknown action type: ${action.type}`);

    // HO·∫∂C log warning v√† return state
    // console.warn(`Unknown action: ${action.type}`);
    // return state;
  }
}
```

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

ƒê√°nh d·∫•u ‚úÖ khi b·∫°n t·ª± tin v·ªõi concept:

**Reducer Basics:**

- [ ] T√¥i hi·ªÉu reducer pattern l√† g√¨
- [ ] T√¥i bi·∫øt c√°ch vi·∫øt reducer function
- [ ] T√¥i hi·ªÉu reducer ph·∫£i pure (no side effects, no mutations)
- [ ] T√¥i bi·∫øt c√°ch ƒë·ªãnh nghƒ©a actions

**useReducer Hook:**

- [ ] T√¥i bi·∫øt syntax: `const [state, dispatch] = useReducer(reducer, initialState)`
- [ ] T√¥i hi·ªÉu dispatch l√† g√¨ v√† c√°ch d√πng
- [ ] T√¥i bi·∫øt khi n√†o d√πng useState vs useReducer
- [ ] T√¥i c√≥ th·ªÉ refactor t·ª´ useState sang useReducer

**Best Practices:**

- [ ] T√¥i lu√¥n c√≥ default case trong reducer
- [ ] T√¥i kh√¥ng mutate state trong reducer
- [ ] T√¥i ƒë·∫∑t t√™n actions r√µ r√†ng (SCREAMING_SNAKE_CASE)
- [ ] T√¥i hi·ªÉu trade-offs c·ªßa useReducer

**Edge Cases:**

- [ ] T√¥i bi·∫øt c√°ch handle validation errors
- [ ] T√¥i bi·∫øt c√°ch prevent double dispatch (isLoading check)
- [ ] T√¥i bi·∫øt c√°ch reset state v·ªÅ initial state

### Code Review Checklist

Review code c·ªßa b·∫°n:

**Reducer Function:**

- [ ] Pure function (kh√¥ng side effects)
- [ ] Immutable updates (kh√¥ng mutate state)
- [ ] C√≥ default case throw error
- [ ] Action types r√µ r√†ng, consistent naming

**State Shape:**

- [ ] Flat khi c√≥ th·ªÉ (avoid deep nesting)
- [ ] Grouped related data
- [ ] Kh√¥ng c√≥ redundant data (derive khi c·∫ßn)

**Actions:**

- [ ] Type names descriptive
- [ ] Payload structure consistent
- [ ] Document payload shape (comments ho·∫∑c TS)

**Component:**

- [ ] Dispatch trong event handlers/useEffect (kh√¥ng trong render)
- [ ] Error handling
- [ ] Loading states
- [ ] Edge cases covered

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**B√†i 1: Refactor useState to useReducer**

Cho component sau d√πng useState:

```jsx
function Calculator() {
  const [display, setDisplay] = useState('0');
  const [operator, setOperator] = useState(null);
  const [previousValue, setPreviousValue] = useState(null);
  const [waitingForOperand, setWaitingForOperand] = useState(false);

  const inputDigit = (digit) => {
    if (waitingForOperand) {
      setDisplay(String(digit));
      setWaitingForOperand(false);
    } else {
      setDisplay(display === '0' ? String(digit) : display + digit);
    }
  };

  const performOperation = (nextOperator) => {
    const inputValue = parseFloat(display);

    if (previousValue === null) {
      setPreviousValue(inputValue);
    } else if (operator) {
      const currentValue = previousValue || 0;
      const newValue = performCalculation[operator](currentValue, inputValue);

      setDisplay(String(newValue));
      setPreviousValue(newValue);
    }

    setWaitingForOperand(true);
    setOperator(nextOperator);
  };

  // ... rest of logic
}
```

**Nhi·ªám v·ª•:**

1. Chuy·ªÉn sang useReducer
2. ƒê·ªãnh nghƒ©a actions: INPUT_DIGIT, SET_OPERATOR, CALCULATE, CLEAR
3. Vi·∫øt reducer handle t·∫•t c·∫£ logic

<details><summary>üí° Solution</summary>

```jsx
/**
 * Calculator component refactored from multiple useState to useReducer
 * Manages calculator state with actions: INPUT_DIGIT, INPUT_DECIMAL, SET_OPERATOR, CALCULATE, CLEAR, DELETE
 */
import { useReducer } from 'react';

// ================= REDUCER =================
function calculatorReducer(state, action) {
  switch (action.type) {
    case 'INPUT_DIGIT': {
      const { digit } = action.payload;

      if (state.waitingForOperand) {
        return {
          ...state,
          display: String(digit),
          waitingForOperand: false,
        };
      }

      if (state.display === '0') {
        return {
          ...state,
          display: String(digit),
        };
      }

      return {
        ...state,
        display: state.display + digit,
      };
    }

    case 'INPUT_DECIMAL': {
      if (state.waitingForOperand) {
        return {
          ...state,
          display: '0.',
          waitingForOperand: false,
        };
      }

      if (!state.display.includes('.')) {
        return {
          ...state,
          display: state.display + '.',
        };
      }

      return state; // already has decimal
    }

    case 'SET_OPERATOR': {
      const { operator } = action.payload;
      const inputValue = parseFloat(state.display);

      if (state.previousValue === null) {
        // First operand
        return {
          ...state,
          previousValue: inputValue,
          operator,
          waitingForOperand: true,
        };
      }

      if (state.operator && !state.waitingForOperand) {
        // Chain operations
        const currentValue = state.previousValue || 0;
        const newValue = performCalculation[state.operator](
          currentValue,
          inputValue,
        );

        return {
          ...state,
          display: String(newValue),
          previousValue: newValue,
          operator,
          waitingForOperand: true,
        };
      }

      return {
        ...state,
        operator,
        waitingForOperand: true,
      };
    }

    case 'CALCULATE': {
      if (state.previousValue === null || state.operator === null) {
        return state;
      }

      const inputValue = parseFloat(state.display);
      const currentValue = state.previousValue || 0;
      const newValue = performCalculation[state.operator](
        currentValue,
        inputValue,
      );

      return {
        ...state,
        display: String(newValue),
        previousValue: null,
        operator: null,
        waitingForOperand: true,
      };
    }

    case 'CLEAR':
      return {
        display: '0',
        operator: null,
        previousValue: null,
        waitingForOperand: false,
      };

    case 'DELETE': {
      if (state.waitingForOperand) return state;

      if (state.display.length <= 1) {
        return {
          ...state,
          display: '0',
        };
      }

      return {
        ...state,
        display: state.display.slice(0, -1),
      };
    }

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// Calculation functions
const performCalculation = {
  '/': (prev, next) => prev / next,
  '*': (prev, next) => prev * next,
  '+': (prev, next) => prev + next,
  '-': (prev, next) => prev - next,
};

// ================= COMPONENT =================
function Calculator() {
  const initialState = {
    display: '0',
    operator: null,
    previousValue: null,
    waitingForOperand: false,
  };

  const [state, dispatch] = useReducer(calculatorReducer, initialState);

  const handleDigit = (digit) => {
    dispatch({ type: 'INPUT_DIGIT', payload: { digit } });
  };

  const handleDecimal = () => {
    dispatch({ type: 'INPUT_DECIMAL' });
  };

  const handleOperator = (op) => {
    dispatch({ type: 'SET_OPERATOR', payload: { operator: op } });
  };

  const handleEquals = () => {
    dispatch({ type: 'CALCULATE' });
  };

  const handleClear = () => {
    dispatch({ type: 'CLEAR' });
  };

  const handleDelete = () => {
    dispatch({ type: 'DELETE' });
  };

  return (
    <div
      style={{
        maxWidth: '320px',
        margin: '2rem auto',
        border: '1px solid #ccc',
        borderRadius: '12px',
        overflow: 'hidden',
        background: '#f8f9fa',
      }}
    >
      {/* Display */}
      <div
        style={{
          background: '#333',
          color: 'white',
          fontSize: '2.8rem',
          textAlign: 'right',
          padding: '1.5rem 1rem',
          minHeight: '80px',
          fontFamily: 'monospace',
        }}
      >
        {state.display}
      </div>

      {/* Buttons */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(4, 1fr)',
          gap: '1px',
          background: '#ddd',
        }}
      >
        <button
          onClick={handleClear}
          style={buttonStyle('orange')}
        >
          C
        </button>
        <button
          onClick={handleDelete}
          style={buttonStyle('gray')}
        >
          ‚Üê
        </button>
        <button
          onClick={() => handleOperator('/')}
          style={buttonStyle('gray')}
        >
          /
        </button>

        <button
          onClick={() => handleDigit(7)}
          style={buttonStyle()}
        >
          7
        </button>
        <button
          onClick={() => handleDigit(8)}
          style={buttonStyle()}
        >
          8
        </button>
        <button
          onClick={() => handleDigit(9)}
          style={buttonStyle()}
        >
          9
        </button>
        <button
          onClick={() => handleOperator('*')}
          style={buttonStyle('gray')}
        >
          √ó
        </button>

        <button
          onClick={() => handleDigit(4)}
          style={buttonStyle()}
        >
          4
        </button>
        <button
          onClick={() => handleDigit(5)}
          style={buttonStyle()}
        >
          5
        </button>
        <button
          onClick={() => handleDigit(6)}
          style={buttonStyle()}
        >
          6
        </button>
        <button
          onClick={() => handleOperator('-')}
          style={buttonStyle('gray')}
        >
          -
        </button>

        <button
          onClick={() => handleDigit(1)}
          style={buttonStyle()}
        >
          1
        </button>
        <button
          onClick={() => handleDigit(2)}
          style={buttonStyle()}
        >
          2
        </button>
        <button
          onClick={() => handleDigit(3)}
          style={buttonStyle()}
        >
          3
        </button>
        <button
          onClick={() => handleOperator('+')}
          style={buttonStyle('gray')}
        >
          +
        </button>

        <button
          onClick={() => handleDigit(0)}
          style={{ ...buttonStyle(), gridColumn: 'span 2' }}
        >
          0
        </button>
        <button
          onClick={handleDecimal}
          style={buttonStyle()}
        >
          .
        </button>
        <button
          onClick={handleEquals}
          style={buttonStyle('orange')}
        >
          =
        </button>
      </div>
    </div>
  );
}

// Helper for consistent button styling
const buttonStyle = (bg = '#fff') => ({
  padding: '1.5rem',
  fontSize: '1.5rem',
  border: 'none',
  background:
    bg === 'orange' ? '#f39c12' : bg === 'gray' ? '#7f8c8d' : '#ecf0f1',
  color: bg === 'orange' || bg === 'gray' ? 'white' : '#2c3e50',
  cursor: 'pointer',
  transition: 'background 0.1s',
  ':hover': { background: bg === 'orange' ? '#e67e22' : '#dfe6e9' },
});

export default Calculator;

/*
V√≠ d·ª• k·∫øt qu·∫£ khi t∆∞∆°ng t√°c:
1. Nh·∫•n 5 ‚Üí hi·ªÉn th·ªã "5"
2. Nh·∫•n + ‚Üí l∆∞u 5 l√†m previousValue, operator = '+'
3. Nh·∫•n 3 ‚Üí hi·ªÉn th·ªã "3"
4. Nh·∫•n = ‚Üí t√≠nh 5 + 3 = 8, hi·ªÉn th·ªã "8"
5. Nh·∫•n √ó ‚Üí operator = '*', waitingForOperand = true
6. Nh·∫•n 4 ‚Üí hi·ªÉn th·ªã "4"
7. Nh·∫•n = ‚Üí t√≠nh 8 √ó 4 = 32, hi·ªÉn th·ªã "32"
8. Nh·∫•n C ‚Üí reset v·ªÅ "0"
9. Nh·∫•n 1 2 3 . 4 5 ‚Üí hi·ªÉn th·ªã "123.45"
10. Nh·∫•n ‚Üê (delete) ‚Üí "123.4"
*/
```

</details>

### N√¢ng cao (60 ph√∫t)

**B√†i 2: Build Undo/Redo v·ªõi useReducer**

Requirements:

1. T·∫°o drawing canvas ƒë∆°n gi·∫£n (grid of clickable cells)
2. User click cell ‚Üí toggle color
3. C√≥ n√∫t Undo (quay l·∫°i 1 b∆∞·ªõc)
4. C√≥ n√∫t Redo (l√†m l·∫°i b∆∞·ªõc v·ª´a undo)
5. Disable Undo khi kh√¥ng c√≥ history
6. Disable Redo khi kh√¥ng c√≥ future

State shape g·ª£i √Ω:

```jsx
{
  past: [state1, state2, ...], // Array of previous states
  present: currentState,        // Current state
  future: [state3, state4, ...] // Array of undone states
}
```

Actions:

- DRAW (toggle cell color)
- UNDO
- REDO
- CLEAR

Tham kh·∫£o pattern: [Time Travel Pattern](https://redux.js.org/usage/implementing-undo-history)

<details><summary>üí° Solution</summary>

```jsx
/**
 * Simple Pixel Drawing Canvas with Undo/Redo using useReducer
 * - Grid of clickable cells (10√ó10)
 * - Click to toggle cell color (black/white)
 * - Undo / Redo buttons with history
 * - Clear button
 */
import { useReducer } from 'react';

// ================= TYPES & INITIAL STATE =================
const GRID_SIZE = 10;

const createEmptyGrid = () =>
  Array(GRID_SIZE)
    .fill()
    .map(() => Array(GRID_SIZE).fill(false));

const initialState = {
  past: [],
  present: createEmptyGrid(),
  future: [],
};

// ================= REDUCER =================
function drawingReducer(state, action) {
  switch (action.type) {
    case 'TOGGLE_CELL': {
      const { row, col } = action.payload;

      // Save current state to past before change
      const newPast = [...state.past, state.present];

      // Create new grid with toggled cell
      const newGrid = state.present.map((r, i) =>
        i === row ? r.map((cell, j) => (j === col ? !cell : cell)) : r,
      );

      return {
        past: newPast,
        present: newGrid,
        future: [], // Clear future when new action occurs
      };
    }

    case 'UNDO': {
      if (state.past.length === 0) return state;

      const previous = state.past[state.past.length - 1];
      const newPast = state.past.slice(0, -1);

      return {
        past: newPast,
        present: previous,
        future: [state.present, ...state.future],
      };
    }

    case 'REDO': {
      if (state.future.length === 0) return state;

      const next = state.future[0];
      const newFuture = state.future.slice(1);

      return {
        past: [...state.past, state.present],
        present: next,
        future: newFuture,
      };
    }

    case 'CLEAR': {
      return {
        past: [],
        present: createEmptyGrid(),
        future: [],
      };
    }

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// ================= COMPONENT =================
function DrawingCanvas() {
  const [state, dispatch] = useReducer(drawingReducer, initialState);

  const handleCellClick = (row, col) => {
    dispatch({ type: 'TOGGLE_CELL', payload: { row, col } });
  };

  const handleUndo = () => dispatch({ type: 'UNDO' });
  const handleRedo = () => dispatch({ type: 'REDO' });
  const handleClear = () => dispatch({ type: 'CLEAR' });

  const canUndo = state.past.length > 0;
  const canRedo = state.future.length > 0;

  return (
    <div style={{ textAlign: 'center', padding: '2rem' }}>
      <h2>Pixel Art - Undo/Redo Demo</h2>

      {/* Controls */}
      <div
        style={{
          marginBottom: '1.5rem',
          display: 'flex',
          gap: '1rem',
          justifyContent: 'center',
        }}
      >
        <button
          onClick={handleUndo}
          disabled={!canUndo}
          style={{
            padding: '10px 20px',
            background: canUndo ? '#3498db' : '#bdc3c7',
            color: 'white',
            border: 'none',
            borderRadius: '6px',
            cursor: canUndo ? 'pointer' : 'not-allowed',
          }}
        >
          Undo
        </button>

        <button
          onClick={handleRedo}
          disabled={!canRedo}
          style={{
            padding: '10px 20px',
            background: canRedo ? '#2ecc71' : '#bdc3c7',
            color: 'white',
            border: 'none',
            borderRadius: '6px',
            cursor: canRedo ? 'pointer' : 'not-allowed',
          }}
        >
          Redo
        </button>

        <button
          onClick={handleClear}
          style={{
            padding: '10px 20px',
            background: '#e74c3c',
            color: 'white',
            border: 'none',
            borderRadius: '6px',
          }}
        >
          Clear
        </button>
      </div>

      {/* Canvas Grid */}
      <div
        style={{
          display: 'inline-grid',
          gridTemplateColumns: `repeat(${GRID_SIZE}, 40px)`,
          gridTemplateRows: `repeat(${GRID_SIZE}, 40px)`,
          gap: '2px',
          background: '#ecf0f1',
          padding: '8px',
          borderRadius: '8px',
          boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
        }}
      >
        {state.present.map((row, rowIndex) =>
          row.map((isFilled, colIndex) => (
            <div
              key={`${rowIndex}-${colIndex}`}
              onClick={() => handleCellClick(rowIndex, colIndex)}
              style={{
                width: '40px',
                height: '40px',
                backgroundColor: isFilled ? '#2c3e50' : 'white',
                border: '1px solid #bdc3c7',
                borderRadius: '3px',
                cursor: 'pointer',
                transition: 'background-color 0.12s',
              }}
            />
          )),
        )}
      </div>

      {/* Status */}
      <div style={{ marginTop: '1rem', color: '#7f8c8d' }}>
        History: {state.past.length} past ‚Ä¢ {state.future.length} future
      </div>
    </div>
  );
}

export default DrawingCanvas;

/*
V√≠ d·ª• k·∫øt qu·∫£ khi t∆∞∆°ng t√°c:
1. Click v√†i √¥ ‚Üí c√°c √¥ chuy·ªÉn th√†nh ƒëen
2. Nh·∫•n Undo ‚Üí quay l·∫°i tr·∫°ng th√°i tr∆∞·ªõc ƒë√≥ (c√°c √¥ tr·∫Øng tr·ªü l·∫°i)
3. Nh·∫•n Redo ‚Üí kh√¥i ph·ª•c thay ƒë·ªïi v·ª´a undo
4. V·∫Ω nhi·ªÅu b∆∞·ªõc ‚Üí Undo nhi·ªÅu l·∫ßn ‚Üí Redo nhi·ªÅu l·∫ßn
5. Nh·∫•n Clear ‚Üí canvas tr·∫Øng, past v√† future reset
6. Kh√¥ng th·ªÉ Undo khi past r·ªóng ‚Üí n√∫t disabled
7. Kh√¥ng th·ªÉ Redo khi future r·ªóng ‚Üí n√∫t disabled
*/
```

</details>

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - useReducer:**
   - https://react.dev/reference/react/useReducer
   - ƒê·ªçc k·ªπ ph·∫ßn "Examples" v√† "Troubleshooting"

2. **When to use useReducer:**
   - https://react.dev/learn/extracting-state-logic-into-a-reducer
   - So s√°nh useState vs useReducer

### ƒê·ªçc th√™m

3. **Redux Style Guide (reducer best practices):**
   - https://redux.js.org/style-guide/style-guide
   - Ph·∫ßn "Write Reducers" √°p d·ª•ng cho useReducer

4. **Immer for Immutable Updates:**
   - https://immerjs.github.io/immer/
   - (Ch∆∞a d√πng h√¥m nay, nh∆∞ng useful sau n√†y)

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (ƒê√£ h·ªçc)

- **Ng√†y 11-12:** useState basics + patterns
  - useReducer l√† "useState on steroids"
  - C√πng purpose: qu·∫£n l√Ω state
  - Kh√°c approach: centralized vs distributed

- **Ng√†y 13:** Forms v·ªõi State
  - useReducer l√†m form logic cleaner
  - 1 reducer thay v√¨ nhi·ªÅu useState

- **Ng√†y 14:** Lifting State Up
  - useReducer gi√∫p avoid prop drilling
  - K·∫øt h·ª£p Context (Ng√†y sau) = global state

### H∆∞·ªõng t·ªõi (S·∫Ω h·ªçc)

- **Ng√†y 27:** useReducer Advanced Patterns
  - State normalization
  - Reducer composition
  - Async actions pattern

- **Ng√†y 28:** useReducer + useEffect
  - Data fetching v·ªõi reducer
  - Loading/error states pattern

- **Ng√†y 29:** Custom Hooks v·ªõi useReducer
  - useAsync, useForm
  - Reusable state machines

- **Ng√†y 40+:** Context + useReducer
  - Global state management
  - Alternative to Redux

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**1. Khi n√†o KH√îNG n√™n d√πng useReducer:**

```jsx
// ‚ùå Over-engineering: State ƒë∆°n gi·∫£n
const [isOpen, setIsOpen] = useState(false);
// Kh√¥ng c·∫ßn:
// const [state, dispatch] = useReducer(modalReducer, { isOpen: false });
```

**2. Action naming conventions:**

```jsx
// ‚úÖ GOOD: Descriptive, present tense, SCREAMING_SNAKE_CASE
'ADD_TODO';
'TOGGLE_TODO';
'DELETE_TODO';
'SET_FILTER';

// ‚ùå BAD: Vague, unclear
'UPDATE'; // Update c√°i g√¨?
'change'; // Kh√¥ng consistent casing
'todoToggled'; // Past tense confusing
```

**3. State shape design:**

```jsx
// ‚ùå BAD: Deeply nested
{
  user: {
    profile: {
      settings: {
        theme: 'dark'
      }
    }
  }
}

// ‚úÖ GOOD: Flat structure
{
  userTheme: 'dark',
  userProfile: {...},
  userSettings: {...}
}
```

**4. Performance:**

useReducer c√≥ overhead nh·ªè so v·ªõi useState, nh∆∞ng:

- Th∆∞·ªùng kh√¥ng ƒë√°ng k·ªÉ
- Trade-off x·ª©ng ƒë√°ng cho code quality
- Profile before optimizing!

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior Level:**

1. **Q:** "useState v√† useReducer kh√°c nhau nh∆∞ th·∫ø n√†o?"

   **Expected Answer:**
   - useState: ƒê∆°n gi·∫£n, cho state ƒë∆°n gi·∫£n
   - useReducer: Ph·ª©c t·∫°p h∆°n, cho complex state logic
   - useReducer centralize logic trong reducer
   - Trade-offs: boilerplate vs maintainability

2. **Q:** "Reducer function c·∫ßn tu√¢n th·ªß quy t·∫Øc g√¨?"

   **Expected Answer:**
   - Pure function (same input ‚Üí same output)
   - No side effects
   - Immutable updates
   - Lu√¥n return state (ho·∫∑c throw error)

**Mid Level:**

3. **Q:** "Khi n√†o n√™n d√πng useReducer thay v√¨ useState?"

   **Expected Answer:**
   - Multiple related state values
   - Next state depends on previous state
   - Complex state logic
   - Easier testing requirements
   - C·∫ßn log/debug state transitions

4. **Q:** "L√†m sao handle async operations v·ªõi useReducer?"

   **Expected Answer:**
   - useReducer ch·ªâ handle synchronous updates
   - Async logic trong useEffect ho·∫∑c event handlers
   - Dispatch actions: START, SUCCESS, ERROR
   - Pattern s·∫Ω h·ªçc ·ªü Ng√†y 28

**Senior Level:**

5. **Q:** "So s√°nh useReducer v·ªõi Redux. Khi n√†o d√πng c√°i n√†o?"

   **Expected Answer:**
   - useReducer: Component-level state, ƒë∆°n gi·∫£n
   - Redux: Global state, middleware, devtools, time-travel
   - useReducer + Context ‚âà mini Redux
   - Start with useReducer, migrate to Redux if needed
   - Trade-off: Simplicity vs Features

### War Stories

**Story 1: Form Hell ‚Üí useReducer Heaven**

> "T√¥i t·ª´ng maintain form ƒëƒÉng k√Ω c√≥ 20+ fields v·ªõi useState. M·ªói l·∫ßn th√™m validation rule, t√¥i ph·∫£i update 5-6 places. Bugs xu·∫•t hi·ªán li√™n t·ª•c. Khi refactor sang useReducer, t·∫•t c·∫£ logic ·ªü 1 ch·ªó. Add validation? Ch·ªâ s·ª≠a reducer. Test? Test reducer nh∆∞ function thu·∫ßn. Dev time gi·∫£m 50%." - Senior Engineer

**Story 2: Debug v·ªõi Action Logs**

> "Production bug: Shopping cart ƒë√¥i khi m·∫•t items. V·ªõi useState kh√¥ng bi·∫øt state thay ƒë·ªïi ·ªü ƒë√¢u. Sau khi chuy·ªÉn useReducer, t√¥i th√™m logger middleware log t·∫•t c·∫£ actions. Ph√°t hi·ªán race condition trong 5 ph√∫t. useReducer gi√∫p debugging predictable h∆°n r·∫•t nhi·ªÅu." - Tech Lead

**Story 3: Premature Optimization**

> "Junior dev trong team nghƒ© useReducer 'professional' h∆°n, refactor T·∫§T C·∫¢ useState sang useReducer. K·∫øt qu·∫£? Code ph·ª©c t·∫°p kh√¥ng c·∫ßn thi·∫øt, onboarding m·ªõi kh√≥ khƒÉn. Lesson: D√πng ƒë√∫ng tool cho ƒë√∫ng job. Simple state = useState. Complex state = useReducer." - Engineering Manager

---

## üéØ PREVIEW NG√ÄY MAI

**Ng√†y 27: useReducer - Advanced Patterns**

B·∫°n s·∫Ω h·ªçc:

- ‚ú® Complex state logic v·ªõi nested data
- ‚ú® State normalization (flat structure)
- ‚ú® Reducer composition pattern
- ‚ú® Action creators & action types constants
- ‚ú® Payload structures best practices

Chu·∫©n b·ªã:

- Ho√†n th√†nh b√†i t·∫≠p h√¥m nay
- Review immutable updates (spread, map, filter)
- Suy nghƒ© v·ªÅ c·∫•u tr√∫c state ph·ª©c t·∫°p

---

**üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh Ng√†y 26!**

B·∫°n gi·ªù ƒë√£ hi·ªÉu:

- ‚úÖ Reducer pattern
- ‚úÖ useReducer hook
- ‚úÖ Khi n√†o d√πng useState vs useReducer
- ‚úÖ Best practices & common pitfalls

Keep coding! üí™
