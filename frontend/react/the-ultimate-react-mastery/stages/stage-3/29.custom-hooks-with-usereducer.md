# ğŸ“… NGÃ€Y 29: Custom Hooks vá»›i useReducer - Reusable Logic Patterns

## ğŸ“ Vá»‹ trÃ­: Phase 3, Tuáº§n 6, NgÃ y 29/45

### â±ï¸ Thá»i lÆ°á»£ng: 3-4 giá»

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] **Táº¡o Ä‘Æ°á»£c** custom hooks encapsulate useReducer logic
- [ ] **Implement Ä‘Æ°á»£c** useFetch, useAsync, useForm hooks
- [ ] **Compose Ä‘Æ°á»£c** multiple hooks together
- [ ] **Share Ä‘Æ°á»£c** logic across components without duplication
- [ ] **Test Ä‘Æ°á»£c** custom hooks (conceptual understanding)

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i sau:

1. **Khi nÃ o nÃªn extract logic thÃ nh custom hook?**
   - Gá»£i Ã½: Code Ä‘Æ°á»£c dÃ¹ng á»Ÿ 2+ components, logic phá»©c táº¡p...

2. **Custom hook khÃ¡c function thÃ´ng thÆ°á»ng nhÆ° tháº¿ nÃ o?**
   - Gá»£i Ã½: Naming convention, cÃ³ thá»ƒ dÃ¹ng hooks bÃªn trong...

3. **Báº¡n Ä‘Ã£ gáº·p trÆ°á»ng há»£p copy-paste logic giá»¯a components chÆ°a?**
   - VÃ­ dá»¥: Fetch user data á»Ÿ nhiá»u nÆ¡i, form handling duplicate...

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

HÃ£y tÆ°á»Ÿng tÆ°á»£ng báº¡n cÃ³ **3 components** Ä‘á»u fetch data tá»« API:

```jsx
// âŒ Váº¤N Äá»€: Duplicate Logic Everywhere

// Component 1: UserProfile
function UserProfile({ userId }) {
  const [state, dispatch] = useReducer(dataReducer, initialState);

  useEffect(() => {
    const controller = new AbortController();

    const fetchUser = async () => {
      dispatch({ type: 'FETCH_START' });
      try {
        const res = await fetch(`/api/users/${userId}`, {
          signal: controller.signal,
        });
        const data = await res.json();
        dispatch({ type: 'FETCH_SUCCESS', payload: data });
      } catch (err) {
        if (err.name !== 'AbortError') {
          dispatch({ type: 'FETCH_ERROR', payload: err.message });
        }
      }
    };

    fetchUser();
    return () => controller.abort();
  }, [userId]);

  // ... render
}

// Component 2: PostList
function PostList() {
  const [state, dispatch] = useReducer(dataReducer, initialState);

  useEffect(() => {
    const controller = new AbortController();

    const fetchPosts = async () => {
      dispatch({ type: 'FETCH_START' });
      try {
        const res = await fetch('/api/posts', {
          signal: controller.signal,
        });
        const data = await res.json();
        dispatch({ type: 'FETCH_SUCCESS', payload: data });
      } catch (err) {
        if (err.name !== 'AbortError') {
          dispatch({ type: 'FETCH_ERROR', payload: err.message });
        }
      }
    };

    fetchPosts();
    return () => controller.abort();
  }, []);

  // ... render
}

// Component 3: CommentList
function CommentList({ postId }) {
  const [state, dispatch] = useReducer(dataReducer, initialState);

  useEffect(() => {
    const controller = new AbortController();

    const fetchComments = async () => {
      dispatch({ type: 'FETCH_START' });
      try {
        const res = await fetch(`/api/posts/${postId}/comments`, {
          signal: controller.signal,
        });
        const data = await res.json();
        dispatch({ type: 'FETCH_SUCCESS', payload: data });
      } catch (err) {
        if (err.name !== 'AbortError') {
          dispatch({ type: 'FETCH_ERROR', payload: err.message });
        }
      }
    };

    fetchComments();
    return () => controller.abort();
  }, [postId]);

  // ... render
}
```

**Váº¥n Ä‘á»:**

1. ğŸ”´ **90% code giá»‘ng nhau** â†’ Copy-paste nightmare
2. ğŸ”´ **Bug fix pháº£i sá»­a 3 chá»—** â†’ Easy to miss
3. ğŸ”´ **Add feature (retry) pháº£i update everywhere** â†’ Unmaintainable
4. ğŸ”´ **Hard to test** â†’ Test 3 components riÃªng biá»‡t
5. ğŸ”´ **No single source of truth** â†’ Inconsistent behavior

### 1.2 Giáº£i PhÃ¡p: Custom Hook

**Custom Hook** = Function extract reusable logic

```jsx
// âœ… GIáº¢I PHÃP: useFetch Hook
function useFetch(url) {
  const initialState = {
    data: null,
    loading: false,
    error: null,
  };

  const [state, dispatch] = useReducer(dataReducer, initialState);

  useEffect(() => {
    if (!url) return;

    const controller = new AbortController();

    const fetchData = async () => {
      dispatch({ type: 'FETCH_START' });

      try {
        const res = await fetch(url, { signal: controller.signal });
        const data = await res.json();
        dispatch({ type: 'FETCH_SUCCESS', payload: data });
      } catch (err) {
        if (err.name !== 'AbortError') {
          dispatch({ type: 'FETCH_ERROR', payload: err.message });
        }
      }
    };

    fetchData();
    return () => controller.abort();
  }, [url]);

  return state;
}

// âœ… USAGE: Clean & Consistent
function UserProfile({ userId }) {
  const { data, loading, error } = useFetch(`/api/users/${userId}`);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  return <div>{data?.name}</div>;
}

function PostList() {
  const { data, loading, error } = useFetch('/api/posts');
  // ... render
}

function CommentList({ postId }) {
  const { data, loading, error } = useFetch(`/api/posts/${postId}/comments`);
  // ... render
}
```

**Lá»£i Ã­ch:**

- âœ… **DRY** (Don't Repeat Yourself) â†’ Logic á»Ÿ 1 chá»—
- âœ… **Easy to maintain** â†’ Bug fix/feature add 1 láº§n
- âœ… **Testable** â†’ Test hook Ä‘á»™c láº­p
- âœ… **Reusable** â†’ DÃ¹ng á»Ÿ unlimited components
- âœ… **Consistent** â†’ Same behavior everywhere

### 1.3 Mental Model

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CUSTOM HOOK (Logic Container)         â”‚
â”‚                                                â”‚
â”‚  function useFetch(url) {                     â”‚
â”‚    const [state, dispatch] = useReducer(...)  â”‚
â”‚    useEffect(() => { ... }, [url])            â”‚
â”‚    return { data, loading, error }            â”‚
â”‚  }                                             â”‚
â”‚                                                â”‚
â”‚  âœ… Encapsulates:                             â”‚
â”‚  â€¢ State management (useReducer)              â”‚
â”‚  â€¢ Side effects (useEffect)                   â”‚
â”‚  â€¢ Cleanup logic                              â”‚
â”‚  â€¢ Error handling                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“                â†“                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Component A â”‚  â”‚ Component B â”‚  â”‚ Component C â”‚
â”‚             â”‚  â”‚             â”‚  â”‚             â”‚
â”‚ useFetch(A) â”‚  â”‚ useFetch(B) â”‚  â”‚ useFetch(C) â”‚
â”‚             â”‚  â”‚             â”‚  â”‚             â”‚
â”‚ Render UI   â”‚  â”‚ Render UI   â”‚  â”‚ Render UI   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Analogy:** Custom Hook giá»‘ng **Recipe (cÃ´ng thá»©c náº¥u Äƒn)**

- **Recipe:** Äá»‹nh nghÄ©a steps (logic)
- **Cook:** Components dÃ¹ng recipe
- **Ingredients:** Parameters (url, userId, etc.)
- **Result:** Cooked dish (data, loading, error)

Nhiá»u cooks cÃ³ thá»ƒ dÃ¹ng cÃ¹ng recipe â†’ Consistent dishes!

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

âŒ **Hiá»ƒu láº§m 1:** "Custom hook chá»‰ lÃ  rename function"

- âœ… **Sá»± tháº­t:** Custom hook CÃ“ THá»‚ dÃ¹ng hooks (useState, useEffect, etc.). Regular function KHÃ”NG THá»‚!

âŒ **Hiá»ƒu láº§m 2:** "Custom hook pháº£i báº¯t Ä‘áº§u báº±ng 'use'"

- âœ… **Sá»± tháº­t:** ÄÃ‚Y LÃ€ QUY Táº®C Báº®T BUá»˜C! React dá»±a vÃ o naming Ä‘á»ƒ check Rules of Hooks

âŒ **Hiá»ƒu láº§m 3:** "Custom hooks share state giá»¯a components"

- âœ… **Sá»± tháº­t:** Má»—i component gá»i hook cÃ³ STATE RIÃŠNG. Hook chá»‰ share LOGIC, khÃ´ng share state!

âŒ **Hiá»ƒu láº§m 4:** "NÃªn táº¡o custom hook cho má»i thá»©"

- âœ… **Sá»± tháº­t:** Chá»‰ extract khi cÃ³ reuse hoáº·c logic phá»©c táº¡p. Premature abstraction = bad!

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: useFetch - Basic Data Fetching Hook â­

```jsx
import { useReducer, useEffect } from 'react';

// ğŸ­ REDUCER
function fetchReducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { data: null, loading: true, error: null };

    case 'FETCH_SUCCESS':
      return { data: action.payload, loading: false, error: null };

    case 'FETCH_ERROR':
      return { data: null, loading: false, error: action.payload };

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// ğŸ¯ CUSTOM HOOK: useFetch
function useFetch(url, options = {}) {
  const initialState = {
    data: null,
    loading: false,
    error: null,
  };

  const [state, dispatch] = useReducer(fetchReducer, initialState);

  useEffect(() => {
    // âš ï¸ Skip náº¿u no URL
    if (!url) return;

    const controller = new AbortController();

    const fetchData = async () => {
      dispatch({ type: 'FETCH_START' });

      try {
        const response = await fetch(url, {
          ...options,
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        dispatch({ type: 'FETCH_SUCCESS', payload: data });
      } catch (error) {
        if (error.name !== 'AbortError') {
          dispatch({ type: 'FETCH_ERROR', payload: error.message });
        }
      }
    };

    fetchData();

    // Cleanup
    return () => controller.abort();
  }, [url]); // Re-fetch khi URL changes

  return state;
}

// âœ… USAGE EXAMPLES

// Example 1: Simple fetch
function UserList() {
  const { data, loading, error } = useFetch(
    'https://jsonplaceholder.typicode.com/users',
  );

  if (loading) return <div>Loading users...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {data?.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Example 2: Dynamic URL
function UserProfile({ userId }) {
  const { data, loading, error } = useFetch(
    userId ? `https://jsonplaceholder.typicode.com/users/${userId}` : null,
  );

  if (!userId) return <div>Select a user</div>;
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      <h2>{data?.name}</h2>
      <p>{data?.email}</p>
    </div>
  );
}

// Example 3: POST request
function CreatePost() {
  const [title, setTitle] = useState('');
  const [shouldPost, setShouldPost] = useState(false);

  const { data, loading, error } = useFetch(
    shouldPost ? 'https://jsonplaceholder.typicode.com/posts' : null,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title, userId: 1 }),
    },
  );

  const handleSubmit = (e) => {
    e.preventDefault();
    setShouldPost(true);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <button
        type='submit'
        disabled={loading}
      >
        {loading ? 'Creating...' : 'Create Post'}
      </button>
      {error && <div>Error: {error}</div>}
      {data && <div>Created post #{data.id}</div>}
    </form>
  );
}
```

**ğŸ¯ Key Points:**

1. **Hook Naming:**
   - MUST start with `use` (React rule)
   - Descriptive name: `useFetch`, NOT `getData`

2. **Parameters:**
   - Accept `url` and `options`
   - Flexible for different use cases

3. **Return Value:**
   - Return state object: `{ data, loading, error }`
   - Destructure in component

4. **Each Component = Separate State:**
   - `UserList` cÃ³ state riÃªng
   - `UserProfile` cÃ³ state riÃªng
   - Hook chá»‰ share logic!

### Demo 2: useAsync - Generic Async Hook â­â­

```jsx
// ğŸ¯ CUSTOM HOOK: useAsync (More flexible than useFetch)
function useAsync(asyncFunction, immediate = true) {
  const initialState = {
    data: null,
    loading: immediate, // Start loading náº¿u immediate
    error: null,
  };

  const [state, dispatch] = useReducer(fetchReducer, initialState);

  // âœ… Execute function manually
  const execute = async (...params) => {
    dispatch({ type: 'FETCH_START' });

    try {
      const data = await asyncFunction(...params);
      dispatch({ type: 'FETCH_SUCCESS', payload: data });
      return data;
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
      throw error;
    }
  };

  // âœ… Auto-execute on mount náº¿u immediate = true
  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, []); // Empty deps = run once

  return { ...state, execute };
}

// âœ… USAGE EXAMPLES

// Example 1: Auto-execute on mount
function UserList() {
  const fetchUsers = async () => {
    const res = await fetch('https://jsonplaceholder.typicode.com/users');
    return res.json();
  };

  const { data, loading, error } = useAsync(fetchUsers, true);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {data?.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Example 2: Manual execution (button click)
function CreateUser() {
  const [name, setName] = useState('');

  const createUser = async (userName) => {
    const res = await fetch('https://jsonplaceholder.typicode.com/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name: userName }),
    });
    return res.json();
  };

  const { data, loading, error, execute } = useAsync(createUser, false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await execute(name);
      setName(''); // Clear input on success
    } catch (err) {
      // Error already handled by hook
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <button
        type='submit'
        disabled={loading}
      >
        {loading ? 'Creating...' : 'Create'}
      </button>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      {data && <div style={{ color: 'green' }}>Created: {data.name}</div>}
    </form>
  );
}

// Example 3: Retry functionality
function DataWithRetry() {
  const fetchData = async () => {
    // Simulate random failure
    if (Math.random() > 0.5) {
      throw new Error('Random failure');
    }
    const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    return res.json();
  };

  const { data, loading, error, execute } = useAsync(fetchData, true);

  return (
    <div>
      {loading && <div>Loading...</div>}
      {error && (
        <div>
          <div style={{ color: 'red' }}>Error: {error}</div>
          <button onClick={execute}>Retry</button>
        </div>
      )}
      {data && (
        <div>
          <h3>{data.title}</h3>
          <p>{data.body}</p>
        </div>
      )}
    </div>
  );
}
```

**ğŸ¯ useAsync vs useFetch:**

| Feature            | useFetch  | useAsync     |
| ------------------ | --------- | ------------ |
| **URL-specific**   | âœ… Yes    | âŒ No        |
| **Any async fn**   | âŒ No     | âœ… Yes       |
| **Manual trigger** | âŒ Auto   | âœ… execute() |
| **Flexibility**    | âš ï¸ Medium | âœ… High      |

### Demo 3: useForm - Form Management Hook â­â­â­

```jsx
// ğŸ­ FORM REDUCER
function formReducer(state, action) {
  switch (action.type) {
    case 'UPDATE_FIELD':
      return {
        ...state,
        values: {
          ...state.values,
          [action.payload.name]: action.payload.value,
        },
        touched: {
          ...state.touched,
          [action.payload.name]: true,
        },
        // Clear error khi user edits
        errors: {
          ...state.errors,
          [action.payload.name]: undefined,
        },
      };

    case 'SET_ERRORS':
      return {
        ...state,
        errors: action.payload.errors,
      };

    case 'SET_SUBMITTING':
      return {
        ...state,
        isSubmitting: action.payload.isSubmitting,
      };

    case 'RESET_FORM':
      return action.payload.initialState;

    default:
      throw new Error(`Unknown action: ${action.type}`);
  }
}

// ğŸ¯ CUSTOM HOOK: useForm
function useForm(initialValues, validate, onSubmit) {
  const initialState = {
    values: initialValues,
    errors: {},
    touched: {},
    isSubmitting: false,
  };

  const [state, dispatch] = useReducer(formReducer, initialState);

  // âœ… Handle field change
  const handleChange = (e) => {
    const { name, value } = e.target;
    dispatch({
      type: 'UPDATE_FIELD',
      payload: { name, value },
    });
  };

  // âœ… Handle blur (mark as touched)
  const handleBlur = (e) => {
    const { name } = e.target;
    dispatch({
      type: 'UPDATE_FIELD',
      payload: { name, value: state.values[name] },
    });
  };

  // âœ… Handle submit
  const handleSubmit = async (e) => {
    e.preventDefault();

    // Validate
    const validationErrors = validate(state.values);

    if (Object.keys(validationErrors).length > 0) {
      dispatch({
        type: 'SET_ERRORS',
        payload: { errors: validationErrors },
      });
      return;
    }

    // Submit
    dispatch({ type: 'SET_SUBMITTING', payload: { isSubmitting: true } });

    try {
      await onSubmit(state.values);
      // Reset form on success
      dispatch({ type: 'RESET_FORM', payload: { initialState } });
    } catch (error) {
      dispatch({
        type: 'SET_ERRORS',
        payload: { errors: { submit: error.message } },
      });
    } finally {
      dispatch({ type: 'SET_SUBMITTING', payload: { isSubmitting: false } });
    }
  };

  // âœ… Reset form manually
  const reset = () => {
    dispatch({ type: 'RESET_FORM', payload: { initialState } });
  };

  return {
    values: state.values,
    errors: state.errors,
    touched: state.touched,
    isSubmitting: state.isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
  };
}

// âœ… USAGE EXAMPLE
function RegistrationForm() {
  // Initial values
  const initialValues = {
    username: '',
    email: '',
    password: '',
  };

  // Validation function
  const validate = (values) => {
    const errors = {};

    if (!values.username) {
      errors.username = 'Username is required';
    } else if (values.username.length < 3) {
      errors.username = 'Username must be at least 3 characters';
    }

    if (!values.email) {
      errors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(values.email)) {
      errors.email = 'Email is invalid';
    }

    if (!values.password) {
      errors.password = 'Password is required';
    } else if (values.password.length < 6) {
      errors.password = 'Password must be at least 6 characters';
    }

    return errors;
  };

  // Submit handler
  const onSubmit = async (values) => {
    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1000));
    console.log('Form submitted:', values);
    alert('Registration successful!');
  };

  // âœ… Use the hook
  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
  } = useForm(initialValues, validate, onSubmit);

  return (
    <form onSubmit={handleSubmit}>
      {/* Username */}
      <div>
        <label>Username:</label>
        <input
          type='text'
          name='username'
          value={values.username}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.username && errors.username && (
          <span style={{ color: 'red' }}>{errors.username}</span>
        )}
      </div>

      {/* Email */}
      <div>
        <label>Email:</label>
        <input
          type='email'
          name='email'
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.email && errors.email && (
          <span style={{ color: 'red' }}>{errors.email}</span>
        )}
      </div>

      {/* Password */}
      <div>
        <label>Password:</label>
        <input
          type='password'
          name='password'
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
        />
        {touched.password && errors.password && (
          <span style={{ color: 'red' }}>{errors.password}</span>
        )}
      </div>

      {/* Submit error */}
      {errors.submit && <div style={{ color: 'red' }}>{errors.submit}</div>}

      {/* Buttons */}
      <button
        type='submit'
        disabled={isSubmitting}
      >
        {isSubmitting ? 'Submitting...' : 'Register'}
      </button>
      <button
        type='button'
        onClick={reset}
      >
        Reset
      </button>
    </form>
  );
}
```

**ğŸ¯ useForm Benefits:**

1. **Reusable:** DÃ¹ng cho báº¥t ká»³ form nÃ o
2. **Flexible:** Pass custom validate, onSubmit
3. **Complete:** Handles values, errors, touched, submitting
4. **Clean components:** Form logic extracted

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Level 1: Ãp Dá»¥ng Concept (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Create useToggle custom hook
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: Context, useMemo, useCallback
 *
 * Requirements:
 * 1. Hook quáº£n lÃ½ boolean state (true/false)
 * 2. Provide: value, toggle(), setTrue(), setFalse()
 * 3. Optional initial value (default false)
 *
 * Usage:
 * const { value, toggle, setTrue, setFalse } = useToggle(false);
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - DÃ¹ng useState (simple case, khÃ´ng cáº§n useReducer)
 * - Return object vá»›i 4 properties
 * - Memoize functions? NO - chÆ°a há»c useCallback!
 */

// TODO: Implement useToggle hook

// Starter:
function useToggle(initialValue = false) {
  // TODO: Implement
}

// Test component:
function ToggleDemo() {
  const modal = useToggle(false);
  const sidebar = useToggle(true);

  return (
    <div>
      <button onClick={modal.toggle}>Toggle Modal</button>
      <button onClick={modal.setTrue}>Open Modal</button>
      <button onClick={modal.setFalse}>Close Modal</button>
      {modal.value && <div>Modal is open!</div>}

      <button onClick={sidebar.toggle}>Toggle Sidebar</button>
      {sidebar.value && <div>Sidebar visible</div>}
    </div>
  );
}
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook quáº£n lÃ½ tráº¡ng thÃ¡i boolean vá»›i cÃ¡c hÃ m Ä‘iá»u khiá»ƒn tiá»‡n lá»£i
 * @param {boolean} [initialValue=false] - GiÃ¡ trá»‹ ban Ä‘áº§u
 * @returns {{
 *   value: boolean,
 *   toggle: () => void,
 *   setTrue: () => void,
 *   setFalse: () => void
 * }}
 */
function useToggle(initialValue = false) {
  const [value, setValue] = React.useState(initialValue);

  const toggle = () => setValue((prev) => !prev);
  const setTrue = () => setValue(true);
  const setFalse = () => setValue(false);

  return { value, toggle, setTrue, setFalse };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VÃ­ dá»¥ sá»­ dá»¥ng
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function ToggleDemo() {
  const modal = useToggle(false);
  const sidebar = useToggle(true);

  return (
    <div>
      <button onClick={modal.toggle}>Toggle Modal</button>
      <button onClick={modal.setTrue}>Open Modal</button>
      <button onClick={modal.setFalse}>Close Modal</button>
      {modal.value && <div>Modal is open!</div>}

      <hr />

      <button onClick={sidebar.toggle}>Toggle Sidebar</button>
      {sidebar.value && <div>Sidebar visible</div>}
    </div>
  );
}

/* Káº¿t quáº£ vÃ­ dá»¥:
- Ban Ä‘áº§u: Modal Ä‘Ã³ng, Sidebar má»Ÿ
- Nháº¥n "Toggle Modal" â†’ Modal má»Ÿ â†’ nháº¥n láº§n ná»¯a â†’ Modal Ä‘Ã³ng
- Nháº¥n "Open Modal" â†’ Modal má»Ÿ (dÃ¹ trÆ°á»›c Ä‘Ã³ Ä‘ang Ä‘Ã³ng)
- Nháº¥n "Close Modal" â†’ Modal Ä‘Ã³ng ngay láº­p tá»©c
- Sidebar cÃ³ thá»ƒ báº­t/táº¯t Ä‘á»™c láº­p
*/
```

</details>

### â­â­ Level 2: Nháº­n Biáº¿t Pattern (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Create useLocalStorage hook
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Requirements:
 * - Sync state vá»›i localStorage
 * - Auto-save khi state changes
 * - Auto-load tá»« localStorage on mount
 * - Handle JSON serialization
 * - Handle localStorage errors (quota, private mode)
 *
 * Usage:
 * const [name, setName] = useLocalStorage('username', 'Guest');
 * // name auto loads from localStorage
 * // setName auto saves to localStorage
 *
 * ğŸ¤” DESIGN DECISIONS:
 *
 * Approach A: useState + useEffect
 * - useState for state
 * - useEffect to sync localStorage
 * Pros: Simple, straightforward
 * Cons: 2 separate hooks, potential race conditions
 *
 * Approach B: useReducer
 * - Reducer handles both state + localStorage
 * - Actions: SET_VALUE, LOAD_FROM_STORAGE
 * Pros: Centralized logic, atomic updates
 * Cons: More boilerplate
 *
 * ğŸ’­ WHICH APPROACH AND WHY?
 * (Document your decision in comments)
 */

// TODO: Implement useLocalStorage

// Hints:
// - localStorage.getItem(key)
// - localStorage.setItem(key, value)
// - JSON.parse(), JSON.stringify()
// - Try-catch for errors
// - Check if window.localStorage exists (SSR)

// Test:
function LocalStorageDemo() {
  const [name, setName] = useLocalStorage('username', 'Guest');
  const [count, setCount] = useLocalStorage('count', 0);

  return (
    <div>
      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <p>Stored name: {name}</p>

      <button onClick={() => setCount(count + 1)}>Count: {count}</button>

      <p>Refresh page - values persist!</p>
    </div>
  );
}
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook Ä‘á»“ng bá»™ state vá»›i localStorage
 * Tá»± Ä‘á»™ng load khi mount, tá»± Ä‘á»™ng save khi state thay Ä‘á»•i
 * @template T
 * @param {string} key - Key trong localStorage
 * @param {T} initialValue - GiÃ¡ trá»‹ máº·c Ä‘á»‹nh náº¿u chÆ°a cÃ³ dá»¯ liá»‡u
 * @returns {[T, (value: T | ((val: T) => T)) => void]}
 */
function useLocalStorage(key, initialValue) {
  // Load tá»« localStorage khi mount (chá»‰ cháº¡y 1 láº§n)
  const [storedValue, setStoredValue] = React.useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      // Náº¿u cÃ³ dá»¯ liá»‡u â†’ parse, khÃ´ng cÃ³ â†’ dÃ¹ng initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key â€œ${key}â€:`, error);
      return initialValue;
    }
  });

  // Má»—i khi storedValue thay Ä‘á»•i â†’ lÆ°u vÃ o localStorage
  React.useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(storedValue));
    } catch (error) {
      console.warn(`Error writing localStorage key â€œ${key}â€:`, error);
    }
  }, [key, storedValue]);

  return [storedValue, setStoredValue];
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VÃ­ dá»¥ sá»­ dá»¥ng
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function LocalStorageDemo() {
  const [name, setName] = useLocalStorage('username', 'Guest');
  const [count, setCount] = useLocalStorage('count', 0);

  return (
    <div style={{ padding: '20px', fontFamily: 'sans-serif' }}>
      <h2>useLocalStorage Demo</h2>

      <div style={{ marginBottom: '20px' }}>
        <label>
          Name:{' '}
          <input
            value={name}
            onChange={(e) => setName(e.target.value)}
            style={{ padding: '8px', fontSize: '16px' }}
          />
        </label>
        <p>
          <strong>Stored name:</strong> {name || 'Guest'}
        </p>
      </div>

      <div>
        <button
          onClick={() => setCount(count + 1)}
          style={{ padding: '10px 20px', fontSize: '16px' }}
        >
          Count: {count}
        </button>
      </div>

      <p style={{ marginTop: '30px', color: '#555' }}>
        ğŸ”„ Refresh trang hoáº·c Ä‘Ã³ng tab â†’ dá»¯ liá»‡u váº«n cÃ²n!
      </p>
    </div>
  );
}

/* Káº¿t quáº£ vÃ­ dá»¥:
- Láº§n Ä‘áº§u má»Ÿ trang: name = "Guest", count = 0
- Thay Ä‘á»•i input â†’ giÃ¡ trá»‹ tá»± Ä‘á»™ng lÆ°u vÃ o localStorage
- TÄƒng count â†’ cÅ©ng tá»± Ä‘á»™ng lÆ°u
- Refresh trang â†’ má»i giÃ¡ trá»‹ Ä‘Æ°á»£c khÃ´i phá»¥c chÃ­nh xÃ¡c
- Má»Ÿ DevTools â†’ Application â†’ Local Storage â†’ tháº¥y 2 key: "username" vÃ  "count"
*/
```

**Design Decision**: Chá»n **Approach A (useState + useEffect)**  
LÃ½ do:

- ÄÆ¡n giáº£n, dá»… hiá»ƒu, Ã­t boilerplate
- KhÃ´ng cáº§n reducer vÃ¬ chá»‰ cÃ³ 1 action chÃ­nh (set value)
- useEffect chá»‰ cháº¡y khi value thay Ä‘á»•i â†’ performance tá»‘t
- Xá»­ lÃ½ lá»—i localStorage (private mode, quota exceeded) báº±ng try/catch
- Hoáº¡t Ä‘á»™ng tá»‘t vá»›i SSR náº¿u thÃªm kiá»ƒm tra `typeof window !== 'undefined'`

</details>

### â­â­â­ Level 3: Ká»‹ch Báº£n Thá»±c Táº¿ (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Create usePagination hook
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  developer, tÃ´i muá»‘n pagination logic reusable"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Track current page
 * - [ ] Calculate total pages from total items
 * - [ ] Provide: currentPage, totalPages, goToPage, nextPage, prevPage
 * - [ ] Prevent going < 1 or > totalPages
 * - [ ] Calculate offset for API (skip = (page - 1) * pageSize)
 * - [ ] Reset to page 1 when totalItems changes
 *
 * Usage:
 * const pagination = usePagination({
 *   totalItems: 100,
 *   itemsPerPage: 10,
 *   initialPage: 1
 * });
 *
 * <button onClick={pagination.prevPage} disabled={pagination.currentPage === 1}>
 *   Previous
 * </button>
 * <span>Page {pagination.currentPage} of {pagination.totalPages}</span>
 * <button onClick={pagination.nextPage} disabled={pagination.currentPage === pagination.totalPages}>
 *   Next
 * </button>
 *
 * ğŸ¨ State Shape:
 * {
 *   currentPage: 1,
 *   totalPages: 10,
 *   itemsPerPage: 10,
 *   totalItems: 100,
 *   offset: 0
 * }
 *
 * ğŸš¨ Edge Cases:
 * - totalItems = 0 â†’ totalPages = 0
 * - currentPage > totalPages after totalItems reduces
 * - Negative page numbers
 * - Non-integer inputs
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] useReducer with actions: SET_PAGE, NEXT_PAGE, PREV_PAGE, SET_TOTAL_ITEMS
 * - [ ] Calculate totalPages = Math.ceil(totalItems / itemsPerPage)
 * - [ ] Calculate offset = (currentPage - 1) * itemsPerPage
 * - [ ] useEffect: reset to page 1 náº¿u totalItems changes
 * - [ ] Validate: page >= 1 && page <= totalPages
 */

// TODO: Implement usePagination

// Test with real API:
function PaginatedUsers() {
  const [totalItems, setTotalItems] = useState(0);

  const pagination = usePagination({
    totalItems,
    itemsPerPage: 5,
    initialPage: 1,
  });

  const { data, loading, error } = useFetch(
    `https://jsonplaceholder.typicode.com/users?_start=${pagination.offset}&_limit=5`,
  );

  // Update total on initial load
  useEffect(() => {
    if (data && totalItems === 0) {
      setTotalItems(10); // Total users in API
    }
  }, [data]);

  return (
    <div>
      {loading && <div>Loading...</div>}
      {error && <div>Error: {error}</div>}
      {data && (
        <>
          <ul>
            {data.map((user) => (
              <li key={user.id}>{user.name}</li>
            ))}
          </ul>

          <div>
            <button
              onClick={pagination.prevPage}
              disabled={pagination.currentPage === 1}
            >
              Previous
            </button>
            <span>
              Page {pagination.currentPage} of {pagination.totalPages}
            </span>
            <button
              onClick={pagination.nextPage}
              disabled={pagination.currentPage === pagination.totalPages}
            >
              Next
            </button>
          </div>
        </>
      )}
    </div>
  );
}
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook quáº£n lÃ½ logic phÃ¢n trang (pagination)
 * @param {Object} options
 * @param {number} options.totalItems - Tá»•ng sá»‘ item (thÆ°á»ng tá»« API)
 * @param {number} [options.itemsPerPage=10] - Sá»‘ item má»—i trang
 * @param {number} [options.initialPage=1] - Trang báº¯t Ä‘áº§u
 * @returns {{
 *   currentPage: number,
 *   totalPages: number,
 *   itemsPerPage: number,
 *   offset: number,
 *   goToPage: (page: number) => void,
 *   nextPage: () => void,
 *   prevPage: () => void,
 *   canGoNext: boolean,
 *   canGoPrev: boolean
 * }}
 */
function usePagination({
  totalItems,
  itemsPerPage = 10,
  initialPage = 1,
} = {}) {
  const [currentPage, setCurrentPage] = React.useState(initialPage);

  // TÃ­nh toÃ¡n láº¡i khi totalItems thay Ä‘á»•i â†’ reset vá» trang 1 náº¿u cáº§n
  React.useEffect(() => {
    // Náº¿u totalItems giáº£m máº¡nh â†’ currentPage cÃ³ thá»ƒ vÆ°á»£t quÃ¡ totalPages
    const newTotalPages = Math.max(1, Math.ceil(totalItems / itemsPerPage));
    if (currentPage > newTotalPages) {
      setCurrentPage(newTotalPages);
    }
    // Náº¿u totalItems = 0 â†’ vá» trang 1
    if (totalItems === 0) {
      setCurrentPage(1);
    }
  }, [totalItems, itemsPerPage, currentPage]);

  const totalPages = Math.max(1, Math.ceil(totalItems / itemsPerPage));
  const offset = (currentPage - 1) * itemsPerPage;

  const goToPage = (page) => {
    const target = Math.max(1, Math.min(page, totalPages));
    setCurrentPage(target);
  };

  const nextPage = () => {
    if (currentPage < totalPages) {
      setCurrentPage((prev) => prev + 1);
    }
  };

  const prevPage = () => {
    if (currentPage > 1) {
      setCurrentPage((prev) => prev - 1);
    }
  };

  return {
    currentPage,
    totalPages,
    itemsPerPage,
    offset,
    goToPage,
    nextPage,
    prevPage,
    canGoNext: currentPage < totalPages,
    canGoPrev: currentPage > 1,
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VÃ­ dá»¥ sá»­ dá»¥ng vá»›i API thá»±c táº¿ (jsonplaceholder)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function PaginatedUsers() {
  const [totalItems, setTotalItems] = React.useState(0);

  const pagination = usePagination({
    totalItems,
    itemsPerPage: 5,
    initialPage: 1,
  });

  const { data, loading, error } = useFetch(
    `https://jsonplaceholder.typicode.com/users?_start=${pagination.offset}&_limit=5`,
  );

  // Cáº­p nháº­t totalItems má»™t láº§n khi load danh sÃ¡ch Ä‘áº§u tiÃªn
  React.useEffect(() => {
    if (data && totalItems === 0) {
      // jsonplaceholder cÃ³ 10 users
      setTotalItems(10);
    }
  }, [data, totalItems]);

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h2>Users (Paginated)</h2>

      {loading && <p>Loading users...</p>}
      {error && <p style={{ color: 'red' }}>Error: {error}</p>}

      {data && (
        <>
          <ul style={{ listStyle: 'none', padding: 0 }}>
            {data.map((user) => (
              <li
                key={user.id}
                style={{
                  padding: '12px',
                  borderBottom: '1px solid #eee',
                }}
              >
                <strong>{user.name}</strong>
                <br />
                <small>{user.email}</small>
              </li>
            ))}
          </ul>

          <div
            style={{
              marginTop: '24px',
              display: 'flex',
              alignItems: 'center',
              gap: '16px',
              justifyContent: 'center',
            }}
          >
            <button
              onClick={pagination.prevPage}
              disabled={!pagination.canGoPrev}
              style={{
                padding: '8px 16px',
                cursor: pagination.canGoPrev ? 'pointer' : 'not-allowed',
              }}
            >
              Previous
            </button>

            <span>
              Page <strong>{pagination.currentPage}</strong> of{' '}
              <strong>{pagination.totalPages}</strong>
            </span>

            <button
              onClick={pagination.nextPage}
              disabled={!pagination.canGoNext}
              style={{
                padding: '8px 16px',
                cursor: pagination.canGoNext ? 'pointer' : 'not-allowed',
              }}
            >
              Next
            </button>
          </div>
        </>
      )}
    </div>
  );
}

/* Káº¿t quáº£ vÃ­ dá»¥:
- Trang 1: hiá»ƒn thá»‹ users 1â€“5
- Nháº¥n Next â†’ Trang 2: users 6â€“10
- Nháº¥n Previous â†’ quay láº¡i Trang 1
- KhÃ´ng thá»ƒ Next khi Ä‘ang á»Ÿ trang 2 (vÃ¬ total = 10, 2 trang)
- KhÃ´ng thá»ƒ Previous khi Ä‘ang á»Ÿ trang 1
- Náº¿u totalItems thay Ä‘á»•i (vÃ­ dá»¥ API tráº£ vá» 7 users), tá»± Ä‘á»™ng Ä‘iá»u chá»‰nh totalPages vÃ  reset page náº¿u cáº§n
*/
```

</details>

### â­â­â­â­ Level 4: Quyáº¿t Äá»‹nh Kiáº¿n TrÃºc (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Create useInfiniteScroll hook
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Context: Infinite scroll lÃ  common pattern (Twitter, Instagram)
 * Cáº§n reusable hook cho nhiá»u lists.
 *
 * Design Questions:
 *
 * 1. State Management:
 *    Option A: useState for each piece
 *    Option B: useReducer for combined state
 *    â†’ DECIDE & DOCUMENT
 *
 * 2. Scroll Detection:
 *    Option A: window scroll listener
 *    Option B: IntersectionObserver (sentinel element)
 *    â†’ DECIDE & DOCUMENT
 *
 * 3. Loading More:
 *    Option A: Hook handles fetching
 *    Option B: Hook only detects scroll, component fetches
 *    â†’ DECIDE & DOCUMENT
 *
 * ğŸ“ Design Doc:
 *
 * ## State Management Decision
 * Choose: useReducer
 * Reason: Multiple related states (items, page, hasMore, loading)
 *
 * ## Scroll Detection Decision
 * Choose: IntersectionObserver
 * Reason: Better performance, no scroll event spam
 *
 * ## Fetch Strategy Decision
 * Choose: Hook returns loadMore callback
 * Reason: Flexibility (works with any API)
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 *
 * Hook API:
 * const { items, loadMore, loading, hasMore, observer } = useInfiniteScroll({
 *   fetchFunction: (page) => fetch(`/api/items?page=${page}`),
 *   initialPage: 1
 * });
 *
 * Usage:
 * - Append observer ref to sentinel element: <div ref={observer} />
 * - When sentinel visible â†’ auto call loadMore
 *
 * State:
 * {
 *   items: [],
 *   page: 1,
 *   loading: false,
 *   hasMore: true
 * }
 *
 * Actions:
 * - LOAD_START
 * - LOAD_SUCCESS (append items, increment page)
 * - LOAD_ERROR
 * - NO_MORE_DATA
 *
 * ğŸ§ª PHASE 3: Testing (10 phÃºt)
 *
 * Test cases:
 * - Initial load â†’ show first page
 * - Scroll to bottom â†’ load page 2
 * - Continue scrolling â†’ load pages 3, 4...
 * - No more data â†’ stop loading
 * - Error handling â†’ retry option
 */

// TODO: Implement useInfiniteScroll

// Hints:
// - useRef for IntersectionObserver
// - useEffect setup observer
// - Cleanup: observer.disconnect()
// - Check entries[0].isIntersecting

// Test:
function InfinitePhotoGallery() {
  const fetchPhotos = async (page) => {
    const res = await fetch(
      `https://jsonplaceholder.typicode.com/photos?_page=${page}&_limit=10`,
    );
    const data = await res.json();
    return data;
  };

  const { items, loading, hasMore, observerRef } = useInfiniteScroll({
    fetchFunction: fetchPhotos,
    initialPage: 1,
  });

  return (
    <div>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(3, 1fr)',
          gap: '10px',
        }}
      >
        {items.map((photo) => (
          <img
            key={photo.id}
            src={photo.thumbnailUrl}
            alt={photo.title}
            style={{ width: '100%' }}
          />
        ))}
      </div>

      {loading && <div>Loading more...</div>}
      {hasMore && (
        <div
          ref={observerRef}
          style={{ height: '20px' }}
        />
      )}
      {!hasMore && <div>No more photos</div>}
    </div>
  );
}
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook há»— trá»£ infinite scroll sá»­ dá»¥ng IntersectionObserver
 * Hook chá»‰ quáº£n lÃ½ viá»‡c phÃ¡t hiá»‡n scroll vÃ  trigger loadMore callback,
 * component chá»‹u trÃ¡ch nhiá»‡m fetch data vÃ  append items.
 *
 * @param {Object} options
 * @param {Function} options.loadMore - async function gá»i Ä‘á»ƒ táº£i thÃªm dá»¯ liá»‡u
 *                                      nháº­n tham sá»‘ currentPage vÃ  tráº£ vá» array items má»›i
 * @param {number} [options.initialPage=1] - trang báº¯t Ä‘áº§u
 * @param {boolean} [options.enabled=true] - cÃ³ báº­t infinite scroll hay khÃ´ng
 * @returns {{
 *   items: any[],
 *   page: number,
 *   loading: boolean,
 *   hasMore: boolean,
 *   error: string | null,
 *   loadMore: () => Promise<void>,
 *   observerRef: (node: Element | null) => void,
 *   reset: () => void
 * }}
 */
function useInfiniteScroll({
  loadMore, // async (page) => Promise<any[]>
  initialPage = 1,
  enabled = true,
} = {}) {
  const [items, setItems] = React.useState([]);
  const [page, setPage] = React.useState(initialPage);
  const [loading, setLoading] = React.useState(false);
  const [hasMore, setHasMore] = React.useState(true);
  const [error, setError] = React.useState(null);

  const observer = React.useRef(null);
  const sentinelRef = React.useRef(null);

  // Cleanup observer khi unmount
  React.useEffect(() => {
    return () => {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, []);

  // Táº¡o IntersectionObserver
  React.useEffect(() => {
    if (!enabled || !hasMore || loading) return;

    observer.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !loading) {
          loadMoreFn();
        }
      },
      { threshold: 0.1 },
    );

    if (sentinelRef.current) {
      observer.current.observe(sentinelRef.current);
    }

    return () => {
      if (observer.current && sentinelRef.current) {
        observer.current.unobserve(sentinelRef.current);
      }
    };
  }, [enabled, hasMore, loading, page]);

  const loadMoreFn = React.useCallback(async () => {
    if (loading || !hasMore) return;

    setLoading(true);
    setError(null);

    try {
      const newItems = await loadMore(page);

      if (!newItems || newItems.length === 0) {
        setHasMore(false);
        return;
      }

      setItems((prev) => [...prev, ...newItems]);
      setPage((prev) => prev + 1);

      // Náº¿u API tráº£ vá» Ã­t hÆ¡n mong Ä‘á»£i â†’ coi nhÆ° háº¿t
      if (newItems.length < 5) {
        // ngÆ°á»¡ng tÃ¹y Ã½
        setHasMore(false);
      }
    } catch (err) {
      setError(err.message || 'Failed to load more items');
      setHasMore(false);
    } finally {
      setLoading(false);
    }
  }, [loading, hasMore, page, loadMore]);

  // Manual trigger load more (cho nÃºt "Load more" fallback)
  const manualLoadMore = React.useCallback(() => {
    if (!loading && hasMore) {
      loadMoreFn();
    }
  }, [loading, hasMore, loadMoreFn]);

  // Reset toÃ n bá»™ state
  const reset = React.useCallback(() => {
    setItems([]);
    setPage(initialPage);
    setLoading(false);
    setHasMore(true);
    setError(null);
  }, [initialPage]);

  // Ref callback cho sentinel element
  const observerRef = React.useCallback(
    (node) => {
      if (node !== null) {
        sentinelRef.current = node;
        if (observer.current && enabled) {
          observer.current.observe(node);
        }
      }
    },
    [enabled],
  );

  // Load trang Ä‘áº§u tiÃªn tá»± Ä‘á»™ng náº¿u enabled
  React.useEffect(() => {
    if (enabled && page === initialPage && items.length === 0 && !loading) {
      loadMoreFn();
    }
  }, [enabled, initialPage, loadMoreFn, items.length, loading, page]);

  return {
    items,
    page,
    loading,
    hasMore,
    error,
    loadMore: manualLoadMore,
    observerRef,
    reset,
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VÃ­ dá»¥ sá»­ dá»¥ng
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function InfinitePhotoGallery() {
  const fetchPhotos = async (page) => {
    const res = await fetch(
      `https://jsonplaceholder.typicode.com/photos?_page=${page}&_limit=10`,
    );
    if (!res.ok) throw new Error('Network response was not ok');
    return res.json();
  };

  const { items, loading, hasMore, error, observerRef } = useInfiniteScroll({
    loadMore: fetchPhotos,
    initialPage: 1,
    enabled: true,
  });

  return (
    <div style={{ padding: '20px' }}>
      <h2>Infinite Photo Gallery</h2>

      {error && (
        <div style={{ color: 'red', marginBottom: '16px' }}>
          {error}
          <button
            onClick={() => {
              // CÃ³ thá»ƒ thÃªm retry logic á»Ÿ Ä‘Ã¢y
              window.location.reload();
            }}
            style={{ marginLeft: '12px' }}
          >
            Retry
          </button>
        </div>
      )}

      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))',
          gap: '16px',
        }}
      >
        {items.map((photo) => (
          <div
            key={photo.id}
            style={{
              border: '1px solid #ddd',
              borderRadius: '8px',
              overflow: 'hidden',
            }}
          >
            <img
              src={photo.thumbnailUrl}
              alt={photo.title}
              style={{ width: '100%', height: 'auto', display: 'block' }}
              loading='lazy'
            />
            <div style={{ padding: '8px', fontSize: '14px' }}>
              {photo.title.substring(0, 40)}
              {photo.title.length > 40 ? '...' : ''}
            </div>
          </div>
        ))}
      </div>

      {loading && (
        <div
          style={{ textAlign: 'center', padding: '40px 0', fontSize: '18px' }}
        >
          Loading more photos...
        </div>
      )}

      {hasMore && !loading && (
        <div
          ref={observerRef}
          style={{
            height: '80px',
            margin: '20px 0',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
        >
          {/* Sentinel element â€“ khi scroll Ä‘áº¿n Ä‘Ã¢y sáº½ tá»± Ä‘á»™ng load */}
        </div>
      )}

      {!hasMore && items.length > 0 && (
        <div style={{ textAlign: 'center', padding: '40px 0', color: '#666' }}>
          No more photos to load
        </div>
      )}

      {items.length === 0 && !loading && !error && (
        <div style={{ textAlign: 'center', padding: '60px 0' }}>
          Loading initial photos...
        </div>
      )}
    </div>
  );
}

/* Káº¿t quáº£ vÃ­ dá»¥:
- Trang tá»± Ä‘á»™ng táº£i 10 áº£nh Ä‘áº§u tiÃªn khi mount
- Khi scroll xuá»‘ng gáº§n cuá»‘i (sentinel element hiá»‡n ra) â†’ tá»± Ä‘á»™ng táº£i trang tiáº¿p theo
- Má»—i láº§n load thÃªm 10 áº£nh, append vÃ o danh sÃ¡ch
- Khi API háº¿t dá»¯ liá»‡u (hoáº·c tráº£ vá» máº£ng rá»—ng) â†’ hasMore = false, hiá»ƒn thá»‹ thÃ´ng bÃ¡o "No more photos"
- Há»— trá»£ error handling vÃ  lazy loading áº£nh
- CÃ³ thá»ƒ reset báº±ng cÃ¡ch gá»i hook.reset() náº¿u cáº§n
*/
```

**Design Decisions (tÃ³m táº¯t):**

- State Management â†’ useState riÃªng láº» (khÃ´ng dÃ¹ng useReducer)  
  â†’ ÄÆ¡n giáº£n hÆ¡n, Ã­t boilerplate, Ä‘á»§ cho trÆ°á»ng há»£p nÃ y

- Scroll Detection â†’ IntersectionObserver (sentinel)  
  â†’ Hiá»‡u suáº¥t tá»‘t, khÃ´ng gÃ¢y lag nhÆ° window scroll listener

- Fetch Strategy â†’ Hook chá»‰ trigger loadMore callback  
  â†’ Linh hoáº¡t: component quyáº¿t Ä‘á»‹nh cÃ¡ch fetch (useFetch, axios, fetch, graphqlâ€¦)

</details>

### â­â­â­â­â­ Level 5: Production Challenge (90 phÃºt)

````jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build useDataTable Hook Suite
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 *
 * "Reusable Data Table System" - Hook suite cho data tables
 *
 * Hooks to Build:
 * 1. useDataTable (main hook - composes others)
 * 2. useTableSort
 * 3. useTableFilter
 * 4. useTableSelection
 * 5. useTablePagination (from Level 3)
 *
 * ğŸ—ï¸ Technical Design:
 *
 * 1. Hook Composition Pattern:
 * function useDataTable(data, config) {
 *   const sort = useTableSort(data, config.defaultSort);
 *   const filter = useTableFilter(sort.data, config.filters);
 *   const selection = useTableSelection(filter.data);
 *   const pagination = useTablePagination({
 *     totalItems: filter.data.length,
 *     itemsPerPage: config.pageSize
 *   });
 *
 *   return {
 *     data: pagination.paginatedData,
 *     sort,
 *     filter,
 *     selection,
 *     pagination
 *   };
 * }
 *
 * 2. useTableSort:
 * - State: { column: null, direction: 'asc' }
 * - Actions: SORT_BY_COLUMN, TOGGLE_DIRECTION
 * - Returns: { data, sortBy, sortDirection, toggleSort }
 *
 * 3. useTableFilter:
 * - State: { filters: {} }
 * - Actions: SET_FILTER, CLEAR_FILTER, CLEAR_ALL
 * - Returns: { data, filters, setFilter, clearFilter }
 *
 * 4. useTableSelection:
 * - State: { selected: Set(), selectAll: false }
 * - Actions: SELECT, DESELECT, TOGGLE, SELECT_ALL, DESELECT_ALL
 * - Returns: { selected, toggleSelection, selectAll, clearSelection }
 *
 * 5. Hook Composition Flow:
 * Raw Data
 *   â†“ useTableSort
 * Sorted Data
 *   â†“ useTableFilter
 * Filtered Data
 *   â†“ useTableSelection (on filtered)
 * Selected Items
 *   â†“ useTablePagination
 * Paginated Data
 *
 * âœ… Production Checklist:
 * - [ ] Each hook testable independently
 * - [ ] Hooks composable (work together)
 * - [ ] Type-safe (document expected shapes)
 * - [ ] Performance (memo filtered/sorted data)
 * - [ ] Edge cases:
 *   - [ ] Empty data
 *   - [ ] Sort by non-existent column
 *   - [ ] Select all with pagination
 *   - [ ] Filter removes selected items
 * - [ ] Demo component using all hooks
 * - [ ] Documentation for each hook
 *
 * ğŸ“ Documentation Template (for each hook):
 *
 * ## useTableSort
 *
 * ### Purpose
 * Handles table column sorting
 *
 * ### API
 * ```js
 * const { data, column, direction, toggleSort } = useTableSort(rawData, defaultSort);
 * ```
 *
 * ### Parameters
 * - rawData: Array - Data to sort
 * - defaultSort: Object - { column: string, direction: 'asc'|'desc' }
 *
 * ### Returns
 * - data: Array - Sorted data
 * - column: string - Current sort column
 * - direction: 'asc'|'desc' - Current direction
 * - toggleSort: Function - (columnName) => void
 *
 * ### Example
 * ```js
 * const users = [{ name: 'Alice', age: 30 }, { name: 'Bob', age: 25 }];
 * const sort = useTableSort(users, { column: 'name', direction: 'asc' });
 * ```
 *
 * ğŸ” Self-Review:
 * - [ ] Hooks don't violate Rules of Hooks
 * - [ ] Each hook has single responsibility
 * - [ ] Composition works smoothly
 * - [ ] No prop drilling (hooks provide direct access)
 * - [ ] Documented edge cases handled
 */

// TODO: Implement hook suite

// Starter: Sample data
const sampleUsers = [
  { id: 1, name: 'Alice', age: 30, role: 'Admin', active: true },
  { id: 2, name: 'Bob', age: 25, role: 'User', active: false },
  { id: 3, name: 'Charlie', age: 35, role: 'User', active: true },
  { id: 4, name: 'Diana', age: 28, role: 'Admin', active: true },
  // ... 20 more users
];

// TODO: Implement hooks

// Demo component:
function DataTableDemo() {
  const table = useDataTable(sampleUsers, {
    defaultSort: { column: 'name', direction: 'asc' },
    pageSize: 5,
    filters: ['role', 'active'],
  });

  return (
    <div>
      {/* Filters */}
      <div>
        <select
          onChange={(e) => table.filter.setFilter('role', e.target.value)}
        >
          <option value=''>All Roles</option>
          <option value='Admin'>Admin</option>
          <option value='User'>User</option>
        </select>

        <label>
          <input
            type='checkbox'
            checked={table.filter.filters.active}
            onChange={(e) => table.filter.setFilter('active', e.target.checked)}
          />
          Active Only
        </label>
      </div>

      {/* Selection */}
      <div>
        <button onClick={table.selection.selectAll}>Select All</button>
        <button onClick={table.selection.clearSelection}>
          Clear Selection
        </button>
        <span>Selected: {table.selection.selected.size}</span>
      </div>

      {/* Table */}
      <table>
        <thead>
          <tr>
            <th>
              <input
                type='checkbox'
                checked={table.selection.allSelected}
                onChange={table.selection.toggleSelectAll}
              />
            </th>
            <th onClick={() => table.sort.toggleSort('name')}>
              Name{' '}
              {table.sort.column === 'name' &&
                (table.sort.direction === 'asc' ? 'â†‘' : 'â†“')}
            </th>
            <th onClick={() => table.sort.toggleSort('age')}>
              Age{' '}
              {table.sort.column === 'age' &&
                (table.sort.direction === 'asc' ? 'â†‘' : 'â†“')}
            </th>
            <th>Role</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          {table.data.map((user) => (
            <tr key={user.id}>
              <td>
                <input
                  type='checkbox'
                  checked={table.selection.selected.has(user.id)}
                  onChange={() => table.selection.toggleSelection(user.id)}
                />
              </td>
              <td>{user.name}</td>
              <td>{user.age}</td>
              <td>{user.role}</td>
              <td>{user.active ? 'Active' : 'Inactive'}</td>
            </tr>
          ))}
        </tbody>
      </table>

      {/* Pagination */}
      <div>
        <button
          onClick={table.pagination.prevPage}
          disabled={table.pagination.currentPage === 1}
        >
          Previous
        </button>
        <span>
          Page {table.pagination.currentPage} of {table.pagination.totalPages}
        </span>
        <button
          onClick={table.pagination.nextPage}
          disabled={
            table.pagination.currentPage === table.pagination.totalPages
          }
        >
          Next
        </button>
      </div>
    </div>
  );
}
````

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * === useTableSort ===
 * Hook quáº£n lÃ½ sáº¯p xáº¿p báº£ng theo cá»™t
 */
function useTableSort(data, defaultSort = { column: null, direction: 'asc' }) {
  const [sort, setSort] = React.useState(defaultSort);

  const sortedData = React.useMemo(() => {
    if (!sort.column) return [...data];

    return [...data].sort((a, b) => {
      const aValue = a[sort.column];
      const bValue = b[sort.column];

      if (typeof aValue === 'string' && typeof bValue === 'string') {
        return sort.direction === 'asc'
          ? aValue.localeCompare(bValue)
          : bValue.localeCompare(aValue);
      }

      if (aValue < bValue) return sort.direction === 'asc' ? -1 : 1;
      if (aValue > bValue) return sort.direction === 'asc' ? 1 : -1;
      return 0;
    });
  }, [data, sort.column, sort.direction]);

  const toggleSort = (column) => {
    setSort((prev) => ({
      column,
      direction:
        prev.column === column && prev.direction === 'asc' ? 'desc' : 'asc',
    }));
  };

  return {
    data: sortedData,
    column: sort.column,
    direction: sort.direction,
    toggleSort,
  };
}

/**
 * === useTableFilter ===
 * Hook quáº£n lÃ½ lá»c dá»¯ liá»‡u theo nhiá»u trÆ°á»ng
 */
function useTableFilter(data, filterableFields = []) {
  const [filters, setFilters] = React.useState({});

  const filteredData = React.useMemo(() => {
    return data.filter((item) => {
      return Object.entries(filters).every(([key, value]) => {
        if (value === undefined || value === '' || value === null) return true;

        const itemValue = item[key];

        if (typeof value === 'boolean') {
          return itemValue === value;
        }

        if (typeof itemValue === 'string') {
          return itemValue.toLowerCase().includes(value.toLowerCase());
        }

        return itemValue === value;
      });
    });
  }, [data, filters]);

  const setFilter = (key, value) => {
    setFilters((prev) => ({
      ...prev,
      [key]: value,
    }));
  };

  const clearFilter = (key) => {
    setFilters((prev) => {
      const next = { ...prev };
      delete next[key];
      return next;
    });
  };

  const clearAllFilters = () => setFilters({});

  return {
    data: filteredData,
    filters,
    setFilter,
    clearFilter,
    clearAllFilters,
  };
}

/**
 * === useTableSelection ===
 * Hook quáº£n lÃ½ chá»n nhiá»u báº£n ghi (checkbox)
 */
function useTableSelection(data) {
  const [selected, setSelected] = React.useState(new Set());

  const toggleSelection = (id) => {
    setSelected((prev) => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  };

  const selectAll = () => {
    setSelected(new Set(data.map((item) => item.id)));
  };

  const deselectAll = () => {
    setSelected(new Set());
  };

  const toggleSelectAll = () => {
    if (selected.size === data.length) {
      deselectAll();
    } else {
      selectAll();
    }
  };

  const allSelected = data.length > 0 && selected.size === data.length;
  const someSelected = selected.size > 0 && selected.size < data.length;

  return {
    selected,
    toggleSelection,
    selectAll,
    deselectAll,
    toggleSelectAll,
    allSelected,
    someSelected,
    clearSelection: deselectAll,
  };
}

/**
 * === useTablePagination (Ä‘Æ¡n giáº£n hÃ³a tá»« Level 3) ===
 */
function useTablePagination({ data, itemsPerPage = 10, initialPage = 1 }) {
  const [currentPage, setCurrentPage] = React.useState(initialPage);

  const totalPages = Math.max(1, Math.ceil(data.length / itemsPerPage));
  const paginatedData = React.useMemo(() => {
    const start = (currentPage - 1) * itemsPerPage;
    return data.slice(start, start + itemsPerPage);
  }, [data, currentPage, itemsPerPage]);

  const goToPage = (page) => {
    const target = Math.max(1, Math.min(page, totalPages));
    setCurrentPage(target);
  };

  return {
    currentPage,
    totalPages,
    paginatedData,
    goToPage,
    nextPage: () => goToPage(currentPage + 1),
    prevPage: () => goToPage(currentPage - 1),
    canGoNext: currentPage < totalPages,
    canGoPrev: currentPage > 1,
  };
}

/**
 * === useDataTable - Composition Hook ===
 * Káº¿t há»£p táº¥t cáº£ cÃ¡c tÃ­nh nÄƒng trÃªn thÃ nh má»™t API thá»‘ng nháº¥t
 */
function useDataTable(rawData, config = {}) {
  const { defaultSort, pageSize = 8 } = config;

  const sort = useTableSort(rawData, defaultSort);
  const filter = useTableFilter(sort.data);
  const selection = useTableSelection(filter.data);
  const pagination = useTablePagination({
    data: filter.data,
    itemsPerPage: pageSize,
    initialPage: 1,
  });

  return {
    // Dá»¯ liá»‡u cuá»‘i cÃ¹ng Ä‘Ã£ Ä‘Æ°á»£c xá»­ lÃ½
    data: pagination.paginatedData,

    // Tráº¡ng thÃ¡i & actions cá»§a tá»«ng tÃ­nh nÄƒng
    sort,
    filter,
    selection,
    pagination,

    // Tiá»‡n Ã­ch tá»•ng há»£p
    totalItems: rawData.length,
    filteredCount: filter.data.length,
    selectedCount: selection.selected.size,
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Demo component sá»­ dá»¥ng toÃ n bá»™ suite
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const sampleUsers = [
  { id: 1, name: 'Alice', age: 30, role: 'Admin', active: true },
  { id: 2, name: 'Bob', age: 25, role: 'User', active: false },
  { id: 3, name: 'Charlie', age: 35, role: 'User', active: true },
  { id: 4, name: 'Diana', age: 28, role: 'Admin', active: true },
  { id: 5, name: 'Eve', age: 42, role: 'Editor', active: true },
  { id: 6, name: 'Frank', age: 31, role: 'User', active: false },
  { id: 7, name: 'Grace', age: 29, role: 'Admin', active: true },
  { id: 8, name: 'Henry', age: 37, role: 'User', active: true },
  // ... cÃ³ thá»ƒ thÃªm nhiá»u record hÆ¡n
];

function DataTableDemo() {
  const table = useDataTable(sampleUsers, {
    defaultSort: { column: 'name', direction: 'asc' },
    pageSize: 5,
  });

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui, sans-serif' }}>
      <h2>Data Table with Hooks</h2>

      {/* Controls */}
      <div
        style={{
          marginBottom: '24px',
          display: 'flex',
          gap: '16px',
          flexWrap: 'wrap',
        }}
      >
        {/* Filter by role */}
        <select
          onChange={(e) =>
            table.filter.setFilter('role', e.target.value || undefined)
          }
          style={{ padding: '8px' }}
        >
          <option value=''>All Roles</option>
          <option value='Admin'>Admin</option>
          <option value='User'>User</option>
          <option value='Editor'>Editor</option>
        </select>

        {/* Active only */}
        <label style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
          <input
            type='checkbox'
            checked={table.filter.filters.active === true}
            onChange={(e) =>
              table.filter.setFilter(
                'active',
                e.target.checked ? true : undefined,
              )
            }
          />
          Active only
        </label>

        {/* Selection info */}
        <div style={{ marginLeft: 'auto' }}>
          Selected: {table.selectedCount} / {table.filteredCount} items
        </div>
      </div>

      {/* Table */}
      <table style={{ width: '100%', borderCollapse: 'collapse' }}>
        <thead>
          <tr style={{ background: '#f4f4f5' }}>
            <th style={{ padding: '12px', textAlign: 'left', width: '40px' }}>
              <input
                type='checkbox'
                checked={table.selection.allSelected}
                onChange={table.selection.toggleSelectAll}
              />
            </th>
            <th
              onClick={() => table.sort.toggleSort('name')}
              style={{ padding: '12px', cursor: 'pointer', userSelect: 'none' }}
            >
              Name{' '}
              {table.sort.column === 'name' &&
                (table.sort.direction === 'asc' ? 'â†‘' : 'â†“')}
            </th>
            <th
              onClick={() => table.sort.toggleSort('age')}
              style={{ padding: '12px', cursor: 'pointer', userSelect: 'none' }}
            >
              Age{' '}
              {table.sort.column === 'age' &&
                (table.sort.direction === 'asc' ? 'â†‘' : 'â†“')}
            </th>
            <th style={{ padding: '12px' }}>Role</th>
            <th style={{ padding: '12px' }}>Status</th>
          </tr>
        </thead>
        <tbody>
          {table.data.map((user) => (
            <tr
              key={user.id}
              style={{ borderBottom: '1px solid #eee' }}
            >
              <td style={{ padding: '12px' }}>
                <input
                  type='checkbox'
                  checked={table.selection.selected.has(user.id)}
                  onChange={() => table.selection.toggleSelection(user.id)}
                />
              </td>
              <td style={{ padding: '12px' }}>{user.name}</td>
              <td style={{ padding: '12px' }}>{user.age}</td>
              <td style={{ padding: '12px' }}>{user.role}</td>
              <td style={{ padding: '12px' }}>
                <span style={{ color: user.active ? '#2e7d32' : '#d32f2f' }}>
                  {user.active ? 'Active' : 'Inactive'}
                </span>
              </td>
            </tr>
          ))}
        </tbody>
      </table>

      {/* Pagination */}
      <div
        style={{
          marginTop: '24px',
          display: 'flex',
          justifyContent: 'center',
          gap: '16px',
          alignItems: 'center',
        }}
      >
        <button
          onClick={table.pagination.prevPage}
          disabled={!table.pagination.canGoPrev}
          style={{ padding: '8px 16px' }}
        >
          Previous
        </button>
        <span>
          Page <strong>{table.pagination.currentPage}</strong> of{' '}
          <strong>{table.pagination.totalPages}</strong>
        </span>
        <button
          onClick={table.pagination.nextPage}
          disabled={!table.pagination.canGoNext}
          style={{ padding: '8px 16px' }}
        >
          Next
        </button>
      </div>
    </div>
  );
}

/* Káº¿t quáº£ vÃ­ dá»¥:
- Sáº¯p xáº¿p theo tÃªn / tuá»•i khi click header
- Lá»c theo role vÃ  active/inactive
- Chá»n tá»«ng dÃ²ng / chá»n táº¥t cáº£ (chá»‰ trong trang hiá»‡n táº¡i)
- PhÃ¢n trang tá»± Ä‘á»™ng 5 record/trang
- Khi lá»c â†’ pagination tá»± cáº­p nháº­t láº¡i sá»‘ trang & dá»¯ liá»‡u
- Khi sáº¯p xáº¿p â†’ filter & pagination váº«n hoáº¡t Ä‘á»™ng Ä‘Ãºng
*/

// **Ghi chÃº thiáº¿t káº¿ chÃ­nh:**

// - Má»—i hook cÃ³ trÃ¡ch nhiá»‡m **Ä‘Æ¡n láº»** (Single Responsibility)
// - Composition theo thá»© tá»± logic: sort â†’ filter â†’ selection â†’ pagination
// - Sá»­ dá»¥ng **useMemo** Ä‘á»ƒ trÃ¡nh tÃ­nh toÃ¡n khÃ´ng cáº§n thiáº¿t
// - State Ä‘Æ°á»£c giá»¯ riÃªng biá»‡t â†’ dá»… test tá»«ng hook Ä‘á»™c láº­p
// - API tá»•ng há»£p á»Ÿ `useDataTable` giÃºp component sá»­ dá»¥ng ráº¥t gá»n gÃ ng

// Hy vá»ng implementation nÃ y Ä‘á»§ thá»±c táº¿ Ä‘á»ƒ dÃ¹ng trong dá»± Ã¡n production nhá» Ä‘áº¿n trung bÃ¬nh!
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Custom Hook Strategies

| Strategy             | Complexity | Reusability    | Testability | Use When                    |
| -------------------- | ---------- | -------------- | ----------- | --------------------------- |
| **Inline Logic**     | âœ… Simple  | âŒ None        | âŒ Hard     | One-off, component-specific |
| **Extract Function** | âœ… Simple  | âš ï¸ Medium      | âœ… Easy     | Pure logic, no hooks        |
| **Custom Hook**      | âš ï¸ Medium  | âœ… High        | âœ… Easy     | Reusable stateful logic     |
| **Hook Composition** | âŒ Complex | âœ…âœ… Very High | âœ… Modular  | Complex features            |

### Decision Tree: Khi nÃ o táº¡o Custom Hook?

```
START: Cáº§n refactor logic?
â”‚
â”œâ”€ Logic chá»‰ dÃ¹ng 1 component?
â”‚  â””â”€ YES â†’ Keep inline âœ…
â”‚     No need custom hook yet
â”‚
â”œâ”€ Logic pure (no hooks)?
â”‚  â””â”€ YES â†’ Extract regular function âœ…
â”‚     Example: validation, formatting
â”‚
â”œâ”€ Logic dÃ¹ng hooks (useState, useEffect)?
â”‚  â””â”€ YES
â”‚     â”‚
â”‚     â”œâ”€ DÃ¹ng á»Ÿ 2+ components?
â”‚     â”‚  â””â”€ YES â†’ Custom Hook âœ…
â”‚     â”‚     Example: useFetch, useForm
â”‚     â”‚
â”‚     â”œâ”€ Logic phá»©c táº¡p (>50 lines)?
â”‚     â”‚  â””â”€ YES â†’ Custom Hook âœ…
â”‚     â”‚     Even if 1 component (readability)
â”‚     â”‚
â”‚     â””â”€ Will likely reuse in future?
â”‚        â””â”€ YES â†’ Custom Hook âœ…
â”‚           Proactive abstraction
â”‚
â””â”€ Complex feature (multiple concerns)?
   â””â”€ YES â†’ Hook Composition âœ…
      Example: useDataTable = sort + filter + pagination
```

### Custom Hook Best Practices

**âœ… DO:**

```jsx
// âœ… Descriptive naming
function useFetchUser(userId) { ... }
function useDebounce(value, delay) { ... }
function useLocalStorage(key, initialValue) { ... }

// âœ… Return consistent structure
function useFetch(url) {
  return { data, loading, error }; // Always same shape
}

// âœ… Accept config object for flexibility
function useTable(data, config = {}) {
  const {
    defaultSort = { column: null, direction: 'asc' },
    pageSize = 10,
  } = config;
}

// âœ… Document with JSDoc
/**
 * Fetches data from URL
 * @param {string} url - API endpoint
 * @returns {{ data, loading, error }}
 */
function useFetch(url) { ... }
```

**âŒ DON'T:**

```jsx
// âŒ Generic naming
function useData() { ... } // Data from where?

// âŒ Inconsistent returns
function useFetch(url) {
  if (loading) return [null, true, null];
  return { data, loading, error }; // Different types!
}

// âŒ Too many parameters
function useFetch(url, method, headers, body, timeout, retries) { ... }
// Better: useFetch(url, options)

// âŒ Side effects in hook body
function useFetch(url) {
  console.log('Fetching...'); // Don't log in hook!
  // Put logging in useEffect
}
```

### Hook Composition Patterns

**Pattern 1: Sequential Composition**

```jsx
// Each hook depends on previous
function useDataTable(data) {
  const sorted = useSort(data);
  const filtered = useFilter(sorted);
  const paginated = usePagination(filtered);
  return paginated;
}
```

**Pattern 2: Parallel Composition**

```jsx
// Hooks independent
function useForm(initialValues) {
  const validation = useValidation(initialValues);
  const storage = useLocalStorage('form', initialValues);
  const submit = useSubmit();

  // Combine results
  return { ...validation, ...storage, ...submit };
}
```

**Pattern 3: Conditional Composition**

```jsx
// Use hooks conditionally (WRONG!)
function useConditional(shouldFetch) {
  // âŒ VIOLATES RULES OF HOOKS
  if (shouldFetch) {
    const data = useFetch('/api/data');
  }
}

// âœ… CORRECT
function useConditional(shouldFetch) {
  const { data } = useFetch(shouldFetch ? '/api/data' : null);
  // Hook always called, but fetch is conditional
}
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Shared State Misconception ğŸ›

```jsx
// âŒ CODE/CONCEPT SAI
function useCounter() {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return { count, increment };
}

function ComponentA() {
  const { count, increment } = useCounter();
  return <button onClick={increment}>A: {count}</button>;
}

function ComponentB() {
  const { count, increment } = useCounter();
  return <button onClick={increment}>B: {count}</button>;
}

function App() {
  return (
    <div>
      <ComponentA />
      <ComponentB />
    </div>
  );
}

// ğŸ¤” User clicks ComponentA button
// Expected: ComponentA = 1, ComponentB = 1 (shared state?)
// Actual: ComponentA = 1, ComponentB = 0
// WHY?
```

**â“ CÃ¢u há»i:**

1. Táº¡i sao count khÃ´ng shared giá»¯a A vÃ  B?
2. Custom hook share gÃ¬?
3. LÃ m sao share state tháº­t sá»±?

**ğŸ’¡ Giáº£i thÃ­ch:**

- **Custom hooks share LOGIC, not STATE**
- Má»—i component gá»i hook â†’ separate instance
- A cÃ³ state riÃªng, B cÃ³ state riÃªng
- Giá»‘ng nhÆ° 2 components cÃ¹ng dÃ¹ng useState - má»—i cÃ¡i cÃ³ state riÃªng!

**âœ… Fix (náº¿u cáº§n shared state):**

```jsx
// Option 1: Lift state up
function App() {
  const { count, increment } = useCounter();

  return (
    <div>
      <ComponentA
        count={count}
        increment={increment}
      />
      <ComponentB
        count={count}
        increment={increment}
      />
    </div>
  );
}

// Option 2: Context (will learn later)
// const CountContext = createContext();
```

### Bug 2: Rules of Hooks Violation ğŸ›

```jsx
// âŒ CODE Bá»Š Lá»–I
function useFetchOnCondition(shouldFetch, url) {
  // ğŸ› Conditional hook call!
  if (shouldFetch) {
    const { data, loading } = useFetch(url);
    return { data, loading };
  }

  return { data: null, loading: false };
}

// React Error: "Rendered more hooks than during the previous render"
```

**â“ CÃ¢u há»i:**

1. Váº¥n Ä‘á» gÃ¬ vá»›i code?
2. Táº¡i sao React throw error?
3. LÃ m sao fix?

**ğŸ’¡ Giáº£i thÃ­ch:**

- **Rules of Hooks:** Hooks pháº£i gá»i trong SAME ORDER má»—i render
- Conditional â†’ order thay Ä‘á»•i â†’ React confused
- Render 1: shouldFetch=true â†’ 1 hook called
- Render 2: shouldFetch=false â†’ 0 hooks called
- React: "WTF? Where did hook go?"

**âœ… Fix:**

```jsx
// âœ… Always call hook, conditionally use result
function useFetchOnCondition(shouldFetch, url) {
  const { data, loading } = useFetch(shouldFetch ? url : null);
  return { data, loading };
}

// useFetch internally handles null URL:
function useFetch(url) {
  useEffect(() => {
    if (!url) return; // Skip fetch if no URL
    // ... fetch logic
  }, [url]);
}
```

### Bug 3: Stale Closure in Custom Hook ğŸ›

```jsx
// âŒ CODE Bá»Š Lá»–I
function useInterval(callback, delay) {
  useEffect(() => {
    const interval = setInterval(callback, delay);
    return () => clearInterval(interval);
  }, [delay]); // ğŸ› Missing callback in deps!
}

function Counter() {
  const [count, setCount] = useState(0);

  useInterval(() => {
    console.log('Count:', count); // ğŸ› Always logs 0!
    setCount(count + 1); // ğŸ› Always sets 1!
  }, 1000);

  return <div>{count}</div>;
}

// Bug: count increments to 1, then stops!
// Log always shows "Count: 0"
```

**â“ CÃ¢u há»i:**

1. Táº¡i sao count luÃ´n 0 trong callback?
2. Táº¡i sao count chá»‰ tÄƒng lÃªn 1 rá»“i dá»«ng?
3. LÃ m sao fix?

**ğŸ’¡ Giáº£i thÃ­ch:**

- **Stale closure:** callback captures `count` tá»« initial render
- useEffect chá»‰ re-run khi delay changes
- callback khÃ´ng update â†’ luÃ´n tháº¥y count = 0
- setCount(0 + 1) â†’ count = 1, rá»“i stuck

**âœ… Fix:**

```jsx
// âœ… Option 1: Include callback in deps
function useInterval(callback, delay) {
  useEffect(() => {
    const interval = setInterval(callback, delay);
    return () => clearInterval(interval);
  }, [callback, delay]); // Add callback
}
// Problem: callback changes every render â†’ interval resets!

// âœ… Option 2: useRef to store latest callback
function useInterval(callback, delay) {
  const savedCallback = useRef();

  // Update ref khi callback changes
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // Setup interval
  useEffect(() => {
    const tick = () => {
      savedCallback.current(); // Call latest callback
    };

    const interval = setInterval(tick, delay);
    return () => clearInterval(interval);
  }, [delay]); // Only re-run khi delay changes
}

// âœ… Option 3: Functional update
function Counter() {
  const [count, setCount] = useState(0);

  useInterval(() => {
    setCount((prev) => prev + 1); // âœ… No dependency on count!
  }, 1000);
}
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u âœ… khi báº¡n tá»± tin:

**Custom Hook Basics:**

- [ ] TÃ´i hiá»ƒu custom hook lÃ  gÃ¬
- [ ] TÃ´i biáº¿t naming convention (must start with 'use')
- [ ] TÃ´i hiá»ƒu custom hooks share logic, not state
- [ ] TÃ´i biáº¿t khi nÃ o nÃªn extract custom hook

**Hook Creation:**

- [ ] TÃ´i biáº¿t cÃ¡ch extract logic thÃ nh hook
- [ ] TÃ´i biáº¿t cÃ¡ch accept parameters
- [ ] TÃ´i biáº¿t cÃ¡ch return values (object vs array)
- [ ] TÃ´i biáº¿t cÃ¡ch document hooks (JSDoc)

**Hook Composition:**

- [ ] TÃ´i biáº¿t cÃ¡ch compose multiple hooks
- [ ] TÃ´i hiá»ƒu sequential vs parallel composition
- [ ] TÃ´i biáº¿t cÃ¡ch handle dependencies giá»¯a hooks
- [ ] TÃ´i trÃ¡nh Ä‘Æ°á»£c conditional hook calls

**Rules of Hooks:**

- [ ] TÃ´i hiá»ƒu Rules of Hooks
- [ ] TÃ´i khÃ´ng call hooks conditionally
- [ ] TÃ´i khÃ´ng call hooks in loops
- [ ] TÃ´i khÃ´ng call hooks in regular functions

### Code Review Checklist

**Hook Design:**

- [ ] Naming: starts with 'use', descriptive
- [ ] Single responsibility
- [ ] Configurable via parameters
- [ ] Consistent return type

**Implementation:**

- [ ] No Rules of Hooks violations
- [ ] Dependencies correct (no missing, no extra)
- [ ] Cleanup functions where needed
- [ ] Error handling

**Reusability:**

- [ ] No hardcoded values
- [ ] Flexible via config
- [ ] Works in different contexts
- [ ] Well documented

**Testing:**

- [ ] Can be tested independently
- [ ] Clear inputs/outputs
- [ ] Edge cases handled
- [ ] No side effects in hook body

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**BÃ i 1: useDebounce Hook**

Requirements:

1. Accept value vÃ  delay
2. Return debounced value
3. Delay updates by specified ms
4. Cancel pending update on value change
5. Cancel pending update on unmount

Usage:

```jsx
function SearchBox() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearch = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearch) {
      // API call with debouncedSearch
    }
  }, [debouncedSearch]);

  return (
    <input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
    />
  );
}
```

Hints:

- Use useState for debounced value
- Use useEffect with setTimeout
- Return cleanup function to clear timeout

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook debounce giÃ¡ trá»‹ Ä‘áº§u vÃ o
 * TrÃ¬ hoÃ£n viá»‡c cáº­p nháº­t giÃ¡ trá»‹ cho Ä‘áº¿n khi ngÆ°á»i dÃ¹ng ngá»«ng thay Ä‘á»•i trong khoáº£ng delay
 * @param {any} value - GiÃ¡ trá»‹ cáº§n debounce (thÆ°á»ng lÃ  string tá»« input)
 * @param {number} [delay=500] - Thá»i gian chá» (ms) trÆ°á»›c khi cáº­p nháº­t giÃ¡ trá»‹
 * @returns {any} GiÃ¡ trá»‹ Ä‘Ã£ Ä‘Æ°á»£c debounce
 */
function useDebounce(value, delay = 500) {
  const [debouncedValue, setDebouncedValue] = React.useState(value);

  React.useEffect(() => {
    // Thiáº¿t láº­p timer Ä‘á»ƒ cáº­p nháº­t giÃ¡ trá»‹ sau delay
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cleanup: há»§y timer náº¿u value thay Ä‘á»•i trÆ°á»›c khi delay káº¿t thÃºc
    // hoáº·c khi component unmount
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]); // Chá»‰ cháº¡y láº¡i khi value hoáº·c delay thay Ä‘á»•i

  return debouncedValue;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VÃ­ dá»¥ sá»­ dá»¥ng
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function SearchBox() {
  const [searchTerm, setSearchTerm] = React.useState('');
  const debouncedSearch = useDebounce(searchTerm, 500);

  // Má»—i khi debouncedSearch thay Ä‘á»•i â†’ thá»±c hiá»‡n tÃ¬m kiáº¿m / gá»i API
  React.useEffect(() => {
    if (debouncedSearch.trim()) {
      console.log('TÃ¬m kiáº¿m vá»›i tá»« khÃ³a:', debouncedSearch);
      // VÃ­ dá»¥: fetch(`/api/search?q=${debouncedSearch}`)
    }
  }, [debouncedSearch]);

  return (
    <div style={{ padding: '20px', maxWidth: '500px', margin: '0 auto' }}>
      <h2>Search with Debounce</h2>

      <input
        type='text'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder='Nháº­p tá»« khÃ³a Ä‘á»ƒ tÃ¬m kiáº¿m...'
        style={{
          width: '100%',
          padding: '12px',
          fontSize: '16px',
          borderRadius: '6px',
          border: '1px solid #ccc',
        }}
      />

      <div style={{ marginTop: '20px' }}>
        <p>
          <strong>GiÃ¡ trá»‹ Ä‘ang nháº­p:</strong> {searchTerm || '(chÆ°a nháº­p)'}
        </p>
        <p style={{ color: debouncedSearch ? '#2e7d32' : '#757575' }}>
          <strong>GiÃ¡ trá»‹ debounce (sau {500}ms):</strong>{' '}
          {debouncedSearch || '(Ä‘ang chá»...)'}
        </p>
      </div>

      <small style={{ color: '#666', display: 'block', marginTop: '16px' }}>
        API / tÃ¬m kiáº¿m chá»‰ Ä‘Æ°á»£c gá»i khi báº¡n ngá»«ng gÃµ Ã­t nháº¥t 500ms
      </small>
    </div>
  );
}

/* Káº¿t quáº£ vÃ­ dá»¥:
- GÃµ nhanh "react hooks" â†’ debouncedSearch váº«n lÃ  "" hoáº·c giÃ¡ trá»‹ cÅ©
- Ngá»«ng gÃµ 500ms â†’ console.log("TÃ¬m kiáº¿m vá»›i tá»« khÃ³a: react hooks")
- Thay Ä‘á»•i input liÃªn tá»¥c â†’ khÃ´ng gá»i API liÃªn tá»¥c, chá»‰ gá»i 1 láº§n sau khi ngá»«ng gÃµ
- XÃ³a háº¿t input â†’ sau 500ms debouncedSearch trá»Ÿ thÃ nh ""
*/
```

</details>

### NÃ¢ng cao (60 phÃºt)

**BÃ i 2: useUndo Hook**

Requirements:

1. Track state history
2. Provide: state, setState, undo, redo, canUndo, canRedo
3. Limit history size (e.g., max 10 states)
4. Clear future history when new state set
5. Works with any state type

State shape:

```jsx
{
  past: [state1, state2, ...],
  present: currentState,
  future: [state3, state4, ...]
}
```

Actions:

- SET (new state)
- UNDO
- REDO
- CLEAR_HISTORY

Usage:

```jsx
function DrawingApp() {
  const {
    state: canvas,
    setState: setCanvas,
    undo,
    redo,
    canUndo,
    canRedo,
    reset,
  } = useUndo([]);

  return (
    <div>
      <button
        onClick={undo}
        disabled={!canUndo}
      >
        Undo
      </button>
      <button
        onClick={redo}
        disabled={!canRedo}
      >
        Redo
      </button>
      <button onClick={reset}>Clear</button>
      <Canvas
        data={canvas}
        onChange={setCanvas}
      />
    </div>
  );
}
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook há»— trá»£ undo / redo cho báº¥t ká»³ giÃ¡ trá»‹ state nÃ o
 * Giá»¯ lá»‹ch sá»­ cÃ¡c thay Ä‘á»•i (past + future) vá»›i giá»›i háº¡n kÃ­ch thÆ°á»›c
 * @template T
 * @param {T} initialValue - GiÃ¡ trá»‹ ban Ä‘áº§u
 * @param {number} [maxHistory=10] - Sá»‘ lÆ°á»£ng tráº¡ng thÃ¡i tá»‘i Ä‘a trong history (past + future)
 * @returns {{
 *   state: T,
 *   setState: (newState: T | ((prev: T) => T)) => void,
 *   undo: () => void,
 *   redo: () => void,
 *   canUndo: boolean,
 *   canRedo: boolean,
 *   reset: () => void,
 *   clearHistory: () => void
 * }}
 */
function useUndo(initialValue, maxHistory = 10) {
  const initialState = {
    past: [],
    present: initialValue,
    future: [],
  };

  const [history, setHistory] = React.useState(initialState);

  const { past, present, future } = history;

  const canUndo = past.length > 0;
  const canRedo = future.length > 0;

  const setState = React.useCallback(
    (newState) => {
      setHistory((prev) => {
        const nextPresent =
          typeof newState === 'function' ? newState(prev.present) : newState;

        // Náº¿u giÃ¡ trá»‹ khÃ´ng thay Ä‘á»•i â†’ khÃ´ng thÃªm vÃ o history
        if (nextPresent === prev.present) {
          return prev;
        }

        // ThÃªm present hiá»‡n táº¡i vÃ o past
        // Giá»›i háº¡n kÃ­ch thÆ°á»›c past
        const newPast = [...prev.past, prev.present];
        if (newPast.length > maxHistory) {
          newPast.shift(); // xÃ³a tráº¡ng thÃ¡i cÅ© nháº¥t
        }

        return {
          past: newPast,
          present: nextPresent,
          future: [], // xÃ³a future khi cÃ³ thay Ä‘á»•i má»›i
        };
      });
    },
    [maxHistory],
  );

  const undo = React.useCallback(() => {
    if (!canUndo) return;

    setHistory((prev) => {
      const previous = prev.past[prev.past.length - 1];
      const newPast = prev.past.slice(0, -1);

      return {
        past: newPast,
        present: previous,
        future: [prev.present, ...prev.future],
      };
    });
  }, [canUndo]);

  const redo = React.useCallback(() => {
    if (!canRedo) return;

    setHistory((prev) => {
      const next = prev.future[0];
      const newFuture = prev.future.slice(1);

      return {
        past: [...prev.past, prev.present],
        present: next,
        future: newFuture,
      };
    });
  }, [canRedo]);

  const reset = React.useCallback(() => {
    setHistory({
      past: [],
      present: initialValue,
      future: [],
    });
  }, [initialValue]);

  const clearHistory = React.useCallback(() => {
    setHistory((prev) => ({
      past: [],
      present: prev.present,
      future: [],
    }));
  }, []);

  return {
    state: present,
    setState,
    undo,
    redo,
    canUndo,
    canRedo,
    reset,
    clearHistory,
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VÃ­ dá»¥ sá»­ dá»¥ng: á»¨ng dá»¥ng váº½ Ä‘Æ¡n giáº£n (máº£ng Ä‘iá»ƒm)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function DrawingApp() {
  const {
    state: points,
    setState: setPoints,
    undo,
    redo,
    canUndo,
    canRedo,
    reset,
  } = useUndo([], 15); // Giá»›i háº¡n 15 bÆ°á»›c history

  const handleClick = (e) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setPoints((prev) => [...prev, { x, y }]);
  };

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui, sans-serif' }}>
      <h2>useUndo Demo - Simple Drawing</h2>

      <div
        style={{
          marginBottom: '16px',
          display: 'flex',
          gap: '12px',
          flexWrap: 'wrap',
        }}
      >
        <button
          onClick={undo}
          disabled={!canUndo}
        >
          Undo ({canUndo ? 'âœ“' : 'âœ—'})
        </button>
        <button
          onClick={redo}
          disabled={!canRedo}
        >
          Redo ({canRedo ? 'âœ“' : 'âœ—'})
        </button>
        <button onClick={reset}>Reset / Clear All</button>
      </div>

      <div
        onClick={handleClick}
        style={{
          width: '500px',
          height: '400px',
          border: '2px solid #333',
          background: '#f8f9fa',
          position: 'relative',
          cursor: 'crosshair',
          overflow: 'hidden',
        }}
      >
        {points.map((point, index) => (
          <div
            key={index}
            style={{
              position: 'absolute',
              left: point.x - 6,
              top: point.y - 6,
              width: '12px',
              height: '12px',
              background: '#1976d2',
              borderRadius: '50%',
              transform: 'translate(-50%, -50%)',
            }}
          />
        ))}
      </div>

      <div style={{ marginTop: '16px', color: '#555' }}>
        Points: {points.length} | History: {canUndo ? past.length : 0} past,{' '}
        {canRedo ? future.length : 0} future
      </div>

      <small style={{ color: '#777', display: 'block', marginTop: '8px' }}>
        Click vÃ o khung Ä‘á»ƒ váº½ Ä‘iá»ƒm â€¢ Undo/Redo Ä‘á»ƒ quay láº¡i hoáº·c tiáº¿n tá»›i
      </small>
    </div>
  );
}

/* Káº¿t quáº£ vÃ­ dá»¥:
- Click nhiá»u láº§n vÃ o khung â†’ táº¡o cÃ¡c Ä‘iá»ƒm mÃ u xanh
- Nháº¥n Undo â†’ xÃ³a Ä‘iá»ƒm cuá»‘i cÃ¹ng (cÃ³ thá»ƒ Undo nhiá»u bÆ°á»›c)
- Nháº¥n Redo â†’ khÃ´i phá»¥c Ä‘iá»ƒm vá»«a bá»‹ Undo
- Reset â†’ xÃ³a háº¿t Ä‘iá»ƒm vÃ  history
- Sau 15 bÆ°á»›c â†’ cÃ¡c bÆ°á»›c cÅ© nháº¥t tá»± Ä‘á»™ng bá»‹ xÃ³a khá»i history (giá»›i háº¡n maxHistory)
- KhÃ´ng thá»ƒ Undo khi khÃ´ng cÃ²n lá»‹ch sá»­ (nÃºt disable)
*/
```

</details>

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - Reusing Logic with Custom Hooks:**
   - https://react.dev/learn/reusing-logic-with-custom-hooks
   - Official guide, best practices

2. **Rules of Hooks:**
   - https://react.dev/warnings/invalid-hook-call-warning
   - Why rules exist, common violations

### Äá»c thÃªm

3. **useHooks Collection:**
   - https://usehooks.com/
   - Many real-world custom hooks examples

4. **React Hook Patterns:**
   - https://github.com/streamich/react-use
   - Open-source hook library for inspiration

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (ÄÃ£ há»c)

- **NgÃ y 11-14:** useState
  - Foundation cho custom hooks
  - useFetch, useToggle dÃ¹ng useState

- **NgÃ y 16-20:** useEffect
  - Critical cho side effects in hooks
  - Cleanup patterns

- **NgÃ y 21-22:** useRef
  - Store mutable values
  - useInterval pattern (savedCallback ref)

- **NgÃ y 26-28:** useReducer
  - Complex state in hooks
  - useForm, usePagination patterns

### HÆ°á»›ng tá»›i (Sáº½ há»c)

- **NgÃ y 30:** Project 4 - Shopping Cart
  - Apply custom hooks learned today
  - Hook composition in practice

- **NgÃ y 31-34:** Performance Hooks
  - useMemo, useCallback
  - Optimize custom hooks
  - Memoize expensive operations

- **Phase 5:** Context API
  - Custom hooks + Context
  - Global state management
  - useAuth, useTheme patterns

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. When NOT to create custom hook:**

```jsx
// âŒ Over-abstraction
function useButtonClick(onClick) {
  return { onClick }; // Unnecessary!
}

// âŒ One-off logic
function useSpecificBusinessLogic() {
  // Logic chá»‰ dÃ¹ng 1 component
  // Keep inline!
}

// âœ… When to extract:
// - Used in 2+ components
// - Complex logic (>50 lines)
// - Reusable across projects
```

**2. Hook Library Organization:**

```
src/
  hooks/
    useAuth.js          # Domain-specific
    useUser.js
    useProduct.js

    useAsync.js         # Generic utilities
    useFetch.js
    useLocalStorage.js

    useTable/           # Complex hooks
      useTableSort.js
      useTableFilter.js
      index.js          # Main composition
```

**3. Versioning Custom Hooks:**

```jsx
// v1: Simple
function useFetch(url) { ... }

// v2: Add options (backward compatible)
function useFetch(url, options = {}) { ... }

// v3: Breaking change (rename parameter)
function useFetchV3(config) { ... }
// Or: deprecate v2, migrate gradually
```

**4. Testing Strategy:**

```jsx
// Test custom hook vá»›i @testing-library/react-hooks
import { renderHook, act } from '@testing-library/react-hooks';

test('useFetch loads data', async () => {
  const { result, waitForNextUpdate } = renderHook(() => useFetch('/api/data'));

  expect(result.current.loading).toBe(true);

  await waitForNextUpdate();

  expect(result.current.data).toBeDefined();
  expect(result.current.loading).toBe(false);
});
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

1. **Q:** "Custom hook khÃ¡c function thÃ´ng thÆ°á»ng nhÆ° tháº¿ nÃ o?"

   **Expected:**
   - Naming: must start with 'use'
   - Can use other hooks inside
   - Follow Rules of Hooks
   - Regular function khÃ´ng thá»ƒ dÃ¹ng hooks

2. **Q:** "Viáº¿t custom hook quáº£n lÃ½ input field"

   **Expected:**

   ```jsx
   function useInput(initialValue) {
     const [value, setValue] = useState(initialValue);

     const onChange = (e) => setValue(e.target.value);
     const reset = () => setValue(initialValue);

     return { value, onChange, reset };
   }
   ```

**Mid Level:**

3. **Q:** "2 components dÃ¹ng cÃ¹ng custom hook cÃ³ share state khÃ´ng? Giáº£i thÃ­ch."

   **Expected:**
   - NO, má»—i component cÃ³ state riÃªng
   - Hook chá»‰ share logic
   - Demo vá»›i code example
   - Explain khi nÃ o cáº§n share state (Context)

4. **Q:** "Implement useDebounce hook. Explain use case."

   **Expected:**
   - Code implementation
   - Use case: search input, auto-save
   - Performance benefits
   - Dependencies chÃ­nh xÃ¡c

**Senior Level:**

5. **Q:** "Design custom hook library cho company. Architecture? Best practices? Testing strategy?"

   **Expected:**
   - Organization (generic vs domain-specific)
   - Documentation standards
   - Versioning strategy
   - TypeScript support
   - Testing (unit + integration)
   - Performance considerations
   - Code review checklist
   - Migration path cho breaking changes

### War Stories

**Story 1: The useInterval Bug**

> "App cÃ³ timer countdown. User reported 'timer stuck at 1'. Sau 3 giá» debug, phÃ¡t hiá»‡n stale closure trong useInterval hook. Callback capture count=0 lÃºc mount. Fix báº±ng useRef pattern. Lesson: Understand closure, deps array carefully!" - Senior Engineer

**Story 2: Over-Abstraction Hell**

> "Junior dev táº¡o hook cho Má»ŒI THá»¨. useButtonState, useInputValue, useModalOpen... 50+ hooks, má»—i cÃ¡i 5 lines. Code review: 'This is over-engineering'. Rollback, giá»¯ láº¡i 10 hooks tháº­t sá»± reusable. Lesson: Abstraction cÃ³ cost. Extract khi cÃ³ clear benefit." - Tech Lead

**Story 3: Custom Hook Saved 10k Lines**

> "E-commerce app cÃ³ 20 components fetch data. Má»—i cÃ¡i 100 lines useEffect + reducer. Total 2000 lines duplicate. Extracted useFetch hook â†’ 200 lines. Add retry logic? 1 line change instead of 20. ROI huge. Lesson: Good abstraction pays off!" - CTO

---

## ğŸ¯ PREVIEW NGÃ€Y MAI

**NgÃ y 30: âš¡ Project 4 - Shopping Cart**

Báº¡n sáº½ build:

- âœ¨ Complete shopping cart vá»›i useReducer
- âœ¨ Custom hooks: useCart, useProducts, useCheckout
- âœ¨ Optimistic updates (add/remove items)
- âœ¨ localStorage persistence
- âœ¨ Discount codes, tax calculation

Chuáº©n bá»‹:

- HoÃ n thÃ nh bÃ i táº­p hÃ´m nay
- Review useReducer patterns (NgÃ y 26-28)
- Review custom hooks learned today
- NghÄ© vá» shopping cart features cáº§n thiáº¿t

---

**ğŸ‰ ChÃºc má»«ng! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 29!**

Báº¡n giá» Ä‘Ã£ master:

- âœ… Custom hooks creation
- âœ… useFetch, useAsync, useForm patterns
- âœ… Hook composition
- âœ… Rules of Hooks
- âœ… Reusable logic extraction

Tomorrow: Tá»•ng há»£p táº¥t cáº£ vÃ o 1 project thá»±c táº¿! ğŸ’ª
