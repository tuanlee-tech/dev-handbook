# üìÖ NG√ÄY 20: Data Fetching - Advanced Patterns

## üìç Phase 2, Tu·∫ßn 4, Ng√†y 20 c·ªßa 45

## ‚è±Ô∏è Th·ªùi l∆∞·ª£ng: 3-4 gi·ªù

---

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

- [ ] Gi·∫£i quy·∫øt **Race Conditions** trong data fetching
- [ ] S·ª≠ d·ª•ng **AbortController** ƒë·ªÉ cancel requests
- [ ] Implement **Dependent Requests** (sequential fetching)
- [ ] Optimize **Parallel Requests** cho multiple endpoints
- [ ] Handle **Stale Data** v√† request deduplication

---

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu, h√£y tr·∫£ l·ªùi 3 c√¢u h·ªèi sau:

1. **C√¢u 1:** N·∫øu fetch request ƒëang pending m√† component unmount, c·∫ßn l√†m g√¨?
   - _ƒê√°p √°n: Cleanup v·ªõi isCancelled flag ho·∫∑c AbortController (ƒë√£ h·ªçc Ng√†y 18-19)_

2. **C√¢u 2:** User typing nhanh "abc" ‚Üí 3 fetch requests. Request n√†o n√™n ƒë∆∞·ª£c d√πng?
   - _ƒê√°p √°n: Request cu·ªëi c√πng ("abc"), cancel 2 requests tr∆∞·ªõc_

3. **C√¢u 3:** Fetch user details ‚Üí C·∫ßn userId. Fetch user posts ‚Üí C·∫ßn userId. L√†m sao fetch hi·ªáu qu·∫£?
   - _ƒê√°p √°n: Ch∆∞a bi·∫øt! (H√¥m nay h·ªçc parallel vs sequential)_

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø: Race Conditions

**Scenario:** User search v·ªõi auto-complete

```jsx
function UserSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    // ‚ùå PROBLEM: Race condition!
    async function search() {
      const response = await fetch(`/api/search?q=${query}`);
      const data = await response.json();
      setResults(data); // ‚Üê N√†o request v·ªÅ tr∆∞·ªõc?
    }

    if (query) search();
  }, [query]);

  // User types: "r" ‚Üí "re" ‚Üí "rea" ‚Üí "reac" ‚Üí "react"
  // 5 requests fire: Q1, Q2, Q3, Q4, Q5
  // Response order: Q1(100ms), Q3(150ms), Q2(200ms), Q5(250ms), Q4(300ms)
  // ‚ùå Final results: Q4 ("reac") - WRONG! Should be Q5 ("react")
}
```

**V·∫•n ƒë·ªÅ:**

- Multiple requests in-flight c√πng l√∫c
- Response order KH√îNG ƒë·∫£m b·∫£o = request order
- Slow request c√≥ th·ªÉ overwrite fast request
- User sees stale/wrong data

**Real-world impact:**

- Search shows outdated results
- Profile page shows wrong user
- Dashboard displays mixed data
- Confusion v√† poor UX

---

### 1.2 Gi·∫£i Ph√°p: Request Cancellation & Tracking

**Solution 1: Ignore Outdated Responses**

```jsx
function UserSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    let isLatest = true; // ‚Üê Track if this is latest request

    async function search() {
      const response = await fetch(`/api/search?q=${query}`);
      const data = await response.json();

      // ‚úÖ Only update if this is still the latest request
      if (isLatest) {
        setResults(data);
      } else {
        console.log('üö´ Ignoring outdated response for:', query);
      }
    }

    if (query) search();

    // Cleanup: Mark this request as outdated
    return () => {
      isLatest = false;
    };
  }, [query]);
}
```

**Solution 2: Cancel In-Flight Requests (AbortController)**

```jsx
function UserSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    const controller = new AbortController();

    async function search() {
      try {
        const response = await fetch(`/api/search?q=${query}`, {
          signal: controller.signal, // ‚Üê Pass abort signal
        });
        const data = await response.json();
        setResults(data);
      } catch (err) {
        if (err.name === 'AbortError') {
          console.log('üö´ Request cancelled for:', query);
        } else {
          console.error('Error:', err);
        }
      }
    }

    if (query) search();

    // Cleanup: Abort in-flight request
    return () => {
      controller.abort();
    };
  }, [query]);
}
```

---

### 1.3 Mental Model: Request Lifecycle v·ªõi Cancellation

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         RACE CONDITION & CANCELLATION TIMELINE               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

USER TYPES: "r" ‚Üí "re" ‚Üí "rea"
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

WITHOUT CANCELLATION:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

t=0ms:   Type "r"   ‚Üí Request R1 fires
t=100ms: Type "re"  ‚Üí Request R2 fires (R1 still pending)
t=200ms: Type "rea" ‚Üí Request R3 fires (R1, R2 still pending)
t=250ms: R1 returns ‚Üí setResults([...]) ‚úÖ
t=300ms: R3 returns ‚Üí setResults([...]) ‚úÖ (Latest data)
t=400ms: R2 returns ‚Üí setResults([...]) ‚ùå (Overwrites R3!)

FINAL RESULT: Shows "re" results (WRONG!)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

WITH IGNORE OUTDATED:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

t=0ms:   Type "r"   ‚Üí Request R1, isLatest=true
t=100ms: Type "re"  ‚Üí Cleanup R1 (isLatest=false), Request R2
t=200ms: Type "rea" ‚Üí Cleanup R2 (isLatest=false), Request R3
t=250ms: R1 returns ‚Üí isLatest=false ‚Üí IGNORE ‚úÖ
t=300ms: R3 returns ‚Üí isLatest=true ‚Üí UPDATE ‚úÖ
t=400ms: R2 returns ‚Üí isLatest=false ‚Üí IGNORE ‚úÖ

FINAL RESULT: Shows "rea" results (CORRECT!)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

WITH ABORTCONTROLLER:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

t=0ms:   Type "r"   ‚Üí Request R1, controller C1
t=100ms: Type "re"  ‚Üí Abort C1, Request R2, controller C2
t=200ms: Type "rea" ‚Üí Abort C2, Request R3, controller C3
t=250ms: R1 aborted ‚Üí Cancelled (no response)
t=300ms: R3 returns ‚Üí UPDATE ‚úÖ
t=400ms: R2 aborted ‚Üí Cancelled (no response)

FINAL RESULT: Shows "rea" results (CORRECT!)
BONUS: R1 v√† R2 actually cancelled ‚Üí Less network traffic!

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

KEY DIFFERENCES:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Ignore Outdated:
‚úÖ Simple to implement
‚úÖ Works with any async operation
‚ùå Requests still complete (waste bandwidth)
‚ùå Server still processes (waste resources)

AbortController:
‚úÖ Actually cancels requests (saves bandwidth)
‚úÖ Server can detect abort (save resources)
‚úÖ Cleaner (no lingering promises)
‚ùå Only works with fetch (not all async)
‚ùå Slightly more complex
```

---

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

#### ‚ùå Hi·ªÉu l·∫ßm #1: "AbortController cancel c·∫£ Promise"

```jsx
// ‚ùå WRONG: Abort kh√¥ng cancel non-fetch promises
useEffect(() => {
  const controller = new AbortController();

  async function doWork() {
    // ‚ùå setTimeout KH√îNG b·ªã abort!
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // This still runs sau abort
    console.log('This will still execute');
  }

  doWork();

  return () => {
    controller.abort(); // Kh√¥ng effect g√¨!
  };
}, []);

// ‚úÖ CORRECT: Abort ch·ªâ cho fetch
useEffect(() => {
  const controller = new AbortController();

  async function doWork() {
    // ‚úÖ fetch C√ì TH·ªÇ b·ªã abort
    await fetch('/api/data', { signal: controller.signal });
  }

  doWork();

  return () => {
    controller.abort(); // ‚úÖ Cancels fetch
  };
}, []);
```

---

#### ‚ùå Hi·ªÉu l·∫ßm #2: "Dependencies thay ƒë·ªïi ‚Üí Old request auto-cancelled"

```jsx
// ‚ùå WRONG ASSUMPTION
function UserDetail({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // ‚ùå NO! Old fetch still continues!
    fetch(`/api/users/${userId}`)
      .then((res) => res.json())
      .then(setUser);
  }, [userId]);
}

// userId: 1 ‚Üí 2 ‚Üí 3
// Request 1 fires
// Request 2 fires (Request 1 still going!)
// Request 3 fires (Requests 1, 2 still going!)
// All 3 complete ‚Üí setUser called 3 times
// ‚ùå Race condition!

// ‚úÖ CORRECT: Manual cancellation
function UserDetail({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    fetch(`/api/users/${userId}`, { signal: controller.signal })
      .then((res) => res.json())
      .then(setUser)
      .catch((err) => {
        if (err.name !== 'AbortError') throw err;
      });

    return () => controller.abort(); // ‚úÖ Cancel old
  }, [userId]);
}
```

---

#### ‚ùå Hi·ªÉu l·∫ßm #3: "Parallel requests = Promise.all() lu√¥n lu√¥n"

```jsx
// ‚ùå WRONG: Promise.all fails n·∫øu 1 request fails
async function fetchDashboard() {
  const [users, posts, comments] = await Promise.all([
    fetch('/api/users'),
    fetch('/api/posts'),
    fetch('/api/comments'), // ‚Üê N·∫øu fail ‚Üí ALL fail!
  ]);
}

// ‚úÖ BETTER: Promise.allSettled() - handle failures gracefully
async function fetchDashboard() {
  const results = await Promise.allSettled([
    fetch('/api/users').then((r) => r.json()),
    fetch('/api/posts').then((r) => r.json()),
    fetch('/api/comments').then((r) => r.json()),
  ]);

  results.forEach((result, i) => {
    if (result.status === 'fulfilled') {
      console.log(`Request ${i} success:`, result.value);
    } else {
      console.error(`Request ${i} failed:`, result.reason);
    }
  });
}
```

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: AbortController Basic ‚≠ê

```jsx
/**
 * Demo: Cancel fetch requests v·ªõi AbortController
 * Concepts: abort signal, cleanup, error handling
 */

import { useState, useEffect } from 'react';

function AbortControllerDemo() {
  const [userId, setUserId] = useState(1);
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [requestLog, setRequestLog] = useState([]);

  useEffect(() => {
    // Create AbortController for this effect run
    const controller = new AbortController();
    const requestId = `User ${userId} @ ${Date.now()}`;

    console.log(`üöÄ Starting request: ${requestId}`);
    setRequestLog((prev) => [...prev, { id: requestId, status: 'pending' }]);

    setLoading(true);
    setError(null);

    async function fetchUser() {
      try {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/users/${userId}`,
          {
            signal: controller.signal, // ‚Üê Pass abort signal
          },
        );

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();

        console.log(`‚úÖ Completed request: ${requestId}`);
        setRequestLog((prev) =>
          prev.map((req) =>
            req.id === requestId ? { ...req, status: 'completed' } : req,
          ),
        );

        setUser(data);
        setLoading(false);
      } catch (err) {
        if (err.name === 'AbortError') {
          console.log(`üö´ Aborted request: ${requestId}`);
          setRequestLog((prev) =>
            prev.map((req) =>
              req.id === requestId ? { ...req, status: 'aborted' } : req,
            ),
          );
        } else {
          console.error(`‚ùå Failed request: ${requestId}`, err);
          setRequestLog((prev) =>
            prev.map((req) =>
              req.id === requestId ? { ...req, status: 'failed' } : req,
            ),
          );
          setError(err.message);
          setLoading(false);
        }
      }
    }

    fetchUser();

    // Cleanup: Abort request if effect re-runs or unmounts
    return () => {
      console.log(`üßπ Cleanup: Aborting ${requestId}`);
      controller.abort();
    };
  }, [userId]);

  const handleQuickSwitch = () => {
    // Rapidly change userId to demonstrate abortion
    setUserId(1);
    setTimeout(() => setUserId(2), 100);
    setTimeout(() => setUserId(3), 200);
    setTimeout(() => setUserId(4), 300);
  };

  return (
    <div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}>
      <h2>AbortController Demo</h2>

      {/* User Selection */}
      <div style={{ marginBottom: '20px' }}>
        <label>Select User: </label>
        <select
          value={userId}
          onChange={(e) => setUserId(Number(e.target.value))}
          style={{ padding: '8px', marginRight: '10px' }}
        >
          {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((id) => (
            <option
              key={id}
              value={id}
            >
              User {id}
            </option>
          ))}
        </select>

        <button
          onClick={handleQuickSwitch}
          style={{
            padding: '8px 16px',
            background: '#ff9800',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          üöÄ Quick Switch Test
        </button>
      </div>

      {/* User Display */}
      <div
        style={{
          padding: '20px',
          border: '2px solid #ddd',
          borderRadius: '8px',
          background: 'white',
          minHeight: '150px',
        }}
      >
        {loading && (
          <div style={{ textAlign: 'center', padding: '40px' }}>
            <div style={{ fontSize: '32px' }}>‚è≥</div>
            <p>Loading user {userId}...</p>
          </div>
        )}

        {error && (
          <div style={{ color: 'red', textAlign: 'center', padding: '40px' }}>
            <div style={{ fontSize: '32px' }}>‚ùå</div>
            <p>Error: {error}</p>
          </div>
        )}

        {!loading && !error && user && (
          <div>
            <h3>{user.name}</h3>
            <p>
              <strong>Email:</strong> {user.email}
            </p>
            <p>
              <strong>Phone:</strong> {user.phone}
            </p>
            <p>
              <strong>Website:</strong> {user.website}
            </p>
          </div>
        )}
      </div>

      {/* Request Log */}
      <div style={{ marginTop: '30px' }}>
        <h3>üìã Request Log (Last 10):</h3>
        <div
          style={{
            background: '#f5f5f5',
            padding: '15px',
            borderRadius: '4px',
            maxHeight: '200px',
            overflowY: 'auto',
          }}
        >
          {requestLog
            .slice(-10)
            .reverse()
            .map((req, i) => (
              <div
                key={i}
                style={{
                  padding: '8px',
                  marginBottom: '5px',
                  background: 'white',
                  borderRadius: '4px',
                  borderLeft: `4px solid ${
                    req.status === 'completed'
                      ? '#4CAF50'
                      : req.status === 'aborted'
                        ? '#ff9800'
                        : req.status === 'failed'
                          ? '#f44336'
                          : '#2196F3'
                  }`,
                }}
              >
                <span style={{ marginRight: '10px' }}>
                  {req.status === 'completed'
                    ? '‚úÖ'
                    : req.status === 'aborted'
                      ? 'üö´'
                      : req.status === 'failed'
                        ? '‚ùå'
                        : '‚è≥'}
                </span>
                <span>{req.id}</span>
                <span
                  style={{
                    marginLeft: '10px',
                    fontSize: '12px',
                    color: '#666',
                  }}
                >
                  ({req.status})
                </span>
              </div>
            ))}
        </div>
      </div>

      {/* Instructions */}
      <div
        style={{
          marginTop: '30px',
          padding: '20px',
          background: '#e3f2fd',
          borderRadius: '8px',
        }}
      >
        <h3>üß™ Test Scenarios:</h3>
        <ol>
          <li>
            <strong>Normal fetch:</strong> Select different users slowly
            <br />‚Üí Each request completes ‚úÖ
          </li>
          <li>
            <strong>Quick switching:</strong> Change users rapidly
            <br />‚Üí Old requests aborted üö´, only latest completes ‚úÖ
          </li>
          <li>
            <strong>Quick Switch button:</strong> Click button
            <br />
            ‚Üí Fires 4 requests in 300ms
            <br />‚Üí First 3 aborted, only last one completes
          </li>
        </ol>

        <h3>üí° Key Observations:</h3>
        <ul>
          <li>‚úÖ AbortController created PER effect run</li>
          <li>‚úÖ Cleanup aborts old request BEFORE new request starts</li>
          <li>‚úÖ AbortError caught separately (kh√¥ng display error UI)</li>
          <li>‚úÖ Request log shows lifecycle clearly</li>
        </ul>
      </div>
    </div>
  );
}

export default AbortControllerDemo;
```

---

### Demo 2: Dependent Requests (Sequential) ‚≠ê‚≠ê

```jsx
/**
 * Demo: Sequential data fetching - request B depends on request A
 * Use case: Fetch user ‚Üí Fetch user's posts
 */

import { useState, useEffect } from 'react';

const USERS_API = 'https://jsonplaceholder.typicode.com/users';
const POSTS_API = 'https://jsonplaceholder.typicode.com/posts';

function DependentRequestsDemo() {
  const [userId, setUserId] = useState(1);

  // User data
  const [user, setUser] = useState(null);
  const [userLoading, setUserLoading] = useState(true);
  const [userError, setUserError] = useState(null);

  // Posts data
  const [posts, setPosts] = useState([]);
  const [postsLoading, setPostsLoading] = useState(false);
  const [postsError, setPostsError] = useState(null);

  // Step 1: Fetch User
  useEffect(() => {
    const controller = new AbortController();

    async function fetchUser() {
      try {
        console.log(`üì• Step 1: Fetching user ${userId}...`);
        setUserLoading(true);
        setUserError(null);

        const response = await fetch(`${USERS_API}/${userId}`, {
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error('User not found');
        }

        const data = await response.json();
        console.log(`‚úÖ Step 1 Complete: User loaded`);

        setUser(data);
        setUserLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(`‚ùå Step 1 Failed:`, err);
          setUserError(err.message);
          setUserLoading(false);
        }
      }
    }

    fetchUser();

    return () => controller.abort();
  }, [userId]);

  // Step 2: Fetch Posts (depends on user)
  useEffect(() => {
    // ‚ö†Ô∏è Don't fetch if no user or user still loading
    if (!user || userLoading) return;

    const controller = new AbortController();

    async function fetchPosts() {
      try {
        console.log(`üì• Step 2: Fetching posts for user ${user.id}...`);
        setPostsLoading(true);
        setPostsError(null);

        const response = await fetch(`${POSTS_API}?userId=${user.id}`, {
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error('Failed to fetch posts');
        }

        const data = await response.json();
        console.log(`‚úÖ Step 2 Complete: ${data.length} posts loaded`);

        setPosts(data);
        setPostsLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(`‚ùå Step 2 Failed:`, err);
          setPostsError(err.message);
          setPostsLoading(false);
        }
      }
    }

    fetchPosts();

    return () => controller.abort();
  }, [user, userLoading]); // ‚Üê Dependencies: user data

  return (
    <div style={{ maxWidth: '1000px', margin: '0 auto', padding: '20px' }}>
      <h2>Dependent Requests Demo</h2>

      {/* User Selection */}
      <div style={{ marginBottom: '20px' }}>
        <label>Select User: </label>
        <select
          value={userId}
          onChange={(e) => setUserId(Number(e.target.value))}
          style={{ padding: '8px' }}
        >
          {[1, 2, 3, 4, 5].map((id) => (
            <option
              key={id}
              value={id}
            >
              User {id}
            </option>
          ))}
        </select>
      </div>

      {/* Request Flow Visualization */}
      <div
        style={{
          padding: '20px',
          background: '#f5f5f5',
          borderRadius: '8px',
          marginBottom: '20px',
        }}
      >
        <h3>üîÑ Request Flow:</h3>
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          {/* Step 1 */}
          <div
            style={{
              padding: '15px',
              background: userLoading
                ? '#2196F3'
                : userError
                  ? '#f44336'
                  : '#4CAF50',
              color: 'white',
              borderRadius: '8px',
              flex: 1,
              textAlign: 'center',
            }}
          >
            <div style={{ fontSize: '24px', marginBottom: '5px' }}>
              {userLoading ? '‚è≥' : userError ? '‚ùå' : '‚úÖ'}
            </div>
            <div>Step 1: Fetch User</div>
            <div style={{ fontSize: '12px', marginTop: '5px' }}>
              {userLoading ? 'Loading...' : userError ? 'Failed' : 'Complete'}
            </div>
          </div>

          <div style={{ fontSize: '24px' }}>‚Üí</div>

          {/* Step 2 */}
          <div
            style={{
              padding: '15px',
              background: !user
                ? '#ccc'
                : postsLoading
                  ? '#2196F3'
                  : postsError
                    ? '#f44336'
                    : '#4CAF50',
              color: 'white',
              borderRadius: '8px',
              flex: 1,
              textAlign: 'center',
            }}
          >
            <div style={{ fontSize: '24px', marginBottom: '5px' }}>
              {!user ? '‚è∏Ô∏è' : postsLoading ? '‚è≥' : postsError ? '‚ùå' : '‚úÖ'}
            </div>
            <div>Step 2: Fetch Posts</div>
            <div style={{ fontSize: '12px', marginTop: '5px' }}>
              {!user
                ? 'Waiting...'
                : postsLoading
                  ? 'Loading...'
                  : postsError
                    ? 'Failed'
                    : 'Complete'}
            </div>
          </div>
        </div>
      </div>

      {/* Content Grid */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: '1fr 2fr',
          gap: '20px',
        }}
      >
        {/* User Panel */}
        <div>
          <h3>üë§ User Details</h3>
          <div
            style={{
              padding: '15px',
              border: '2px solid #ddd',
              borderRadius: '8px',
              background: 'white',
              minHeight: '150px',
            }}
          >
            {userLoading && <div>Loading user...</div>}
            {userError && (
              <div style={{ color: 'red' }}>Error: {userError}</div>
            )}
            {user && !userLoading && (
              <div>
                <h4>{user.name}</h4>
                <p style={{ fontSize: '14px', color: '#666' }}>
                  üìß {user.email}
                </p>
                <p style={{ fontSize: '14px', color: '#666' }}>
                  üè¢ {user.company.name}
                </p>
              </div>
            )}
          </div>
        </div>

        {/* Posts Panel */}
        <div>
          <h3>üìù User Posts ({posts.length})</h3>
          <div
            style={{
              padding: '15px',
              border: '2px solid #ddd',
              borderRadius: '8px',
              background: 'white',
              minHeight: '150px',
              maxHeight: '400px',
              overflowY: 'auto',
            }}
          >
            {!user && (
              <div
                style={{ textAlign: 'center', padding: '40px', color: '#999' }}
              >
                Select a user to view posts
              </div>
            )}

            {user && postsLoading && (
              <div style={{ textAlign: 'center', padding: '40px' }}>
                Loading posts...
              </div>
            )}

            {user && postsError && (
              <div style={{ color: 'red' }}>Error: {postsError}</div>
            )}

            {user && !postsLoading && !postsError && (
              <div style={{ display: 'grid', gap: '10px' }}>
                {posts.map((post) => (
                  <div
                    key={post.id}
                    style={{
                      padding: '10px',
                      border: '1px solid #eee',
                      borderRadius: '4px',
                      background: '#f9f9f9',
                    }}
                  >
                    <h5 style={{ margin: '0 0 5px 0' }}>{post.title}</h5>
                    <p style={{ margin: 0, fontSize: '13px', color: '#666' }}>
                      {post.body.substring(0, 80)}...
                    </p>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Technical Explanation */}
      <div
        style={{
          marginTop: '30px',
          padding: '20px',
          background: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        <h3>üîë Key Patterns:</h3>

        <h4>1. Sequential Execution:</h4>
        <pre
          style={{
            background: 'white',
            padding: '10px',
            borderRadius: '4px',
            overflow: 'auto',
          }}
        >
          {`// Effect 1: Fetch user
useEffect(() => {
  fetchUser(userId);
}, [userId]);

// Effect 2: Fetch posts (waits for user)
useEffect(() => {
  if (!user || userLoading) return; // ‚Üê Guard clause
  fetchPosts(user.id);
}, [user, userLoading]); // ‚Üê Depends on user`}
        </pre>

        <h4>2. Guard Clauses:</h4>
        <ul>
          <li>
            <code>if (!user) return;</code> - Don't fetch if dependency not
            ready
          </li>
          <li>
            <code>if (userLoading) return;</code> - Wait for first request to
            complete
          </li>
        </ul>

        <h4>3. Benefits:</h4>
        <ul>
          <li>‚úÖ Clear separation of concerns</li>
          <li>‚úÖ Each effect handles 1 data source</li>
          <li>‚úÖ Automatic refetch when dependencies change</li>
          <li>‚úÖ Independent error handling</li>
        </ul>
      </div>
    </div>
  );
}

export default DependentRequestsDemo;
```

---

### Demo 3: Parallel Requests Optimization ‚≠ê‚≠ê‚≠ê

```jsx
/**
 * Demo: Parallel data fetching - multiple independent requests
 * Use case: Dashboard with multiple data sources
 */

import { useState, useEffect } from 'react';

const API_BASE = 'https://jsonplaceholder.typicode.com';

function ParallelRequestsDemo() {
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // Individual states for each data source
  const [stats, setStats] = useState({
    users: { data: null, loading: true, error: null },
    posts: { data: null, loading: true, error: null },
    comments: { data: null, loading: true, error: null },
  });

  // Timing metrics
  const [metrics, setMetrics] = useState({
    startTime: null,
    endTime: null,
    duration: null,
  });

  useEffect(() => {
    const startTime = Date.now();
    setMetrics({ startTime, endTime: null, duration: null });

    console.log('üöÄ Starting parallel requests...');

    // Create abort controllers for each request
    const controllers = {
      users: new AbortController(),
      posts: new AbortController(),
      comments: new AbortController(),
    };

    // Fetch function for each endpoint
    async function fetchData(endpoint, key, controller) {
      try {
        console.log(`üì• Fetching ${key}...`);

        setStats((prev) => ({
          ...prev,
          [key]: { ...prev[key], loading: true, error: null },
        }));

        const response = await fetch(`${API_BASE}/${endpoint}`, {
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        console.log(`‚úÖ ${key} loaded: ${data.length} items`);

        setStats((prev) => ({
          ...prev,
          [key]: { data, loading: false, error: null },
        }));

        return { key, success: true, count: data.length };
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(`‚ùå ${key} failed:`, err);

          setStats((prev) => ({
            ...prev,
            [key]: { data: null, loading: false, error: err.message },
          }));

          return { key, success: false, error: err.message };
        }
        return { key, success: false, aborted: true };
      }
    }

    // Fire all requests in parallel
    Promise.allSettled([
      fetchData('users', 'users', controllers.users),
      fetchData('posts', 'posts', controllers.posts),
      fetchData('comments', 'comments', controllers.comments),
    ]).then((results) => {
      const endTime = Date.now();
      const duration = endTime - startTime;

      setMetrics({ startTime, endTime, duration });

      console.log('üèÅ All requests completed');
      console.log('‚è±Ô∏è Total time:', duration, 'ms');

      results.forEach((result, i) => {
        if (result.status === 'fulfilled' && result.value.success) {
          console.log(`  ‚úÖ ${result.value.key}: ${result.value.count} items`);
        } else if (result.status === 'fulfilled' && result.value.aborted) {
          console.log(`  üö´ ${result.value.key}: Aborted`);
        } else {
          console.log(`  ‚ùå ${result.value?.key || 'Unknown'}: Failed`);
        }
      });
    });

    // Cleanup: Abort all requests
    return () => {
      console.log('üßπ Cleanup: Aborting all requests');
      Object.values(controllers).forEach((ctrl) => ctrl.abort());
    };
  }, [refreshTrigger]);

  const handleRefresh = () => {
    setRefreshTrigger((prev) => prev + 1);
  };

  // Check overall status
  const allLoaded = Object.values(stats).every((s) => !s.loading);
  const anyError = Object.values(stats).some((s) => s.error);
  const allSuccess = Object.values(stats).every((s) => s.data && !s.error);

  return (
    <div style={{ maxWidth: '1200px', margin: '0 auto', padding: '20px' }}>
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '20px',
        }}
      >
        <h2>Parallel Requests Demo</h2>

        <button
          onClick={handleRefresh}
          disabled={!allLoaded}
          style={{
            padding: '10px 20px',
            background: allLoaded ? '#4CAF50' : '#ccc',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: allLoaded ? 'pointer' : 'not-allowed',
            fontSize: '16px',
          }}
        >
          üîÑ Refresh All
        </button>
      </div>

      {/* Performance Metrics */}
      <div
        style={{
          padding: '20px',
          background: allSuccess ? '#d4edda' : anyError ? '#fff3cd' : '#cfe2ff',
          border: `2px solid ${allSuccess ? '#4CAF50' : anyError ? '#ffc107' : '#2196F3'}`,
          borderRadius: '8px',
          marginBottom: '20px',
        }}
      >
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
          }}
        >
          <div>
            <strong>Status:</strong>{' '}
            {!allLoaded
              ? '‚è≥ Loading...'
              : allSuccess
                ? '‚úÖ All loaded successfully'
                : '‚ö†Ô∏è Some requests failed'}
          </div>

          {metrics.duration && (
            <div>
              <strong>Total Time:</strong> {metrics.duration}ms
            </div>
          )}
        </div>

        {allLoaded && (
          <div style={{ marginTop: '10px', fontSize: '14px', color: '#666' }}>
            üí° Parallel fetching completed in {metrics.duration}ms (vs ~
            {Object.keys(stats).length * 500}ms if sequential)
          </div>
        )}
      </div>

      {/* Stats Cards */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
          gap: '20px',
          marginBottom: '30px',
        }}
      >
        {Object.entries(stats).map(([key, state]) => (
          <StatCard
            key={key}
            title={key.charAt(0).toUpperCase() + key.slice(1)}
            data={state.data}
            loading={state.loading}
            error={state.error}
            icon={key === 'users' ? 'üë•' : key === 'posts' ? 'üìù' : 'üí¨'}
          />
        ))}
      </div>

      {/* Comparison: Sequential vs Parallel */}
      <div
        style={{
          padding: '20px',
          background: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        <h3>üìä Sequential vs Parallel Comparison:</h3>

        <div
          style={{
            display: 'grid',
            gridTemplateColumns: '1fr 1fr',
            gap: '20px',
            marginTop: '15px',
          }}
        >
          {/* Sequential */}
          <div
            style={{
              padding: '15px',
              background: 'white',
              borderRadius: '4px',
              border: '2px solid #f44336',
            }}
          >
            <h4 style={{ marginTop: 0 }}>‚ùå Sequential (Bad)</h4>
            <pre
              style={{
                fontSize: '12px',
                background: '#f9f9f9',
                padding: '10px',
                borderRadius: '4px',
              }}
            >
              {`useEffect(() => {
  // Request 1
  const users = await fetch('/users');
  setUsers(users);
  
  // Request 2 (waits for 1)
  const posts = await fetch('/posts');
  setPosts(posts);
  
  // Request 3 (waits for 2)
  const comments = await fetch('/comments');
  setComments(comments);
}, []);

// Total time: ~1500ms
// (500ms + 500ms + 500ms)`}
            </pre>
          </div>

          {/* Parallel */}
          <div
            style={{
              padding: '15px',
              background: 'white',
              borderRadius: '4px',
              border: '2px solid #4CAF50',
            }}
          >
            <h4 style={{ marginTop: 0 }}>‚úÖ Parallel (Good)</h4>
            <pre
              style={{
                fontSize: '12px',
                background: '#f9f9f9',
                padding: '10px',
                borderRadius: '4px',
              }}
            >
              {`useEffect(() => {
  Promise.allSettled([
    fetch('/users'),
    fetch('/posts'),
    fetch('/comments')
  ]).then(results => {
    // Process results
  });
}, []);

// Total time: ~500ms
// (all fire simultaneously!)
// 3x faster! üöÄ`}
            </pre>
          </div>
        </div>

        <div style={{ marginTop: '20px' }}>
          <h4>‚úÖ Benefits of Parallel Fetching:</h4>
          <ul>
            <li>
              <strong>Performance:</strong> Requests fire simultaneously ‚Üí
              Faster overall
            </li>
            <li>
              <strong>Independence:</strong> One failure doesn't block others
              (Promise.allSettled)
            </li>
            <li>
              <strong>Progressive display:</strong> Show data as it arrives
            </li>
            <li>
              <strong>Better UX:</strong> User sees content loading
              progressively
            </li>
          </ul>

          <h4>‚ö†Ô∏è When NOT to use Parallel:</h4>
          <ul>
            <li>Request B depends on data from Request A (use sequential)</li>
            <li>Server rate limits (may need to throttle)</li>
            <li>Requests must complete in specific order</li>
          </ul>
        </div>
      </div>
    </div>
  );
}

// Reusable StatCard component
function StatCard({ title, data, loading, error, icon }) {
  if (loading) {
    return (
      <div
        style={{
          padding: '20px',
          background: '#f5f5f5',
          borderRadius: '8px',
          textAlign: 'center',
          border: '2px solid #2196F3',
        }}
      >
        <div style={{ fontSize: '32px', marginBottom: '10px' }}>‚è≥</div>
        <div>Loading {title.toLowerCase()}...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div
        style={{
          padding: '20px',
          background: '#fff0f0',
          borderRadius: '8px',
          textAlign: 'center',
          border: '2px solid #f44336',
        }}
      >
        <div style={{ fontSize: '32px', marginBottom: '10px' }}>‚ùå</div>
        <div style={{ color: '#f44336', marginBottom: '10px' }}>{error}</div>
      </div>
    );
  }

  return (
    <div
      style={{
        padding: '20px',
        background: 'white',
        borderRadius: '8px',
        textAlign: 'center',
        border: '2px solid #4CAF50',
      }}
    >
      <div style={{ fontSize: '32px', marginBottom: '10px' }}>{icon}</div>
      <div style={{ fontSize: '14px', color: '#666', marginBottom: '5px' }}>
        {title}
      </div>
      <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#4CAF50' }}>
        {Array.isArray(data) ? data.length : data}
      </div>
    </div>
  );
}

export default ParallelRequestsDemo;
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Level 1: √Åp D·ª•ng Concept (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Implement AbortController cho search
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: Libraries, custom hooks
 *
 * Requirements:
 * 1. Search input v·ªõi auto-complete
 * 2. Fetch results khi user types
 * 3. Cancel old requests khi query thay ƒë·ªïi
 * 4. Handle AbortError properly
 *
 * API: https://jsonplaceholder.typicode.com/users?name_like={query}
 *
 * üí° G·ª£i √Ω:
 * - AbortController per effect
 * - Cleanup aborts controller
 * - Catch AbortError separately
 */

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
function SearchWithAbort() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!query || query.length < 2) {
      setResults([]);
      return;
    }

    // TODO: Create AbortController

    // TODO: Fetch users with abort signal
    // API: `https://jsonplaceholder.typicode.com/users`
    // Filter client-side by name.includes(query)

    // TODO: Handle AbortError vs other errors

    // TODO: Return cleanup function that aborts
  }, [query]);

  return (
    <div>
      <h2>Search with Abort</h2>

      <input
        type='text'
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search users (min 2 chars)...'
        style={{
          width: '100%',
          padding: '12px',
          fontSize: '16px',
          border: '2px solid #ddd',
          borderRadius: '4px',
        }}
      />

      {loading && <p>Searching...</p>}
      {error && <p style={{ color: 'red' }}>Error: {error}</p>}

      <div style={{ marginTop: '20px' }}>
        {results.map((user) => (
          <div
            key={user.id}
            style={{
              padding: '10px',
              border: '1px solid #ddd',
              borderRadius: '4px',
              marginBottom: '10px',
            }}
          >
            <strong>{user.name}</strong>
            <p style={{ margin: '5px 0 0 0', fontSize: '14px', color: '#666' }}>
              {user.email}
            </p>
          </div>
        ))}
      </div>

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>üß™ Test:</h3>
        <ol>
          <li>Type "Le" quickly ‚Üí Should cancel first request</li>
          <li>Type "Leanne" fast ‚Üí Multiple cancellations</li>
          <li>Console should show abort messages</li>
          <li>No errors displayed for AbortError</li>
        </ol>
      </div>
    </div>
  );
}

export default SearchWithAbort;
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * SearchWithAbort - Level 1
 * Implement search with AbortController to cancel outdated requests
 */
function SearchWithAbort() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!query || query.length < 2) {
      setResults([]);
      setLoading(false);
      return;
    }

    const controller = new AbortController();

    async function searchUsers() {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch(
          'https://jsonplaceholder.typicode.com/users',
          {
            signal: controller.signal,
          },
        );

        if (!response.ok) {
          throw new Error('Network response was not ok');
        }

        const data = await response.json();

        // Client-side filtering
        const filtered = data.filter((user) =>
          user.name.toLowerCase().includes(query.toLowerCase()),
        );

        // Only update state if not aborted
        if (!controller.signal.aborted) {
          setResults(filtered);
          setLoading(false);
        }
      } catch (err) {
        if (err.name === 'AbortError') {
          // Silent abort - no error message needed
          console.log('Search aborted for query:', query);
        } else {
          setError(err.message || 'Failed to fetch users');
          setLoading(false);
        }
      }
    }

    searchUsers();

    // Cleanup: abort previous request when query changes or component unmounts
    return () => {
      controller.abort();
    };
  }, [query]);

  return (
    <div>
      <h2>Search with Abort</h2>
      <input
        type='text'
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search users (min 2 chars)...'
        style={{
          width: '100%',
          padding: '12px',
          fontSize: '16px',
          border: '2px solid #ddd',
          borderRadius: '4px',
        }}
      />
      {loading && <p>Searching...</p>}
      {error && <p style={{ color: 'red' }}>Error: {error}</p>}
      <div style={{ marginTop: '20px' }}>
        {results.map((user) => (
          <div
            key={user.id}
            style={{
              padding: '10px',
              border: '1px solid #ddd',
              borderRadius: '4px',
              marginBottom: '10px',
            }}
          >
            <strong>{user.name}</strong>
            <p style={{ margin: '5px 0 0 0', fontSize: '14px', color: '#666' }}>
              {user.email}
            </p>
          </div>
        ))}
      </div>
      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>üß™ Test:</h3>
        <ol>
          <li>Type "Le" quickly ‚Üí Should cancel first request</li>
          <li>Type "Leanne" fast ‚Üí Multiple cancellations</li>
          <li>Console should show abort messages</li>
          <li>No errors displayed for AbortError</li>
        </ol>
      </div>
    </div>
  );
}

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- G√µ nhanh "Le" ‚Üí "Lea" ‚Üí "Leann" ‚Üí "Leanne"
‚Üí Ch·ªâ request cu·ªëi c√πng hi·ªÉn th·ªã (th∆∞·ªùng l√† Leanne Graham)
‚Üí C√°c request tr∆∞·ªõc b·ªã abort ‚Üí console th·∫•y "Search aborted for query: Lea"...
‚Üí Kh√¥ng b·ªã hi·ªán nh·∫ßm t√™n ng∆∞·ªùi d√πng c≈©
*/
```

</details>

---

### ‚≠ê‚≠ê Level 2: Nh·∫≠n Bi·∫øt Pattern (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Dependent requests v·ªõi proper error handling
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Fetch album ‚Üí Fetch photos from that album
 *
 * Requirements:
 * - Fetch album details
 * - Fetch photos for that album (depends on album ID)
 * - Show loading states for each step
 * - Handle errors independently
 * - Cancel both on album change
 *
 * APIs:
 * - Albums: https://jsonplaceholder.typicode.com/albums/{id}
 * - Photos: https://jsonplaceholder.typicode.com/photos?albumId={id}
 */

function AlbumPhotosViewer() {
  const [albumId, setAlbumId] = useState(1);

  // TODO: Album state
  const [album, setAlbum] = useState(null);
  const [albumLoading, setAlbumLoading] = useState(true);
  const [albumError, setAlbumError] = useState(null);

  // TODO: Photos state
  const [photos, setPhotos] = useState([]);
  const [photosLoading, setPhotosLoading] = useState(false);
  const [photosError, setPhotosError] = useState(null);

  // TODO: Effect 1 - Fetch album
  useEffect(() => {
    const controller = new AbortController();

    async function fetchAlbum() {
      try {
        // TODO: Implement fetch album
        // Set loading, fetch, handle response, set data
      } catch (err) {
        // TODO: Handle abort vs other errors
      }
    }

    fetchAlbum();

    return () => controller.abort();
  }, [albumId]);

  // TODO: Effect 2 - Fetch photos (depends on album)
  useEffect(() => {
    // TODO: Guard clause - don't fetch if no album

    const controller = new AbortController();

    async function fetchPhotos() {
      try {
        // TODO: Implement fetch photos
        // API: /photos?albumId=${album.id}
      } catch (err) {
        // TODO: Handle errors
      }
    }

    fetchPhotos();

    return () => controller.abort();
  }, [album]); // Dependencies: album data

  return (
    <div style={{ maxWidth: '1000px', margin: '0 auto', padding: '20px' }}>
      <h2>Album Photos Viewer</h2>

      {/* Album Selection */}
      <div style={{ marginBottom: '20px' }}>
        <label>Select Album: </label>
        <select
          value={albumId}
          onChange={(e) => setAlbumId(Number(e.target.value))}
        >
          {[1, 2, 3, 4, 5].map((id) => (
            <option
              key={id}
              value={id}
            >
              Album {id}
            </option>
          ))}
        </select>
      </div>

      {/* Request Flow Indicator */}
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '10px',
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
          marginBottom: '20px',
        }}
      >
        <div
          style={{
            padding: '10px 20px',
            background: albumLoading
              ? '#2196F3'
              : albumError
                ? '#f44336'
                : '#4CAF50',
            color: 'white',
            borderRadius: '4px',
            flex: 1,
            textAlign: 'center',
          }}
        >
          {albumLoading
            ? '‚è≥ Fetching Album'
            : albumError
              ? '‚ùå Album Failed'
              : '‚úÖ Album Loaded'}
        </div>

        <span style={{ fontSize: '24px' }}>‚Üí</span>

        <div
          style={{
            padding: '10px 20px',
            background: !album
              ? '#ccc'
              : photosLoading
                ? '#2196F3'
                : photosError
                  ? '#f44336'
                  : '#4CAF50',
            color: 'white',
            borderRadius: '4px',
            flex: 1,
            textAlign: 'center',
          }}
        >
          {!album
            ? '‚è∏Ô∏è Waiting'
            : photosLoading
              ? '‚è≥ Fetching Photos'
              : photosError
                ? '‚ùå Photos Failed'
                : '‚úÖ Photos Loaded'}
        </div>
      </div>

      {/* Content */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: '300px 1fr',
          gap: '20px',
        }}
      >
        {/* Album Details */}
        <div>
          <h3>Album Details</h3>
          {/* TODO: Display album info or loading/error */}
        </div>

        {/* Photos Grid */}
        <div>
          <h3>Photos ({photos.length})</h3>
          {/* TODO: Display photos grid or loading/error */}
          {/* Hint: Use thumbnailUrl for images */}
        </div>
      </div>

      <div
        style={{
          marginTop: '30px',
          padding: '15px',
          background: '#e3f2fd',
          borderRadius: '4px',
        }}
      >
        <h3>üîë Implementation Checklist:</h3>
        <ul>
          <li>[ ] Album fetch has AbortController</li>
          <li>[ ] Photos fetch has AbortController</li>
          <li>[ ] Photos effect has guard clause (if !album return)</li>
          <li>[ ] Both effects cleanup properly</li>
          <li>[ ] AbortError handled separately</li>
          <li>[ ] Loading states independent</li>
          <li>[ ] Changing album cancels both requests</li>
        </ul>
      </div>
    </div>
  );
}

export default AlbumPhotosViewer;
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * AlbumPhotosViewer - Level 2
 * Dependent requests: Fetch album ‚Üí then fetch photos for that album
 * Independent AbortController for each request + proper guard clause
 */
function AlbumPhotosViewer() {
  const [albumId, setAlbumId] = useState(1);

  // Album state
  const [album, setAlbum] = useState(null);
  const [albumLoading, setAlbumLoading] = useState(true);
  const [albumError, setAlbumError] = useState(null);

  // Photos state
  const [photos, setPhotos] = useState([]);
  const [photosLoading, setPhotosLoading] = useState(false);
  const [photosError, setPhotosError] = useState(null);

  // Effect 1: Fetch album details
  useEffect(() => {
    const controller = new AbortController();

    async function fetchAlbum() {
      setAlbumLoading(true);
      setAlbumError(null);
      setPhotos([]); // Reset photos when changing album

      try {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/albums/${albumId}`,
          { signal: controller.signal },
        );

        if (!response.ok) {
          throw new Error(`Album not found (HTTP ${response.status})`);
        }

        const data = await response.json();
        setAlbum(data);
        setAlbumLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setAlbumError(err.message || 'Failed to load album');
          setAlbumLoading(false);
        }
      }
    }

    fetchAlbum();

    return () => controller.abort();
  }, [albumId]);

  // Effect 2: Fetch photos (only when we have a valid album)
  useEffect(() => {
    // Guard clause: don't fetch until album is loaded
    if (!album || albumLoading) return;

    const controller = new AbortController();

    async function fetchPhotos() {
      setPhotosLoading(true);
      setPhotosError(null);

      try {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/photos?albumId=${album.id}`,
          { signal: controller.signal },
        );

        if (!response.ok) {
          throw new Error('Failed to fetch photos');
        }

        const data = await response.json();
        setPhotos(data);
        setPhotosLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setPhotosError(err.message || 'Failed to load photos');
          setPhotosLoading(false);
        }
      }
    }

    fetchPhotos();

    return () => controller.abort();
  }, [album, albumLoading]); // Depend on album object & loading state

  return (
    <div style={{ maxWidth: '1000px', margin: '0 auto', padding: '20px' }}>
      <h2>Album Photos Viewer</h2>

      {/* Album Selection */}
      <div style={{ marginBottom: '20px' }}>
        <label>Select Album: </label>
        <select
          value={albumId}
          onChange={(e) => setAlbumId(Number(e.target.value))}
        >
          {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((id) => (
            <option
              key={id}
              value={id}
            >
              Album {id}
            </option>
          ))}
        </select>
      </div>

      {/* Request Flow Indicator */}
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '10px',
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
          marginBottom: '20px',
        }}
      >
        <div
          style={{
            padding: '10px 20px',
            background: albumLoading
              ? '#2196F3'
              : albumError
                ? '#f44336'
                : '#4CAF50',
            color: 'white',
            borderRadius: '4px',
            flex: 1,
            textAlign: 'center',
          }}
        >
          {albumLoading
            ? '‚è≥ Fetching Album'
            : albumError
              ? '‚ùå Album Failed'
              : '‚úÖ Album Loaded'}
        </div>
        <span style={{ fontSize: '24px' }}>‚Üí</span>
        <div
          style={{
            padding: '10px 20px',
            background: !album
              ? '#ccc'
              : photosLoading
                ? '#2196F3'
                : photosError
                  ? '#f44336'
                  : '#4CAF50',
            color: 'white',
            borderRadius: '4px',
            flex: 1,
            textAlign: 'center',
          }}
        >
          {!album
            ? '‚è∏Ô∏è Waiting'
            : photosLoading
              ? '‚è≥ Fetching Photos'
              : photosError
                ? '‚ùå Photos Failed'
                : '‚úÖ Photos Loaded'}
        </div>
      </div>

      {/* Content */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: '300px 1fr',
          gap: '20px',
        }}
      >
        {/* Album Details */}
        <div>
          <h3>Album Details</h3>
          {albumLoading && <div>Loading album info...</div>}
          {albumError && <div style={{ color: 'red' }}>{albumError}</div>}
          {album && !albumLoading && (
            <div
              style={{
                padding: '12px',
                background: '#fff',
                border: '1px solid #eee',
              }}
            >
              <h4>{album.title}</h4>
              <p style={{ color: '#666', fontSize: '14px' }}>
                User ID: {album.userId} ‚Ä¢ Album ID: {album.id}
              </p>
            </div>
          )}
        </div>

        {/* Photos Grid */}
        <div>
          <h3>Photos ({photos.length})</h3>
          {photosLoading && <div>Loading photos...</div>}
          {photosError && <div style={{ color: 'red' }}>{photosError}</div>}
          {!album && <div style={{ color: '#999' }}>Select an album first</div>}
          {photos.length > 0 && !photosLoading && !photosError && (
            <div
              style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))',
                gap: '12px',
                maxHeight: '500px',
                overflowY: 'auto',
              }}
            >
              {photos.map((photo) => (
                <div
                  key={photo.id}
                  style={{
                    border: '1px solid #eee',
                    borderRadius: '6px',
                    overflow: 'hidden',
                    background: '#fff',
                  }}
                >
                  <img
                    src={photo.thumbnailUrl}
                    alt={photo.title}
                    style={{ width: '100%', height: 'auto', display: 'block' }}
                  />
                  <div style={{ padding: '8px', fontSize: '13px' }}>
                    {photo.title.substring(0, 60)}
                    {photo.title.length > 60 ? '...' : ''}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      <div
        style={{
          marginTop: '30px',
          padding: '15px',
          background: '#e3f2fd',
          borderRadius: '4px',
        }}
      >
        <h3>üîë Implementation Checklist:</h3>
        <ul>
          <li>‚úì Album fetch has AbortController</li>
          <li>‚úì Photos fetch has AbortController</li>
          <li>‚úì Photos effect has guard clause (if !album return)</li>
          <li>‚úì Both effects cleanup properly</li>
          <li>‚úì AbortError handled separately</li>
          <li>‚úì Loading states independent</li>
          <li>‚úì Changing album cancels both requests</li>
        </ul>
      </div>
    </div>
  );
}

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- Ch·ªçn Album 1 ‚Üí th·∫•y album title + ~50 thumbnails load tu·∫ßn t·ª±
- Chuy·ªÉn nhanh sang Album 3 ‚Üí request Album 1 b·ªã abort, request photos Album 1 b·ªã abort
- Ch·ªâ th·∫•y d·ªØ li·ªáu Album 3 + photos c·ªßa Album 3
- Kh√¥ng b·ªã hi·ªán l·∫´n l·ªôn ·∫£nh gi·ªØa c√°c album
- Console c√≥ log abort khi chuy·ªÉn nhanh
*/
```

</details>

---

### ‚≠ê‚≠ê‚≠ê Level 3: K·ªãch B·∫£n Th·ª±c T·∫ø (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: E-commerce Product Browser v·ªõi Advanced Fetching
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën browse products by category,
 * search products, v√† view product details"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Fetch categories on mount
 * - [ ] Fetch products by selected category
 * - [ ] Search products (debounced)
 * - [ ] Click product ‚Üí Fetch product details
 * - [ ] Cancel old requests khi filter/search thay ƒë·ªïi
 * - [ ] Loading states cho m·ªói section
 * - [ ] Error handling graceful
 *
 * üé® Technical Constraints:
 * - API: https://fakestoreapi.com
 * - Endpoints:
 *   - /products/categories
 *   - /products/category/{category}
 *   - /products/{id}
 * - AbortController cho t·∫•t c·∫£ requests
 * - Debounce search 500ms
 *
 * üö® Edge Cases:
 * - Switch category while search active ‚Üí Clear search
 * - Click product while loading ‚Üí Cancel old, fetch new
 * - Rapid category switching ‚Üí Only latest request matters
 */

import { useState, useEffect } from 'react';

const API_BASE = 'https://fakestoreapi.com';

function ProductBrowser() {
  // Categories
  const [categories, setCategories] = useState([]);
  const [categoriesLoading, setCategoriesLoading] = useState(true);

  // Products
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [products, setProducts] = useState([]);
  const [productsLoading, setProductsLoading] = useState(false);
  const [productsError, setProductsError] = useState(null);

  // Search
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');

  // Product details
  const [selectedProduct, setSelectedProduct] = useState(null);
  const [productDetails, setProductDetails] = useState(null);
  const [detailsLoading, setDetailsLoading] = useState(false);

  // TODO: Effect 1 - Fetch categories (once on mount)
  useEffect(() => {
    const controller = new AbortController();

    async function fetchCategories() {
      try {
        const response = await fetch(`${API_BASE}/products/categories`, {
          signal: controller.signal,
        });
        const data = await response.json();
        setCategories(['all', ...data]);
        setCategoriesLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Categories error:', err);
          setCategoriesLoading(false);
        }
      }
    }

    fetchCategories();
    return () => controller.abort();
  }, []);

  // TODO: Effect 2 - Debounce search
  useEffect(() => {
    const timerId = setTimeout(() => {
      setDebouncedQuery(searchQuery);
    }, 500);

    return () => clearTimeout(timerId);
  }, [searchQuery]);

  // TODO: Effect 3 - Fetch products (by category or search)
  useEffect(() => {
    const controller = new AbortController();

    async function fetchProducts() {
      try {
        setProductsLoading(true);
        setProductsError(null);

        let url;
        if (debouncedQuery) {
          // Search mode - fetch all and filter client-side
          url = `${API_BASE}/products`;
        } else if (selectedCategory === 'all') {
          url = `${API_BASE}/products`;
        } else {
          url = `${API_BASE}/products/category/${selectedCategory}`;
        }

        const response = await fetch(url, { signal: controller.signal });
        let data = await response.json();

        // Client-side filter by search
        if (debouncedQuery) {
          data = data.filter((p) =>
            p.title.toLowerCase().includes(debouncedQuery.toLowerCase()),
          );
        }

        setProducts(data);
        setProductsLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setProductsError(err.message);
          setProductsLoading(false);
        }
      }
    }

    fetchProducts();
    return () => controller.abort();
  }, [selectedCategory, debouncedQuery]);

  // TODO: Effect 4 - Fetch product details
  useEffect(() => {
    if (!selectedProduct) {
      setProductDetails(null);
      return;
    }

    const controller = new AbortController();

    async function fetchDetails() {
      try {
        setDetailsLoading(true);

        const response = await fetch(
          `${API_BASE}/products/${selectedProduct}`,
          {
            signal: controller.signal,
          },
        );
        const data = await response.json();

        setProductDetails(data);
        setDetailsLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Details error:', err);
          setDetailsLoading(false);
        }
      }
    }

    fetchDetails();
    return () => controller.abort();
  }, [selectedProduct]);

  const handleCategoryChange = (category) => {
    setSelectedCategory(category);
    setSearchQuery(''); // Clear search when changing category
    setSelectedProduct(null); // Clear selected product
  };

  const handleProductClick = (productId) => {
    setSelectedProduct(productId);
  };

  return (
    <div style={{ maxWidth: '1400px', margin: '0 auto', padding: '20px' }}>
      <h2>üõí Product Browser</h2>

      {/* Filters Bar */}
      <div
        style={{
          display: 'flex',
          gap: '20px',
          marginBottom: '20px',
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
        }}
      >
        {/* Categories */}
        <div style={{ flex: 1 }}>
          <label
            style={{
              display: 'block',
              marginBottom: '5px',
              fontWeight: 'bold',
            }}
          >
            Category:
          </label>
          {categoriesLoading ? (
            <div>Loading categories...</div>
          ) : (
            <select
              value={selectedCategory}
              onChange={(e) => handleCategoryChange(e.target.value)}
              style={{ width: '100%', padding: '8px', borderRadius: '4px' }}
            >
              {categories.map((cat) => (
                <option
                  key={cat}
                  value={cat}
                >
                  {cat.charAt(0).toUpperCase() + cat.slice(1)}
                </option>
              ))}
            </select>
          )}
        </div>

        {/* Search */}
        <div style={{ flex: 2 }}>
          <label
            style={{
              display: 'block',
              marginBottom: '5px',
              fontWeight: 'bold',
            }}
          >
            Search:
          </label>
          <input
            type='text'
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder='Search products...'
            style={{
              width: '100%',
              padding: '8px',
              borderRadius: '4px',
              border: '1px solid #ddd',
            }}
          />
          {searchQuery && (
            <div style={{ fontSize: '12px', color: '#666', marginTop: '5px' }}>
              {debouncedQuery !== searchQuery
                ? 'Typing...'
                : `Searching for "${debouncedQuery}"`}
            </div>
          )}
        </div>
      </div>

      {/* Main Content */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: selectedProduct ? '2fr 1fr' : '1fr',
          gap: '20px',
        }}
      >
        {/* Products Grid */}
        <div>
          <h3>Products ({products.length})</h3>

          {productsLoading ? (
            <div style={{ textAlign: 'center', padding: '40px' }}>
              Loading products...
            </div>
          ) : productsError ? (
            <div style={{ color: 'red', padding: '20px' }}>
              Error: {productsError}
            </div>
          ) : products.length === 0 ? (
            <div
              style={{ textAlign: 'center', padding: '40px', color: '#999' }}
            >
              No products found
            </div>
          ) : (
            <div
              style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
                gap: '15px',
              }}
            >
              {products.map((product) => (
                <div
                  key={product.id}
                  onClick={() => handleProductClick(product.id)}
                  style={{
                    padding: '15px',
                    border:
                      selectedProduct === product.id
                        ? '2px solid #4CAF50'
                        : '1px solid #ddd',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    background: 'white',
                    transition: 'all 0.2s',
                  }}
                >
                  <img
                    src={product.image}
                    alt={product.title}
                    style={{
                      width: '100%',
                      height: '150px',
                      objectFit: 'contain',
                      marginBottom: '10px',
                    }}
                  />
                  <h4
                    style={{
                      margin: '0 0 10px 0',
                      fontSize: '14px',
                      height: '40px',
                      overflow: 'hidden',
                    }}
                  >
                    {product.title}
                  </h4>
                  <div
                    style={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                    }}
                  >
                    <span style={{ fontWeight: 'bold', color: '#4CAF50' }}>
                      ${product.price}
                    </span>
                    <span style={{ fontSize: '12px', color: '#666' }}>
                      ‚≠ê {product.rating?.rate || 'N/A'}
                    </span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Product Details Panel */}
        {selectedProduct && (
          <div>
            <h3>Product Details</h3>
            <div
              style={{
                padding: '20px',
                border: '2px solid #ddd',
                borderRadius: '8px',
                background: 'white',
                position: 'sticky',
                top: '20px',
              }}
            >
              {detailsLoading ? (
                <div style={{ textAlign: 'center', padding: '40px' }}>
                  Loading details...
                </div>
              ) : productDetails ? (
                <div>
                  <img
                    src={productDetails.image}
                    alt={productDetails.title}
                    style={{
                      width: '100%',
                      height: '200px',
                      objectFit: 'contain',
                      marginBottom: '15px',
                    }}
                  />
                  <h4>{productDetails.title}</h4>
                  <p style={{ color: '#666', fontSize: '14px' }}>
                    {productDetails.description}
                  </p>
                  <div style={{ marginTop: '15px' }}>
                    <div
                      style={{
                        fontSize: '24px',
                        fontWeight: 'bold',
                        color: '#4CAF50',
                        marginBottom: '10px',
                      }}
                    >
                      ${productDetails.price}
                    </div>
                    <div style={{ fontSize: '14px', color: '#666' }}>
                      Category: {productDetails.category}
                    </div>
                    <div style={{ fontSize: '14px', color: '#666' }}>
                      Rating: ‚≠ê {productDetails.rating?.rate} (
                      {productDetails.rating?.count} reviews)
                    </div>
                  </div>
                  <button
                    onClick={() => setSelectedProduct(null)}
                    style={{
                      marginTop: '15px',
                      padding: '10px 20px',
                      background: '#2196F3',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      width: '100%',
                    }}
                  >
                    Close Details
                  </button>
                </div>
              ) : null}
            </div>
          </div>
        )}
      </div>

      {/* Technical Info */}
      <div
        style={{
          marginTop: '30px',
          padding: '20px',
          background: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        <h3>üîß Technical Implementation:</h3>
        <ul>
          <li>‚úÖ 4 independent useEffect hooks</li>
          <li>‚úÖ Each effect has AbortController</li>
          <li>‚úÖ Search debounced 500ms</li>
          <li>‚úÖ Category change clears search</li>
          <li>‚úÖ Parallel category + product fetches cancelled on change</li>
          <li>‚úÖ Product details fetch cancelled on new selection</li>
        </ul>
      </div>
    </div>
  );
}

export default ProductBrowser;
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * ProductBrowser - Level 3
 * E-commerce Product Browser v·ªõi:
 * - Fetch categories on mount
 * - Fetch products by category or search (debounced)
 * - Product details on click
 * - AbortController cho m·ªçi request
 * - Clear search khi ƒë·ªïi category
 */
function ProductBrowser() {
  const [categories, setCategories] = useState([]);
  const [categoriesLoading, setCategoriesLoading] = useState(true);

  const [selectedCategory, setSelectedCategory] = useState('all');
  const [products, setProducts] = useState([]);
  const [productsLoading, setProductsLoading] = useState(false);
  const [productsError, setProductsError] = useState(null);

  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');

  const [selectedProduct, setSelectedProduct] = useState(null);
  const [productDetails, setProductDetails] = useState(null);
  const [detailsLoading, setDetailsLoading] = useState(false);

  // Effect 1: Fetch categories once on mount
  useEffect(() => {
    const controller = new AbortController();

    async function fetchCategories() {
      try {
        const res = await fetch(`${API_BASE}/products/categories`, {
          signal: controller.signal,
        });
        if (!res.ok) throw new Error('Failed to fetch categories');
        const data = await res.json();
        setCategories(['all', ...data]);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Categories fetch failed:', err);
        }
      } finally {
        setCategoriesLoading(false);
      }
    }

    fetchCategories();

    return () => controller.abort();
  }, []);

  // Effect 2: Debounce search input
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(searchQuery.trim());
    }, 500);

    return () => clearTimeout(timer);
  }, [searchQuery]);

  // Effect 3: Fetch products (category ho·∫∑c search)
  useEffect(() => {
    const controller = new AbortController();

    async function fetchProducts() {
      setProductsLoading(true);
      setProductsError(null);
      setProducts([]);

      try {
        let url = `${API_BASE}/products`;
        let data;

        if (debouncedQuery) {
          // Search mode: l·∫•y t·∫•t c·∫£ r·ªìi filter client-side
          const res = await fetch(url, { signal: controller.signal });
          if (!res.ok) throw new Error('Failed to fetch products');
          data = await res.json();
          data = data.filter((p) =>
            p.title.toLowerCase().includes(debouncedQuery.toLowerCase()),
          );
        } else if (selectedCategory === 'all') {
          const res = await fetch(url, { signal: controller.signal });
          if (!res.ok) throw new Error('Failed to fetch products');
          data = await res.json();
        } else {
          const res = await fetch(
            `${API_BASE}/products/category/${selectedCategory}`,
            { signal: controller.signal },
          );
          if (!res.ok) throw new Error('Failed to fetch category products');
          data = await res.json();
        }

        setProducts(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setProductsError(err.message || 'Failed to load products');
        }
      } finally {
        setProductsLoading(false);
      }
    }

    fetchProducts();

    return () => controller.abort();
  }, [selectedCategory, debouncedQuery]);

  // Effect 4: Fetch product details khi ch·ªçn s·∫£n ph·∫©m
  useEffect(() => {
    if (!selectedProduct) {
      setProductDetails(null);
      setDetailsLoading(false);
      return;
    }

    const controller = new AbortController();

    async function fetchDetails() {
      setDetailsLoading(true);

      try {
        const res = await fetch(`${API_BASE}/products/${selectedProduct}`, {
          signal: controller.signal,
        });
        if (!res.ok) throw new Error('Failed to fetch product details');
        const data = await res.json();
        setProductDetails(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Product details error:', err);
        }
      } finally {
        setDetailsLoading(false);
      }
    }

    fetchDetails();

    return () => controller.abort();
  }, [selectedProduct]);

  const handleCategoryChange = (category) => {
    setSelectedCategory(category);
    setSearchQuery(''); // Clear search khi ƒë·ªïi category
    setSelectedProduct(null); // ƒê√≥ng chi ti·∫øt s·∫£n ph·∫©m
  };

  const handleProductClick = (productId) => {
    setSelectedProduct(productId);
  };

  return (
    <div style={{ maxWidth: '1400px', margin: '0 auto', padding: '20px' }}>
      <h2>üõí Product Browser</h2>

      {/* Filters */}
      <div style={{ display: 'flex', gap: '20px', marginBottom: '20px' }}>
        <div style={{ flex: 1 }}>
          <label
            style={{
              fontWeight: 'bold',
              display: 'block',
              marginBottom: '5px',
            }}
          >
            Category
          </label>
          {categoriesLoading ? (
            <div>Loading categories...</div>
          ) : (
            <select
              value={selectedCategory}
              onChange={(e) => handleCategoryChange(e.target.value)}
              style={{ width: '100%', padding: '8px' }}
            >
              {categories.map((cat) => (
                <option
                  key={cat}
                  value={cat}
                >
                  {cat.charAt(0).toUpperCase() + cat.slice(1)}
                </option>
              ))}
            </select>
          )}
        </div>

        <div style={{ flex: 2 }}>
          <label
            style={{
              fontWeight: 'bold',
              display: 'block',
              marginBottom: '5px',
            }}
          >
            Search
          </label>
          <input
            type='text'
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder='Search products...'
            style={{ width: '100%', padding: '8px' }}
          />
          {searchQuery && (
            <small style={{ color: '#666' }}>
              {debouncedQuery !== searchQuery
                ? 'Typing...'
                : `Searching "${debouncedQuery}"`}
            </small>
          )}
        </div>
      </div>

      {/* Main content */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: selectedProduct ? '2fr 1fr' : '1fr',
          gap: '20px',
        }}
      >
        {/* Products list */}
        <div>
          <h3>Products {products.length > 0 && `(${products.length})`}</h3>

          {productsLoading && (
            <div style={{ padding: '40px', textAlign: 'center' }}>
              Loading products...
            </div>
          )}

          {productsError && (
            <div style={{ color: 'red', padding: '20px' }}>
              Error: {productsError}
            </div>
          )}

          {!productsLoading && !productsError && products.length === 0 && (
            <div
              style={{ textAlign: 'center', color: '#999', padding: '40px' }}
            >
              No products found
            </div>
          )}

          {products.length > 0 && (
            <div
              style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
                gap: '15px',
              }}
            >
              {products.map((product) => (
                <div
                  key={product.id}
                  onClick={() => handleProductClick(product.id)}
                  style={{
                    border:
                      selectedProduct === product.id
                        ? '2px solid #4CAF50'
                        : '1px solid #ddd',
                    borderRadius: '8px',
                    padding: '12px',
                    cursor: 'pointer',
                    background: 'white',
                  }}
                >
                  <img
                    src={product.image}
                    alt={product.title}
                    style={{
                      width: '100%',
                      height: '140px',
                      objectFit: 'contain',
                      marginBottom: '10px',
                    }}
                  />
                  <h4
                    style={{
                      fontSize: '14px',
                      margin: '0 0 8px 0',
                      height: '40px',
                      overflow: 'hidden',
                    }}
                  >
                    {product.title}
                  </h4>
                  <div
                    style={{ display: 'flex', justifyContent: 'space-between' }}
                  >
                    <span style={{ fontWeight: 'bold', color: '#4CAF50' }}>
                      ${product.price}
                    </span>
                    <span>‚≠ê {product.rating?.rate || '?'}</span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Product details sidebar */}
        {selectedProduct && (
          <div>
            <h3>Product Details</h3>
            <div
              style={{
                position: 'sticky',
                top: '20px',
                padding: '20px',
                border: '1px solid #ddd',
                borderRadius: '8px',
                background: 'white',
              }}
            >
              {detailsLoading && (
                <div style={{ textAlign: 'center', padding: '60px 0' }}>
                  Loading details...
                </div>
              )}

              {productDetails && !detailsLoading && (
                <>
                  <img
                    src={productDetails.image}
                    alt={productDetails.title}
                    style={{
                      width: '100%',
                      height: '220px',
                      objectFit: 'contain',
                      marginBottom: '15px',
                    }}
                  />
                  <h4>{productDetails.title}</h4>
                  <p style={{ color: '#555', fontSize: '14px' }}>
                    {productDetails.description}
                  </p>
                  <div
                    style={{
                      margin: '15px 0',
                      fontSize: '22px',
                      fontWeight: 'bold',
                      color: '#4CAF50',
                    }}
                  >
                    ${productDetails.price}
                  </div>
                  <div style={{ color: '#666', fontSize: '14px' }}>
                    Category: {productDetails.category}
                    <br />
                    Rating: ‚≠ê {productDetails.rating?.rate} (
                    {productDetails.rating?.count} reviews)
                  </div>
                  <button
                    onClick={() => setSelectedProduct(null)}
                    style={{
                      marginTop: '20px',
                      width: '100%',
                      padding: '10px',
                      background: '#2196F3',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer',
                    }}
                  >
                    Close
                  </button>
                </>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- Load trang ‚Üí th·∫•y categories: all, electronics, jewelery, men's clothing, women's clothing
- Ch·ªçn "electronics" ‚Üí load ~5 s·∫£n ph·∫©m electronics
- G√µ nhanh "shirt" ‚Üí debounce 500ms ‚Üí ch·ªâ hi·ªÉn th·ªã s·∫£n ph·∫©m c√≥ "shirt" trong title
- Chuy·ªÉn sang category "jewelery" ‚Üí search b·ªã clear, load s·∫£n ph·∫©m jewelery
- Click v√†o m·ªôt s·∫£n ph·∫©m ‚Üí sidebar ph·∫£i hi·ªán chi ti·∫øt (h√¨nh, m√¥ t·∫£, gi√°, rating)
- Click s·∫£n ph·∫©m kh√°c nhanh ‚Üí request c≈© b·ªã abort, ch·ªâ hi·ªán chi ti·∫øt s·∫£n ph·∫©m m·ªõi nh·∫•t
- Console th·∫•y th√¥ng b√°o abort khi chuy·ªÉn category ho·∫∑c click s·∫£n ph·∫©m nhanh
*/
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê Level 4: Quy·∫øt ƒê·ªãnh Ki·∫øn Tr√∫c (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Social Media Feed v·ªõi Infinite Scroll & Real-time Updates
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Context:
 * X√¢y d·ª±ng social feed with:
 * - Initial posts load
 * - Infinite scroll (load more)
 * - Pull-to-refresh
 * - Real-time updates (polling)
 * - Cancel all on unmount
 *
 * APPROACH OPTIONS:
 *
 * APPROACH 1: Single effect, all logic together
 * Pros:
 * - One effect, one controller
 * Cons:
 * - Complex, hard to read
 * - Mixing concerns
 * - Difficult to test
 *
 * APPROACH 2: Separate effects per concern
 * Pros:
 * - Clear separation
 * - Easy to disable features
 * - Testable
 * Cons:
 * - Multiple controllers
 * - Coordination needed
 *
 * APPROACH 3: Custom hooks (not yet learned)
 *
 * üí≠ RECOMMENDATION: Approach 2
 *
 * ADR:
 * ---
 * # ADR: Social Feed Architecture
 *
 * ## Decision
 * Separate effects for:
 * 1. Initial load
 * 2. Infinite scroll
 * 3. Polling updates
 *
 * ## Rationale
 * - Each concern independent
 * - Can enable/disable features
 * - Clear abort strategy per feature
 * ---
 */

// üíª PHASE 2: Implementation (30 ph√∫t)

import { useState, useEffect, useRef } from 'react';

const POSTS_API = 'https://jsonplaceholder.typicode.com/posts';
const POSTS_PER_PAGE = 10;

function SocialFeed() {
  // Posts state
  const [posts, setPosts] = useState([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState(null);

  // Polling state
  const [polling, setPolling] = useState(true);
  const [newPostsCount, setNewPostsCount] = useState(0);

  // Refs
  const observerTarget = useRef(null);

  // Effect 1: Initial load
  useEffect(() => {
    const controller = new AbortController();

    async function loadInitialPosts() {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch(
          `${POSTS_API}?_page=1&_limit=${POSTS_PER_PAGE}`,
          { signal: controller.signal },
        );

        const data = await response.json();
        setPosts(data);
        setPage(1);
        setLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message);
          setLoading(false);
        }
      }
    }

    loadInitialPosts();

    return () => controller.abort();
  }, []); // Only on mount

  // Effect 2: Load more (infinite scroll)
  useEffect(() => {
    if (!hasMore || loading || loadingMore) return;

    const controller = new AbortController();

    async function loadMore() {
      try {
        setLoadingMore(true);

        const response = await fetch(
          `${POSTS_API}?_page=${page + 1}&_limit=${POSTS_PER_PAGE}`,
          { signal: controller.signal },
        );

        const data = await response.json();

        if (data.length === 0) {
          setHasMore(false);
        } else {
          setPosts((prev) => [...prev, ...data]);
          setPage((prev) => prev + 1);
        }

        setLoadingMore(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Load more error:', err);
          setLoadingMore(false);
        }
      }
    }

    // Intersection Observer for infinite scroll
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          loadMore();
        }
      },
      { threshold: 1.0 },
    );

    if (observerTarget.current) {
      observer.observe(observerTarget.current);
    }

    return () => {
      observer.disconnect();
      controller.abort();
    };
  }, [page, hasMore, loading, loadingMore]);

  // Effect 3: Polling for new posts
  useEffect(() => {
    if (!polling) return;

    const controller = new AbortController();

    const pollInterval = setInterval(async () => {
      try {
        // Check for new posts (simulate)
        const response = await fetch(`${POSTS_API}?_page=1&_limit=1`, {
          signal: controller.signal,
        });

        const data = await response.json();

        // Simulate new posts count (random)
        if (Math.random() > 0.7) {
          setNewPostsCount((prev) => prev + 1);
        }
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Polling error:', err);
        }
      }
    }, 5000); // Poll every 5 seconds

    return () => {
      clearInterval(pollInterval);
      controller.abort();
    };
  }, [polling]);

  const handleRefresh = () => {
    setPosts([]);
    setPage(1);
    setHasMore(true);
    setNewPostsCount(0);
    setLoading(true);
    // Trigger re-fetch (will use Effect 1)
  };

  const handleLoadNew = () => {
    setNewPostsCount(0);
    handleRefresh();
  };

  if (loading) {
    return (
      <div style={{ textAlign: 'center', padding: '40px' }}>
        <div style={{ fontSize: '48px' }}>üì±</div>
        <p>Loading feed...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div style={{ color: 'red', padding: '20px', textAlign: 'center' }}>
        Error: {error}
        <br />
        <button
          onClick={handleRefresh}
          style={{ marginTop: '10px' }}
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div style={{ maxWidth: '600px', margin: '0 auto', padding: '20px' }}>
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '20px',
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
          position: 'sticky',
          top: 0,
          zIndex: 10,
        }}
      >
        <h2 style={{ margin: 0 }}>üì± Social Feed</h2>

        <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
          <label style={{ fontSize: '14px' }}>
            <input
              type='checkbox'
              checked={polling}
              onChange={(e) => setPolling(e.target.checked)}
            />{' '}
            Polling
          </label>

          <button
            onClick={handleRefresh}
            style={{
              padding: '8px 16px',
              background: '#2196F3',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            üîÑ Refresh
          </button>
        </div>
      </div>

      {/* New Posts Banner */}
      {newPostsCount > 0 && (
        <div
          onClick={handleLoadNew}
          style={{
            padding: '15px',
            background: '#4CAF50',
            color: 'white',
            borderRadius: '8px',
            marginBottom: '20px',
            textAlign: 'center',
            cursor: 'pointer',
          }}
        >
          {newPostsCount} new post{newPostsCount > 1 ? 's' : ''} available.
          Click to load.
        </div>
      )}

      {/* Posts */}
      <div>
        {posts.map((post) => (
          <div
            key={post.id}
            style={{
              padding: '20px',
              border: '1px solid #ddd',
              borderRadius: '8px',
              marginBottom: '15px',
              background: 'white',
            }}
          >
            <h3 style={{ margin: '0 0 10px 0' }}>{post.title}</h3>
            <p style={{ margin: 0, color: '#666', fontSize: '14px' }}>
              {post.body}
            </p>
            <div
              style={{
                marginTop: '10px',
                fontSize: '12px',
                color: '#999',
                display: 'flex',
                gap: '15px',
              }}
            >
              <span>üëç {Math.floor(Math.random() * 100)}</span>
              <span>üí¨ {Math.floor(Math.random() * 20)}</span>
              <span>üîÑ {Math.floor(Math.random() * 10)}</span>
            </div>
          </div>
        ))}
      </div>

      {/* Load More Trigger */}
      {hasMore && (
        <div
          ref={observerTarget}
          style={{
            padding: '20px',
            textAlign: 'center',
            color: '#666',
          }}
        >
          {loadingMore ? (
            <div>
              <div style={{ fontSize: '24px' }}>‚è≥</div>
              <p>Loading more posts...</p>
            </div>
          ) : (
            <p>Scroll down to load more</p>
          )}
        </div>
      )}

      {!hasMore && (
        <div
          style={{
            padding: '20px',
            textAlign: 'center',
            color: '#999',
          }}
        >
          üéâ You've reached the end!
        </div>
      )}

      {/* Debug Info */}
      <div
        style={{
          marginTop: '30px',
          padding: '15px',
          background: '#f0f0f0',
          borderRadius: '8px',
          fontSize: '14px',
        }}
      >
        <h4>üìä Debug Info:</h4>
        <p>Current Page: {page}</p>
        <p>Posts Loaded: {posts.length}</p>
        <p>Has More: {hasMore ? 'Yes' : 'No'}</p>
        <p>Polling: {polling ? 'Active' : 'Inactive'}</p>
        <p>New Posts: {newPostsCount}</p>
      </div>
    </div>
  );
}

export default SocialFeed;

// üß™ PHASE 3: Testing (10 ph√∫t)
// - [ ] Initial posts load
// - [ ] Scroll to bottom ‚Üí Load more
// - [ ] New posts banner appears (polling)
// - [ ] Click banner ‚Üí Refresh feed
// - [ ] Toggle polling on/off
// - [ ] Refresh button works
// - [ ] Unmount ‚Üí All requests cancelled
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * SocialFeed - Level 4
 * Social Media Feed v·ªõi:
 * - Initial load + Infinite scroll (IntersectionObserver)
 * - Polling cho new posts (simulate)
 * - Pull-to-refresh style via button
 * - Separate AbortControllers cho t·ª´ng lo·∫°i request
 * - Cleanup ƒë√∫ng c√°ch khi unmount ho·∫∑c polling toggle
 */
const POSTS_API = 'https://jsonplaceholder.typicode.com/posts';
const POSTS_PER_PAGE = 10;

function SocialFeed() {
  const [posts, setPosts] = useState([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState(null);

  // Polling
  const [polling, setPolling] = useState(true);
  const [newPostsCount, setNewPostsCount] = useState(0);

  const observerTarget = useRef(null);

  // Effect 1: Initial load (ch·ªâ ch·∫°y 1 l·∫ßn khi mount)
  useEffect(() => {
    const controller = new AbortController();

    async function loadInitialPosts() {
      try {
        setLoading(true);
        setError(null);

        const res = await fetch(
          `${POSTS_API}?_page=1&_limit=${POSTS_PER_PAGE}`,
          { signal: controller.signal },
        );
        if (!res.ok) throw new Error('Failed to load initial posts');

        const data = await res.json();
        setPosts(data);
        setPage(1);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message || 'Failed to load feed');
        }
      } finally {
        setLoading(false);
      }
    }

    loadInitialPosts();

    return () => controller.abort();
  }, []);

  // Effect 2: Infinite scroll - load more khi scroll ƒë·∫øn target
  useEffect(() => {
    if (!hasMore || loading || loadingMore) return;

    const controller = new AbortController();

    async function loadMorePosts() {
      try {
        setLoadingMore(true);

        const res = await fetch(
          `${POSTS_API}?_page=${page + 1}&_limit=${POSTS_PER_PAGE}`,
          { signal: controller.signal },
        );
        if (!res.ok) throw new Error('Failed to load more posts');

        const data = await res.json();

        if (data.length === 0) {
          setHasMore(false);
        } else {
          setPosts((prev) => [...prev, ...data]);
          setPage((prev) => prev + 1);
        }
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Load more failed:', err);
        }
      } finally {
        setLoadingMore(false);
      }
    }

    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          loadMorePosts();
        }
      },
      { threshold: 0.1 },
    );

    if (observerTarget.current) {
      observer.observe(observerTarget.current);
    }

    return () => {
      observer.disconnect();
      controller.abort();
    };
  }, [page, hasMore, loading, loadingMore]);

  // Effect 3: Polling cho new posts (simulate new content)
  useEffect(() => {
    if (!polling) return;

    const controller = new AbortController();

    const interval = setInterval(async () => {
      try {
        // L·∫•y post m·ªõi nh·∫•t ƒë·ªÉ simulate
        const res = await fetch(`${POSTS_API}?_page=1&_limit=1`, {
          signal: controller.signal,
        });
        if (!res.ok) return;

        // Simulate vi·ªác c√≥ post m·ªõi (random 0-30% c∆° h·ªôi)
        if (Math.random() > 0.7) {
          setNewPostsCount((prev) => prev + Math.floor(Math.random() * 3) + 1);
        }
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Polling error:', err);
        }
      }
    }, 6000); // m·ªói ~6 gi√¢y

    return () => {
      clearInterval(interval);
      controller.abort();
    };
  }, [polling]);

  const handleRefresh = () => {
    setPosts([]);
    setPage(1);
    setHasMore(true);
    setNewPostsCount(0);
    setLoading(true);
    setError(null);
    // Effect 1 s·∫Ω kh√¥ng t·ª± ch·∫°y l·∫°i ‚Üí ta g·ªçi manual logic t∆∞∆°ng t·ª±
    // ·ªû ƒë√¢y ta reset state ƒë·ªÉ trigger l·∫°i initial load effect (nh∆∞ng v√¨ dep=[] n√™n kh√¥ng trigger)
    // C√°ch ƒë∆°n gi·∫£n: reload trang ho·∫∑c t√°ch h√†m fetch ra custom hook (nh∆∞ng gi·ªØ ƒë∆°n gi·∫£n)
    window.location.reload(); // t·∫°m th·ªùi d√πng reload ƒë·ªÉ ƒë∆°n gi·∫£n
  };

  const handleLoadNewPosts = () => {
    setNewPostsCount(0);
    handleRefresh();
  };

  if (loading) {
    return (
      <div style={{ textAlign: 'center', padding: '80px' }}>
        Loading feed...
      </div>
    );
  }

  if (error) {
    return (
      <div style={{ textAlign: 'center', color: 'red', padding: '40px' }}>
        <p>{error}</p>
        <button
          onClick={handleRefresh}
          style={{ padding: '8px 16px', marginTop: '12px' }}
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div style={{ maxWidth: '600px', margin: '0 auto', padding: '16px' }}>
      <div
        style={{
          position: 'sticky',
          top: 0,
          background: '#f8f9fa',
          padding: '12px 0',
          borderBottom: '1px solid #ddd',
          zIndex: 10,
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <h2 style={{ margin: 0 }}>Social Feed</h2>
        <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
          <label style={{ fontSize: '14px' }}>
            <input
              type='checkbox'
              checked={polling}
              onChange={(e) => setPolling(e.target.checked)}
            />{' '}
            Auto-refresh
          </label>
          <button
            onClick={handleRefresh}
            style={{
              padding: '6px 14px',
              background: '#0d6efd',
              color: 'white',
              border: 'none',
              borderRadius: '6px',
            }}
          >
            Refresh
          </button>
        </div>
      </div>

      {newPostsCount > 0 && (
        <div
          onClick={handleLoadNewPosts}
          style={{
            background: '#d4edda',
            color: '#155724',
            padding: '12px',
            borderRadius: '6px',
            margin: '16px 0',
            textAlign: 'center',
            cursor: 'pointer',
          }}
        >
          {newPostsCount} new post{newPostsCount > 1 ? 's' : ''} ‚Äî Click to load
        </div>
      )}

      {posts.map((post) => (
        <div
          key={post.id}
          style={{
            background: 'white',
            border: '1px solid #ddd',
            borderRadius: '8px',
            padding: '16px',
            marginBottom: '16px',
          }}
        >
          <h3 style={{ margin: '0 0 10px 0', fontSize: '18px' }}>
            {post.title}
          </h3>
          <p style={{ margin: 0, color: '#444', lineHeight: 1.5 }}>
            {post.body}
          </p>
          <div
            style={{
              marginTop: '12px',
              fontSize: '13px',
              color: '#777',
              display: 'flex',
              gap: '20px',
            }}
          >
            <span>‚ù§Ô∏è {Math.floor(Math.random() * 200) + 10}</span>
            <span>üí¨ {Math.floor(Math.random() * 40)}</span>
            <span>üîÅ {Math.floor(Math.random() * 25)}</span>
          </div>
        </div>
      ))}

      {hasMore && (
        <div
          ref={observerTarget}
          style={{
            padding: '32px 0',
            textAlign: 'center',
            color: '#666',
          }}
        >
          {loadingMore ? 'Loading more posts...' : 'Scroll down for more'}
        </div>
      )}

      {!hasMore && posts.length > 0 && (
        <div style={{ textAlign: 'center', padding: '40px 0', color: '#888' }}>
          üéâ You've reached the end of the feed
        </div>
      )}
    </div>
  );
}

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- M·ªü component ‚Üí load 10 post ƒë·∫ßu ti√™n
- Scroll xu·ªëng d∆∞·ªõi c√πng ‚Üí t·ª± ƒë·ªông load th√™m 10 post (page 2,3,...), loadingMore hi·ªán
- B·∫≠t polling ‚Üí kho·∫£ng 6-7 gi√¢y c√≥ th·ªÉ th·∫•y banner "X new posts" (simulate)
- Click banner ‚Üí refresh to√†n b·ªô feed v·ªÅ page 1
- T·∫Øt polling ‚Üí d·ª´ng interval
- Chuy·ªÉn tab ho·∫∑c unmount ‚Üí t·∫•t c·∫£ request b·ªã abort (kh√¥ng th·∫•y l·ªói trong console)
- Nhanh ch√≥ng scroll nhi·ªÅu l·∫ßn ‚Üí ch·ªâ request m·ªõi nh·∫•t ƒë∆∞·ª£c x·ª≠ l√Ω, c≈© b·ªã cancel
*/
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Level 5: Production Challenge (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Multi-Tab Analytics Dashboard v·ªõi Advanced Patterns
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 * Dashboard v·ªõi 4 tabs:
 * 1. Overview - Parallel fetch multiple stats
 * 2. Users - Table with pagination & search
 * 3. Posts - Dependent fetch (user ‚Üí posts)
 * 4. Activity - Real-time polling
 *
 * Requirements:
 * - Lazy load tab data (only fetch when tab clicked)
 * - Cache fetched data (don't refetch same tab)
 * - Cancel requests on tab switch
 * - Refresh button per tab
 * - Global abort on unmount
 * - Error recovery per tab
 *
 * üèóÔ∏è Architecture:
 * - TabContainer (manages active tab)
 * - Each tab component handles own fetching
 * - Shared cache in parent state
 * - AbortController per tab
 *
 * ‚úÖ Production Checklist:
 * - [ ] Lazy loading
 * - [ ] Caching strategy
 * - [ ] Request cancellation
 * - [ ] Error handling
 * - [ ] Loading states
 * - [ ] Refresh mechanism
 * - [ ] Memory cleanup
 */

// Due to length, providing architecture + starter code
// Student implements full solution

import { useState, useEffect } from 'react';

const API_BASE = 'https://jsonplaceholder.typicode.com';

// Tab configuration
const TABS = {
  overview: { id: 'overview', label: 'üìä Overview', icon: 'üìä' },
  users: { id: 'users', label: 'üë• Users', icon: 'üë•' },
  posts: { id: 'posts', label: 'üìù Posts', icon: 'üìù' },
  activity: { id: 'activity', label: '‚ö° Activity', icon: '‚ö°' },
};

function MultiTabDashboard() {
  const [activeTab, setActiveTab] = useState('overview');
  const [cache, setCache] = useState({
    overview: null,
    users: null,
    posts: null,
    activity: null,
  });
  const [loadedTabs, setLoadedTabs] = useState(new Set());

  const handleTabChange = (tabId) => {
    setActiveTab(tabId);
    // Mark tab as needing load if not cached
    if (!loadedTabs.has(tabId)) {
      setLoadedTabs((prev) => new Set([...prev, tabId]));
    }
  };

  const handleRefreshTab = (tabId) => {
    // Clear cache for this tab
    setCache((prev) => ({ ...prev, [tabId]: null }));
    // Trigger reload
    setLoadedTabs((prev) => {
      const newSet = new Set(prev);
      newSet.delete(tabId);
      newSet.add(tabId);
      return newSet;
    });
  };

  return (
    <div style={{ maxWidth: '1400px', margin: '0 auto', padding: '20px' }}>
      <h1>üéØ Multi-Tab Analytics Dashboard</h1>

      {/* Tab Navigation */}
      <div
        style={{
          display: 'flex',
          gap: '10px',
          marginBottom: '20px',
          borderBottom: '2px solid #ddd',
          paddingBottom: '10px',
        }}
      >
        {Object.values(TABS).map((tab) => (
          <button
            key={tab.id}
            onClick={() => handleTabChange(tab.id)}
            style={{
              padding: '10px 20px',
              background: activeTab === tab.id ? '#4CAF50' : 'white',
              color: activeTab === tab.id ? 'white' : '#333',
              border: '2px solid',
              borderColor: activeTab === tab.id ? '#4CAF50' : '#ddd',
              borderRadius: '8px 8px 0 0',
              cursor: 'pointer',
              fontSize: '16px',
              fontWeight: activeTab === tab.id ? 'bold' : 'normal',
            }}
          >
            {tab.icon} {tab.label}
          </button>
        ))}
      </div>

      {/* Tab Content */}
      <div>
        {activeTab === 'overview' && (
          <OverviewTab
            cache={cache.overview}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, overview: data }))
            }
            onRefresh={() => handleRefreshTab('overview')}
            shouldLoad={loadedTabs.has('overview')}
          />
        )}

        {activeTab === 'users' && (
          <UsersTab
            cache={cache.users}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, users: data }))
            }
            onRefresh={() => handleRefreshTab('users')}
            shouldLoad={loadedTabs.has('users')}
          />
        )}

        {activeTab === 'posts' && (
          <PostsTab
            cache={cache.posts}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, posts: data }))
            }
            onRefresh={() => handleRefreshTab('posts')}
            shouldLoad={loadedTabs.has('posts')}
          />
        )}

        {activeTab === 'activity' && (
          <ActivityTab
            cache={cache.activity}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, activity: data }))
            }
            onRefresh={() => handleRefreshTab('activity')}
            shouldLoad={loadedTabs.has('activity')}
          />
        )}
      </div>

      {/* Implementation Guide */}
      <div
        style={{
          marginTop: '40px',
          padding: '20px',
          background: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        <h3>üîß Implementation Guide:</h3>

        <h4>Tab Components to Implement:</h4>

        <p>
          <strong>1. OverviewTab:</strong>
        </p>
        <ul>
          <li>Parallel fetch: users count, posts count, comments count</li>
          <li>Promise.allSettled for independent failures</li>
          <li>Display in stat cards</li>
        </ul>

        <p>
          <strong>2. UsersTab:</strong>
        </p>
        <ul>
          <li>Fetch users with pagination</li>
          <li>Search functionality (debounced)</li>
          <li>Table display</li>
        </ul>

        <p>
          <strong>3. PostsTab:</strong>
        </p>
        <ul>
          <li>Select user dropdown</li>
          <li>Fetch posts for selected user (dependent)</li>
          <li>AbortController for both requests</li>
        </ul>

        <p>
          <strong>4. ActivityTab:</strong>
        </p>
        <ul>
          <li>Polling latest activity (every 10s)</li>
          <li>Display activity feed</li>
          <li>Toggle polling on/off</li>
        </ul>

        <h4>‚úÖ Required Features:</h4>
        <ul>
          <li>[ ] Lazy loading (don't fetch until tab clicked)</li>
          <li>[ ] Caching (use cached data if available)</li>
          <li>[ ] Refresh button per tab (clear cache, refetch)</li>
          <li>[ ] AbortController per tab (cancel on tab switch)</li>
          <li>[ ] Loading states per tab</li>
          <li>[ ] Error handling per tab</li>
          <li>[ ] Clean unmount (abort all)</li>
        </ul>
      </div>
    </div>
  );
}

// TODO: Implement tab components
function OverviewTab({ cache, onDataLoad, onRefresh, shouldLoad }) {
  // TODO: Implement
  return <div>Overview Tab - To be implemented</div>;
}

function UsersTab({ cache, onDataLoad, onRefresh, shouldLoad }) {
  // TODO: Implement
  return <div>Users Tab - To be implemented</div>;
}

function PostsTab({ cache, onDataLoad, onRefresh, shouldLoad }) {
  // TODO: Implement
  return <div>Posts Tab - To be implemented</div>;
}

function ActivityTab({ cache, onDataLoad, onRefresh, shouldLoad }) {
  // TODO: Implement
  return <div>Activity Tab - To be implemented</div>;
}

export default MultiTabDashboard;
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * MultiTabDashboard - Level 5 Production Challenge
 * Multi-tab analytics dashboard v·ªõi:
 * - Lazy loading (ch·ªâ fetch khi tab ƒë∆∞·ª£c ch·ªçn l·∫ßn ƒë·∫ßu)
 * - Caching (gi·ªØ data ƒë√£ fetch)
 * - Refresh per tab (clear cache + refetch)
 * - AbortController per tab + global cleanup
 * - Independent loading/error states per tab
 */
const API_BASE = 'https://jsonplaceholder.typicode.com';

function MultiTabDashboard() {
  const [activeTab, setActiveTab] = useState('overview');

  // Cache + loading + error states
  const [cache, setCache] = useState({
    overview: null,
    users: null,
    posts: null,
    activity: null,
  });

  const [loadingStates, setLoadingStates] = useState({
    overview: false,
    users: false,
    posts: false,
    activity: false,
  });

  const [errorStates, setErrorStates] = useState({
    overview: null,
    users: null,
    posts: null,
    activity: null,
  });

  const [loadedTabs, setLoadedTabs] = useState(new Set());

  // Abort controllers map (ƒë·ªÉ cancel khi switch tab ho·∫∑c unmount)
  const abortControllers = useRef(new Map());

  const loadTabData = useCallback(
    (tabId) => {
      // ƒê√£ load r·ªìi ‚Üí d√πng cache
      if (loadedTabs.has(tabId) && cache[tabId]) {
        return;
      }

      // Cleanup controller c≈© n·∫øu c√≥
      if (abortControllers.current.has(tabId)) {
        abortControllers.current.get(tabId).abort();
        abortControllers.current.delete(tabId);
      }

      const controller = new AbortController();
      abortControllers.current.set(tabId, controller);

      setLoadingStates((prev) => ({ ...prev, [tabId]: true }));
      setErrorStates((prev) => ({ ...prev, [tabId]: null }));

      switch (tabId) {
        case 'overview':
          // Parallel fetch stats
          Promise.allSettled([
            fetch(`${API_BASE}/users`, { signal: controller.signal }).then(
              (r) => r.json(),
            ),
            fetch(`${API_BASE}/posts`, { signal: controller.signal }).then(
              (r) => r.json(),
            ),
            fetch(`${API_BASE}/comments`, { signal: controller.signal }).then(
              (r) => r.json(),
            ),
          ])
            .then((results) => {
              const [usersRes, postsRes, commentsRes] = results;
              const data = {
                usersCount:
                  usersRes.status === 'fulfilled'
                    ? usersRes.value.length
                    : 'Error',
                postsCount:
                  postsRes.status === 'fulfilled'
                    ? postsRes.value.length
                    : 'Error',
                commentsCount:
                  commentsRes.status === 'fulfilled'
                    ? commentsRes.value.length
                    : 'Error',
              };
              setCache((prev) => ({ ...prev, overview: data }));
              setLoadedTabs((prev) => new Set([...prev, tabId]));
            })
            .catch((err) => {
              if (err.name !== 'AbortError') {
                setErrorStates((prev) => ({
                  ...prev,
                  overview: 'Failed to load overview',
                }));
              }
            })
            .finally(() => {
              setLoadingStates((prev) => ({ ...prev, overview: false }));
              abortControllers.current.delete(tabId);
            });
          break;

        case 'users':
          fetch(`${API_BASE}/users`, { signal: controller.signal })
            .then((res) => {
              if (!res.ok) throw new Error('Failed');
              return res.json();
            })
            .then((data) => {
              setCache((prev) => ({ ...prev, users: data }));
              setLoadedTabs((prev) => new Set([...prev, tabId]));
            })
            .catch((err) => {
              if (err.name !== 'AbortError') {
                setErrorStates((prev) => ({ ...prev, users: err.message }));
              }
            })
            .finally(() => {
              setLoadingStates((prev) => ({ ...prev, users: false }));
              abortControllers.current.delete(tabId);
            });
          break;

        case 'posts':
          // Gi·∫£ l·∫≠p: load users tr∆∞·ªõc, r·ªìi posts (dependent)
          fetch(`${API_BASE}/users`, { signal: controller.signal })
            .then((res) => res.json())
            .then((users) => {
              if (controller.signal.aborted) return;
              // Ch·ªçn random user ƒë·ªÉ demo dependent
              const randomUser =
                users[Math.floor(Math.random() * users.length)];
              return fetch(`${API_BASE}/posts?userId=${randomUser.id}`, {
                signal: controller.signal,
              }).then((res) => res.json());
            })
            .then((posts) => {
              setCache((prev) => ({ ...prev, posts }));
              setLoadedTabs((prev) => new Set([...prev, tabId]));
            })
            .catch((err) => {
              if (err.name !== 'AbortError') {
                setErrorStates((prev) => ({
                  ...prev,
                  posts: 'Failed to load posts',
                }));
              }
            })
            .finally(() => {
              setLoadingStates((prev) => ({ ...prev, posts: false }));
              abortControllers.current.delete(tabId);
            });
          break;

        case 'activity':
          // Simulate activity feed + polling
          const interval = setInterval(() => {
            if (controller.signal.aborted) {
              clearInterval(interval);
              return;
            }
            // Simulate new activity
            setCache((prev) => ({
              ...prev,
              activity: prev.activity
                ? [
                    ...prev.activity,
                    {
                      id: Date.now(),
                      text: `New activity at ${new Date().toLocaleTimeString()}`,
                    },
                  ]
                : [{ id: Date.now(), text: 'Activity feed started' }],
            }));
          }, 4000);

          setCache((prev) => ({
            ...prev,
            activity: [
              { id: 1, text: 'Dashboard activity monitoring started' },
            ],
          }));
          setLoadedTabs((prev) => new Set([...prev, tabId]));

          return () => {
            clearInterval(interval);
            controller.abort();
            abortControllers.current.delete(tabId);
          };
      }
    },
    [cache, loadedTabs],
  );

  // Trigger load khi activeTab thay ƒë·ªïi
  useEffect(() => {
    loadTabData(activeTab);

    // Cleanup t·∫•t c·∫£ controllers khi unmount dashboard
    return () => {
      abortControllers.current.forEach((ctrl) => ctrl.abort());
      abortControllers.current.clear();
    };
  }, [activeTab, loadTabData]);

  const handleRefreshTab = (tabId) => {
    setCache((prev) => ({ ...prev, [tabId]: null }));
    setErrorStates((prev) => ({ ...prev, [tabId]: null }));
    setLoadedTabs((prev) => {
      const newSet = new Set(prev);
      newSet.delete(tabId);
      return newSet;
    });
    // Trigger reload ngay
    loadTabData(tabId);
  };

  const TABS = [
    { id: 'overview', label: 'Overview', icon: 'üìä' },
    { id: 'users', label: 'Users', icon: 'üë•' },
    { id: 'posts', label: 'Posts', icon: 'üìù' },
    { id: 'activity', label: 'Activity', icon: '‚ö°' },
  ];

  return (
    <div style={{ maxWidth: '1400px', margin: '0 auto', padding: '20px' }}>
      <h1>Multi-Tab Analytics Dashboard</h1>

      {/* Tab Navigation */}
      <div
        style={{
          display: 'flex',
          gap: '8px',
          marginBottom: '24px',
          borderBottom: '2px solid #eee',
        }}
      >
        {TABS.map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            style={{
              padding: '12px 24px',
              background: activeTab === tab.id ? '#4CAF50' : '#f8f9fa',
              color: activeTab === tab.id ? 'white' : '#333',
              border: 'none',
              borderRadius: '8px 8px 0 0',
              fontWeight: activeTab === tab.id ? 'bold' : 'normal',
              cursor: 'pointer',
            }}
          >
            {tab.icon} {tab.label}
          </button>
        ))}
      </div>

      {/* Tab Content */}
      <div
        style={{
          minHeight: '400px',
          background: 'white',
          padding: '24px',
          borderRadius: '8px',
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        }}
      >
        {activeTab === 'overview' && (
          <div>
            <h2>Overview Stats</h2>
            {loadingStates.overview && <p>Loading dashboard stats...</p>}
            {errorStates.overview && (
              <p style={{ color: 'red' }}>{errorStates.overview}</p>
            )}
            {cache.overview && (
              <div
                style={{
                  display: 'grid',
                  gridTemplateColumns: 'repeat(auto-fit, minmax(220px, 1fr))',
                  gap: '16px',
                }}
              >
                <div
                  style={{
                    padding: '16px',
                    background: '#e3f2fd',
                    borderRadius: '8px',
                  }}
                >
                  <h3>Users</h3>
                  <p style={{ fontSize: '32px', margin: '8px 0' }}>
                    {cache.overview.usersCount}
                  </p>
                </div>
                <div
                  style={{
                    padding: '16px',
                    background: '#e8f5e9',
                    borderRadius: '8px',
                  }}
                >
                  <h3>Posts</h3>
                  <p style={{ fontSize: '32px', margin: '8px 0' }}>
                    {cache.overview.postsCount}
                  </p>
                </div>
                <div
                  style={{
                    padding: '16px',
                    background: '#fff3e0',
                    borderRadius: '8px',
                  }}
                >
                  <h3>Comments</h3>
                  <p style={{ fontSize: '32px', margin: '8px 0' }}>
                    {cache.overview.commentsCount}
                  </p>
                </div>
              </div>
            )}
            <button
              onClick={() => handleRefreshTab('overview')}
              style={{ marginTop: '16px' }}
            >
              Refresh Overview
            </button>
          </div>
        )}

        {activeTab === 'users' && (
          <div>
            <h2>Users List</h2>
            {loadingStates.users && <p>Loading users...</p>}
            {errorStates.users && (
              <p style={{ color: 'red' }}>{errorStates.users}</p>
            )}
            {cache.users && (
              <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                <thead>
                  <tr style={{ background: '#f5f5f5' }}>
                    <th style={{ padding: '12px', textAlign: 'left' }}>ID</th>
                    <th style={{ padding: '12px', textAlign: 'left' }}>Name</th>
                    <th style={{ padding: '12px', textAlign: 'left' }}>
                      Email
                    </th>
                  </tr>
                </thead>
                <tbody>
                  {cache.users.slice(0, 8).map((user) => (
                    <tr
                      key={user.id}
                      style={{ borderBottom: '1px solid #eee' }}
                    >
                      <td style={{ padding: '12px' }}>{user.id}</td>
                      <td style={{ padding: '12px' }}>{user.name}</td>
                      <td style={{ padding: '12px' }}>{user.email}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
            <button
              onClick={() => handleRefreshTab('users')}
              style={{ marginTop: '16px' }}
            >
              Refresh Users
            </button>
          </div>
        )}

        {activeTab === 'posts' && (
          <div>
            <h2>Sample Posts (Random User)</h2>
            {loadingStates.posts && <p>Loading posts...</p>}
            {errorStates.posts && (
              <p style={{ color: 'red' }}>{errorStates.posts}</p>
            )}
            {cache.posts && (
              <div>
                {cache.posts.slice(0, 6).map((post) => (
                  <div
                    key={post.id}
                    style={{
                      marginBottom: '16px',
                      padding: '12px',
                      border: '1px solid #eee',
                      borderRadius: '6px',
                    }}
                  >
                    <h4 style={{ margin: '0 0 8px 0' }}>{post.title}</h4>
                    <p style={{ margin: 0, color: '#555' }}>
                      {post.body.substring(0, 120)}...
                    </p>
                  </div>
                ))}
              </div>
            )}
            <button
              onClick={() => handleRefreshTab('posts')}
              style={{ marginTop: '16px' }}
            >
              Refresh Posts
            </button>
          </div>
        )}

        {activeTab === 'activity' && (
          <div>
            <h2>Recent Activity</h2>
            {cache.activity ? (
              <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
                {cache.activity.map((item) => (
                  <div
                    key={item.id}
                    style={{
                      padding: '12px',
                      borderBottom: '1px solid #eee',
                      background:
                        item.id === cache.activity[0]?.id
                          ? '#e8f5e9'
                          : 'transparent',
                    }}
                  >
                    {item.text}
                  </div>
                ))}
              </div>
            ) : (
              <p>Activity monitoring starting...</p>
            )}
            <button
              onClick={() => handleRefreshTab('activity')}
              style={{ marginTop: '16px' }}
            >
              Restart Activity Feed
            </button>
          </div>
        )}
      </div>
    </div>
  );
}

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- M·ªü dashboard ‚Üí tab Overview t·ª± ƒë·ªông load ‚Üí th·∫•y 3 s·ªë li·ªáu parallel (users ~10, posts ~100, comments ~500)
- Chuy·ªÉn sang Users ‚Üí load danh s√°ch users l·∫ßn ƒë·∫ßu
- Chuy·ªÉn nhanh qua l·∫°i gi·ªØa c√°c tab ‚Üí request c≈© b·ªã abort, ch·ªâ tab hi·ªán t·∫°i ho√†n th√†nh
- Nh·∫•n Refresh tr√™n tab b·∫•t k·ª≥ ‚Üí clear cache + fetch l·∫°i
- Tab Activity ‚Üí t·ª± append item m·ªõi m·ªói ~4 gi√¢y (simulate polling)
- ƒê√≥ng component ho·∫∑c chuy·ªÉn tab nhanh ‚Üí kh√¥ng c√≤n request treo, console s·∫°ch (kh√¥ng l·ªói ngo√†i AbortError)
- M·ªü l·∫°i tab ƒë√£ load ‚Üí d√πng cache ngay l·∫≠p t·ª©c (nhanh, kh√¥ng loading)
*/
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh: Cancellation Strategies

| Strategy            | Code                                                                           | Pros                                      | Cons                                              | Use Case          |
| ------------------- | ------------------------------------------------------------------------------ | ----------------------------------------- | ------------------------------------------------- | ----------------- |
| **Ignore Outdated** | `let isLatest = true;`<br>`return () => { isLatest = false; }`                 | ‚úÖ Simple<br>‚úÖ Works everywhere          | ‚ùå Requests still complete<br>‚ùå Wastes bandwidth | Non-fetch async   |
| **AbortController** | `const ctrl = new AbortController();`<br>`fetch(url, { signal: ctrl.signal })` | ‚úÖ Actually cancels<br>‚úÖ Saves bandwidth | ‚ùå Only for fetch<br>‚ùå Slightly complex          | fetch requests    |
| **Promise Racing**  | `Promise.race([fetch(), timeout()])`                                           | ‚úÖ Timeout control                        | ‚ùå Doesn't cancel<br>‚ùå Complex                   | Timeout scenarios |

### B·∫£ng So S√°nh: Sequential vs Parallel

| Aspect             | Sequential                   | Parallel                 |
| ------------------ | ---------------------------- | ------------------------ |
| **Pattern**        | `await A; await B; await C;` | `Promise.all([A, B, C])` |
| **Timing**         | A ‚Üí B ‚Üí C (cumulative)       | A, B, C (simultaneous)   |
| **Speed**          | ~1500ms (500+500+500)        | ~500ms (max of all)      |
| **Dependencies**   | B depends on A result        | All independent          |
| **Error Handling** | try/catch per request        | Promise.allSettled       |
| **Use When**       | B needs data from A          | All independent data     |

### Decision Tree: Request Strategy

```
C·∫ßn fetch data?
‚îÇ
‚îú‚îÄ Request B depends on data from Request A?
‚îÇ  ‚Üí SEQUENTIAL (await A, then B)
‚îÇ  ‚Üí useEffect deps: [dataA]
‚îÇ  ‚Üí Example: Fetch user ‚Üí Fetch user's posts
‚îÇ
‚îú‚îÄ Multiple INDEPENDENT requests?
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ All must succeed?
‚îÇ  ‚îÇ  ‚Üí Promise.all() - fails if any fails
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Independent failures OK?
‚îÇ     ‚Üí Promise.allSettled() - continues despite failures
‚îÇ     ‚Üí Example: Dashboard stats (show what loaded)
‚îÇ
‚îú‚îÄ User might change input quickly?
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ Each keystroke triggers fetch?
‚îÇ  ‚îÇ  ‚Üí Debounce + AbortController
‚îÇ  ‚îÇ  ‚Üí Example: Search autocomplete
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Each selection triggers fetch?
‚îÇ     ‚Üí AbortController only
‚îÇ     ‚Üí Example: Dropdown filter
‚îÇ
‚îî‚îÄ Long-running request?
   ‚Üí AbortController + timeout
   ‚Üí Example: Large file upload
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug #1: Race Condition - Wrong Data Displayed üèéÔ∏è

```jsx
/**
 * üêõ BUG: User sees wrong user's data
 * üéØ Nhi·ªám v·ª•: Identify and fix race condition
 */

function BuggyUserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // ‚ùå NO CANCELLATION!
    async function fetchUser() {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      setUser(data); // ‚Üê N√†o request v·ªÅ tr∆∞·ªõc?
    }

    fetchUser();
  }, [userId]);

  return <div>{user?.name}</div>;
}

// ü§î SCENARIO:
// t=0ms:   userId=1 ‚Üí Request R1 fires (takes 500ms)
// t=100ms: userId=2 ‚Üí Request R2 fires (takes 200ms)
// t=300ms: R2 returns ‚Üí setUser(user2) ‚Üí Display "User 2" ‚úÖ
// t=500ms: R1 returns ‚Üí setUser(user1) ‚Üí Display "User 1" ‚ùå WRONG!

// USER SEES: User 1 (but userId prop = 2!)

// ‚úÖ FIX: AbortController
function Fixed({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    async function fetchUser() {
      try {
        const response = await fetch(`/api/users/${userId}`, {
          signal: controller.signal,
        });
        const data = await response.json();
        setUser(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(err);
        }
      }
    }

    fetchUser();

    return () => controller.abort();
  }, [userId]);

  // FIXED TIMELINE:
  // t=0ms:   userId=1 ‚Üí R1 fires
  // t=100ms: userId=2 ‚Üí R1 ABORTED, R2 fires
  // t=300ms: R2 returns ‚Üí Display "User 2" ‚úÖ CORRECT!
  // t=500ms: R1 aborted (no update)

  return <div>{user?.name}</div>;
}

// üéì B√ÄI H·ªåC:
// - Race conditions = wrong data displayed
// - AbortController prevents stale updates
// - Always cancel old requests
```

---

### Bug #2: Promise.all() Single Failure üí•

```jsx
/**
 * üêõ BUG: One failed request breaks entire dashboard
 * üéØ Nhi·ªám v·ª•: Fix with Promise.allSettled
 */

function BuggyDashboard() {
  const [stats, setStats] = useState(null);

  useEffect(() => {
    async function fetchStats() {
      // ‚ùå Promise.all fails if ANY request fails
      const [users, posts, comments] = await Promise.all([
        fetch('/api/users').then((r) => r.json()),
        fetch('/api/posts').then((r) => r.json()),
        fetch('/api/comments').then((r) => r.json()), // ‚Üê THIS FAILS!
      ]);

      setStats({ users, posts, comments });
    }

    fetchStats().catch((err) => {
      console.error('Failed to load dashboard:', err);
      // User sees NOTHING, even though users & posts succeeded
    });
  }, []);

  // ...
}

// ü§î PROBLEM:
// - /api/comments returns 500
// - Promise.all() rejects entirely
// - setStats never called
// - User sees error, no data at all
// - ‚ùå Users and Posts data is lost!

// ‚úÖ FIX: Promise.allSettled
function Fixed() {
  const [stats, setStats] = useState({
    users: null,
    posts: null,
    comments: null,
  });

  useEffect(() => {
    async function fetchStats() {
      const results = await Promise.allSettled([
        fetch('/api/users').then((r) => r.json()),
        fetch('/api/posts').then((r) => r.json()),
        fetch('/api/comments').then((r) => r.json()),
      ]);

      const [usersResult, postsResult, commentsResult] = results;

      setStats({
        users: usersResult.status === 'fulfilled' ? usersResult.value : null,
        posts: postsResult.status === 'fulfilled' ? postsResult.value : null,
        comments:
          commentsResult.status === 'fulfilled' ? commentsResult.value : null,
      });
    }

    fetchStats();
  }, []);

  // RESULT:
  // - Users: ‚úÖ Loaded
  // - Posts: ‚úÖ Loaded
  // - Comments: ‚ùå Failed (but others still show!)
  // ‚Üí Partial success! Better UX!

  // ...
}

// üéì B√ÄI H·ªåC:
// - Promise.all() = all-or-nothing
// - Promise.allSettled() = graceful degradation
// - Show what worked, indicate what failed
```

---

### Bug #3: Forgotten Cleanup ‚Üí Memory Leak üíß

```jsx
/**
 * üêõ BUG: Polling continues after unmount
 * üéØ Nhi·ªám v·ª•: Add cleanup
 */

function BuggyLiveStats() {
  const [stats, setStats] = useState(null);

  useEffect(() => {
    // ‚ùå No cleanup for interval!
    const intervalId = setInterval(async () => {
      const response = await fetch('/api/stats');
      const data = await response.json();
      setStats(data); // ‚Üê Continues after unmount!
    }, 5000);

    // ‚ùå Missing return!
  }, []);

  // ...
}

// ü§î PROBLEM:
// - Component mounts ‚Üí Interval starts
// - Component unmounts ‚Üí Interval KEEPS RUNNING
// - setStats called on unmounted component ‚Üí Warning
// - Memory leak (interval never cleared)

// ‚úÖ FIX: Cleanup interval
function Fixed() {
  const [stats, setStats] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    const intervalId = setInterval(async () => {
      try {
        const response = await fetch('/api/stats', {
          signal: controller.signal,
        });
        const data = await response.json();
        setStats(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(err);
        }
      }
    }, 5000);

    return () => {
      clearInterval(intervalId); // ‚úÖ Clear interval
      controller.abort(); // ‚úÖ Abort in-flight request
    };
  }, []);

  // FIXED:
  // - Unmount ‚Üí Cleanup runs
  // - Interval cleared ‚úÖ
  // - Pending request aborted ‚úÖ
  // - No memory leak ‚úÖ

  // ...
}

// üéì B√ÄI H·ªåC:
// - Polling/intervals ALWAYS need cleanup
// - Cleanup both interval AND pending requests
// - Test unmount behavior
```

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

- [ ] T√¥i hi·ªÉu race conditions v√† t·∫°i sao x·∫£y ra
- [ ] T√¥i bi·∫øt s·ª≠ d·ª•ng AbortController
- [ ] T√¥i ph√¢n bi·ªát ƒë∆∞·ª£c sequential vs parallel
- [ ] T√¥i bi·∫øt khi n√†o d√πng Promise.all vs Promise.allSettled
- [ ] T√¥i c√≥ th·ªÉ implement dependent requests
- [ ] T√¥i handle ƒë∆∞·ª£c stale data issues
- [ ] T√¥i cleanup ƒë∆∞·ª£c all requests properly

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**B√†i 1: GitHub Repos Browser v·ªõi Abort**

- Search organizations
- Fetch repos for selected org
- Cancel old searches
- AbortController cho both

**B√†i 2: Weather + Forecast (Dependent)**

- Fetch current weather by city
- Fetch 5-day forecast (depends on city coords)
- Sequential fetching
- Error handling per step

---

### N√¢ng cao (60 ph√∫t)

**B√†i 3: Reddit Clone Feed**

- Infinite scroll
- Real-time score updates (polling)
- Filter by subreddit
- Abort all on filter change

**B√†i 4: Multi-Currency Converter**

- Parallel fetch multiple exchange rates
- Promise.allSettled
- Show partial data
- Refresh individual rates

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

1. **AbortController MDN**
   - https://developer.mozilla.org/en-US/docs/Web/API/AbortController

2. **Promise.allSettled**
   - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### ƒê√£ h·ªçc:

- Ng√†y 18: Cleanup
- Ng√†y 19: Basic fetching

### H∆∞·ªõng t·ªõi:

- Ng√†y 21: useRef
- Ng√†y 24: Custom hooks (useAbortableFetch)

---

**üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh Ng√†y 20!**

B·∫°n ƒë√£ master:

- ‚úÖ Race conditions
- ‚úÖ AbortController
- ‚úÖ Dependent requests
- ‚úÖ Parallel optimization
- ‚úÖ Production-ready patterns

**Phase 2 ho√†n th√†nh! Ng√†y mai: useRef fundamentals! üöÄ**
