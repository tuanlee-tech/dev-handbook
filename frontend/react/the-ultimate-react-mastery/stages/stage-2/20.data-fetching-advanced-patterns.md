# üìÖ NG√ÄY 20: Data Fetching - Advanced Patterns

## üìç Phase 2, Tu·∫ßn 4, Ng√†y 20 c·ªßa 45

## ‚è±Ô∏è Th·ªùi l∆∞·ª£ng: 3-4 gi·ªù

---

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

- [ ] Gi·∫£i quy·∫øt **Race Conditions** trong data fetching
- [ ] S·ª≠ d·ª•ng **AbortController** ƒë·ªÉ cancel requests
- [ ] Implement **Dependent Requests** (sequential fetching)
- [ ] Optimize **Parallel Requests** cho multiple endpoints
- [ ] Handle **Stale Data** v√† request deduplication

---

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu, h√£y tr·∫£ l·ªùi 3 c√¢u h·ªèi sau:

1. **C√¢u 1:** N·∫øu fetch request ƒëang pending m√† component unmount, c·∫ßn l√†m g√¨?
   - _ƒê√°p √°n: Cleanup v·ªõi isCancelled flag ho·∫∑c AbortController (ƒë√£ h·ªçc Ng√†y 18-19)_

2. **C√¢u 2:** User typing nhanh "abc" ‚Üí 3 fetch requests. Request n√†o n√™n ƒë∆∞·ª£c d√πng?
   - _ƒê√°p √°n: Request cu·ªëi c√πng ("abc"), cancel 2 requests tr∆∞·ªõc_

3. **C√¢u 3:** Fetch user details ‚Üí C·∫ßn userId. Fetch user posts ‚Üí C·∫ßn userId. L√†m sao fetch hi·ªáu qu·∫£?
   - _ƒê√°p √°n: Ch∆∞a bi·∫øt! (H√¥m nay h·ªçc parallel vs sequential)_

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø: Race Conditions

**Scenario:** User search v·ªõi auto-complete

```jsx
function UserSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    // ‚ùå PROBLEM: Race condition!
    async function search() {
      const response = await fetch(`/api/search?q=${query}`);
      const data = await response.json();
      setResults(data); // ‚Üê N√†o request v·ªÅ tr∆∞·ªõc?
    }

    if (query) search();
  }, [query]);

  // User types: "r" ‚Üí "re" ‚Üí "rea" ‚Üí "reac" ‚Üí "react"
  // 5 requests fire: Q1, Q2, Q3, Q4, Q5
  // Response order: Q1(100ms), Q3(150ms), Q2(200ms), Q5(250ms), Q4(300ms)
  // ‚ùå Final results: Q4 ("reac") - WRONG! Should be Q5 ("react")
}
```

**V·∫•n ƒë·ªÅ:**

- Multiple requests in-flight c√πng l√∫c
- Response order KH√îNG ƒë·∫£m b·∫£o = request order
- Slow request c√≥ th·ªÉ overwrite fast request
- User sees stale/wrong data

**Real-world impact:**

- Search shows outdated results
- Profile page shows wrong user
- Dashboard displays mixed data
- Confusion v√† poor UX

---

### 1.2 Gi·∫£i Ph√°p: Request Cancellation & Tracking

**Solution 1: Ignore Outdated Responses**

```jsx
function UserSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    let isLatest = true; // ‚Üê Track if this is latest request

    async function search() {
      const response = await fetch(`/api/search?q=${query}`);
      const data = await response.json();

      // ‚úÖ Only update if this is still the latest request
      if (isLatest) {
        setResults(data);
      } else {
        console.log('üö´ Ignoring outdated response for:', query);
      }
    }

    if (query) search();

    // Cleanup: Mark this request as outdated
    return () => {
      isLatest = false;
    };
  }, [query]);
}
```

**Solution 2: Cancel In-Flight Requests (AbortController)**

```jsx
function UserSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  useEffect(() => {
    const controller = new AbortController();

    async function search() {
      try {
        const response = await fetch(`/api/search?q=${query}`, {
          signal: controller.signal, // ‚Üê Pass abort signal
        });
        const data = await response.json();
        setResults(data);
      } catch (err) {
        if (err.name === 'AbortError') {
          console.log('üö´ Request cancelled for:', query);
        } else {
          console.error('Error:', err);
        }
      }
    }

    if (query) search();

    // Cleanup: Abort in-flight request
    return () => {
      controller.abort();
    };
  }, [query]);
}
```

---

### 1.3 Mental Model: Request Lifecycle v·ªõi Cancellation

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         RACE CONDITION & CANCELLATION TIMELINE               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

USER TYPES: "r" ‚Üí "re" ‚Üí "rea"
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

WITHOUT CANCELLATION:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

t=0ms:   Type "r"   ‚Üí Request R1 fires
t=100ms: Type "re"  ‚Üí Request R2 fires (R1 still pending)
t=200ms: Type "rea" ‚Üí Request R3 fires (R1, R2 still pending)
t=250ms: R1 returns ‚Üí setResults([...]) ‚úÖ
t=300ms: R3 returns ‚Üí setResults([...]) ‚úÖ (Latest data)
t=400ms: R2 returns ‚Üí setResults([...]) ‚ùå (Overwrites R3!)

FINAL RESULT: Shows "re" results (WRONG!)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

WITH IGNORE OUTDATED:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

t=0ms:   Type "r"   ‚Üí Request R1, isLatest=true
t=100ms: Type "re"  ‚Üí Cleanup R1 (isLatest=false), Request R2
t=200ms: Type "rea" ‚Üí Cleanup R2 (isLatest=false), Request R3
t=250ms: R1 returns ‚Üí isLatest=false ‚Üí IGNORE ‚úÖ
t=300ms: R3 returns ‚Üí isLatest=true ‚Üí UPDATE ‚úÖ
t=400ms: R2 returns ‚Üí isLatest=false ‚Üí IGNORE ‚úÖ

FINAL RESULT: Shows "rea" results (CORRECT!)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

WITH ABORTCONTROLLER:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

t=0ms:   Type "r"   ‚Üí Request R1, controller C1
t=100ms: Type "re"  ‚Üí Abort C1, Request R2, controller C2
t=200ms: Type "rea" ‚Üí Abort C2, Request R3, controller C3
t=250ms: R1 aborted ‚Üí Cancelled (no response)
t=300ms: R3 returns ‚Üí UPDATE ‚úÖ
t=400ms: R2 aborted ‚Üí Cancelled (no response)

FINAL RESULT: Shows "rea" results (CORRECT!)
BONUS: R1 v√† R2 actually cancelled ‚Üí Less network traffic!

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

KEY DIFFERENCES:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Ignore Outdated:
‚úÖ Simple to implement
‚úÖ Works with any async operation
‚ùå Requests still complete (waste bandwidth)
‚ùå Server still processes (waste resources)

AbortController:
‚úÖ Actually cancels requests (saves bandwidth)
‚úÖ Server can detect abort (save resources)
‚úÖ Cleaner (no lingering promises)
‚ùå Only works with fetch (not all async)
‚ùå Slightly more complex
```

---

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

#### ‚ùå Hi·ªÉu l·∫ßm #1: "AbortController cancel c·∫£ Promise"

```jsx
// ‚ùå WRONG: Abort kh√¥ng cancel non-fetch promises
useEffect(() => {
  const controller = new AbortController();

  async function doWork() {
    // ‚ùå setTimeout KH√îNG b·ªã abort!
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // This still runs sau abort
    console.log('This will still execute');
  }

  doWork();

  return () => {
    controller.abort(); // Kh√¥ng effect g√¨!
  };
}, []);

// ‚úÖ CORRECT: Abort ch·ªâ cho fetch
useEffect(() => {
  const controller = new AbortController();

  async function doWork() {
    // ‚úÖ fetch C√ì TH·ªÇ b·ªã abort
    await fetch('/api/data', { signal: controller.signal });
  }

  doWork();

  return () => {
    controller.abort(); // ‚úÖ Cancels fetch
  };
}, []);
```

---

#### ‚ùå Hi·ªÉu l·∫ßm #2: "Dependencies thay ƒë·ªïi ‚Üí Old request auto-cancelled"

```jsx
// ‚ùå WRONG ASSUMPTION
function UserDetail({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // ‚ùå NO! Old fetch still continues!
    fetch(`/api/users/${userId}`)
      .then((res) => res.json())
      .then(setUser);
  }, [userId]);
}

// userId: 1 ‚Üí 2 ‚Üí 3
// Request 1 fires
// Request 2 fires (Request 1 still going!)
// Request 3 fires (Requests 1, 2 still going!)
// All 3 complete ‚Üí setUser called 3 times
// ‚ùå Race condition!

// ‚úÖ CORRECT: Manual cancellation
function UserDetail({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    fetch(`/api/users/${userId}`, { signal: controller.signal })
      .then((res) => res.json())
      .then(setUser)
      .catch((err) => {
        if (err.name !== 'AbortError') throw err;
      });

    return () => controller.abort(); // ‚úÖ Cancel old
  }, [userId]);
}
```

---

#### ‚ùå Hi·ªÉu l·∫ßm #3: "Parallel requests = Promise.all() lu√¥n lu√¥n"

```jsx
// ‚ùå WRONG: Promise.all fails n·∫øu 1 request fails
async function fetchDashboard() {
  const [users, posts, comments] = await Promise.all([
    fetch('/api/users'),
    fetch('/api/posts'),
    fetch('/api/comments'), // ‚Üê N·∫øu fail ‚Üí ALL fail!
  ]);
}

// ‚úÖ BETTER: Promise.allSettled() - handle failures gracefully
async function fetchDashboard() {
  const results = await Promise.allSettled([
    fetch('/api/users').then((r) => r.json()),
    fetch('/api/posts').then((r) => r.json()),
    fetch('/api/comments').then((r) => r.json()),
  ]);

  results.forEach((result, i) => {
    if (result.status === 'fulfilled') {
      console.log(`Request ${i} success:`, result.value);
    } else {
      console.error(`Request ${i} failed:`, result.reason);
    }
  });
}
```

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: AbortController Basic ‚≠ê

```jsx
/**
 * Demo: Cancel fetch requests v·ªõi AbortController
 * Concepts: abort signal, cleanup, error handling
 */

import { useState, useEffect } from 'react';

function AbortControllerDemo() {
  const [userId, setUserId] = useState(1);
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [requestLog, setRequestLog] = useState([]);

  useEffect(() => {
    // Create AbortController for this effect run
    const controller = new AbortController();
    const requestId = `User ${userId} @ ${Date.now()}`;

    console.log(`üöÄ Starting request: ${requestId}`);
    setRequestLog((prev) => [...prev, { id: requestId, status: 'pending' }]);

    setLoading(true);
    setError(null);

    async function fetchUser() {
      try {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/users/${userId}`,
          {
            signal: controller.signal, // ‚Üê Pass abort signal
          },
        );

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();

        console.log(`‚úÖ Completed request: ${requestId}`);
        setRequestLog((prev) =>
          prev.map((req) =>
            req.id === requestId ? { ...req, status: 'completed' } : req,
          ),
        );

        setUser(data);
        setLoading(false);
      } catch (err) {
        if (err.name === 'AbortError') {
          console.log(`üö´ Aborted request: ${requestId}`);
          setRequestLog((prev) =>
            prev.map((req) =>
              req.id === requestId ? { ...req, status: 'aborted' } : req,
            ),
          );
        } else {
          console.error(`‚ùå Failed request: ${requestId}`, err);
          setRequestLog((prev) =>
            prev.map((req) =>
              req.id === requestId ? { ...req, status: 'failed' } : req,
            ),
          );
          setError(err.message);
          setLoading(false);
        }
      }
    }

    fetchUser();

    // Cleanup: Abort request if effect re-runs or unmounts
    return () => {
      console.log(`üßπ Cleanup: Aborting ${requestId}`);
      controller.abort();
    };
  }, [userId]);

  const handleQuickSwitch = () => {
    // Rapidly change userId to demonstrate abortion
    setUserId(1);
    setTimeout(() => setUserId(2), 100);
    setTimeout(() => setUserId(3), 200);
    setTimeout(() => setUserId(4), 300);
  };

  return (
    <div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}>
      <h2>AbortController Demo</h2>

      {/* User Selection */}
      <div style={{ marginBottom: '20px' }}>
        <label>Select User: </label>
        <select
          value={userId}
          onChange={(e) => setUserId(Number(e.target.value))}
          style={{ padding: '8px', marginRight: '10px' }}
        >
          {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((id) => (
            <option
              key={id}
              value={id}
            >
              User {id}
            </option>
          ))}
        </select>

        <button
          onClick={handleQuickSwitch}
          style={{
            padding: '8px 16px',
            background: '#ff9800',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          üöÄ Quick Switch Test
        </button>
      </div>

      {/* User Display */}
      <div
        style={{
          padding: '20px',
          border: '2px solid #ddd',
          borderRadius: '8px',
          background: 'white',
          minHeight: '150px',
        }}
      >
        {loading && (
          <div style={{ textAlign: 'center', padding: '40px' }}>
            <div style={{ fontSize: '32px' }}>‚è≥</div>
            <p>Loading user {userId}...</p>
          </div>
        )}

        {error && (
          <div style={{ color: 'red', textAlign: 'center', padding: '40px' }}>
            <div style={{ fontSize: '32px' }}>‚ùå</div>
            <p>Error: {error}</p>
          </div>
        )}

        {!loading && !error && user && (
          <div>
            <h3>{user.name}</h3>
            <p>
              <strong>Email:</strong> {user.email}
            </p>
            <p>
              <strong>Phone:</strong> {user.phone}
            </p>
            <p>
              <strong>Website:</strong> {user.website}
            </p>
          </div>
        )}
      </div>

      {/* Request Log */}
      <div style={{ marginTop: '30px' }}>
        <h3>üìã Request Log (Last 10):</h3>
        <div
          style={{
            background: '#f5f5f5',
            padding: '15px',
            borderRadius: '4px',
            maxHeight: '200px',
            overflowY: 'auto',
          }}
        >
          {requestLog
            .slice(-10)
            .reverse()
            .map((req, i) => (
              <div
                key={i}
                style={{
                  padding: '8px',
                  marginBottom: '5px',
                  background: 'white',
                  borderRadius: '4px',
                  borderLeft: `4px solid ${
                    req.status === 'completed'
                      ? '#4CAF50'
                      : req.status === 'aborted'
                        ? '#ff9800'
                        : req.status === 'failed'
                          ? '#f44336'
                          : '#2196F3'
                  }`,
                }}
              >
                <span style={{ marginRight: '10px' }}>
                  {req.status === 'completed'
                    ? '‚úÖ'
                    : req.status === 'aborted'
                      ? 'üö´'
                      : req.status === 'failed'
                        ? '‚ùå'
                        : '‚è≥'}
                </span>
                <span>{req.id}</span>
                <span
                  style={{
                    marginLeft: '10px',
                    fontSize: '12px',
                    color: '#666',
                  }}
                >
                  ({req.status})
                </span>
              </div>
            ))}
        </div>
      </div>

      {/* Instructions */}
      <div
        style={{
          marginTop: '30px',
          padding: '20px',
          background: '#e3f2fd',
          borderRadius: '8px',
        }}
      >
        <h3>üß™ Test Scenarios:</h3>
        <ol>
          <li>
            <strong>Normal fetch:</strong> Select different users slowly
            <br />‚Üí Each request completes ‚úÖ
          </li>
          <li>
            <strong>Quick switching:</strong> Change users rapidly
            <br />‚Üí Old requests aborted üö´, only latest completes ‚úÖ
          </li>
          <li>
            <strong>Quick Switch button:</strong> Click button
            <br />
            ‚Üí Fires 4 requests in 300ms
            <br />‚Üí First 3 aborted, only last one completes
          </li>
        </ol>

        <h3>üí° Key Observations:</h3>
        <ul>
          <li>‚úÖ AbortController created PER effect run</li>
          <li>‚úÖ Cleanup aborts old request BEFORE new request starts</li>
          <li>‚úÖ AbortError caught separately (kh√¥ng display error UI)</li>
          <li>‚úÖ Request log shows lifecycle clearly</li>
        </ul>
      </div>
    </div>
  );
}

export default AbortControllerDemo;
```

---

### Demo 2: Dependent Requests (Sequential) ‚≠ê‚≠ê

```jsx
/**
 * Demo: Sequential data fetching - request B depends on request A
 * Use case: Fetch user ‚Üí Fetch user's posts
 */

import { useState, useEffect } from 'react';

const USERS_API = 'https://jsonplaceholder.typicode.com/users';
const POSTS_API = 'https://jsonplaceholder.typicode.com/posts';

function DependentRequestsDemo() {
  const [userId, setUserId] = useState(1);

  // User data
  const [user, setUser] = useState(null);
  const [userLoading, setUserLoading] = useState(true);
  const [userError, setUserError] = useState(null);

  // Posts data
  const [posts, setPosts] = useState([]);
  const [postsLoading, setPostsLoading] = useState(false);
  const [postsError, setPostsError] = useState(null);

  // Step 1: Fetch User
  useEffect(() => {
    const controller = new AbortController();

    async function fetchUser() {
      try {
        console.log(`üì• Step 1: Fetching user ${userId}...`);
        setUserLoading(true);
        setUserError(null);

        const response = await fetch(`${USERS_API}/${userId}`, {
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error('User not found');
        }

        const data = await response.json();
        console.log(`‚úÖ Step 1 Complete: User loaded`);

        setUser(data);
        setUserLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(`‚ùå Step 1 Failed:`, err);
          setUserError(err.message);
          setUserLoading(false);
        }
      }
    }

    fetchUser();

    return () => controller.abort();
  }, [userId]);

  // Step 2: Fetch Posts (depends on user)
  useEffect(() => {
    // ‚ö†Ô∏è Don't fetch if no user or user still loading
    if (!user || userLoading) return;

    const controller = new AbortController();

    async function fetchPosts() {
      try {
        console.log(`üì• Step 2: Fetching posts for user ${user.id}...`);
        setPostsLoading(true);
        setPostsError(null);

        const response = await fetch(`${POSTS_API}?userId=${user.id}`, {
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error('Failed to fetch posts');
        }

        const data = await response.json();
        console.log(`‚úÖ Step 2 Complete: ${data.length} posts loaded`);

        setPosts(data);
        setPostsLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(`‚ùå Step 2 Failed:`, err);
          setPostsError(err.message);
          setPostsLoading(false);
        }
      }
    }

    fetchPosts();

    return () => controller.abort();
  }, [user, userLoading]); // ‚Üê Dependencies: user data

  return (
    <div style={{ maxWidth: '1000px', margin: '0 auto', padding: '20px' }}>
      <h2>Dependent Requests Demo</h2>

      {/* User Selection */}
      <div style={{ marginBottom: '20px' }}>
        <label>Select User: </label>
        <select
          value={userId}
          onChange={(e) => setUserId(Number(e.target.value))}
          style={{ padding: '8px' }}
        >
          {[1, 2, 3, 4, 5].map((id) => (
            <option
              key={id}
              value={id}
            >
              User {id}
            </option>
          ))}
        </select>
      </div>

      {/* Request Flow Visualization */}
      <div
        style={{
          padding: '20px',
          background: '#f5f5f5',
          borderRadius: '8px',
          marginBottom: '20px',
        }}
      >
        <h3>üîÑ Request Flow:</h3>
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          {/* Step 1 */}
          <div
            style={{
              padding: '15px',
              background: userLoading
                ? '#2196F3'
                : userError
                  ? '#f44336'
                  : '#4CAF50',
              color: 'white',
              borderRadius: '8px',
              flex: 1,
              textAlign: 'center',
            }}
          >
            <div style={{ fontSize: '24px', marginBottom: '5px' }}>
              {userLoading ? '‚è≥' : userError ? '‚ùå' : '‚úÖ'}
            </div>
            <div>Step 1: Fetch User</div>
            <div style={{ fontSize: '12px', marginTop: '5px' }}>
              {userLoading ? 'Loading...' : userError ? 'Failed' : 'Complete'}
            </div>
          </div>

          <div style={{ fontSize: '24px' }}>‚Üí</div>

          {/* Step 2 */}
          <div
            style={{
              padding: '15px',
              background: !user
                ? '#ccc'
                : postsLoading
                  ? '#2196F3'
                  : postsError
                    ? '#f44336'
                    : '#4CAF50',
              color: 'white',
              borderRadius: '8px',
              flex: 1,
              textAlign: 'center',
            }}
          >
            <div style={{ fontSize: '24px', marginBottom: '5px' }}>
              {!user ? '‚è∏Ô∏è' : postsLoading ? '‚è≥' : postsError ? '‚ùå' : '‚úÖ'}
            </div>
            <div>Step 2: Fetch Posts</div>
            <div style={{ fontSize: '12px', marginTop: '5px' }}>
              {!user
                ? 'Waiting...'
                : postsLoading
                  ? 'Loading...'
                  : postsError
                    ? 'Failed'
                    : 'Complete'}
            </div>
          </div>
        </div>
      </div>

      {/* Content Grid */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: '1fr 2fr',
          gap: '20px',
        }}
      >
        {/* User Panel */}
        <div>
          <h3>üë§ User Details</h3>
          <div
            style={{
              padding: '15px',
              border: '2px solid #ddd',
              borderRadius: '8px',
              background: 'white',
              minHeight: '150px',
            }}
          >
            {userLoading && <div>Loading user...</div>}
            {userError && (
              <div style={{ color: 'red' }}>Error: {userError}</div>
            )}
            {user && !userLoading && (
              <div>
                <h4>{user.name}</h4>
                <p style={{ fontSize: '14px', color: '#666' }}>
                  üìß {user.email}
                </p>
                <p style={{ fontSize: '14px', color: '#666' }}>
                  üè¢ {user.company.name}
                </p>
              </div>
            )}
          </div>
        </div>

        {/* Posts Panel */}
        <div>
          <h3>üìù User Posts ({posts.length})</h3>
          <div
            style={{
              padding: '15px',
              border: '2px solid #ddd',
              borderRadius: '8px',
              background: 'white',
              minHeight: '150px',
              maxHeight: '400px',
              overflowY: 'auto',
            }}
          >
            {!user && (
              <div
                style={{ textAlign: 'center', padding: '40px', color: '#999' }}
              >
                Select a user to view posts
              </div>
            )}

            {user && postsLoading && (
              <div style={{ textAlign: 'center', padding: '40px' }}>
                Loading posts...
              </div>
            )}

            {user && postsError && (
              <div style={{ color: 'red' }}>Error: {postsError}</div>
            )}

            {user && !postsLoading && !postsError && (
              <div style={{ display: 'grid', gap: '10px' }}>
                {posts.map((post) => (
                  <div
                    key={post.id}
                    style={{
                      padding: '10px',
                      border: '1px solid #eee',
                      borderRadius: '4px',
                      background: '#f9f9f9',
                    }}
                  >
                    <h5 style={{ margin: '0 0 5px 0' }}>{post.title}</h5>
                    <p style={{ margin: 0, fontSize: '13px', color: '#666' }}>
                      {post.body.substring(0, 80)}...
                    </p>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Technical Explanation */}
      <div
        style={{
          marginTop: '30px',
          padding: '20px',
          background: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        <h3>üîë Key Patterns:</h3>

        <h4>1. Sequential Execution:</h4>
        <pre
          style={{
            background: 'white',
            padding: '10px',
            borderRadius: '4px',
            overflow: 'auto',
          }}
        >
          {`// Effect 1: Fetch user
useEffect(() => {
  fetchUser(userId);
}, [userId]);

// Effect 2: Fetch posts (waits for user)
useEffect(() => {
  if (!user || userLoading) return; // ‚Üê Guard clause
  fetchPosts(user.id);
}, [user, userLoading]); // ‚Üê Depends on user`}
        </pre>

        <h4>2. Guard Clauses:</h4>
        <ul>
          <li>
            <code>if (!user) return;</code> - Don't fetch if dependency not
            ready
          </li>
          <li>
            <code>if (userLoading) return;</code> - Wait for first request to
            complete
          </li>
        </ul>

        <h4>3. Benefits:</h4>
        <ul>
          <li>‚úÖ Clear separation of concerns</li>
          <li>‚úÖ Each effect handles 1 data source</li>
          <li>‚úÖ Automatic refetch when dependencies change</li>
          <li>‚úÖ Independent error handling</li>
        </ul>
      </div>
    </div>
  );
}

export default DependentRequestsDemo;
```

---

### Demo 3: Parallel Requests Optimization ‚≠ê‚≠ê‚≠ê

```jsx
/**
 * Demo: Parallel data fetching - multiple independent requests
 * Use case: Dashboard with multiple data sources
 */

import { useState, useEffect } from 'react';

const API_BASE = 'https://jsonplaceholder.typicode.com';

function ParallelRequestsDemo() {
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // Individual states for each data source
  const [stats, setStats] = useState({
    users: { data: null, loading: true, error: null },
    posts: { data: null, loading: true, error: null },
    comments: { data: null, loading: true, error: null },
  });

  // Timing metrics
  const [metrics, setMetrics] = useState({
    startTime: null,
    endTime: null,
    duration: null,
  });

  useEffect(() => {
    const startTime = Date.now();
    setMetrics({ startTime, endTime: null, duration: null });

    console.log('üöÄ Starting parallel requests...');

    // Create abort controllers for each request
    const controllers = {
      users: new AbortController(),
      posts: new AbortController(),
      comments: new AbortController(),
    };

    // Fetch function for each endpoint
    async function fetchData(endpoint, key, controller) {
      try {
        console.log(`üì• Fetching ${key}...`);

        setStats((prev) => ({
          ...prev,
          [key]: { ...prev[key], loading: true, error: null },
        }));

        const response = await fetch(`${API_BASE}/${endpoint}`, {
          signal: controller.signal,
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        console.log(`‚úÖ ${key} loaded: ${data.length} items`);

        setStats((prev) => ({
          ...prev,
          [key]: { data, loading: false, error: null },
        }));

        return { key, success: true, count: data.length };
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(`‚ùå ${key} failed:`, err);

          setStats((prev) => ({
            ...prev,
            [key]: { data: null, loading: false, error: err.message },
          }));

          return { key, success: false, error: err.message };
        }
        return { key, success: false, aborted: true };
      }
    }

    // Fire all requests in parallel
    Promise.allSettled([
      fetchData('users', 'users', controllers.users),
      fetchData('posts', 'posts', controllers.posts),
      fetchData('comments', 'comments', controllers.comments),
    ]).then((results) => {
      const endTime = Date.now();
      const duration = endTime - startTime;

      setMetrics({ startTime, endTime, duration });

      console.log('üèÅ All requests completed');
      console.log('‚è±Ô∏è Total time:', duration, 'ms');

      results.forEach((result, i) => {
        if (result.status === 'fulfilled' && result.value.success) {
          console.log(`  ‚úÖ ${result.value.key}: ${result.value.count} items`);
        } else if (result.status === 'fulfilled' && result.value.aborted) {
          console.log(`  üö´ ${result.value.key}: Aborted`);
        } else {
          console.log(`  ‚ùå ${result.value?.key || 'Unknown'}: Failed`);
        }
      });
    });

    // Cleanup: Abort all requests
    return () => {
      console.log('üßπ Cleanup: Aborting all requests');
      Object.values(controllers).forEach((ctrl) => ctrl.abort());
    };
  }, [refreshTrigger]);

  const handleRefresh = () => {
    setRefreshTrigger((prev) => prev + 1);
  };

  // Check overall status
  const allLoaded = Object.values(stats).every((s) => !s.loading);
  const anyError = Object.values(stats).some((s) => s.error);
  const allSuccess = Object.values(stats).every((s) => s.data && !s.error);

  return (
    <div style={{ maxWidth: '1200px', margin: '0 auto', padding: '20px' }}>
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '20px',
        }}
      >
        <h2>Parallel Requests Demo</h2>

        <button
          onClick={handleRefresh}
          disabled={!allLoaded}
          style={{
            padding: '10px 20px',
            background: allLoaded ? '#4CAF50' : '#ccc',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: allLoaded ? 'pointer' : 'not-allowed',
            fontSize: '16px',
          }}
        >
          üîÑ Refresh All
        </button>
      </div>

      {/* Performance Metrics */}
      <div
        style={{
          padding: '20px',
          background: allSuccess ? '#d4edda' : anyError ? '#fff3cd' : '#cfe2ff',
          border: `2px solid ${allSuccess ? '#4CAF50' : anyError ? '#ffc107' : '#2196F3'}`,
          borderRadius: '8px',
          marginBottom: '20px',
        }}
      >
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
          }}
        >
          <div>
            <strong>Status:</strong>{' '}
            {!allLoaded
              ? '‚è≥ Loading...'
              : allSuccess
                ? '‚úÖ All loaded successfully'
                : '‚ö†Ô∏è Some requests failed'}
          </div>

          {metrics.duration && (
            <div>
              <strong>Total Time:</strong> {metrics.duration}ms
            </div>
          )}
        </div>

        {allLoaded && (
          <div style={{ marginTop: '10px', fontSize: '14px', color: '#666' }}>
            üí° Parallel fetching completed in {metrics.duration}ms (vs ~
            {Object.keys(stats).length * 500}ms if sequential)
          </div>
        )}
      </div>

      {/* Stats Cards */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
          gap: '20px',
          marginBottom: '30px',
        }}
      >
        {Object.entries(stats).map(([key, state]) => (
          <StatCard
            key={key}
            title={key.charAt(0).toUpperCase() + key.slice(1)}
            data={state.data}
            loading={state.loading}
            error={state.error}
            icon={key === 'users' ? 'üë•' : key === 'posts' ? 'üìù' : 'üí¨'}
          />
        ))}
      </div>

      {/* Comparison: Sequential vs Parallel */}
      <div
        style={{
          padding: '20px',
          background: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        <h3>üìä Sequential vs Parallel Comparison:</h3>

        <div
          style={{
            display: 'grid',
            gridTemplateColumns: '1fr 1fr',
            gap: '20px',
            marginTop: '15px',
          }}
        >
          {/* Sequential */}
          <div
            style={{
              padding: '15px',
              background: 'white',
              borderRadius: '4px',
              border: '2px solid #f44336',
            }}
          >
            <h4 style={{ marginTop: 0 }}>‚ùå Sequential (Bad)</h4>
            <pre
              style={{
                fontSize: '12px',
                background: '#f9f9f9',
                padding: '10px',
                borderRadius: '4px',
              }}
            >
              {`useEffect(() => {
  // Request 1
  const users = await fetch('/users');
  setUsers(users);
  
  // Request 2 (waits for 1)
  const posts = await fetch('/posts');
  setPosts(posts);
  
  // Request 3 (waits for 2)
  const comments = await fetch('/comments');
  setComments(comments);
}, []);

// Total time: ~1500ms
// (500ms + 500ms + 500ms)`}
            </pre>
          </div>

          {/* Parallel */}
          <div
            style={{
              padding: '15px',
              background: 'white',
              borderRadius: '4px',
              border: '2px solid #4CAF50',
            }}
          >
            <h4 style={{ marginTop: 0 }}>‚úÖ Parallel (Good)</h4>
            <pre
              style={{
                fontSize: '12px',
                background: '#f9f9f9',
                padding: '10px',
                borderRadius: '4px',
              }}
            >
              {`useEffect(() => {
  Promise.allSettled([
    fetch('/users'),
    fetch('/posts'),
    fetch('/comments')
  ]).then(results => {
    // Process results
  });
}, []);

// Total time: ~500ms
// (all fire simultaneously!)
// 3x faster! üöÄ`}
            </pre>
          </div>
        </div>

        <div style={{ marginTop: '20px' }}>
          <h4>‚úÖ Benefits of Parallel Fetching:</h4>
          <ul>
            <li>
              <strong>Performance:</strong> Requests fire simultaneously ‚Üí
              Faster overall
            </li>
            <li>
              <strong>Independence:</strong> One failure doesn't block others
              (Promise.allSettled)
            </li>
            <li>
              <strong>Progressive display:</strong> Show data as it arrives
            </li>
            <li>
              <strong>Better UX:</strong> User sees content loading
              progressively
            </li>
          </ul>

          <h4>‚ö†Ô∏è When NOT to use Parallel:</h4>
          <ul>
            <li>Request B depends on data from Request A (use sequential)</li>
            <li>Server rate limits (may need to throttle)</li>
            <li>Requests must complete in specific order</li>
          </ul>
        </div>
      </div>
    </div>
  );
}

// Reusable StatCard component
function StatCard({ title, data, loading, error, icon }) {
  if (loading) {
    return (
      <div
        style={{
          padding: '20px',
          background: '#f5f5f5',
          borderRadius: '8px',
          textAlign: 'center',
          border: '2px solid #2196F3',
        }}
      >
        <div style={{ fontSize: '32px', marginBottom: '10px' }}>‚è≥</div>
        <div>Loading {title.toLowerCase()}...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div
        style={{
          padding: '20px',
          background: '#fff0f0',
          borderRadius: '8px',
          textAlign: 'center',
          border: '2px solid #f44336',
        }}
      >
        <div style={{ fontSize: '32px', marginBottom: '10px' }}>‚ùå</div>
        <div style={{ color: '#f44336', marginBottom: '10px' }}>{error}</div>
      </div>
    );
  }

  return (
    <div
      style={{
        padding: '20px',
        background: 'white',
        borderRadius: '8px',
        textAlign: 'center',
        border: '2px solid #4CAF50',
      }}
    >
      <div style={{ fontSize: '32px', marginBottom: '10px' }}>{icon}</div>
      <div style={{ fontSize: '14px', color: '#666', marginBottom: '5px' }}>
        {title}
      </div>
      <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#4CAF50' }}>
        {Array.isArray(data) ? data.length : data}
      </div>
    </div>
  );
}

export default ParallelRequestsDemo;
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Level 1: √Åp D·ª•ng Concept (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Implement AbortController cho search
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: Libraries, custom hooks
 *
 * Requirements:
 * 1. Search input v·ªõi auto-complete
 * 2. Fetch results khi user types
 * 3. Cancel old requests khi query thay ƒë·ªïi
 * 4. Handle AbortError properly
 *
 * API: https://jsonplaceholder.typicode.com/users?name_like={query}
 *
 * üí° G·ª£i √Ω:
 * - AbortController per effect
 * - Cleanup aborts controller
 * - Catch AbortError separately
 */

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
function SearchWithAbort() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!query || query.length < 2) {
      setResults([]);
      return;
    }

    // TODO: Create AbortController

    // TODO: Fetch users with abort signal

    // TODO: Handle AbortError vs other errors

    // TODO: Return cleanup function that aborts
  }, [query]);

  return (
    <div>
      <h2>Search with Abort</h2>

      <input
        type='text'
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search users (min 2 chars)...'
        style={{
          width: '100%',
          padding: '12px',
          fontSize: '16px',
          border: '2px solid #ddd',
          borderRadius: '4px',
        }}
      />

      {loading && <p>Searching...</p>}
      {error && <p style={{ color: 'red' }}>Error: {error}</p>}

      <div style={{ marginTop: '20px' }}>
        {results.map((user) => (
          <div
            key={user.id}
            style={{
              padding: '10px',
              border: '1px solid #ddd',
              borderRadius: '4px',
              marginBottom: '10px',
            }}
          >
            <strong>{user.name}</strong>
            <p style={{ margin: '5px 0 0 0', fontSize: '14px', color: '#666' }}>
              {user.email}
            </p>
          </div>
        ))}
      </div>

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>üß™ Test:</h3>
        <ol>
          <li>Type "Le" quickly ‚Üí Should cancel first request</li>
          <li>Type "Leanne" fast ‚Üí Multiple cancellations</li>
          <li>Console should show abort messages</li>
          <li>No errors displayed for AbortError</li>
        </ol>
      </div>
    </div>
  );
}

export default SearchWithAbort;
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * SearchWithAbort - Level 1
 * Implement search with AbortController to cancel outdated requests
 */
function SearchWithAbort() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!query || query.length < 2) {
      setResults([]);
      setLoading(false);
      return;
    }

    const controller = new AbortController();

    async function searchUsers() {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/users?name_like=${query}`,
          {
            signal: controller.signal,
          },
        );

        if (!response.ok) {
          throw new Error('Network response was not ok');
        }

        const data = await response.json();

        // Only update state if not aborted
        if (!controller.signal.aborted) {
          setResults(data);
          setLoading(false);
        }
      } catch (err) {
        if (err.name === 'AbortError') {
          // Silent abort - no error message needed
          console.log('Search aborted for query:', query);
        } else {
          setError(err.message || 'Failed to fetch users');
          setLoading(false);
        }
      }
    }

    searchUsers();

    // Cleanup: abort previous request when query changes or component unmounts
    return () => {
      controller.abort();
    };
  }, [query]);

  return (
    <div>
      <h2>Search with Abort</h2>
      <input
        type='text'
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search users (min 2 chars)...'
        style={{
          width: '100%',
          padding: '12px',
          fontSize: '16px',
          border: '2px solid #ddd',
          borderRadius: '4px',
        }}
      />
      {loading && <p>Searching...</p>}
      {error && <p style={{ color: 'red' }}>Error: {error}</p>}
      <div style={{ marginTop: '20px' }}>
        {results.map((user) => (
          <div
            key={user.id}
            style={{
              padding: '10px',
              border: '1px solid #ddd',
              borderRadius: '4px',
              marginBottom: '10px',
            }}
          >
            <strong>{user.name}</strong>
            <p style={{ margin: '5px 0 0 0', fontSize: '14px', color: '#666' }}>
              {user.email}
            </p>
          </div>
        ))}
      </div>
      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>üß™ Test:</h3>
        <ol>
          <li>Type "Le" quickly ‚Üí Should cancel first request</li>
          <li>Type "Leanne" fast ‚Üí Multiple cancellations</li>
          <li>Console should show abort messages</li>
          <li>No errors displayed for AbortError</li>
        </ol>
      </div>
    </div>
  );
}

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- G√µ nhanh "Le" ‚Üí "Lea" ‚Üí "Leann" ‚Üí "Leanne"
‚Üí Ch·ªâ request cu·ªëi c√πng hi·ªÉn th·ªã (th∆∞·ªùng l√† Leanne Graham)
‚Üí C√°c request tr∆∞·ªõc b·ªã abort ‚Üí console th·∫•y "Search aborted for query: Lea"...
‚Üí Kh√¥ng b·ªã hi·ªán nh·∫ßm t√™n ng∆∞·ªùi d√πng c≈©
*/
```

</details>

---

### ‚≠ê‚≠ê Level 2: Nh·∫≠n Bi·∫øt Pattern (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Dependent requests v·ªõi proper error handling
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Fetch album ‚Üí Fetch photos from that album
 *
 * Requirements:
 * - Fetch album details
 * - Fetch photos for that album (depends on album ID)
 * - Show loading states for each step
 * - Handle errors independently
 * - Cancel both on album change
 *
 * APIs:
 * - Albums: https://jsonplaceholder.typicode.com/albums/{id}
 * - Photos: https://jsonplaceholder.typicode.com/photos?albumId={id}
 */

function AlbumPhotosViewer() {
  const [albumId, setAlbumId] = useState(1);

  // TODO: Album state
  const [album, setAlbum] = useState(null);
  const [albumLoading, setAlbumLoading] = useState(true);
  const [albumError, setAlbumError] = useState(null);

  // TODO: Photos state
  const [photos, setPhotos] = useState([]);
  const [photosLoading, setPhotosLoading] = useState(false);
  const [photosError, setPhotosError] = useState(null);

  // TODO: Effect 1 - Fetch album
  useEffect(() => {
    const controller = new AbortController();

    async function fetchAlbum() {
      try {
        // TODO: Implement fetch album
        // Set loading, fetch, handle response, set data
      } catch (err) {
        // TODO: Handle abort vs other errors
      }
    }

    fetchAlbum();

    return () => controller.abort();
  }, [albumId]);

  // TODO: Effect 2 - Fetch photos (depends on album)
  useEffect(() => {
    // TODO: Guard clause - don't fetch if no album

    const controller = new AbortController();

    async function fetchPhotos() {
      try {
        // TODO: Implement fetch photos
        // API: /photos?albumId=${album.id}
      } catch (err) {
        // TODO: Handle errors
      }
    }

    fetchPhotos();

    return () => controller.abort();
  }, [album]); // Dependencies: album data

  return (
    <div style={{ maxWidth: '1000px', margin: '0 auto', padding: '20px' }}>
      <h2>Album Photos Viewer</h2>

      {/* Album Selection */}
      <div style={{ marginBottom: '20px' }}>
        <label>Select Album: </label>
        <select
          value={albumId}
          onChange={(e) => setAlbumId(Number(e.target.value))}
        >
          {[1, 2, 3, 4, 5].map((id) => (
            <option
              key={id}
              value={id}
            >
              Album {id}
            </option>
          ))}
        </select>
      </div>

      {/* Request Flow Indicator */}
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '10px',
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
          marginBottom: '20px',
        }}
      >
        <div
          style={{
            padding: '10px 20px',
            background: albumLoading
              ? '#2196F3'
              : albumError
                ? '#f44336'
                : '#4CAF50',
            color: 'white',
            borderRadius: '4px',
            flex: 1,
            textAlign: 'center',
          }}
        >
          {albumLoading
            ? '‚è≥ Fetching Album'
            : albumError
              ? '‚ùå Album Failed'
              : '‚úÖ Album Loaded'}
        </div>

        <span style={{ fontSize: '24px' }}>‚Üí</span>

        <div
          style={{
            padding: '10px 20px',
            background: !album
              ? '#ccc'
              : photosLoading
                ? '#2196F3'
                : photosError
                  ? '#f44336'
                  : '#4CAF50',
            color: 'white',
            borderRadius: '4px',
            flex: 1,
            textAlign: 'center',
          }}
        >
          {!album
            ? '‚è∏Ô∏è Waiting'
            : photosLoading
              ? '‚è≥ Fetching Photos'
              : photosError
                ? '‚ùå Photos Failed'
                : '‚úÖ Photos Loaded'}
        </div>
      </div>

      {/* Content */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: '300px 1fr',
          gap: '20px',
        }}
      >
        {/* Album Details */}
        <div>
          <h3>Album Details</h3>
          {/* TODO: Display album info or loading/error */}
        </div>

        {/* Photos Grid */}
        <div>
          <h3>Photos ({photos.length})</h3>
          {/* TODO: Display photos grid or loading/error */}
          {/* Hint: Use thumbnailUrl for images */}
        </div>
      </div>

      <div
        style={{
          marginTop: '30px',
          padding: '15px',
          background: '#e3f2fd',
          borderRadius: '4px',
        }}
      >
        <h3>üîë Implementation Checklist:</h3>
        <ul>
          <li>[ ] Album fetch has AbortController</li>
          <li>[ ] Photos fetch has AbortController</li>
          <li>[ ] Photos effect has guard clause (if !album return)</li>
          <li>[ ] Both effects cleanup properly</li>
          <li>[ ] AbortError handled separately</li>
          <li>[ ] Loading states independent</li>
          <li>[ ] Changing album cancels both requests</li>
        </ul>
      </div>
    </div>
  );
}

export default AlbumPhotosViewer;
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * AlbumPhotosViewer - Level 2
 * Dependent requests: Fetch album ‚Üí then fetch photos for that album
 * Independent AbortController for each request + proper guard clause
 */
function AlbumPhotosViewer() {
  const [albumId, setAlbumId] = useState(1);

  // Album state
  const [album, setAlbum] = useState(null);
  const [albumLoading, setAlbumLoading] = useState(true);
  const [albumError, setAlbumError] = useState(null);

  // Photos state
  const [photos, setPhotos] = useState([]);
  const [photosLoading, setPhotosLoading] = useState(false);
  const [photosError, setPhotosError] = useState(null);

  // Effect 1: Fetch album details
  useEffect(() => {
    const controller = new AbortController();

    async function fetchAlbum() {
      setAlbumLoading(true);
      setAlbumError(null);
      setPhotos([]); // Reset photos when changing album

      try {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/albums/${albumId}`,
          { signal: controller.signal },
        );

        if (!response.ok) {
          throw new Error(`Album not found (HTTP ${response.status})`);
        }

        const data = await response.json();
        setAlbum(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setAlbumError(err.message || 'Failed to load album');
        }
      } finally {
        setAlbumLoading(false);
      }
    }

    fetchAlbum();

    return () => controller.abort();
  }, [albumId]);

  // Effect 2: Fetch photos (only when we have a valid album)
  useEffect(() => {
    // Guard clause: don't fetch until album is loaded
    if (!album || albumLoading) return;

    const controller = new AbortController();

    async function fetchPhotos() {
      setPhotosLoading(true);
      setPhotosError(null);

      try {
        const response = await fetch(
          `https://jsonplaceholder.typicode.com/photos?albumId=${album.id}`,
          { signal: controller.signal },
        );

        if (!response.ok) {
          throw new Error('Failed to fetch photos');
        }

        const data = await response.json();
        setPhotos(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setPhotosError(err.message || 'Failed to load photos');
        }
      } finally {
        setPhotosLoading(false);
      }
    }

    fetchPhotos();

    return () => controller.abort();
  }, [album, albumLoading]); // Depend on album object & loading state

  return (
    <div style={{ maxWidth: '1000px', margin: '0 auto', padding: '20px' }}>
      <h2>Album Photos Viewer</h2>

      {/* Album Selection */}
      <div style={{ marginBottom: '20px' }}>
        <label>Select Album: </label>
        <select
          value={albumId}
          onChange={(e) => setAlbumId(Number(e.target.value))}
        >
          {[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map((id) => (
            <option
              key={id}
              value={id}
            >
              Album {id}
            </option>
          ))}
        </select>
      </div>

      {/* Request Flow Indicator */}
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '10px',
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
          marginBottom: '20px',
        }}
      >
        <div
          style={{
            padding: '10px 20px',
            background: albumLoading
              ? '#2196F3'
              : albumError
                ? '#f44336'
                : '#4CAF50',
            color: 'white',
            borderRadius: '4px',
            flex: 1,
            textAlign: 'center',
          }}
        >
          {albumLoading
            ? '‚è≥ Fetching Album'
            : albumError
              ? '‚ùå Album Failed'
              : '‚úÖ Album Loaded'}
        </div>
        <span style={{ fontSize: '24px' }}>‚Üí</span>
        <div
          style={{
            padding: '10px 20px',
            background: !album
              ? '#ccc'
              : photosLoading
                ? '#2196F3'
                : photosError
                  ? '#f44336'
                  : '#4CAF50',
            color: 'white',
            borderRadius: '4px',
            flex: 1,
            textAlign: 'center',
          }}
        >
          {!album
            ? '‚è∏Ô∏è Waiting'
            : photosLoading
              ? '‚è≥ Fetching Photos'
              : photosError
                ? '‚ùå Photos Failed'
                : '‚úÖ Photos Loaded'}
        </div>
      </div>

      {/* Content */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: '300px 1fr',
          gap: '20px',
        }}
      >
        {/* Album Details */}
        <div>
          <h3>Album Details</h3>
          {albumLoading && <div>Loading album info...</div>}
          {albumError && <div style={{ color: 'red' }}>{albumError}</div>}
          {album && !albumLoading && (
            <div
              style={{
                padding: '12px',
                background: '#fff',
                border: '1px solid #eee',
              }}
            >
              <h4>{album.title}</h4>
              <p style={{ color: '#666', fontSize: '14px' }}>
                User ID: {album.userId} ‚Ä¢ Album ID: {album.id}
              </p>
            </div>
          )}
        </div>

        {/* Photos Grid */}
        <div>
          <h3>Photos ({photos.length})</h3>
          {photosLoading && <div>Loading photos...</div>}
          {photosError && <div style={{ color: 'red' }}>{photosError}</div>}
          {!album && <div style={{ color: '#999' }}>Select an album first</div>}
          {photos.length > 0 && !photosLoading && !photosError && (
            <div
              style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))',
                gap: '12px',
                maxHeight: '500px',
                overflowY: 'auto',
              }}
            >
              {photos.map((photo) => (
                <div
                  key={photo.id}
                  style={{
                    border: '1px solid #eee',
                    borderRadius: '6px',
                    overflow: 'hidden',
                    background: '#fff',
                  }}
                >
                  <img
                    src={photo.thumbnailUrl}
                    alt={photo.title}
                    style={{ width: '100%', height: 'auto', display: 'block' }}
                  />
                  <div style={{ padding: '8px', fontSize: '13px' }}>
                    {photo.title.substring(0, 60)}
                    {photo.title.length > 60 ? '...' : ''}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>

      <div
        style={{
          marginTop: '30px',
          padding: '15px',
          background: '#e3f2fd',
          borderRadius: '4px',
        }}
      >
        <h3>üîë Implementation Checklist:</h3>
        <ul>
          <li>‚úì Album fetch has AbortController</li>
          <li>‚úì Photos fetch has AbortController</li>
          <li>‚úì Photos effect has guard clause (if !album return)</li>
          <li>‚úì Both effects cleanup properly</li>
          <li>‚úì AbortError handled separately</li>
          <li>‚úì Loading states independent</li>
          <li>‚úì Changing album cancels both requests</li>
        </ul>
      </div>
    </div>
  );
}

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- Ch·ªçn Album 1 ‚Üí th·∫•y album title + ~50 thumbnails load tu·∫ßn t·ª±
- Chuy·ªÉn nhanh sang Album 3 ‚Üí request Album 1 b·ªã abort, request photos Album 1 b·ªã abort
- Ch·ªâ th·∫•y d·ªØ li·ªáu Album 3 + photos c·ªßa Album 3
- Kh√¥ng b·ªã hi·ªán l·∫´n l·ªôn ·∫£nh gi·ªØa c√°c album
- Console c√≥ log abort khi chuy·ªÉn nhanh
*/
```

</details>

---

### ‚≠ê‚≠ê‚≠ê Level 3: K·ªãch B·∫£n Th·ª±c T·∫ø (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: E-commerce Product Browser v·ªõi Advanced Fetching
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën browse products by category,
 * search products, v√† view product details"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Fetch categories on mount
 * - [ ] Fetch products by selected category
 * - [ ] Search products (debounced)
 * - [ ] Click product ‚Üí Fetch product details
 * - [ ] Cancel old requests khi filter/search thay ƒë·ªïi
 * - [ ] Loading states cho m·ªói section
 * - [ ] Error handling graceful
 *
 * üé® Technical Constraints:
 * - API: https://fakestoreapi.com
 * - Endpoints:
 *   - /products/categories
 *   - /products/category/{category}
 *   - /products/{id}
 * - AbortController cho t·∫•t c·∫£ requests
 * - Debounce search 500ms
 *
 * üö® Edge Cases:
 * - Switch category while search active ‚Üí Clear search
 * - Click product while loading ‚Üí Cancel old, fetch new
 * - Rapid category switching ‚Üí Only latest request matters
 */

import { useState, useEffect } from 'react';

const API_BASE = 'https://fakestoreapi.com';

function ProductBrowser() {
  // Categories
  const [categories, setCategories] = useState([]);
  const [categoriesLoading, setCategoriesLoading] = useState(true);

  // Products
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [products, setProducts] = useState([]);
  const [productsLoading, setProductsLoading] = useState(false);
  const [productsError, setProductsError] = useState(null);

  // Search
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');

  // Product details
  const [selectedProduct, setSelectedProduct] = useState(null);
  const [productDetails, setProductDetails] = useState(null);
  const [detailsLoading, setDetailsLoading] = useState(false);

  // TODO: Effect 1 - Fetch categories (once on mount)
  useEffect(() => {
    const controller = new AbortController();

    async function fetchCategories() {
      try {
        const response = await fetch(`${API_BASE}/products/categories`, {
          signal: controller.signal,
        });
        const data = await response.json();
        setCategories(['all', ...data]);
        setCategoriesLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Categories error:', err);
          setCategoriesLoading(false);
        }
      }
    }

    fetchCategories();
    return () => controller.abort();
  }, []);

  // TODO: Effect 2 - Debounce search
  useEffect(() => {
    const timerId = setTimeout(() => {
      setDebouncedQuery(searchQuery);
    }, 500);

    return () => clearTimeout(timerId);
  }, [searchQuery]);

  // TODO: Effect 3 - Fetch products (by category or search)
  useEffect(() => {
    const controller = new AbortController();

    async function fetchProducts() {
      try {
        setProductsLoading(true);
        setProductsError(null);

        let url;
        if (debouncedQuery) {
          // Search mode - fetch all and filter client-side
          url = `${API_BASE}/products`;
        } else if (selectedCategory === 'all') {
          url = `${API_BASE}/products`;
        } else {
          url = `${API_BASE}/products/category/${selectedCategory}`;
        }

        const response = await fetch(url, { signal: controller.signal });
        let data = await response.json();

        // Client-side filter by search
        if (debouncedQuery) {
          data = data.filter((p) =>
            p.title.toLowerCase().includes(debouncedQuery.toLowerCase()),
          );
        }

        setProducts(data);
        setProductsLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setProductsError(err.message);
          setProductsLoading(false);
        }
      }
    }

    fetchProducts();
    return () => controller.abort();
  }, [selectedCategory, debouncedQuery]);

  // TODO: Effect 4 - Fetch product details
  useEffect(() => {
    if (!selectedProduct) {
      setProductDetails(null);
      return;
    }

    const controller = new AbortController();

    async function fetchDetails() {
      try {
        setDetailsLoading(true);

        const response = await fetch(
          `${API_BASE}/products/${selectedProduct}`,
          {
            signal: controller.signal,
          },
        );
        const data = await response.json();

        setProductDetails(data);
        setDetailsLoading(false);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Details error:', err);
          setDetailsLoading(false);
        }
      }
    }

    fetchDetails();
    return () => controller.abort();
  }, [selectedProduct]);

  const handleCategoryChange = (category) => {
    setSelectedCategory(category);
    setSearchQuery(''); // Clear search when changing category
    setSelectedProduct(null); // Clear selected product
  };

  const handleProductClick = (productId) => {
    setSelectedProduct(productId);
  };

  return (
    <div style={{ maxWidth: '1400px', margin: '0 auto', padding: '20px' }}>
      <h2>üõí Product Browser</h2>

      {/* Filters Bar */}
      <div
        style={{
          display: 'flex',
          gap: '20px',
          marginBottom: '20px',
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
        }}
      >
        {/* Categories */}
        <div style={{ flex: 1 }}>
          <label
            style={{
              display: 'block',
              marginBottom: '5px',
              fontWeight: 'bold',
            }}
          >
            Category:
          </label>
          {categoriesLoading ? (
            <div>Loading categories...</div>
          ) : (
            <select
              value={selectedCategory}
              onChange={(e) => handleCategoryChange(e.target.value)}
              style={{ width: '100%', padding: '8px', borderRadius: '4px' }}
            >
              {categories.map((cat) => (
                <option
                  key={cat}
                  value={cat}
                >
                  {cat.charAt(0).toUpperCase() + cat.slice(1)}
                </option>
              ))}
            </select>
          )}
        </div>

        {/* Search */}
        <div style={{ flex: 2 }}>
          <label
            style={{
              display: 'block',
              marginBottom: '5px',
              fontWeight: 'bold',
            }}
          >
            Search:
          </label>
          <input
            type='text'
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder='Search products...'
            style={{
              width: '100%',
              padding: '8px',
              borderRadius: '4px',
              border: '1px solid #ddd',
            }}
          />
          {searchQuery && (
            <div style={{ fontSize: '12px', color: '#666', marginTop: '5px' }}>
              {debouncedQuery !== searchQuery
                ? 'Typing...'
                : `Searching for "${debouncedQuery}"`}
            </div>
          )}
        </div>
      </div>

      {/* Main Content */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: selectedProduct ? '2fr 1fr' : '1fr',
          gap: '20px',
        }}
      >
        {/* Products Grid */}
        <div>
          <h3>Products ({products.length})</h3>

          {productsLoading ? (
            <div style={{ textAlign: 'center', padding: '40px' }}>
              Loading products...
            </div>
          ) : productsError ? (
            <div style={{ color: 'red', padding: '20px' }}>
              Error: {productsError}
            </div>
          ) : products.length === 0 ? (
            <div
              style={{ textAlign: 'center', padding: '40px', color: '#999' }}
            >
              No products found
            </div>
          ) : (
            <div
              style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
                gap: '15px',
              }}
            >
              {products.map((product) => (
                <div
                  key={product.id}
                  onClick={() => handleProductClick(product.id)}
                  style={{
                    padding: '15px',
                    border:
                      selectedProduct === product.id
                        ? '2px solid #4CAF50'
                        : '1px solid #ddd',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    background: 'white',
                    transition: 'all 0.2s',
                  }}
                >
                  <img
                    src={product.image}
                    alt={product.title}
                    style={{
                      width: '100%',
                      height: '150px',
                      objectFit: 'contain',
                      marginBottom: '10px',
                    }}
                  />
                  <h4
                    style={{
                      margin: '0 0 10px 0',
                      fontSize: '14px',
                      height: '40px',
                      overflow: 'hidden',
                    }}
                  >
                    {product.title}
                  </h4>
                  <div
                    style={{
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                    }}
                  >
                    <span style={{ fontWeight: 'bold', color: '#4CAF50' }}>
                      ${product.price}
                    </span>
                    <span style={{ fontSize: '12px', color: '#666' }}>
                      ‚≠ê {product.rating?.rate || 'N/A'}
                    </span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Product Details Panel */}
        {selectedProduct && (
          <div>
            <h3>Product Details</h3>
            <div
              style={{
                padding: '20px',
                border: '2px solid #ddd',
                borderRadius: '8px',
                background: 'white',
                position: 'sticky',
                top: '20px',
              }}
            >
              {detailsLoading ? (
                <div style={{ textAlign: 'center', padding: '40px' }}>
                  Loading details...
                </div>
              ) : productDetails ? (
                <div>
                  <img
                    src={productDetails.image}
                    alt={productDetails.title}
                    style={{
                      width: '100%',
                      height: '200px',
                      objectFit: 'contain',
                      marginBottom: '15px',
                    }}
                  />
                  <h4>{productDetails.title}</h4>
                  <p style={{ color: '#666', fontSize: '14px' }}>
                    {productDetails.description}
                  </p>
                  <div style={{ marginTop: '15px' }}>
                    <div
                      style={{
                        fontSize: '24px',
                        fontWeight: 'bold',
                        color: '#4CAF50',
                        marginBottom: '10px',
                      }}
                    >
                      ${productDetails.price}
                    </div>
                    <div style={{ fontSize: '14px', color: '#666' }}>
                      Category: {productDetails.category}
                    </div>
                    <div style={{ fontSize: '14px', color: '#666' }}>
                      Rating: ‚≠ê {productDetails.rating?.rate} (
                      {productDetails.rating?.count} reviews)
                    </div>
                  </div>
                  <button
                    onClick={() => setSelectedProduct(null)}
                    style={{
                      marginTop: '15px',
                      padding: '10px 20px',
                      background: '#2196F3',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: 'pointer',
                      width: '100%',
                    }}
                  >
                    Close Details
                  </button>
                </div>
              ) : null}
            </div>
          </div>
        )}
      </div>

      {/* Technical Info */}
      <div
        style={{
          marginTop: '30px',
          padding: '20px',
          background: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        <h3>üîß Technical Implementation:</h3>
        <ul>
          <li>‚úÖ 4 independent useEffect hooks</li>
          <li>‚úÖ Each effect has AbortController</li>
          <li>‚úÖ Search debounced 500ms</li>
          <li>‚úÖ Category change clears search</li>
          <li>‚úÖ Parallel category + product fetches cancelled on change</li>
          <li>‚úÖ Product details fetch cancelled on new selection</li>
        </ul>
      </div>
    </div>
  );
}

export default ProductBrowser;
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * ProductBrowser - Level 3
 * E-commerce Product Browser v·ªõi:
 * - Fetch categories on mount
 * - Fetch products by category or search (debounced)
 * - Product details on click
 * - AbortController cho m·ªçi request
 * - Clear search khi ƒë·ªïi category
 */
function ProductBrowser() {
  const [categories, setCategories] = useState([]);
  const [categoriesLoading, setCategoriesLoading] = useState(true);

  const [selectedCategory, setSelectedCategory] = useState('all');
  const [products, setProducts] = useState([]);
  const [productsLoading, setProductsLoading] = useState(false);
  const [productsError, setProductsError] = useState(null);

  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');

  const [selectedProduct, setSelectedProduct] = useState(null);
  const [productDetails, setProductDetails] = useState(null);
  const [detailsLoading, setDetailsLoading] = useState(false);

  // Effect 1: Fetch categories once on mount
  useEffect(() => {
    const controller = new AbortController();

    async function fetchCategories() {
      try {
        const res = await fetch(`${API_BASE}/products/categories`, {
          signal: controller.signal,
        });
        if (!res.ok) throw new Error('Failed to fetch categories');
        const data = await res.json();
        setCategories(['all', ...data]);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Categories fetch failed:', err);
        }
      } finally {
        setCategoriesLoading(false);
      }
    }

    fetchCategories();

    return () => controller.abort();
  }, []);

  // Effect 2: Debounce search input
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(searchQuery.trim());
    }, 500);

    return () => clearTimeout(timer);
  }, [searchQuery]);

  // Effect 3: Fetch products (category ho·∫∑c search)
  useEffect(() => {
    const controller = new AbortController();

    async function fetchProducts() {
      setProductsLoading(true);
      setProductsError(null);
      setProducts([]);

      try {
        let endpoint = `${API_BASE}/products`;

        if (selectedCategory !== 'all') {
          endpoint = `${API_BASE}/products/category/${selectedCategory}`;
        }
        const res = await fetch(endpoint, { signal: controller.signal });
        if (!res.ok) throw new Error('Failed to fetch products');

        let data = await res.json();

        // Search mode: l·∫•y t·∫•t c·∫£ r·ªìi filter client-side
        if (debouncedQuery) {
          const keyword = debouncedQuery.toLowerCase();
          data = data.filter((p) => p.title.toLowerCase().includes(keyword));
        }

        setProducts(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setProductsError(err.message || 'Failed to load products');
        }
      } finally {
        setProductsLoading(false);
      }
    }

    fetchProducts();

    return () => controller.abort();
  }, [selectedCategory, debouncedQuery]);

  // Effect 4: Fetch product details khi ch·ªçn s·∫£n ph·∫©m
  useEffect(() => {
    if (!selectedProduct) {
      setProductDetails(null);
      setDetailsLoading(false);
      return;
    }

    const controller = new AbortController();

    async function fetchDetails() {
      setDetailsLoading(true);

      try {
        const res = await fetch(`${API_BASE}/products/${selectedProduct}`, {
          signal: controller.signal,
        });
        if (!res.ok) throw new Error('Failed to fetch product details');
        const data = await res.json();
        setProductDetails(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Product details error:', err);
        }
      } finally {
        setDetailsLoading(false);
      }
    }

    fetchDetails();

    return () => controller.abort();
  }, [selectedProduct]);

  const handleCategoryChange = (category) => {
    setSelectedCategory(category);
    setSearchQuery(''); // Clear search khi ƒë·ªïi category
    setSelectedProduct(null); // ƒê√≥ng chi ti·∫øt s·∫£n ph·∫©m
  };

  const handleProductClick = (productId) => {
    setSelectedProduct(productId);
  };

  return (
    <div style={{ maxWidth: '1400px', margin: '0 auto', padding: '20px' }}>
      <h2>üõí Product Browser</h2>

      {/* Filters */}
      <div style={{ display: 'flex', gap: '20px', marginBottom: '20px' }}>
        <div style={{ flex: 1 }}>
          <label
            style={{
              fontWeight: 'bold',
              display: 'block',
              marginBottom: '5px',
            }}
          >
            Category
          </label>
          {categoriesLoading ? (
            <div>Loading categories...</div>
          ) : (
            <select
              value={selectedCategory}
              onChange={(e) => handleCategoryChange(e.target.value)}
              style={{ width: '100%', padding: '8px' }}
            >
              {categories.map((cat) => (
                <option
                  key={cat}
                  value={cat}
                >
                  {cat.charAt(0).toUpperCase() + cat.slice(1)}
                </option>
              ))}
            </select>
          )}
        </div>

        <div style={{ flex: 2 }}>
          <label
            style={{
              fontWeight: 'bold',
              display: 'block',
              marginBottom: '5px',
            }}
          >
            Search
          </label>
          <input
            type='text'
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            placeholder='Search products...'
            style={{ width: '100%', padding: '8px' }}
          />
          {searchQuery && (
            <small style={{ color: '#666' }}>
              {debouncedQuery !== searchQuery
                ? 'Typing...'
                : `Searching "${debouncedQuery}"`}
            </small>
          )}
        </div>
      </div>

      {/* Main content */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: selectedProduct ? '2fr 1fr' : '1fr',
          gap: '20px',
        }}
      >
        {/* Products list */}
        <div>
          <h3>Products {products.length > 0 && `(${products.length})`}</h3>

          {productsLoading && (
            <div style={{ padding: '40px', textAlign: 'center' }}>
              Loading products...
            </div>
          )}

          {productsError && (
            <div style={{ color: 'red', padding: '20px' }}>
              Error: {productsError}
            </div>
          )}

          {!productsLoading && !productsError && products.length === 0 && (
            <div
              style={{ textAlign: 'center', color: '#999', padding: '40px' }}
            >
              No products found
            </div>
          )}

          {products.length > 0 && (
            <div
              style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
                gap: '15px',
              }}
            >
              {products.map((product) => (
                <div
                  key={product.id}
                  onClick={() => handleProductClick(product.id)}
                  style={{
                    border:
                      selectedProduct === product.id
                        ? '2px solid #4CAF50'
                        : '1px solid #ddd',
                    borderRadius: '8px',
                    padding: '12px',
                    cursor: 'pointer',
                    background: 'white',
                  }}
                >
                  <img
                    src={product.image}
                    alt={product.title}
                    style={{
                      width: '100%',
                      height: '140px',
                      objectFit: 'contain',
                      marginBottom: '10px',
                    }}
                  />
                  <h4
                    style={{
                      fontSize: '14px',
                      margin: '0 0 8px 0',
                      height: '40px',
                      overflow: 'hidden',
                    }}
                  >
                    {product.title}
                  </h4>
                  <div
                    style={{ display: 'flex', justifyContent: 'space-between' }}
                  >
                    <span style={{ fontWeight: 'bold', color: '#4CAF50' }}>
                      ${product.price}
                    </span>
                    <span>‚≠ê {product.rating?.rate || '?'}</span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Product details sidebar */}
        {selectedProduct && (
          <div>
            <h3>Product Details</h3>
            <div
              style={{
                position: 'sticky',
                top: '20px',
                padding: '20px',
                border: '1px solid #ddd',
                borderRadius: '8px',
                background: 'white',
              }}
            >
              {detailsLoading && (
                <div style={{ textAlign: 'center', padding: '60px 0' }}>
                  Loading details...
                </div>
              )}

              {productDetails && !detailsLoading && (
                <>
                  <img
                    src={productDetails.image}
                    alt={productDetails.title}
                    style={{
                      width: '100%',
                      height: '220px',
                      objectFit: 'contain',
                      marginBottom: '15px',
                    }}
                  />
                  <h4>{productDetails.title}</h4>
                  <p style={{ color: '#555', fontSize: '14px' }}>
                    {productDetails.description}
                  </p>
                  <div
                    style={{
                      margin: '15px 0',
                      fontSize: '22px',
                      fontWeight: 'bold',
                      color: '#4CAF50',
                    }}
                  >
                    ${productDetails.price}
                  </div>
                  <div style={{ color: '#666', fontSize: '14px' }}>
                    Category: {productDetails.category}
                    <br />
                    Rating: ‚≠ê {productDetails.rating?.rate} (
                    {productDetails.rating?.count} reviews)
                  </div>
                  <button
                    onClick={() => setSelectedProduct(null)}
                    style={{
                      marginTop: '20px',
                      width: '100%',
                      padding: '10px',
                      background: '#2196F3',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer',
                    }}
                  >
                    Close
                  </button>
                </>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- Load trang ‚Üí th·∫•y categories: all, electronics, jewelery, men's clothing, women's clothing
- Ch·ªçn "electronics" ‚Üí load ~5 s·∫£n ph·∫©m electronics
- G√µ nhanh "shirt" ‚Üí debounce 500ms ‚Üí ch·ªâ hi·ªÉn th·ªã s·∫£n ph·∫©m c√≥ "shirt" trong title
- Chuy·ªÉn sang category "jewelery" ‚Üí search b·ªã clear, load s·∫£n ph·∫©m jewelery
- Click v√†o m·ªôt s·∫£n ph·∫©m ‚Üí sidebar ph·∫£i hi·ªán chi ti·∫øt (h√¨nh, m√¥ t·∫£, gi√°, rating)
- Click s·∫£n ph·∫©m kh√°c nhanh ‚Üí request c≈© b·ªã abort, ch·ªâ hi·ªán chi ti·∫øt s·∫£n ph·∫©m m·ªõi nh·∫•t
- Console th·∫•y th√¥ng b√°o abort khi chuy·ªÉn category ho·∫∑c click s·∫£n ph·∫©m nhanh
*/
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê Level 4: Quy·∫øt ƒê·ªãnh Ki·∫øn Tr√∫c (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Social Media Feed v·ªõi Infinite Scroll & Real-time Updates
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Context:
 * X√¢y d·ª±ng social feed with:
 * - Initial posts load
 * - Infinite scroll (load more)
 * - Pull-to-refresh
 * - Real-time updates (polling)
 * - Cancel all on unmount
 *
 * APPROACH OPTIONS:
 *
 * APPROACH 1: Single effect, all logic together
 * Pros:
 * - One effect, one controller
 * Cons:
 * - Complex, hard to read
 * - Mixing concerns
 * - Difficult to test
 *
 * APPROACH 2: Separate effects per concern
 * Pros:
 * - Clear separation
 * - Easy to disable features
 * - Testable
 * Cons:
 * - Multiple controllers
 * - Coordination needed
 *
 * APPROACH 3: Custom hooks (not yet learned)
 *
 * üí≠ RECOMMENDATION: Approach 2
 *
 * ADR:
 * ---
 * # ADR: Social Feed Architecture
 *
 * ## Decision
 * Separate effects for:
 * 1. Initial load
 * 2. Infinite scroll
 * 3. Polling updates
 *
 * ## Rationale
 * - Each concern independent
 * - Can enable/disable features
 * - Clear abort strategy per feature
 * ---
 */

// üíª PHASE 2: Implementation (30 ph√∫t)

// üß™ PHASE 3: Testing (10 ph√∫t)
// - [ ] Initial posts load
// - [ ] Scroll to bottom ‚Üí Load more
// - [ ] New posts banner appears (polling)
// - [ ] Click banner ‚Üí Refresh feed
// - [ ] Toggle polling on/off
// - [ ] Refresh button works
// - [ ] Unmount ‚Üí All requests cancelled
```

<details><summary>üí° Solution</summary>

```jsx
import { useEffect, useRef, useState } from 'react';

// API endpoint v√† h·∫±ng s·ªë
const POSTS_API = 'https://jsonplaceholder.typicode.com/posts';
const POSTS_PER_PAGE = 10;
const PULL_THRESHOLD = 80;

/**
 * Interface ƒë·∫°i di·ªán cho m·ªôt b√†i vi·∫øt t·ª´ JSONPlaceholder API
 */
interface Post {
  userId: number;
  id: number;
  title: string;
  body: string;
}

/**
 * Component ch√≠nh hi·ªÉn th·ªã ngu·ªìn c·∫•p m·∫°ng x√£ h·ªôi v·ªõi c√°c t√≠nh nƒÉng:
 * - T·∫£i b√†i vi·∫øt ban ƒë·∫ßu
 * - Cu·ªôn v√¥ h·∫°n (infinite scroll) s·ª≠ d·ª•ng Intersection Observer
 * - K√©o xu·ªëng ƒë·ªÉ l√†m m·ªõi (pull-to-refresh) tr√™n thi·∫øt b·ªã c·∫£m ·ª©ng
 * - Polling gi·∫£ l·∫≠p ƒë·ªÉ ph√°t hi·ªán b√†i vi·∫øt m·ªõi
 * - Banner th√¥ng b√°o b√†i vi·∫øt m·ªõi
 * - S·ªë th·ª© t·ª± (#1, #2, ...) cho m·ªói b√†i vi·∫øt ƒë·ªÉ d·ªÖ theo d√µi infinite load
 *
 * @component
 */
function SocialFeed() {
  // ==================== STATE ====================

  /** Danh s√°ch b√†i vi·∫øt ƒë√£ t·∫£i */
  const [posts, setPosts] = useState<Post[]>([]);

  /** Trang hi·ªán t·∫°i (d√πng cho ph√¢n trang API) */
  const [page, setPage] = useState<number>(1);

  /** C√≤n d·ªØ li·ªáu ƒë·ªÉ t·∫£i th√™m kh√¥ng */
  const [hasMore, setHasMore] = useState<boolean>(true);

  /** ƒêang t·∫£i d·ªØ li·ªáu ban ƒë·∫ßu */
  const [loading, setLoading] = useState<boolean>(true);

  /** ƒêang t·∫£i th√™m b√†i vi·∫øt (infinite scroll) */
  const [loadingMore, setLoadingMore] = useState<boolean>(false);

  /** L·ªói n·∫øu c√≥ khi t·∫£i d·ªØ li·ªáu */
  const [error, setError] = useState<string | null>(null);

  /** Key ƒë·ªÉ trigger reload d·ªØ li·ªáu ban ƒë·∫ßu khi refresh */
  const [refreshKey, setRefreshKey] = useState<number>(0);

  // Polling state
  /** B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô polling t·ª± ƒë·ªông */
  const [polling, setPolling] = useState<boolean>(true);

  /** S·ªë b√†i vi·∫øt m·ªõi (gi·∫£ l·∫≠p) */
  const [newPostsCount, setNewPostsCount] = useState<number>(0);

  // Pull-to-refresh state
  /** Kho·∫£ng c√°ch k√©o xu·ªëng hi·ªán t·∫°i (px) */
  const [pullDistance, setPullDistance] = useState<number>(0);

  /** ƒêang trong tr·∫°ng th√°i k√©o xu·ªëng */
  const [pulling, setPulling] = useState<boolean>(false);

  /** V·ªã tr√≠ Y b·∫Øt ƒë·∫ßu khi ch·∫°m m√†n h√¨nh */
  const startYRef = useRef<number | null>(null);

  // ==================== REFS ====================

  /** Ref cho IntersectionObserver target (trigger load more) */
  const observerRef = useRef<IntersectionObserver | null>(null);

  // ==================== CALLBACKS ====================

  /**
   * Callback ref ƒë·ªÉ thi·∫øt l·∫≠p IntersectionObserver cho ph·∫ßn t·ª≠ trigger load more
   * @param node - Ph·∫ßn t·ª≠ DOM c·∫ßn observe
   */
  const setObserverTarget = (node: HTMLDivElement | null) => {
    if (observerRef.current) {
      observerRef.current.disconnect();
      observerRef.current = null;
    }

    if (!node) return;

    observerRef.current = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting && hasMore && !loading && !loadingMore) {
          loadMore();
        }
      },
      { threshold: 1 },
    );

    observerRef.current.observe(node);
  };

  // ==================== TOUCH HANDLERS ====================

  /**
   * X·ª≠ l√Ω s·ª± ki·ªán touchstart cho pull-to-refresh
   * Ch·ªâ b·∫Øt ƒë·∫ßu pull khi ƒëang ·ªü ƒë·∫ßu trang v√† kh√¥ng ƒëang load
   */
  const onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {
    if (window.scrollY !== 0 || loading || loadingMore) return;

    startYRef.current = e.touches[0].clientY;
    setPulling(true);
  };

  /**
   * X·ª≠ l√Ω s·ª± ki·ªán touchmove ‚Äì t√≠nh to√°n kho·∫£ng c√°ch k√©o
   */
  const onTouchMove = (e: React.TouchEvent<HTMLDivElement>) => {
    if (!pulling || startYRef.current === null) return;

    const currentY = e.touches[0].clientY;
    const distance = currentY - startYRef.current;

    if (distance > 0) {
      setPullDistance(Math.min(distance, 120));
    }
  };

  /**
   * X·ª≠ l√Ω s·ª± ki·ªán touchend ‚Äì quy·∫øt ƒë·ªãnh c√≥ refresh hay kh√¥ng
   */
  const onTouchEnd = () => {
    if (!pulling) return;

    if (pullDistance >= PULL_THRESHOLD) {
      handleRefresh();
    }

    setPullDistance(0);
    setPulling(false);
    startYRef.current = null;
  };

  // ==================== DATA FETCHING ====================

  /**
   * T·∫£i danh s√°ch b√†i vi·∫øt ban ƒë·∫ßu (page 1)
   */
  useEffect(() => {
    const controller = new AbortController();

    async function loadInitialPosts() {
      try {
        setLoading(true);
        setError(null);

        const res = await fetch(
          `${POSTS_API}?_page=1&_limit=${POSTS_PER_PAGE}`,
          { signal: controller.signal },
        );

        if (!res.ok) throw new Error('Network error');

        const data: Post[] = await res.json();

        setPosts(data);
        setPage(1);
        setHasMore(data.length === POSTS_PER_PAGE);
      } catch (err: any) {
        if (err.name !== 'AbortError') {
          setError(err.message || 'L·ªói t·∫£i d·ªØ li·ªáu');
        }
      } finally {
        setLoading(false);
      }
    }

    loadInitialPosts();
    return () => controller.abort();
  }, [refreshKey]);

  /**
   * T·∫£i th√™m b√†i vi·∫øt (infinite scroll)
   */
  async function loadMore() {
    if (loadingMore || !hasMore) return;

    try {
      setLoadingMore(true);

      const res = await fetch(
        `${POSTS_API}?_page=${page + 1}&_limit=${POSTS_PER_PAGE}`,
      );

      if (!res.ok) throw new Error('Network error');
      await new Promise((res) => setTimeout(res, 1000));
      const data: Post[] = await res.json();

      if (data.length === 0) {
        setHasMore(false);
      } else {
        setPosts((prev) => [...prev, ...data]);
        setPage((prev) => prev + 1);
      }
    } catch (err) {
      console.error('Load more error', err);
    } finally {
      setLoadingMore(false);
    }
  }

  /**
   * Polling gi·∫£ l·∫≠p ƒë·ªÉ ph√°t hi·ªán b√†i vi·∫øt m·ªõi
   */
  useEffect(() => {
    if (!polling) return;

    const interval = setInterval(() => {
      if (Math.random() > 0.7) {
        setNewPostsCount((p) => p + 1);
      }
    }, 5000);

    return () => clearInterval(interval);
  }, [polling]);

  // ==================== ACTIONS ====================

  /**
   * L√†m m·ªõi to√†n b·ªô ngu·ªìn c·∫•p (reset state v√† t·∫£i l·∫°i page 1)
   */
  const handleRefresh = () => {
    setPosts([]);
    setPage(1);
    setHasMore(true);
    setNewPostsCount(0);
    setRefreshKey((k) => k + 1);
  };

  /**
   * X·ª≠ l√Ω khi nh·∫•n v√†o banner "c√≥ b√†i vi·∫øt m·ªõi"
   */
  const handleLoadNew = () => {
    handleRefresh();
  };

  // ==================== RENDER ====================

  if (loading) {
    return (
      <div
        style={{
          height: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
          background: '#f8f9fa',
        }}
      >
        <div
          style={{
            fontSize: 60,
            animation: 'spin 1.5s linear infinite',
            marginBottom: 16,
          }}
        >
          ‚Üª
        </div>
        <p style={{ fontSize: 18, color: '#555' }}>ƒêang t·∫£i ngu·ªìn c·∫•p...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div
        style={{
          height: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
          background: '#fff',
          padding: 20,
        }}
      >
        <p style={{ fontSize: 20, color: '#d32f2f', marginBottom: 16 }}>
          L·ªói: {error}
        </p>
        <button
          onClick={handleRefresh}
          style={{
            padding: '12px 32px',
            fontSize: 16,
            background: '#1976d2',
            color: 'white',
            border: 'none',
            borderRadius: 8,
            cursor: 'pointer',
            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
          }}
        >
          Th·ª≠ l·∫°i
        </button>
      </div>
    );
  }

  return (
    <>
      <style>{`
        @keyframes spin {
          from { transform: rotate(0deg); }
          to   { transform: rotate(360deg); }
        }
      `}</style>

      <div
        onTouchStart={onTouchStart}
        onTouchMove={onTouchMove}
        onTouchEnd={onTouchEnd}
        style={{
          minHeight: '100vh',
          background: '#f0f2f5',
          paddingBottom: 60,
        }}
      >
        {/* Pull indicator */}
        <div
          style={{
            position: 'sticky',
            top: 0,
            height: pullDistance,
            overflow: 'hidden',
            transition: pulling
              ? 'none'
              : 'height 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94)',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'flex-end',
            zIndex: 1000,
            background: 'linear-gradient(to bottom, #e3f2fd, transparent)',
          }}
        >
          {pullDistance > 0 && (
            <div
              style={{
                paddingBottom: 16,
                fontSize: 15,
                fontWeight: 500,
                color: pullDistance >= PULL_THRESHOLD ? '#1976d2' : '#757575',
                opacity: Math.min(pullDistance / PULL_THRESHOLD, 1),
                display: 'flex',
                alignItems: 'center',
                gap: 8,
              }}
            >
              {pullDistance < PULL_THRESHOLD ? (
                <>‚¨áÔ∏è K√©o xu·ªëng ƒë·ªÉ l√†m m·ªõi</>
              ) : (
                <>üîÑ Th·∫£ tay ƒë·ªÉ l√†m m·ªõi</>
              )}
            </div>
          )}
        </div>

        {/* Header */}
        <div
          style={{
            position: 'sticky',
            top: 0,
            zIndex: 999,
            background: 'white',
            padding: '16px 20px',
            borderBottom: '1px solid #e0e0e0',
            boxShadow: '0 2px 10px rgba(0,0,0,0.05)',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
          }}
        >
          <h2 style={{ margin: 0, fontSize: 22, fontWeight: 700 }}>
            üì± Ngu·ªìn c·∫•p
          </h2>
          <div style={{ display: 'flex', alignItems: 'center', gap: 12 }}>
            <label
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: 6,
                fontSize: 14,
              }}
            >
              <input
                type='checkbox'
                checked={polling}
                onChange={(e) => setPolling(e.target.checked)}
                style={{ accentColor: '#1976d2' }}
              />
              Polling
            </label>
            <button
              onClick={handleRefresh}
              style={{
                padding: '8px 16px',
                background: '#1976d2',
                color: 'white',
                border: 'none',
                borderRadius: 8,
                fontWeight: 500,
                cursor: 'pointer',
                boxShadow: '0 2px 6px rgba(25,118,210,0.3)',
              }}
            >
              L√†m m·ªõi
            </button>
          </div>
        </div>

        {/* New posts banner */}
        {newPostsCount > 0 && (
          <div
            onClick={handleLoadNew}
            style={{
              margin: '16px 20px',
              padding: '14px',
              background: 'linear-gradient(135deg, #4caf50, #388e3c)',
              color: 'white',
              borderRadius: 12,
              textAlign: 'center',
              fontWeight: 600,
              cursor: 'pointer',
              boxShadow: '0 4px 12px rgba(76,175,80,0.3)',
            }}
          >
            C√≥ {newPostsCount} b√†i vi·∫øt m·ªõi ‚Äì Nh·∫•n ƒë·ªÉ xem ngay
          </div>
        )}

        {/* Posts v·ªõi s·ªë th·ª© t·ª± */}
        {posts.map((post, index) => (
          <div
            key={post.id}
            style={{
              margin: '16px 20px',
              padding: '16px',
              background: 'white',
              borderRadius: 12,
              boxShadow: '0 2px 12px rgba(0,0,0,0.08)',
              position: 'relative',
            }}
          >
            {/* S·ªë th·ª© t·ª± */}
            <div
              style={{
                position: 'absolute',
                top: -12,
                left: 16,
                background: '#1976d2',
                color: 'white',
                fontSize: 14,
                fontWeight: 700,
                padding: '4px 10px',
                borderRadius: 16,
                boxShadow: '0 2px 6px rgba(0,0,0,0.2)',
              }}
            >
              #{index + 1}
            </div>

            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                marginBottom: 12,
                paddingTop: 12,
              }}
            >
              <div
                style={{
                  width: 40,
                  height: 40,
                  borderRadius: '50%',
                  background: '#e0e0e0',
                  marginRight: 12,
                }}
              />
              <div>
                <div style={{ fontWeight: 600 }}>Ng∆∞·ªùi d√πng {post.userId}</div>
                <div style={{ fontSize: 13, color: '#757575' }}>
                  2 gi·ªù tr∆∞·ªõc
                </div>
              </div>
            </div>
            <h3 style={{ margin: '0 0 12px', fontSize: 18 }}>{post.title}</h3>
            <p style={{ margin: 0, lineHeight: 1.6, color: '#424242' }}>
              {post.body}
            </p>
            <div
              style={{
                marginTop: 16,
                display: 'flex',
                gap: 24,
                color: '#757575',
                fontSize: 14,
              }}
            >
              <span>üëç {Math.floor(Math.random() * 200 + 10)}</span>
              <span>üí¨ {Math.floor(Math.random() * 50 + 5)}</span>
              <span>üîÅ {Math.floor(Math.random() * 30)}</span>
            </div>
          </div>
        ))}

        {/* Load more trigger */}
        {hasMore && (
          <div
            ref={setObserverTarget}
            style={{
              padding: '40px 20px',
              textAlign: 'center',
              color: '#757575',
              fontSize: 15,
            }}
          >
            {loadingMore ? (
              <div
                style={{
                  display: 'flex',
                  justifyContent: 'center',
                  alignItems: 'center',
                  gap: 8,
                }}
              >
                <div
                  style={{
                    width: 20,
                    height: 20,
                    border: '3px solid #1976d2',
                    borderTopColor: 'transparent',
                    borderRadius: '50%',
                    animation: 'spin 1s linear infinite',
                  }}
                />
                ƒêang t·∫£i th√™m...
              </div>
            ) : (
              'Cu·ªôn xu·ªëng ƒë·ªÉ t·∫£i th√™m'
            )}
          </div>
        )}

        {!hasMore && posts.length > 0 && (
          <div
            style={{
              padding: '60px 20px',
              textAlign: 'center',
              color: '#9e9e9e',
              fontSize: 16,
            }}
          >
            üéâ B·∫°n ƒë√£ xem h·∫øt t·∫•t c·∫£ b√†i vi·∫øt
          </div>
        )}
      </div>
    </>
  );
}

export default SocialFeed;


```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Level 5: Production Challenge (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Multi-Tab Analytics Dashboard v·ªõi Advanced Patterns
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 * Dashboard v·ªõi 4 tabs:
 * 1. Overview - Parallel fetch multiple stats
 * 2. Users - Table with pagination & search
 * 3. Posts - Dependent fetch (user ‚Üí posts)
 * 4. Activity - Real-time polling
 *
 * Requirements:
 * - Lazy load tab data (only fetch when tab clicked)
 * - Cache fetched data (don't refetch same tab)
 * - Cancel requests on tab switch
 * - Refresh button per tab
 * - Global abort on unmount
 * - Error recovery per tab
 *
 * üèóÔ∏è Architecture:
 * - TabContainer (manages active tab)
 * - Each tab component handles own fetching
 * - Shared cache in parent state
 * - AbortController per tab
 *
 * ‚úÖ Production Checklist:
 * - [ ] Lazy loading
 * - [ ] Caching strategy
 * - [ ] Request cancellation
 * - [ ] Error handling
 * - [ ] Loading states
 * - [ ] Refresh mechanism
 * - [ ] Memory cleanup
 */

// Due to length, providing architecture + starter code
// Student implements full solution

import { useState, useEffect } from 'react';

const API_BASE = 'https://jsonplaceholder.typicode.com';

// Tab configuration
const TABS = {
  overview: { id: 'overview', label: 'Overview', icon: 'üìä' },
  users: { id: 'users', label: 'Users', icon: 'üë•' },
  posts: { id: 'posts', label: 'Posts', icon: 'üìù' },
  activity: { id: 'activity', label: 'Activity', icon: '‚ö°' },
};

function MultiTabDashboard() {
  const [activeTab, setActiveTab] = useState('overview');
  const [cache, setCache] = useState({
    overview: null,
    users: null,
    posts: null,
    activity: null,
  });
  const [loadedTabs, setLoadedTabs] = useState(new Set());

  const handleTabChange = (tabId) => {
    setActiveTab(tabId);
    // Mark tab as needing load if not cached
    if (!loadedTabs.has(tabId)) {
      setLoadedTabs((prev) => new Set([...prev, tabId]));
    }
  };

  const handleRefreshTab = (tabId) => {
    // Clear cache for this tab
    setCache((prev) => ({ ...prev, [tabId]: null }));
    // Trigger reload
    setLoadedTabs((prev) => {
      const newSet = new Set(prev);
      newSet.delete(tabId);
      newSet.add(tabId);
      return newSet;
    });
  };

  return (
    <div style={{ maxWidth: '1400px', margin: '0 auto', padding: '20px' }}>
      <h1>üéØ Multi-Tab Analytics Dashboard</h1>

      {/* Tab Navigation */}
      <div
        style={{
          display: 'flex',
          gap: '10px',
          marginBottom: '20px',
          borderBottom: '2px solid #ddd',
          paddingBottom: '10px',
        }}
      >
        {Object.values(TABS).map((tab) => (
          <button
            key={tab.id}
            onClick={() => handleTabChange(tab.id)}
            style={{
              padding: '10px 20px',
              background: activeTab === tab.id ? '#4CAF50' : 'white',
              color: activeTab === tab.id ? 'white' : '#333',
              border: '2px solid',
              borderColor: activeTab === tab.id ? '#4CAF50' : '#ddd',
              borderRadius: '8px 8px 0 0',
              cursor: 'pointer',
              fontSize: '16px',
              fontWeight: activeTab === tab.id ? 'bold' : 'normal',
            }}
          >
            {tab.icon} {tab.label}
          </button>
        ))}
      </div>

      {/* Tab Content */}
      <div>
        {activeTab === 'overview' && (
          <OverviewTab
            cache={cache.overview}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, overview: data }))
            }
            onRefresh={() => handleRefreshTab('overview')}
            shouldLoad={loadedTabs.has('overview')}
          />
        )}

        {activeTab === 'users' && (
          <UsersTab
            cache={cache.users}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, users: data }))
            }
            onRefresh={() => handleRefreshTab('users')}
            shouldLoad={loadedTabs.has('users')}
          />
        )}

        {activeTab === 'posts' && (
          <PostsTab
            cache={cache.posts}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, posts: data }))
            }
            onRefresh={() => handleRefreshTab('posts')}
            shouldLoad={loadedTabs.has('posts')}
          />
        )}

        {activeTab === 'activity' && (
          <ActivityTab
            cache={cache.activity}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, activity: data }))
            }
            onRefresh={() => handleRefreshTab('activity')}
            shouldLoad={loadedTabs.has('activity')}
          />
        )}
      </div>

      {/* Implementation Guide */}
      <div
        style={{
          marginTop: '40px',
          padding: '20px',
          background: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        <h3>üîß Implementation Guide:</h3>

        <h4>Tab Components to Implement:</h4>

        <p>
          <strong>1. OverviewTab:</strong>
        </p>
        <ul>
          <li>Parallel fetch: users count, posts count, comments count</li>
          <li>Promise.allSettled for independent failures</li>
          <li>Display in stat cards</li>
        </ul>

        <p>
          <strong>2. UsersTab:</strong>
        </p>
        <ul>
          <li>Fetch users with pagination</li>
          <li>Search functionality (debounced)</li>
          <li>Table display</li>
        </ul>

        <p>
          <strong>3. PostsTab:</strong>
        </p>
        <ul>
          <li>Select user dropdown</li>
          <li>Fetch posts for selected user (dependent)</li>
          <li>AbortController for both requests</li>
        </ul>

        <p>
          <strong>4. ActivityTab:</strong>
        </p>
        <ul>
          <li>Polling latest activity (every 10s)</li>
          <li>Display activity feed</li>
          <li>Toggle polling on/off</li>
        </ul>

        <h4>‚úÖ Required Features:</h4>
        <ul>
          <li>[ ] Lazy loading (don't fetch until tab clicked)</li>
          <li>[ ] Caching (use cached data if available)</li>
          <li>[ ] Refresh button per tab (clear cache, refetch)</li>
          <li>[ ] AbortController per tab (cancel on tab switch)</li>
          <li>[ ] Loading states per tab</li>
          <li>[ ] Error handling per tab</li>
          <li>[ ] Clean unmount (abort all)</li>
        </ul>
      </div>
    </div>
  );
}

// TODO: Implement tab components
function OverviewTab({ cache, onDataLoad, onRefresh, shouldLoad }) {
  // TODO: Implement
  return <div>Overview Tab - To be implemented</div>;
}

function UsersTab({ cache, onDataLoad, onRefresh, shouldLoad }) {
  // TODO: Implement
  return <div>Users Tab - To be implemented</div>;
}

function PostsTab({ cache, onDataLoad, onRefresh, shouldLoad }) {
  // TODO: Implement
  return <div>Posts Tab - To be implemented</div>;
}

function ActivityTab({ cache, onDataLoad, onRefresh, shouldLoad }) {
  // TODO: Implement
  return <div>Activity Tab - To be implemented</div>;
}

export default MultiTabDashboard;
```

<details><summary>üí° Solution</summary>

```tsx
import { useEffect, useRef, useState } from 'react';

const API_BASE = 'https://jsonplaceholder.typicode.com';

// Tab configuration
const TABS = {
  overview: { id: 'overview', label: 'Overview', icon: 'üìä' },
  users: { id: 'users', label: 'Users', icon: 'üë•' },
  posts: { id: 'posts', label: 'Posts', icon: 'üìù' },
  activity: { id: 'activity', label: 'Activity', icon: '‚ö°' },
} as const;

type TabId = keyof typeof TABS;

/**
 * Interface cho d·ªØ li·ªáu cache c·ªßa t·ª´ng tab
 */
interface TabCache {
  overview: OverviewData | null;
  users: User[] | null;
  posts: Post[] | null;
  activity: ActivityItem[] | null;
}

interface OverviewData {
  usersCount: number;
  postsCount: number;
  commentsCount: number;
  lastUpdated: string;
}

interface User {
  id: number;
  name: string;
  username: string;
  email: string;
}

interface Post {
  id: number;
  userId: number;
  title: string;
  body: string;
}

interface ActivityItem {
  id: number;
  type: 'post' | 'comment' | 'like';
  userId: number;
  timestamp: string;
  message: string;
}

/**
 * Dashboard ƒëa tab v·ªõi lazy loading, caching, cancellation v√† refresh ri√™ng t·ª´ng tab
 */
function MultiTabDashboard() {
  const [activeTab, setActiveTab] = useState<TabId>('overview');
  const [cache, setCache] = useState<TabCache>({
    overview: null,
    users: null,
    posts: null,
    activity: null,
  });
  const [loadedTabs, setLoadedTabs] = useState<Set<TabId>>(
    new Set(['overview']),
  );

  // Abort controllers cho t·ª´ng tab
  const abortControllers = useRef<Map<TabId, AbortController>>(new Map());

  const handleTabChange = (tabId: TabId) => {
    // Cancel request tab c≈© n·∫øu ƒëang fetch
    const prevController = abortControllers.current.get(activeTab);
    if (prevController) {
      prevController.abort();
      abortControllers.current.delete(activeTab);
    }

    setActiveTab(tabId);

    // N·∫øu tab ch∆∞a load ‚Üí trigger load
    if (!loadedTabs.has(tabId)) {
      setLoadedTabs((prev) => new Set([...prev, tabId]));
    }
  };

  const handleRefreshTab = (tabId: TabId) => {
    setCache((prev) => ({ ...prev, [tabId]: null }));

    const controller = abortControllers.current.get(tabId);
    if (controller) {
      controller.abort();
      abortControllers.current.delete(tabId);
    }

    setLoadedTabs((prev) => {
      const newSet = new Set(prev);
      newSet.delete(tabId);
      newSet.add(tabId);
      return newSet;
    });
  };

  // Cleanup to√†n b·ªô khi component unmount
  useEffect(() => {
    return () => {
      abortControllers.current.forEach((ctrl) => ctrl.abort());
      abortControllers.current.clear();
    };
  }, []);

  return (
    <div style={{ maxWidth: '1400px', margin: '0 auto', padding: '20px' }}>
      <h1>üéØ Multi-Tab Analytics Dashboard</h1>

      {/* Tab Navigation */}
      <div
        style={{
          display: 'flex',
          gap: '10px',
          marginBottom: '20px',
          borderBottom: '2px solid #ddd',
          paddingBottom: '10px',
        }}
      >
        {Object.values(TABS).map((tab) => (
          <button
            key={tab.id}
            onClick={() => handleTabChange(tab.id as TabId)}
            style={{
              padding: '10px 20px',
              background: activeTab === tab.id ? '#4CAF50' : 'white',
              color: activeTab === tab.id ? 'white' : '#333',
              border: '2px solid',
              borderColor: activeTab === tab.id ? '#4CAF50' : '#ddd',
              borderRadius: '8px 8px 0 0',
              cursor: 'pointer',
              fontSize: '16px',
              fontWeight: activeTab === tab.id ? 'bold' : 'normal',
            }}
          >
            {tab.icon} {tab.label}
          </button>
        ))}
      </div>

      {/* Tab Content */}
      <div>
        {activeTab === 'overview' && (
          <OverviewTab
            cache={cache.overview}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, overview: data }))
            }
            onRefresh={() => handleRefreshTab('overview')}
            shouldLoad={loadedTabs.has('overview')}
          />
        )}
        {activeTab === 'users' && (
          <UsersTab
            cache={cache.users}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, users: data }))
            }
            onRefresh={() => handleRefreshTab('users')}
            shouldLoad={loadedTabs.has('users')}
          />
        )}
        {activeTab === 'posts' && (
          <PostsTab
            cache={cache.posts}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, posts: data }))
            }
            onRefresh={() => handleRefreshTab('posts')}
            shouldLoad={loadedTabs.has('posts')}
          />
        )}
        {activeTab === 'activity' && (
          <ActivityTab
            cache={cache.activity}
            onDataLoad={(data) =>
              setCache((prev) => ({ ...prev, activity: data }))
            }
            onRefresh={() => handleRefreshTab('activity')}
            shouldLoad={loadedTabs.has('activity')}
          />
        )}
      </div>
    </div>
  );
}

/**
 * Tab Overview: Parallel fetch nhi·ªÅu th·ªëng k√™
 */
function OverviewTab({
  cache,
  onDataLoad,
  onRefresh,
  shouldLoad,
}: {
  cache: OverviewData | null;
  onDataLoad: (data: OverviewData) => void;
  onRefresh: () => void;
  shouldLoad: boolean;
}) {
  const [loading, setLoading] = useState(!cache);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!shouldLoad || cache) return;

    const controller = new AbortController();
    const { signal } = controller;

    async function fetchOverview() {
      setLoading(true);
      setError(null);

      try {
        const [usersRes, postsRes, commentsRes] = await Promise.allSettled([
          fetch(`${API_BASE}/users`, { signal }).then((r) => r.json()),
          fetch(`${API_BASE}/posts`, { signal }).then((r) => r.json()),
          fetch(`${API_BASE}/comments`, { signal }).then((r) => r.json()),
        ]);

        const users =
          usersRes.status === 'fulfilled' ? usersRes.value.length : 0;
        const posts =
          postsRes.status === 'fulfilled' ? postsRes.value.length : 0;
        const comments =
          commentsRes.status === 'fulfilled' ? commentsRes.value.length : 0;

        const data: OverviewData = {
          usersCount: users,
          postsCount: posts,
          commentsCount: comments,
          lastUpdated: new Date().toLocaleTimeString(),
        };

        onDataLoad(data);
      } catch (err: any) {
        if (err.name !== 'AbortError') {
          setError('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu t·ªïng quan');
        }
      } finally {
        setLoading(false);
      }
    }

    fetchOverview();

    return () => controller.abort();
  }, [shouldLoad, cache]);

  if (loading)
    return (
      <div style={{ padding: '40px', textAlign: 'center' }}>
        ƒêang t·∫£i t·ªïng quan...
      </div>
    );
  if (error)
    return (
      <div style={{ color: 'red', padding: '20px' }}>
        {error} <button onClick={onRefresh}>Th·ª≠ l·∫°i</button>
      </div>
    );

  if (!cache) return null;

  return (
    <div>
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: 20,
        }}
      >
        <h2>üìä T·ªïng quan</h2>
        <button
          onClick={onRefresh}
          style={{
            padding: '8px 16px',
            background: '#2196F3',
            color: 'white',
            border: 'none',
            borderRadius: 6,
          }}
        >
          L√†m m·ªõi
        </button>
      </div>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
          gap: 20,
        }}
      >
        <StatCard
          title='Ng∆∞·ªùi d√πng'
          value={cache.usersCount}
        />
        <StatCard
          title='B√†i vi·∫øt'
          value={cache.postsCount}
        />
        <StatCard
          title='B√¨nh lu·∫≠n'
          value={cache.commentsCount}
        />
        <StatCard
          title='C·∫≠p nh·∫≠t l·∫ßn cu·ªëi'
          value={cache.lastUpdated}
        />
      </div>
    </div>
  );
}

function StatCard({ title, value }: { title: string; value: number | string }) {
  return (
    <div
      style={{
        padding: 20,
        background: 'white',
        borderRadius: 12,
        boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        textAlign: 'center',
      }}
    >
      <h4 style={{ margin: '0 0 8px', color: '#555' }}>{title}</h4>
      <p
        style={{
          fontSize: 32,
          fontWeight: 'bold',
          margin: 0,
          color: '#1976d2',
        }}
      >
        {value}
      </p>
    </div>
  );
}

/**
 * Tab Users: B·∫£ng ng∆∞·ªùi d√πng v·ªõi ph√¢n trang & t√¨m ki·∫øm debounce
 */
function UsersTab({
  cache,
  onDataLoad,
  onRefresh,
  shouldLoad,
}: {
  cache: User[] | null;
  onDataLoad: (data: User[]) => void;
  onRefresh: () => void;
  shouldLoad: boolean;
}) {
  const [users, setUsers] = useState<User[]>(cache || []);
  const [loading, setLoading] = useState(!cache);
  const [error, setError] = useState<string | null>(null);
  const [search, setSearch] = useState('');
  const [debouncedSearch, setDebouncedSearch] = useState('');

  // Debounce search (kh√¥ng d√πng useCallback)
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearch(search);
    }, 500);

    return () => clearTimeout(timer);
  }, [search]);

  useEffect(() => {
    if (!shouldLoad || cache) {
      if (cache) setUsers(cache);
      return;
    }

    const controller = new AbortController();

    async function fetchUsers() {
      setLoading(true);
      setError(null);

      try {
        const res = await fetch(`${API_BASE}/users`, {
          signal: controller.signal,
        });
        if (!res.ok) throw new Error('Kh√¥ng t·∫£i ƒë∆∞·ª£c ng∆∞·ªùi d√πng');
        const data: User[] = await res.json();
        setUsers(data);
        onDataLoad(data);
      } catch (err: any) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    }

    fetchUsers();

    return () => controller.abort();
  }, [shouldLoad, cache]);

  const filteredUsers = users.filter(
    (u) =>
      u.name.toLowerCase().includes(debouncedSearch.toLowerCase()) ||
      u.username.toLowerCase().includes(debouncedSearch.toLowerCase()),
  );

  if (loading)
    return (
      <div style={{ padding: '40px', textAlign: 'center' }}>
        ƒêang t·∫£i danh s√°ch ng∆∞·ªùi d√πng...
      </div>
    );
  if (error)
    return (
      <div style={{ color: 'red', padding: '20px' }}>
        {error} <button onClick={onRefresh}>Th·ª≠ l·∫°i</button>
      </div>
    );

  return (
    <div>
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: 20,
        }}
      >
        <h2>üë• Ng∆∞·ªùi d√πng</h2>
        <div style={{ display: 'flex', gap: 12 }}>
          <input
            type='text'
            placeholder='T√¨m theo t√™n ho·∫∑c username...'
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            style={{
              padding: '8px 12px',
              borderRadius: 6,
              border: '1px solid #ddd',
              width: 280,
            }}
          />
          <button
            onClick={onRefresh}
            style={{
              padding: '8px 16px',
              background: '#2196F3',
              color: 'white',
              border: 'none',
              borderRadius: 6,
            }}
          >
            L√†m m·ªõi
          </button>
        </div>
      </div>

      <table
        style={{
          width: '100%',
          borderCollapse: 'collapse',
          background: 'white',
          borderRadius: 8,
          overflow: 'hidden',
        }}
      >
        <thead>
          <tr style={{ background: '#f5f5f5' }}>
            <th style={{ padding: 12, textAlign: 'left' }}>ID</th>
            <th style={{ padding: 12, textAlign: 'left' }}>T√™n</th>
            <th style={{ padding: 12, textAlign: 'left' }}>Username</th>
            <th style={{ padding: 12, textAlign: 'left' }}>Email</th>
          </tr>
        </thead>
        <tbody>
          {filteredUsers.map((user) => (
            <tr
              key={user.id}
              style={{ borderBottom: '1px solid #eee' }}
            >
              <td style={{ padding: 12 }}>{user.id}</td>
              <td style={{ padding: 12 }}>{user.name}</td>
              <td style={{ padding: 12 }}>{user.username}</td>
              <td style={{ padding: 12 }}>{user.email}</td>
            </tr>
          ))}
        </tbody>
      </table>

      {filteredUsers.length === 0 && (
        <p style={{ textAlign: 'center', padding: 40, color: '#777' }}>
          Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng n√†o
        </p>
      )}
    </div>
  );
}

/**
 * Tab Posts: Ch·ªçn user ‚Üí t·∫£i b√†i vi·∫øt t∆∞∆°ng ·ª©ng
 */
function PostsTab({
  cache,
  onDataLoad,
  onRefresh,
  shouldLoad,
}: {
  cache: Post[] | null;
  onDataLoad: (data: Post[]) => void;
  onRefresh: () => void;
  shouldLoad: boolean;
}) {
  const [selectedUserId, setSelectedUserId] = useState<number | null>(null);
  const [posts, setPosts] = useState<Post[]>(cache || []);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [users, setUsers] = useState<User[]>([]);

  // T·∫£i danh s√°ch user cho dropdown
  useEffect(() => {
    async function fetchUsers() {
      try {
        const res = await fetch(`${API_BASE}/users`);
        if (!res.ok) throw new Error('Kh√¥ng t·∫£i ƒë∆∞·ª£c danh s√°ch ng∆∞·ªùi d√πng');
        const data: User[] = await res.json();
        setUsers(data);
      } catch {}
    }
    fetchUsers();
  }, []);

  // T·∫£i b√†i vi·∫øt khi ch·ªçn user
  useEffect(() => {
    if (!shouldLoad || !selectedUserId) return;

    const controller = new AbortController();

    async function fetchPosts() {
      setLoading(true);
      setError(null);

      try {
        const res = await fetch(`${API_BASE}/posts?userId=${selectedUserId}`, {
          signal: controller.signal,
        });
        if (!res.ok) throw new Error('Kh√¥ng t·∫£i ƒë∆∞·ª£c b√†i vi·∫øt');
        const data: Post[] = await res.json();
        setPosts(data);
        onDataLoad(data);
      } catch (err: any) {
        if (err.name !== 'AbortError') {
          setError(err.message);
        }
      } finally {
        setLoading(false);
      }
    }

    fetchPosts();

    return () => controller.abort();
  }, [shouldLoad, selectedUserId]);

  const handleUserChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedUserId(Number(e.target.value) || null);
  };

  return (
    <div>
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: 20,
        }}
      >
        <h2>üìù B√†i vi·∫øt</h2>
        <div style={{ display: 'flex', gap: 12 }}>
          <select
            value={selectedUserId || ''}
            onChange={handleUserChange}
            style={{
              padding: '8px 12px',
              borderRadius: 6,
              border: '1px solid #ddd',
            }}
          >
            <option value=''>Ch·ªçn ng∆∞·ªùi d√πng...</option>
            {users.map((u) => (
              <option
                key={u.id}
                value={u.id}
              >
                {u.name} (@{u.username})
              </option>
            ))}
          </select>
          <button
            onClick={onRefresh}
            style={{
              padding: '8px 16px',
              background: '#2196F3',
              color: 'white',
              border: 'none',
              borderRadius: 6,
            }}
          >
            L√†m m·ªõi
          </button>
        </div>
      </div>

      {loading && (
        <div style={{ padding: '40px', textAlign: 'center' }}>
          ƒêang t·∫£i b√†i vi·∫øt...
        </div>
      )}
      {error && (
        <div style={{ color: 'red', padding: '20px' }}>
          {error} <button onClick={onRefresh}>Th·ª≠ l·∫°i</button>
        </div>
      )}

      {!loading && !error && selectedUserId && (
        <>
          {posts.length === 0 ? (
            <p style={{ textAlign: 'center', padding: 40, color: '#777' }}>
              Ng∆∞·ªùi d√πng n√†y ch∆∞a c√≥ b√†i vi·∫øt n√†o
            </p>
          ) : (
            posts.map((post) => (
              <div
                key={post.id}
                style={{
                  marginBottom: 20,
                  padding: 20,
                  background: 'white',
                  borderRadius: 12,
                  boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                }}
              >
                <h3 style={{ margin: '0 0 12px' }}>{post.title}</h3>
                <p style={{ margin: 0, color: '#555' }}>{post.body}</p>
              </div>
            ))
          )}
        </>
      )}

      {!selectedUserId && !loading && (
        <p style={{ textAlign: 'center', padding: 40, color: '#777' }}>
          Vui l√≤ng ch·ªçn m·ªôt ng∆∞·ªùi d√πng ƒë·ªÉ xem b√†i vi·∫øt
        </p>
      )}
    </div>
  );
}

/**
 * Tab Activity: Polling real-time + toggle b·∫≠t/t·∫Øt
 */
function ActivityTab({
  cache,
  onDataLoad,
  onRefresh,
  shouldLoad,
}: {
  cache: ActivityItem[] | null;
  onDataLoad: (data: ActivityItem[]) => void;
  onRefresh: () => void;
  shouldLoad: boolean;
}) {
  const [activities, setActivities] = useState<ActivityItem[]>(cache || []);
  const [polling, setPolling] = useState<boolean>(true);

  // H√†m gi·∫£ l·∫≠p fetch activity m·ªõi
  const fetchActivity = () => {
    const newItem: ActivityItem = {
      id: Date.now(),
      type: Math.random() > 0.5 ? 'post' : 'comment',
      userId: Math.floor(Math.random() * 10) + 1,
      timestamp: new Date().toLocaleTimeString(),
      message: `Ho·∫°t ƒë·ªông m·ªõi t·ª´ ng∆∞·ªùi d√πng ${Math.floor(Math.random() * 10) + 1}`,
    };

    setActivities((prev) => [newItem, ...prev].slice(0, 20));
    onDataLoad([newItem, ...activities.slice(0, 19)]);
  };

  useEffect(() => {
    if (!shouldLoad || cache) {
      if (cache) setActivities(cache);
      return;
    }

    // Load d·ªØ li·ªáu ban ƒë·∫ßu
    fetchActivity();
  }, [shouldLoad, cache]);

  // Polling
  useEffect(() => {
    if (!polling) return;

    const interval = setInterval(fetchActivity, 10000); // 10 gi√¢y

    return () => clearInterval(interval);
  }, [polling]);

  return (
    <div>
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: 20,
        }}
      >
        <h2>‚ö° Ho·∫°t ƒë·ªông th·ªùi gian th·ª±c</h2>
        <div style={{ display: 'flex', gap: 12 }}>
          <label style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
            <input
              type='checkbox'
              checked={polling}
              onChange={(e) => setPolling(e.target.checked)}
            />
            Polling (10s)
          </label>
          <button
            onClick={onRefresh}
            style={{
              padding: '8px 16px',
              background: '#2196F3',
              color: 'white',
              border: 'none',
              borderRadius: 6,
            }}
          >
            L√†m m·ªõi
          </button>
        </div>
      </div>

      {activities.length === 0 ? (
        <p style={{ textAlign: 'center', padding: 40, color: '#777' }}>
          Ch∆∞a c√≥ ho·∫°t ƒë·ªông n√†o
        </p>
      ) : (
        <div style={{ maxHeight: 600, overflowY: 'auto' }}>
          {activities.map((item) => (
            <div
              key={item.id}
              style={{
                padding: 16,
                marginBottom: 12,
                background: 'white',
                borderRadius: 8,
                borderLeft: `4px solid ${item.type === 'post' ? '#4CAF50' : '#FF9800'}`,
              }}
            >
              <div style={{ fontWeight: 600, marginBottom: 4 }}>
                {item.type === 'post' ? 'üìù ƒêƒÉng b√†i m·ªõi' : 'üí¨ B√¨nh lu·∫≠n'}
              </div>
              <div style={{ fontSize: 14, color: '#555' }}>{item.message}</div>
              <div style={{ fontSize: 12, color: '#999', marginTop: 4 }}>
                Ng∆∞·ªùi d√πng #{item.userId} ‚Ä¢ {item.timestamp}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

export default MultiTabDashboard;
```

**K·∫øt qu·∫£ v√≠ d·ª• khi ch·∫°y:**

- M·ªü trang ‚Üí tab Overview t·ª± ƒë·ªông load ngay, hi·ªÉn th·ªã 4 stat card (users, posts, comments, th·ªùi gian c·∫≠p nh·∫≠t)
- Click tab Users ‚Üí fetch 1 l·∫ßn, hi·ªÉn th·ªã b·∫£ng 10 ng∆∞·ªùi d√πng + √¥ t√¨m ki·∫øm ho·∫°t ƒë·ªông m∆∞·ª£t (debounce 500ms)
- Click tab Posts ‚Üí dropdown hi·ªán danh s√°ch user, ch·ªçn user ‚Üí fetch v√† hi·ªÉn th·ªã b√†i vi·∫øt c·ªßa user ƒë√≥ (kh√¥ng loop)
- Click tab Activity ‚Üí t·ª± ƒë·ªông th√™m ho·∫°t ƒë·ªông m·ªõi m·ªói 10s, c√≥ toggle b·∫≠t/t·∫Øt polling
- Refresh b·∫•t k·ª≥ tab ‚Üí n√∫t "L√†m m·ªõi" x√≥a cache v√† t·∫£i l·∫°i d·ªØ li·ªáu tab ƒë√≥
- Switch tab nhanh ‚Üí request c≈© b·ªã h·ªßy, kh√¥ng l·ªói console
- Unmount component ‚Üí t·∫•t c·∫£ request c√≤n l·∫°i b·ªã abort

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh: Cancellation Strategies

| Strategy            | Code                                                                           | Pros                                      | Cons                                              | Use Case          |
| ------------------- | ------------------------------------------------------------------------------ | ----------------------------------------- | ------------------------------------------------- | ----------------- |
| **Ignore Outdated** | `let isLatest = true;`<br>`return () => { isLatest = false; }`                 | ‚úÖ Simple<br>‚úÖ Works everywhere          | ‚ùå Requests still complete<br>‚ùå Wastes bandwidth | Non-fetch async   |
| **AbortController** | `const ctrl = new AbortController();`<br>`fetch(url, { signal: ctrl.signal })` | ‚úÖ Actually cancels<br>‚úÖ Saves bandwidth | ‚ùå Only for fetch<br>‚ùå Slightly complex          | fetch requests    |
| **Promise Racing**  | `Promise.race([fetch(), timeout()])`                                           | ‚úÖ Timeout control                        | ‚ùå Doesn't cancel<br>‚ùå Complex                   | Timeout scenarios |

### B·∫£ng So S√°nh: Sequential vs Parallel

| Aspect             | Sequential                   | Parallel                 |
| ------------------ | ---------------------------- | ------------------------ |
| **Pattern**        | `await A; await B; await C;` | `Promise.all([A, B, C])` |
| **Timing**         | A ‚Üí B ‚Üí C (cumulative)       | A, B, C (simultaneous)   |
| **Speed**          | ~1500ms (500+500+500)        | ~500ms (max of all)      |
| **Dependencies**   | B depends on A result        | All independent          |
| **Error Handling** | try/catch per request        | Promise.allSettled       |
| **Use When**       | B needs data from A          | All independent data     |

### Decision Tree: Request Strategy

```
C·∫ßn fetch data?
‚îÇ
‚îú‚îÄ Request B depends on data from Request A?
‚îÇ  ‚Üí SEQUENTIAL (await A, then B)
‚îÇ  ‚Üí useEffect deps: [dataA]
‚îÇ  ‚Üí Example: Fetch user ‚Üí Fetch user's posts
‚îÇ
‚îú‚îÄ Multiple INDEPENDENT requests?
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ All must succeed?
‚îÇ  ‚îÇ  ‚Üí Promise.all() - fails if any fails
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Independent failures OK?
‚îÇ     ‚Üí Promise.allSettled() - continues despite failures
‚îÇ     ‚Üí Example: Dashboard stats (show what loaded)
‚îÇ
‚îú‚îÄ User might change input quickly?
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ Each keystroke triggers fetch?
‚îÇ  ‚îÇ  ‚Üí Debounce + AbortController
‚îÇ  ‚îÇ  ‚Üí Example: Search autocomplete
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Each selection triggers fetch?
‚îÇ     ‚Üí AbortController only
‚îÇ     ‚Üí Example: Dropdown filter
‚îÇ
‚îî‚îÄ Long-running request?
   ‚Üí AbortController + timeout
   ‚Üí Example: Large file upload
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug #1: Race Condition - Wrong Data Displayed üèéÔ∏è

```jsx
/**
 * üêõ BUG: User sees wrong user's data
 * üéØ Nhi·ªám v·ª•: Identify and fix race condition
 */

function BuggyUserProfile({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    // ‚ùå NO CANCELLATION!
    async function fetchUser() {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      setUser(data); // ‚Üê N√†o request v·ªÅ tr∆∞·ªõc?
    }

    fetchUser();
  }, [userId]);

  return <div>{user?.name}</div>;
}

// ü§î SCENARIO:
// t=0ms:   userId=1 ‚Üí Request R1 fires (takes 500ms)
// t=100ms: userId=2 ‚Üí Request R2 fires (takes 200ms)
// t=300ms: R2 returns ‚Üí setUser(user2) ‚Üí Display "User 2" ‚úÖ
// t=500ms: R1 returns ‚Üí setUser(user1) ‚Üí Display "User 1" ‚ùå WRONG!

// USER SEES: User 1 (but userId prop = 2!)

// ‚úÖ FIX: AbortController
function Fixed({ userId }) {
  const [user, setUser] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    async function fetchUser() {
      try {
        const response = await fetch(`/api/users/${userId}`, {
          signal: controller.signal,
        });
        const data = await response.json();
        setUser(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(err);
        }
      }
    }

    fetchUser();

    return () => controller.abort();
  }, [userId]);

  // FIXED TIMELINE:
  // t=0ms:   userId=1 ‚Üí R1 fires
  // t=100ms: userId=2 ‚Üí R1 ABORTED, R2 fires
  // t=300ms: R2 returns ‚Üí Display "User 2" ‚úÖ CORRECT!
  // t=500ms: R1 aborted (no update)

  return <div>{user?.name}</div>;
}

// üéì B√ÄI H·ªåC:
// - Race conditions = wrong data displayed
// - AbortController prevents stale updates
// - Always cancel old requests
```

---

### Bug #2: Promise.all() Single Failure üí•

```jsx
/**
 * üêõ BUG: One failed request breaks entire dashboard
 * üéØ Nhi·ªám v·ª•: Fix with Promise.allSettled
 */

function BuggyDashboard() {
  const [stats, setStats] = useState(null);

  useEffect(() => {
    async function fetchStats() {
      // ‚ùå Promise.all fails if ANY request fails
      const [users, posts, comments] = await Promise.all([
        fetch('/api/users').then((r) => r.json()),
        fetch('/api/posts').then((r) => r.json()),
        fetch('/api/comments').then((r) => r.json()), // ‚Üê THIS FAILS!
      ]);

      setStats({ users, posts, comments });
    }

    fetchStats().catch((err) => {
      console.error('Failed to load dashboard:', err);
      // User sees NOTHING, even though users & posts succeeded
    });
  }, []);

  // ...
}

// ü§î PROBLEM:
// - /api/comments returns 500
// - Promise.all() rejects entirely
// - setStats never called
// - User sees error, no data at all
// - ‚ùå Users and Posts data is lost!

// ‚úÖ FIX: Promise.allSettled
function Fixed() {
  const [stats, setStats] = useState({
    users: null,
    posts: null,
    comments: null,
  });

  useEffect(() => {
    async function fetchStats() {
      const results = await Promise.allSettled([
        fetch('/api/users').then((r) => r.json()),
        fetch('/api/posts').then((r) => r.json()),
        fetch('/api/comments').then((r) => r.json()),
      ]);

      const [usersResult, postsResult, commentsResult] = results;

      setStats({
        users: usersResult.status === 'fulfilled' ? usersResult.value : null,
        posts: postsResult.status === 'fulfilled' ? postsResult.value : null,
        comments:
          commentsResult.status === 'fulfilled' ? commentsResult.value : null,
      });
    }

    fetchStats();
  }, []);

  // RESULT:
  // - Users: ‚úÖ Loaded
  // - Posts: ‚úÖ Loaded
  // - Comments: ‚ùå Failed (but others still show!)
  // ‚Üí Partial success! Better UX!

  // ...
}

// üéì B√ÄI H·ªåC:
// - Promise.all() = all-or-nothing
// - Promise.allSettled() = graceful degradation
// - Show what worked, indicate what failed
```

---

### Bug #3: Forgotten Cleanup ‚Üí Memory Leak üíß

```jsx
/**
 * üêõ BUG: Polling continues after unmount
 * üéØ Nhi·ªám v·ª•: Add cleanup
 */

function BuggyLiveStats() {
  const [stats, setStats] = useState(null);

  useEffect(() => {
    // ‚ùå No cleanup for interval!
    const intervalId = setInterval(async () => {
      const response = await fetch('/api/stats');
      const data = await response.json();
      setStats(data); // ‚Üê Continues after unmount!
    }, 5000);

    // ‚ùå Missing return!
  }, []);

  // ...
}

// ü§î PROBLEM:
// - Component mounts ‚Üí Interval starts
// - Component unmounts ‚Üí Interval KEEPS RUNNING
// - setStats called on unmounted component ‚Üí Warning
// - Memory leak (interval never cleared)

// ‚úÖ FIX: Cleanup interval
function Fixed() {
  const [stats, setStats] = useState(null);

  useEffect(() => {
    const controller = new AbortController();

    const intervalId = setInterval(async () => {
      try {
        const response = await fetch('/api/stats', {
          signal: controller.signal,
        });
        const data = await response.json();
        setStats(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(err);
        }
      }
    }, 5000);

    return () => {
      clearInterval(intervalId); // ‚úÖ Clear interval
      controller.abort(); // ‚úÖ Abort in-flight request
    };
  }, []);

  // FIXED:
  // - Unmount ‚Üí Cleanup runs
  // - Interval cleared ‚úÖ
  // - Pending request aborted ‚úÖ
  // - No memory leak ‚úÖ

  // ...
}

// üéì B√ÄI H·ªåC:
// - Polling/intervals ALWAYS need cleanup
// - Cleanup both interval AND pending requests
// - Test unmount behavior
```

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

- [ ] T√¥i hi·ªÉu race conditions v√† t·∫°i sao x·∫£y ra
- [ ] T√¥i bi·∫øt s·ª≠ d·ª•ng AbortController
- [ ] T√¥i ph√¢n bi·ªát ƒë∆∞·ª£c sequential vs parallel
- [ ] T√¥i bi·∫øt khi n√†o d√πng Promise.all vs Promise.allSettled
- [ ] T√¥i c√≥ th·ªÉ implement dependent requests
- [ ] T√¥i handle ƒë∆∞·ª£c stale data issues
- [ ] T√¥i cleanup ƒë∆∞·ª£c all requests properly

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**B√†i 1: GitHub Repos Browser v·ªõi Abort**

- Search organizations
- Fetch repos for selected org
- Cancel old searches
- AbortController cho both

<details><summary>üí° Solution</summary>

```jsx
/**
 * GitHub Repos Browser v·ªõi AbortController
 * - T√¨m ki·∫øm organization
 * - Hi·ªÉn th·ªã danh s√°ch repositories c·ªßa organization ƒë∆∞·ª£c ch·ªçn
 * - Cancel request c≈© khi search ho·∫∑c ch·ªçn org m·ªõi
 * - Minimum 2 k√Ω t·ª± ƒë·ªÉ search
 */
import { useState, useEffect } from 'react';

function GitHubReposBrowser() {
  const [searchQuery, setSearchQuery] = useState('');
  const [orgs, setOrgs] = useState([]);
  const [selectedOrg, setSelectedOrg] = useState(null);
  const [repos, setRepos] = useState([]);

  const [orgsLoading, setOrgsLoading] = useState(false);
  const [reposLoading, setReposLoading] = useState(false);
  const [error, setError] = useState(null);

  // T√¨m ki·∫øm organizations
  useEffect(() => {
    if (searchQuery.length < 2) {
      setOrgs([]);
      setSelectedOrg(null);
      setRepos([]);
      return;
    }

    const controller = new AbortController();

    async function searchOrgs() {
      setOrgsLoading(true);
      setError(null);

      try {
        const res = await fetch(
          `https://api.github.com/search/users?q=${searchQuery}+type:org`,
          { signal: controller.signal },
        );

        if (!res.ok) {
          throw new Error(`GitHub API error: ${res.status}`);
        }

        const data = await res.json();
        const orgItems = data.items || [];
        setOrgs(orgItems);

        // N·∫øu ch·ªâ c√≥ 1 k·∫øt qu·∫£ ‚Üí t·ª± ƒë·ªông ch·ªçn lu√¥n
        if (orgItems.length === 1) {
          setSelectedOrg(orgItems[0].login);
        } else {
          setSelectedOrg(null);
          setRepos([]);
        }
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message || 'Kh√¥ng th·ªÉ t√¨m t·ªï ch·ª©c');
        }
      } finally {
        setOrgsLoading(false);
      }
    }

    // Debounce nh·∫π 400ms
    const timer = setTimeout(() => {
      searchOrgs();
    }, 400);

    return () => {
      clearTimeout(timer);
      controller.abort();
    };
  }, [searchQuery]);

  // Fetch repositories khi ch·ªçn organization
  useEffect(() => {
    if (!selectedOrg) {
      setRepos([]);
      return;
    }

    const controller = new AbortController();

    async function fetchRepos() {
      setReposLoading(true);
      setError(null);

      try {
        const res = await fetch(
          `https://api.github.com/orgs/${selectedOrg}/repos?per_page=30&sort=updated`,
          { signal: controller.signal },
        );

        if (!res.ok) {
          throw new Error(`Kh√¥ng th·ªÉ t·∫£i repositories: ${res.status}`);
        }

        const data = await res.json();
        setRepos(data);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message || 'L·ªói khi t·∫£i repositories');
        }
      } finally {
        setReposLoading(false);
      }
    }

    fetchRepos();

    return () => controller.abort();
  }, [selectedOrg]);

  return (
    <div style={{ maxWidth: '900px', margin: '0 auto', padding: '20px' }}>
      <h2>GitHub Organization Repositories</h2>

      <input
        type='text'
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value.trim())}
        placeholder='T√¨m organization (t·ªëi thi·ªÉu 2 k√Ω t·ª±)...'
        style={{
          width: '100%',
          padding: '12px',
          fontSize: '16px',
          marginBottom: '16px',
        }}
      />

      {orgsLoading && <p>ƒêang t√¨m t·ªï ch·ª©c...</p>}
      {error && <p style={{ color: 'red' }}>{error}</p>}

      {orgs.length > 0 && (
        <div style={{ marginBottom: '24px' }}>
          <label
            style={{
              fontWeight: 'bold',
              display: 'block',
              marginBottom: '8px',
            }}
          >
            K·∫øt qu·∫£ t√¨m th·∫•y ({orgs.length} t·ªï ch·ª©c):
          </label>
          <select
            value={selectedOrg || ''}
            onChange={(e) => setSelectedOrg(e.target.value || null)}
            style={{ width: '100%', padding: '10px', fontSize: '15px' }}
          >
            <option value=''>‚Äî Ch·ªçn m·ªôt organization ‚Äî</option>
            {orgs.map((org) => (
              <option
                key={org.id}
                value={org.login}
              >
                {org.login} {org.name ? `(${org.name})` : ''} ‚Äî{' '}
                {org.public_repos || '?'} repos
              </option>
            ))}
          </select>
        </div>
      )}

      {selectedOrg && (
        <>
          <h3>Repositories c·ªßa {selectedOrg}</h3>

          {reposLoading && <p>ƒêang t·∫£i repositories...</p>}

          {repos.length === 0 && !reposLoading && (
            <p style={{ color: '#666' }}>Kh√¥ng c√≥ repository c√¥ng khai n√†o</p>
          )}

          {repos.length > 0 && (
            <div
              style={{
                maxHeight: '500px',
                overflowY: 'auto',
                border: '1px solid #ddd',
                borderRadius: '6px',
              }}
            >
              {repos.map((repo) => (
                <div
                  key={repo.id}
                  style={{
                    padding: '12px 16px',
                    borderBottom: '1px solid #eee',
                  }}
                >
                  <a
                    href={repo.html_url}
                    target='_blank'
                    rel='noopener noreferrer'
                    style={{
                      fontWeight: 'bold',
                      color: '#0366d6',
                      textDecoration: 'none',
                    }}
                  >
                    {repo.name}
                  </a>
                  <p
                    style={{
                      margin: '6px 0 0 0',
                      color: '#586069',
                      fontSize: '14px',
                    }}
                  >
                    {repo.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}
                  </p>
                  <div
                    style={{
                      marginTop: '8px',
                      fontSize: '13px',
                      color: '#586069',
                    }}
                  >
                    ‚≠ê {repo.stargazers_count} ‚Ä¢ üç¥ {repo.forks_count} ‚Ä¢ Ng√¥n
                    ng·ªØ: {repo.language || '‚Äî'}
                  </div>
                </div>
              ))}
            </div>
          )}
        </>
      )}
    </div>
  );
}

export default GitHubReposBrowser;

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- G√µ "facebook" ‚Üí th·∫•y Facebook, facebookexperimental, facebookarchive...
- Ch·ªçn "facebook" ‚Üí load ~30 repo m·ªõi nh·∫•t (React, create-react-app, jest, relay...)
- G√µ nhanh "micro" ‚Üí "microsoft" ‚Üí "mozilla" ‚Üí ch·ªâ request cu·ªëi c√πng ho√†n th√†nh
- Console th·∫•y c√°c th√¥ng b√°o abort cho request c≈©
- Chuy·ªÉn t·ªï ch·ª©c nhanh ‚Üí repo c≈© b·ªã h·ªßy, kh√¥ng b·ªã l·∫´n d·ªØ li·ªáu
*/
```

</details>

**B√†i 2: Weather + Forecast (Dependent)**

- Fetch current weather by city
- Fetch 5-day forecast (depends on city coords)
- Sequential fetching
- Error handling per step

<details><summary>üí° Solution</summary>

```jsx
/**
 * Weather + Forecast Viewer (Dependent Requests)
 * - Nh·∫≠p t√™n th√†nh ph·ªë ‚Üí fetch th·ªùi ti·∫øt hi·ªán t·∫°i
 * - N·∫øu th√†nh c√¥ng ‚Üí t·ª± ƒë·ªông fetch d·ª± b√°o 5 ng√†y (d·ª±a tr√™n t·ªça ƒë·ªô)
 * - S·ª≠ d·ª•ng AbortController cho c·∫£ 2 request
 * - X·ª≠ l√Ω l·ªói ƒë·ªôc l·∫≠p cho t·ª´ng b∆∞·ªõc
 * - Hi·ªÉn th·ªã loading v√† error ri√™ng bi·ªát
 */

// ‚ö†Ô∏è Ch·ªâ d√πng hard-code cho dev/test.
// Tr√™n production, API_KEY ph·∫£i ƒë∆∞·ª£c l·∫•y t·ª´ bi·∫øn m√¥i tr∆∞·ªùng (env)
const API_KEY = 'a9e8470d6cb139f4ac9635219a59a7e1';

import { useEffect, useState } from 'react';

function WeatherWithForecast() {
  const [city, setCity] = useState('');
  const [currentWeather, setCurrentWeather] = useState(null);
  const [forecast, setForecast] = useState([]);

  const [currentLoading, setCurrentLoading] = useState(false);
  const [forecastLoading, setForecastLoading] = useState(false);

  const [currentError, setCurrentError] = useState(null);
  const [forecastError, setForecastError] = useState(null);

  // Fetch current weather
  useEffect(() => {
    if (!city.trim()) {
      setCurrentWeather(null);
      setForecast([]);
      setCurrentError(null);
      setForecastError(null);
      return;
    }

    const controller = new AbortController();

    async function fetchCurrent() {
      setCurrentLoading(true);
      setCurrentError(null);
      setForecast([]); // reset forecast khi t√¨m th√†nh ph·ªë m·ªõi

      try {
        const res = await fetch(
          `https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(city)}&units=metric&appid=${API_KEY}`,
          { signal: controller.signal },
        );

        if (!res.ok) {
          throw new Error(
            res.status === 404
              ? 'Kh√¥ng t√¨m th·∫•y th√†nh ph·ªë'
              : 'L·ªói API th·ªùi ti·∫øt',
          );
        }

        const data = await res.json();
        setCurrentWeather(data);
        setCurrentLoading(false);

        // Kh√¥ng fetch forecast ·ªü ƒë√¢y ‚Üí ƒë·ªÉ effect ph·ª• thu·ªôc v√†o currentWeather x·ª≠ l√Ω
      } catch (err) {
        if (err.name !== 'AbortError') {
          setCurrentError(err.message);
          setCurrentLoading(false);
        }
      }
    }

    // Debounce nh·∫π 500ms ƒë·ªÉ tr√°nh g·ªçi API li√™n t·ª•c khi g√µ
    const timer = setTimeout(() => {
      fetchCurrent();
    }, 500);

    return () => {
      clearTimeout(timer);
      controller.abort();
    };
  }, [city]);

  // Fetch forecast (dependent - ch·ªâ ch·∫°y khi c√≥ currentWeather)
  useEffect(() => {
    if (!currentWeather?.coord) {
      setForecast([]);
      setForecastError(null);
      return;
    }

    const controller = new AbortController();

    async function fetchForecast() {
      setForecastLoading(true);
      setForecastError(null);

      try {
        const { lat, lon } = currentWeather.coord;
        const res = await fetch(
          `https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&units=metric&cnt=40&appid=${API_KEY}`,
          { signal: controller.signal },
        );

        if (!res.ok) {
          throw new Error('Kh√¥ng th·ªÉ t·∫£i d·ª± b√°o');
        }

        const data = await res.json();
        // L·∫•y 1 forecast m·ªói ng√†y (kho·∫£ng 8 item/ng√†y ‚Üí ch·ªçn item ƒë·∫ßu m·ªói ng√†y)
        const daily = [];
        for (let i = 0; i < data.list.length; i += 8) {
          daily.push(data.list[i]);
        }
        setForecast(daily.slice(0, 5)); // t·ªëi ƒëa 5 ng√†y
      } catch (err) {
        if (err.name !== 'AbortError') {
          setForecastError(err.message);
        }
      } finally {
        setForecastLoading(false);
      }
    }

    fetchForecast();

    return () => controller.abort();
  }, [currentWeather]);

  const formatDate = (timestamp) => {
    return new Date(timestamp * 1000).toLocaleDateString('vi-VN', {
      weekday: 'short',
      day: 'numeric',
      month: 'short',
    });
  };

  return (
    <div style={{ maxWidth: '700px', margin: '0 auto', padding: '20px' }}>
      <h2>Th·ªùi ti·∫øt & D·ª± b√°o 5 ng√†y</h2>

      <input
        type='text'
        value={city}
        onChange={(e) => setCity(e.target.value)}
        placeholder='Nh·∫≠p t√™n th√†nh ph·ªë (v√≠ d·ª•: Hanoi, Saigon, Tokyo)...'
        style={{
          width: '100%',
          padding: '12px',
          fontSize: '16px',
          marginBottom: '20px',
        }}
      />

      {/* Current Weather */}
      <div style={{ marginBottom: '30px' }}>
        <h3>
          Th·ªùi ti·∫øt hi·ªán t·∫°i{' '}
          {currentWeather ? `t·∫°i ${currentWeather.name}` : ''}
        </h3>

        {currentLoading && <p>ƒêang t·∫£i th·ªùi ti·∫øt hi·ªán t·∫°i...</p>}
        {currentError && <p style={{ color: 'red' }}>{currentError}</p>}

        {currentWeather && !currentLoading && (
          <div
            style={{
              padding: '16px',
              background: '#e3f2fd',
              borderRadius: '8px',
              display: 'flex',
              alignItems: 'center',
              gap: '20px',
            }}
          >
            <img
              src={`https://openweathermap.org/img/wn/${currentWeather.weather[0].icon}@2x.png`}
              alt={currentWeather.weather[0].description}
              style={{ width: '80px' }}
            />
            <div>
              <div style={{ fontSize: '32px', fontWeight: 'bold' }}>
                {Math.round(currentWeather.main.temp)}¬∞C
              </div>
              <div style={{ fontSize: '18px', textTransform: 'capitalize' }}>
                {currentWeather.weather[0].description}
              </div>
              <div style={{ color: '#555', marginTop: '8px' }}>
                C·∫£m gi√°c: {Math.round(currentWeather.main.feels_like)}¬∞C ‚Ä¢ ƒê·ªô
                ·∫©m: {currentWeather.main.humidity}% ‚Ä¢ Gi√≥:{' '}
                {currentWeather.wind.speed} m/s
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Forecast */}
      {currentWeather && (
        <div>
          <h3>D·ª± b√°o 5 ng√†y</h3>

          {forecastLoading && <p>ƒêang t·∫£i d·ª± b√°o...</p>}
          {forecastError && <p style={{ color: 'red' }}>{forecastError}</p>}

          {!forecastLoading && !forecastError && forecast.length > 0 && (
            <div
              style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fit, minmax(140px, 1fr))',
                gap: '12px',
              }}
            >
              {forecast.map((day, index) => (
                <div
                  key={index}
                  style={{
                    padding: '12px',
                    background: index === 0 ? '#fff3e0' : '#f5f5f5',
                    borderRadius: '8px',
                    textAlign: 'center',
                  }}
                >
                  <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>
                    {index === 0 ? 'H√¥m nay' : formatDate(day.dt)}
                  </div>
                  <img
                    src={`https://openweathermap.org/img/wn/${day.weather[0].icon}.png`}
                    alt={day.weather[0].description}
                    style={{ width: '50px' }}
                  />
                  <div
                    style={{
                      fontSize: '20px',
                      fontWeight: 'bold',
                      margin: '4px 0',
                    }}
                  >
                    {Math.round(day.main.temp)}¬∞C
                  </div>
                  <div
                    style={{
                      fontSize: '14px',
                      color: '#555',
                      textTransform: 'capitalize',
                    }}
                  >
                    {day.weather[0].description}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

export default WeatherWithForecast;

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- G√µ "Hanoi" ‚Üí sau ~500ms th·∫•y th·ªùi ti·∫øt hi·ªán t·∫°i (nhi·ªát ƒë·ªô, c·∫£m gi√°c, ƒë·ªô ·∫©m, gi√≥...)
- T·ª± ƒë·ªông load d·ª± b√°o 5 ng√†y ‚Üí hi·ªÉn th·ªã l∆∞·ªõi 5 ng√†y (h√¥m nay + 4 ng√†y t·ªõi)
- G√µ nhanh "Saigon" ‚Üí "Tokyo" ‚Üí request c≈© b·ªã abort, ch·ªâ hi·ªÉn th·ªã d·ªØ li·ªáu Tokyo
- Console c√≥ log abort khi g√µ nhanh ho·∫∑c ƒë·ªïi th√†nh ph·ªë
- Nh·∫≠p th√†nh ph·ªë kh√¥ng t·ªìn t·∫°i ‚Üí hi·ªÉn th·ªã l·ªói "Kh√¥ng t√¨m th·∫•y th√†nh ph·ªë" m√† kh√¥ng crash forecast
- Kh√¥ng c√≥ th√†nh ph·ªë ‚Üí kh√¥ng hi·ªÉn th·ªã forecast
*/
```

</details>

---

### N√¢ng cao (60 ph√∫t)

**B√†i 3: Reddit Clone Feed**

- Infinite scroll
- Real-time score updates (polling)
- Filter by subreddit
- Abort all on filter change

<details><summary>üí° Solution</summary>

```jsx
/**
 * Reddit Clone Feed
 * - Infinite scroll v·ªõi IntersectionObserver
 * - Real-time polling c·∫≠p nh·∫≠t score m·ªói 10s
 * - Filter by subreddit v·ªõi AbortController
 * - Vote system (upvote/downvote)
 * - Abort all requests khi filter change
 */
import { useState, useEffect, useRef, useCallback } from 'react';

const API_BASE = 'https://jsonplaceholder.typicode.com';
const POSTS_PER_PAGE = 10;

// Mock subreddits
const SUBREDDITS = [
  { id: 'all', name: 'All', color: '#FF4500' },
  { id: 'react', name: 'r/react', color: '#61DAFB' },
  { id: 'javascript', name: 'r/javascript', color: '#F7DF1E' },
  { id: 'webdev', name: 'r/webdev', color: '#4CAF50' },
  { id: 'programming', name: 'r/programming', color: '#9C27B0' },
];

// Simulate Reddit post structure
function enhancePost(post) {
  return {
    ...post,
    subreddit: SUBREDDITS[Math.floor(Math.random() * SUBREDDITS.length)],
    score: Math.floor(Math.random() * 10000) + 100,
    comments: Math.floor(Math.random() * 500) + 10,
    author: `u/user${post.userId}`,
    timestamp: Date.now() - Math.random() * 86400000 * 7, // Last 7 days
    awards: Math.floor(Math.random() * 5),
  };
}

function RedditCloneFeed() {
  // ==================== STATE ====================

  const [selectedSubreddit, setSelectedSubreddit] = useState('all');
  const [posts, setPosts] = useState([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);

  // Loading states
  const [initialLoading, setInitialLoading] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState(null);

  // Polling state
  const [polling, setPolling] = useState(true);
  const [lastUpdate, setLastUpdate] = useState(Date.now());

  // ==================== REFS ====================

  const observerRef = useRef(null);
  const abortControllersRef = useRef({
    initial: null,
    loadMore: null,
    polling: null,
  });

  // ==================== INTERSECTION OBSERVER ====================

  const lastPostRef = (node) => {
    if (loadingMore) return;

    if (observerRef.current) {
      observerRef.current.disconnect();
    }

    observerRef.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !initialLoading) {
          loadMorePosts();
        }
      },
      { threshold: 1.0 },
    );

    if (node) {
      observerRef.current.observe(node);
    }
  };

  // ==================== DATA FETCHING ====================

  // Initial load (when component mounts or filter changes)
  useEffect(() => {
    // Abort all previous requests
    Object.values(abortControllersRef.current).forEach((ctrl) => {
      if (ctrl) ctrl.abort();
    });

    const controller = new AbortController();
    abortControllersRef.current.initial = controller;

    async function loadInitialPosts() {
      try {
        setInitialLoading(true);
        setError(null);
        setPosts([]);
        setPage(1);
        setHasMore(true);

        console.log(`üîÑ Loading initial posts for: ${selectedSubreddit}`);

        const response = await fetch(
          `${API_BASE}/posts?_page=1&_limit=${POSTS_PER_PAGE}`,
          { signal: controller.signal },
        );

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();

        // Enhance posts with Reddit-like data
        let enhancedPosts = data.map(enhancePost);

        // Filter by subreddit if not "all"
        if (selectedSubreddit !== 'all') {
          enhancedPosts = enhancedPosts.filter(
            (post) => post.subreddit.id === selectedSubreddit,
          );
        }

        setPosts(enhancedPosts);
        setInitialLoading(false);

        console.log(`‚úÖ Loaded ${enhancedPosts.length} posts`);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('‚ùå Failed to load posts:', err);
          setError(err.message || 'Failed to load posts');
          setInitialLoading(false);
        }
      }
    }

    loadInitialPosts();

    return () => {
      controller.abort();
    };
  }, [selectedSubreddit]);

  // Load more posts (infinite scroll)
  async function loadMorePosts() {
    if (loadingMore || !hasMore || initialLoading) return;

    // Abort previous loadMore request if any
    if (abortControllersRef.current.loadMore) {
      abortControllersRef.current.loadMore.abort();
    }

    const controller = new AbortController();
    abortControllersRef.current.loadMore = controller;

    try {
      setLoadingMore(true);

      const nextPage = page + 1;
      console.log(`üì• Loading more posts (page ${nextPage})...`);

      const response = await fetch(
        `${API_BASE}/posts?_page=${nextPage}&_limit=${POSTS_PER_PAGE}`,
        { signal: controller.signal },
      );

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();

      if (data.length === 0) {
        setHasMore(false);
        console.log('üèÅ No more posts to load');
        return;
      }

      // Enhance and filter posts
      let enhancedPosts = data.map(enhancePost);

      if (selectedSubreddit !== 'all') {
        enhancedPosts = enhancedPosts.filter(
          (post) => post.subreddit.id === selectedSubreddit,
        );
      }

      setPosts((prev) => [...prev, ...enhancedPosts]);
      setPage(nextPage);

      console.log(`‚úÖ Loaded ${enhancedPosts.length} more posts`);
    } catch (err) {
      if (err.name !== 'AbortError') {
        console.error('‚ùå Failed to load more:', err);
        // Don't show error, just stop loading
      }
    } finally {
      setLoadingMore(false);
    }
  }

  // Polling: Update scores in real-time
  useEffect(() => {
    if (!polling || posts.length === 0) return;

    const controller = new AbortController();
    abortControllersRef.current.polling = controller;

    const intervalId = setInterval(() => {
      console.log('üîÑ Polling: Updating scores...');

      // Simulate score changes
      setPosts((prevPosts) =>
        prevPosts.map((post) => ({
          ...post,
          score: post.score + Math.floor(Math.random() * 20) - 5, // +/- 5
          comments: post.comments + Math.floor(Math.random() * 3),
        })),
      );

      setLastUpdate(Date.now());
    }, 10000); // Every 10 seconds

    return () => {
      clearInterval(intervalId);
      controller.abort();
    };
  }, [polling, posts.length]);

  // ==================== CLEANUP ON UNMOUNT ====================

  useEffect(() => {
    return () => {
      // Abort all requests on unmount
      Object.values(abortControllersRef.current).forEach((ctrl) => {
        if (ctrl) ctrl.abort();
      });

      // Disconnect observer
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, []);

  // ==================== HELPERS ====================

  const formatScore = (score) => {
    if (score >= 1000) {
      return `${(score / 1000).toFixed(1)}k`;
    }
    return score;
  };

  const formatTime = (timestamp) => {
    const diff = Date.now() - timestamp;
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(hours / 24);

    if (days > 0) return `${days}d ago`;
    if (hours > 0) return `${hours}h ago`;
    return 'just now';
  };

  const formatLastUpdate = () => {
    const seconds = Math.floor((Date.now() - lastUpdate) / 1000);
    return `${seconds}s ago`;
  };

  // ==================== EVENT HANDLERS ====================

  const handleSubredditChange = (subredditId) => {
    if (subredditId === selectedSubreddit) return;

    console.log(`üîÄ Changing subreddit to: ${subredditId}`);
    setSelectedSubreddit(subredditId);
  };

  const handleTogglePolling = () => {
    setPolling((prev) => !prev);
    console.log(`${polling ? '‚è∏Ô∏è Paused' : '‚ñ∂Ô∏è Started'} polling`);
  };

  const handleUpvote = (postId) => {
    setPosts((prevPosts) =>
      prevPosts.map((post) =>
        post.id === postId ? { ...post, score: post.score + 1 } : post,
      ),
    );
  };

  const handleDownvote = (postId) => {
    setPosts((prevPosts) =>
      prevPosts.map((post) =>
        post.id === postId ? { ...post, score: post.score - 1 } : post,
      ),
    );
  };

  // ==================== RENDER ====================

  if (initialLoading) {
    return (
      <div style={styles.loadingContainer}>
        <div style={styles.spinner}>‚è≥</div>
        <p>Loading posts...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div style={styles.errorContainer}>
        <div style={{ fontSize: '48px', marginBottom: '16px' }}>‚ùå</div>
        <p style={{ color: '#d32f2f', fontSize: '18px' }}>Error: {error}</p>
        <button
          onClick={() => setSelectedSubreddit('all')}
          style={styles.retryButton}
        >
          Try Again
        </button>
      </div>
    );
  }

  return (
    <div style={styles.container}>
      {/* Header */}
      <div style={styles.header}>
        <div style={styles.headerLeft}>
          <h1 style={styles.title}>üî¥ Reddit Clone</h1>
          <div style={styles.pollingIndicator}>
            <label style={styles.pollingLabel}>
              <input
                type='checkbox'
                checked={polling}
                onChange={handleTogglePolling}
                style={{ marginRight: '8px' }}
              />
              Live updates
              {polling && (
                <span style={styles.lastUpdate}>
                  (updated {formatLastUpdate()})
                </span>
              )}
            </label>
          </div>
        </div>
      </div>

      {/* Subreddit Filter */}
      <div style={styles.subredditBar}>
        {SUBREDDITS.map((sub) => (
          <button
            key={sub.id}
            onClick={() => handleSubredditChange(sub.id)}
            style={{
              ...styles.subredditButton,
              ...(selectedSubreddit === sub.id
                ? {
                    background: sub.color,
                    color: 'white',
                    fontWeight: 'bold',
                  }
                : {}),
            }}
          >
            {sub.name}
          </button>
        ))}
      </div>

      {/* Posts Feed */}
      <div style={styles.feed}>
        {posts.length === 0 ? (
          <div style={styles.emptyState}>
            <div style={{ fontSize: '48px', marginBottom: '16px' }}>üì≠</div>
            <p>No posts found in {selectedSubreddit}</p>
          </div>
        ) : (
          <>
            {posts.map((post, index) => {
              const isLast = index === posts.length - 1;

              return (
                <div
                  key={post.id}
                  ref={isLast ? lastPostRef : null}
                  style={styles.postCard}
                >
                  {/* Vote Section */}
                  <div style={styles.voteSection}>
                    <button
                      onClick={() => handleUpvote(post.id)}
                      style={styles.voteButton}
                    >
                      ‚¨ÜÔ∏è
                    </button>
                    <div style={styles.score}>{formatScore(post.score)}</div>
                    <button
                      onClick={() => handleDownvote(post.id)}
                      style={styles.voteButton}
                    >
                      ‚¨áÔ∏è
                    </button>
                  </div>

                  {/* Content Section */}
                  <div style={styles.contentSection}>
                    <div style={styles.postMeta}>
                      <span
                        style={{
                          ...styles.subredditTag,
                          background: post.subreddit.color,
                        }}
                      >
                        {post.subreddit.name}
                      </span>
                      <span style={styles.author}>{post.author}</span>
                      <span style={styles.timestamp}>
                        ‚Ä¢ {formatTime(post.timestamp)}
                      </span>
                      {post.awards > 0 && (
                        <span style={styles.awards}>üèÜ {post.awards}</span>
                      )}
                    </div>

                    <h3 style={styles.postTitle}>{post.title}</h3>
                    <p style={styles.postBody}>{post.body}</p>

                    <div style={styles.postActions}>
                      <span style={styles.actionButton}>
                        üí¨ {post.comments} comments
                      </span>
                      <span style={styles.actionButton}>üîó Share</span>
                      <span style={styles.actionButton}>üíæ Save</span>
                    </div>
                  </div>
                </div>
              );
            })}
          </>
        )}

        {/* Loading More Indicator */}
        {loadingMore && (
          <div style={styles.loadingMore}>
            <div style={styles.spinner}>‚è≥</div>
            <p>Loading more posts...</p>
          </div>
        )}

        {/* End of Feed */}
        {!hasMore && posts.length > 0 && (
          <div style={styles.endOfFeed}>
            <p>üèÅ You've reached the end!</p>
            <p style={{ fontSize: '14px', color: '#666', marginTop: '8px' }}>
              Total posts loaded: {posts.length}
            </p>
          </div>
        )}
      </div>

      {/* Debug Info */}
      <div style={styles.debugInfo}>
        <h4>üîß Debug Info:</h4>
        <ul>
          <li>Subreddit: {selectedSubreddit}</li>
          <li>Posts loaded: {posts.length}</li>
          <li>Current page: {page}</li>
          <li>Has more: {hasMore ? 'Yes' : 'No'}</li>
          <li>Polling: {polling ? 'Active' : 'Paused'}</li>
          <li>Loading more: {loadingMore ? 'Yes' : 'No'}</li>
        </ul>
      </div>
    </div>
  );
}

// ==================== STYLES ====================

const styles = {
  container: {
    maxWidth: '800px',
    margin: '0 auto',
    padding: '20px',
    background: '#DAE0E6',
    minHeight: '100vh',
  },

  header: {
    background: 'white',
    padding: '16px 20px',
    borderRadius: '8px',
    marginBottom: '16px',
    boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
  },

  headerLeft: {
    flex: 1,
  },

  title: {
    margin: '0 0 8px 0',
    fontSize: '24px',
    fontWeight: 'bold',
    color: '#FF4500',
  },

  pollingIndicator: {
    fontSize: '14px',
  },

  pollingLabel: {
    display: 'flex',
    alignItems: 'center',
    color: '#666',
  },

  lastUpdate: {
    marginLeft: '8px',
    fontSize: '12px',
    color: '#999',
  },

  subredditBar: {
    background: 'white',
    padding: '12px',
    borderRadius: '8px',
    marginBottom: '16px',
    display: 'flex',
    gap: '8px',
    flexWrap: 'wrap',
    boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
  },

  subredditButton: {
    padding: '8px 16px',
    border: '2px solid #ddd',
    borderRadius: '20px',
    background: 'white',
    cursor: 'pointer',
    fontSize: '14px',
    transition: 'all 0.2s',
  },

  feed: {
    display: 'flex',
    flexDirection: 'column',
    gap: '12px',
  },

  postCard: {
    background: 'white',
    borderRadius: '8px',
    padding: '12px',
    display: 'flex',
    gap: '12px',
    boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
    transition: 'transform 0.2s',
  },

  voteSection: {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: '4px',
    minWidth: '40px',
  },

  voteButton: {
    background: 'none',
    border: 'none',
    cursor: 'pointer',
    fontSize: '18px',
    padding: '4px',
    transition: 'transform 0.1s',
  },

  score: {
    fontWeight: 'bold',
    fontSize: '14px',
    color: '#1A1A1B',
  },

  contentSection: {
    flex: 1,
    minWidth: 0,
  },

  postMeta: {
    display: 'flex',
    alignItems: 'center',
    gap: '8px',
    marginBottom: '8px',
    fontSize: '12px',
    flexWrap: 'wrap',
  },

  subredditTag: {
    padding: '2px 8px',
    borderRadius: '12px',
    color: 'white',
    fontWeight: 'bold',
    fontSize: '11px',
  },

  author: {
    color: '#1A1A1B',
    fontWeight: '500',
  },

  timestamp: {
    color: '#7C7C7C',
  },

  awards: {
    marginLeft: 'auto',
  },

  postTitle: {
    margin: '0 0 8px 0',
    fontSize: '18px',
    fontWeight: '500',
    color: '#1A1A1B',
  },

  postBody: {
    margin: '0 0 12px 0',
    fontSize: '14px',
    color: '#1A1A1B',
    lineHeight: '1.4',
  },

  postActions: {
    display: 'flex',
    gap: '16px',
  },

  actionButton: {
    fontSize: '12px',
    color: '#7C7C7C',
    cursor: 'pointer',
    fontWeight: '500',
  },

  loadingMore: {
    textAlign: 'center',
    padding: '40px 20px',
    color: '#666',
  },

  endOfFeed: {
    textAlign: 'center',
    padding: '40px 20px',
    color: '#666',
    background: 'white',
    borderRadius: '8px',
    marginTop: '20px',
  },

  emptyState: {
    textAlign: 'center',
    padding: '80px 20px',
    color: '#666',
    background: 'white',
    borderRadius: '8px',
  },

  loadingContainer: {
    height: '100vh',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    background: '#DAE0E6',
  },

  errorContainer: {
    height: '100vh',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    background: '#DAE0E6',
  },

  retryButton: {
    marginTop: '16px',
    padding: '12px 24px',
    background: '#FF4500',
    color: 'white',
    border: 'none',
    borderRadius: '8px',
    cursor: 'pointer',
    fontSize: '16px',
  },

  spinner: {
    fontSize: '32px',
    animation: 'spin 1.5s linear infinite',
    marginBottom: '16px',
  },

  debugInfo: {
    marginTop: '30px',
    padding: '20px',
    background: 'white',
    borderRadius: '8px',
    boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
  },
};

export default RedditCloneFeed;

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- M·ªü trang ‚Üí load 10 posts ƒë·∫ßu ti√™n v·ªõi score, comments, vote buttons
- Scroll xu·ªëng cu·ªëi ‚Üí IntersectionObserver trigger ‚Üí load th√™m 10 posts
- Click "r/react" ‚Üí abort old requests ‚Üí fetch l·∫°i posts filtered theo r/react
- ƒê·ª£i 10s v·ªõi polling b·∫≠t ‚Üí score t·ª± ƒë·ªông thay ƒë·ªïi (+/- random), "updated Xs ago" update
- Click ‚¨ÜÔ∏è tr√™n post ‚Üí score +1 ngay l·∫≠p t·ª©c
- Click ‚¨áÔ∏è ‚Üí score -1
- Uncheck "Live updates" ‚Üí polling d·ª´ng, score kh√¥ng thay ƒë·ªïi
- Check l·∫°i ‚Üí polling ti·∫øp t·ª•c
- Switch nhanh gi·ªØa "All" ‚Üí "r/javascript" ‚Üí "r/webdev" ‚Üí ch·ªâ request cu·ªëi c√πng ho√†n th√†nh
- Scroll ƒë·∫øn h·∫øt ‚Üí th·∫•y "üèÅ You've reached the end!" + t·ªïng s·ªë posts
- Console log:
  "üîÑ Loading initial posts for: react"
  "‚úÖ Loaded 10 posts"
  "üì• Loading more posts (page 2)..."
  "‚úÖ Loaded 10 more posts"
  "üîÑ Polling: Updating scores..."
  "üîÄ Changing subreddit to: javascript"
*/
```

</details>

**B√†i 4: Multi-Currency Converter**

- Parallel fetch multiple exchange rates
- Promise.allSettled
- Show partial data
- Refresh individual rates

<details><summary>üí° Solution</summary>

```jsx
/**
 * Multi-Currency Converter
 * - Chuy·ªÉn ƒë·ªïi ƒë·ªìng th·ªùi nhi·ªÅu c·∫∑p ti·ªÅn t·ªá (USD ‚Üí EUR, GBP, JPY, VND, ...)
 * - S·ª≠ d·ª•ng Promise.allSettled ƒë·ªÉ fetch song song, ch·ªãu l·ªói t·ª´ng API ri√™ng
 * - Hi·ªÉn th·ªã k·∫øt qu·∫£ t·ª´ng c·∫∑p ƒë·ªôc l·∫≠p (partial success)
 * - Refresh t·ª´ng c·∫∑p ho·∫∑c refresh t·∫•t c·∫£
 * - AbortController cho m·ªçi request
 * - Input s·ªë ti·ªÅn (base amount) v√† base currency (m·∫∑c ƒë·ªãnh USD)
 */

// ‚ö†Ô∏è Ch·ªâ d√πng hard-code cho dev/test.
// Tr√™n production, API_KEY ph·∫£i ƒë∆∞·ª£c l·∫•y t·ª´ bi·∫øn m√¥i tr∆∞·ªùng (env)
// Thay b·∫±ng key th·∫≠t t·ª´ exchangerate-api.com ho·∫∑c t∆∞∆°ng t·ª±
const API_KEY = '2ceead6e2785c152ede16844';
const API_BASE = `https://v6.exchangerate-api.com/v6/${API_KEY}/latest`;

import { useState, useEffect } from 'react';

function MultiCurrencyConverter() {
  const [baseAmount, setBaseAmount] = useState(100);
  const [baseCurrency, setBaseCurrency] = useState('USD');

  const targetCurrencies = [
    'EUR',
    'GBP',
    'JPY',
    'VND',
    'CAD',
    'AUD',
    'CHF',
    'CNY',
  ];

  const [rates, setRates] = useState({});
  const [loadingStates, setLoadingStates] = useState({});
  const [errors, setErrors] = useState({});

  const fetchRates = async (abortSignal) => {
    const newLoading = {};
    const newErrors = {};
    targetCurrencies.forEach((c) => {
      newLoading[c] = true;
      newErrors[c] = null;
    });
    setLoadingStates(newLoading);
    setErrors(newErrors);

    const promises = targetCurrencies.map(async (target) => {
      try {
        const res = await fetch(`${API_BASE}/${baseCurrency}`, {
          signal: abortSignal,
        });

        if (!res.ok) {
          throw new Error(`HTTP ${res.status}`);
        }

        const data = await res.json();

        if (data.result !== 'success') {
          throw new Error(data['error-type'] || 'API error');
        }

        const rate = data.conversion_rates?.[target];
        if (!rate) {
          throw new Error(`Kh√¥ng c√≥ t·ª∑ gi√° cho ${target}`);
        }

        return { target, rate, success: true };
      } catch (err) {
        if (err.name === 'AbortError') {
          return { target, aborted: true };
        }
        return {
          target,
          error: err.message || 'L·ªói kh√¥ng x√°c ƒë·ªãnh',
          success: false,
        };
      }
    });

    const results = await Promise.allSettled(promises);

    const newRates = {};
    const finalLoading = {};
    const finalErrors = {};

    results.forEach((result, index) => {
      const target = targetCurrencies[index];

      if (result.status === 'fulfilled') {
        const { success, rate, error, aborted } = result.value;

        if (aborted) {
          // Kh√¥ng c·∫≠p nh·∫≠t n·∫øu b·ªã abort
          finalLoading[target] = false;
          return;
        }

        if (success) {
          newRates[target] = rate;
          finalErrors[target] = null;
        } else {
          finalErrors[target] = error;
        }
      } else {
        finalErrors[target] = result.reason?.message || 'Promise rejected';
      }

      finalLoading[target] = false;
    });

    setRates((prev) => ({ ...prev, ...newRates }));
    setLoadingStates((prev) => ({ ...prev, ...finalLoading }));
    setErrors((prev) => ({ ...prev, ...finalErrors }));
  };

  useEffect(() => {
    const controller = new AbortController();

    fetchRates(controller.signal);

    return () => controller.abort();
  }, [baseCurrency]);

  const handleRefreshAll = () => {
    const controller = new AbortController();
    fetchRates(controller.signal);
  };

  const handleRefreshOne = (target) => {
    const controller = new AbortController();

    async function refreshSingle() {
      setLoadingStates((prev) => ({ ...prev, [target]: true }));
      setErrors((prev) => ({ ...prev, [target]: null }));

      try {
        const res = await fetch(`${API_BASE}/${baseCurrency}`, {
          signal: controller.signal,
        });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        const data = await res.json();
        if (data.result !== 'success')
          throw new Error(data['error-type'] || 'API error');

        const rate = data.conversion_rates?.[target];
        if (!rate) throw new Error(`Kh√¥ng c√≥ t·ª∑ gi√°`);

        setRates((prev) => ({ ...prev, [target]: rate }));
        setErrors((prev) => ({ ...prev, [target]: null }));
      } catch (err) {
        if (err.name !== 'AbortError') {
          setErrors((prev) => ({ ...prev, [target]: err.message }));
        }
      } finally {
        setLoadingStates((prev) => ({ ...prev, [target]: false }));
      }
    }

    refreshSingle();

    return () => controller.abort();
  };

  const formatNumber = (num) => {
    return num.toLocaleString('vi-VN', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 4,
    });
  };

  return (
    <div style={{ maxWidth: '900px', margin: '0 auto', padding: '20px' }}>
      <h2>Multi-Currency Converter</h2>

      <div
        style={{
          display: 'flex',
          gap: '16px',
          marginBottom: '24px',
          alignItems: 'flex-end',
        }}
      >
        <div style={{ flex: 1 }}>
          <label
            style={{
              display: 'block',
              marginBottom: '6px',
              fontWeight: 'bold',
            }}
          >
            S·ªë ti·ªÅn
          </label>
          <input
            type='number'
            value={baseAmount}
            onChange={(e) => setBaseAmount(Number(e.target.value) || 0)}
            min='0'
            step='any'
            style={{ width: '100%', padding: '10px', fontSize: '16px' }}
          />
        </div>

        <div style={{ flex: 1 }}>
          <label
            style={{
              display: 'block',
              marginBottom: '6px',
              fontWeight: 'bold',
            }}
          >
            T·ª´ ƒë∆°n v·ªã
          </label>
          <select
            value={baseCurrency}
            onChange={(e) => setBaseCurrency(e.target.value)}
            style={{ width: '100%', padding: '10px', fontSize: '16px' }}
          >
            <option value='USD'>USD - US Dollar</option>
            <option value='EUR'>EUR - Euro</option>
            <option value='GBP'>GBP - British Pound</option>
            <option value='JPY'>JPY - Japanese Yen</option>
            <option value='VND'>VND - Vietnamese Dong</option>
            <option value='CAD'>CAD - Canadian Dollar</option>
            <option value='AUD'>AUD - Australian Dollar</option>
            <option value='CHF'>CHF - Swiss Franc</option>
            <option value='CNY'>CNY - Chinese Yuan</option>
          </select>
        </div>

        <button
          onClick={handleRefreshAll}
          disabled={Object.values(loadingStates).some(Boolean)}
          style={{
            padding: '10px 20px',
            background: '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '6px',
            cursor: 'pointer',
          }}
        >
          Refresh All
        </button>
      </div>

      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(280px, 1fr))',
          gap: '16px',
        }}
      >
        {targetCurrencies.map((target) => {
          const rate = rates[target];
          const converted = baseAmount * (rate || 0);
          const isLoading = loadingStates[target];
          const err = errors[target];

          return (
            <div
              key={target}
              style={{
                padding: '16px',
                border: '1px solid #ddd',
                borderRadius: '8px',
                background: err ? '#fff5f5' : rate ? '#f9fff9' : '#f8f9fa',
              }}
            >
              <div
                style={{
                  fontSize: '18px',
                  fontWeight: 'bold',
                  marginBottom: '8px',
                }}
              >
                {baseCurrency} ‚Üí {target}
              </div>

              {isLoading ? (
                <div>ƒêang t·∫£i t·ª∑ gi√°...</div>
              ) : err ? (
                <div style={{ color: 'red' }}>
                  {err}
                  <button
                    onClick={() => handleRefreshOne(target)}
                    style={{
                      marginLeft: '12px',
                      padding: '4px 12px',
                      fontSize: '12px',
                      background: '#ff9800',
                      color: 'white',
                      border: 'none',
                      borderRadius: '4px',
                      cursor: 'pointer',
                    }}
                  >
                    Th·ª≠ l·∫°i
                  </button>
                </div>
              ) : rate ? (
                <>
                  <div
                    style={{
                      fontSize: '28px',
                      fontWeight: 'bold',
                      color: '#2e7d32',
                    }}
                  >
                    {formatNumber(converted)} {target}
                  </div>
                  <div style={{ color: '#555', marginTop: '4px' }}>
                    1 {baseCurrency} = {formatNumber(rate)} {target}
                  </div>
                </>
              ) : (
                <div>Ch∆∞a c√≥ d·ªØ li·ªáu</div>
              )}

              {!isLoading && !err && rate && (
                <button
                  onClick={() => handleRefreshOne(target)}
                  style={{
                    marginTop: '12px',
                    padding: '6px 12px',
                    fontSize: '13px',
                    background: '#2196F3',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer',
                  }}
                >
                  Refresh {target}
                </button>
              )}
            </div>
          );
        })}
      </div>

      <div style={{ marginTop: '24px', color: '#666', fontSize: '14px' }}>
        <p>
          L∆∞u √Ω: D·ªØ li·ªáu t·ª∑ gi√° l·∫•y t·ª´ exchangerate-api.com (c·∫≠p nh·∫≠t h√†ng
          ng√†y).
        </p>
        <p>API mi·ªÖn ph√≠ c√≥ gi·ªõi h·∫°n ‚Üí thay key th·∫≠t ƒë·ªÉ tr√°nh l·ªói quota.</p>
      </div>
    </div>
  );
}

export default MultiCurrencyConverter;

/* K·∫øt qu·∫£ v√≠ d·ª• khi test:
- M·ªü component ‚Üí th·∫•y 8 th·∫ª chuy·ªÉn ƒë·ªïi t·ª´ USD sang EUR, GBP, JPY, VND... t·ª± ƒë·ªông fetch song song
- M·ªôt v√†i c·∫∑p th√†nh c√¥ng ‚Üí hi·ªÉn th·ªã s·ªë ti·ªÅn quy ƒë·ªïi (v√≠ d·ª•: 100 USD ‚âà 92.5 EUR)
- M·ªôt c·∫∑p l·ªói (gi·∫£ s·ª≠ API quota ho·∫∑c m·∫°ng) ‚Üí th·∫ª ƒë√≥ hi·ªán l·ªói ƒë·ªè + n√∫t "Th·ª≠ l·∫°i"
- ƒê·ªïi baseCurrency sang EUR ‚Üí t·∫•t c·∫£ th·∫ª refresh l·∫°i v·ªõi base EUR
- Nh·∫≠p baseAmount = 500 ‚Üí t·∫•t c·∫£ k·∫øt qu·∫£ t·ª± ƒë·ªông c·∫≠p nh·∫≠t
- Nh·∫•n "Refresh EUR" ‚Üí ch·ªâ fetch l·∫°i t·ª∑ gi√° EUR, c√°c c·∫∑p kh√°c gi·ªØ nguy√™n
- Nh·∫•n "Refresh All" ‚Üí fetch l·∫°i to√†n b·ªô
- ƒê·ªïi nhanh base currency nhi·ªÅu l·∫ßn ‚Üí request c≈© b·ªã abort, kh√¥ng b·ªã l·∫´n k·∫øt qu·∫£
*/
```

</details>

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

1. **AbortController MDN**
   - https://developer.mozilla.org/en-US/docs/Web/API/AbortController

2. **Promise.allSettled**
   - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### ƒê√£ h·ªçc:

- Ng√†y 18: Cleanup
- Ng√†y 19: Basic fetching

### H∆∞·ªõng t·ªõi:

- Ng√†y 21: useRef
- Ng√†y 24: Custom hooks (useAbortableFetch)

---

**üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh Ng√†y 20!**

B·∫°n ƒë√£ master:

- ‚úÖ Race conditions
- ‚úÖ AbortController
- ‚úÖ Dependent requests
- ‚úÖ Parallel optimization
- ‚úÖ Production-ready patterns

**Phase 2 ho√†n th√†nh! Ng√†y mai: useRef fundamentals! üöÄ**
