# ğŸ“… NGÃ€Y 21: useRef - Fundamentals & Mutable Values

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] Hiá»ƒu báº£n cháº¥t cá»§a useRef vÃ  khi nÃ o cáº§n dÃ¹ng thay vÃ¬ useState
- [ ] Náº¯m vá»¯ng cÃ¡ch useRef lÆ°u trá»¯ giÃ¡ trá»‹ mutable khÃ´ng trigger re-render
- [ ] Biáº¿t cÃ¡ch persist values across renders mÃ  khÃ´ng gÃ¢y side effects
- [ ] PhÃ¢n biá»‡t rÃµ rÃ ng use cases cá»§a useRef vs useState
- [ ] Ãp dá»¥ng useRef Ä‘á»ƒ giáº£i quyáº¿t cÃ¡c váº¥n Ä‘á» thá»±c táº¿ nhÆ° tracking previous values, storing timer IDs

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i nÃ y:

1. **Äiá»u gÃ¬ xáº£y ra khi báº¡n update state báº±ng setState?**
   - Component re-render vá»›i giÃ¡ trá»‹ má»›i

2. **useEffect cleanup function cháº¡y khi nÃ o?**
   - TrÆ°á»›c khi effect cháº¡y láº§n tiáº¿p theo hoáº·c khi component unmount

3. **LÃ m sao Ä‘á»ƒ store má»™t giÃ¡ trá»‹ persists across renders nhÆ°ng khÃ´ng muá»‘n trigger re-render khi thay Ä‘á»•i?**
   - ÄÃ¢y chÃ­nh lÃ  váº¥n Ä‘á» useRef giáº£i quyáº¿t! ğŸ¯

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

HÃ£y xem xÃ©t tÃ¬nh huá»‘ng nÃ y:

```jsx
// âŒ Váº¤N Äá»€: Muá»‘n store interval ID Ä‘á»ƒ clear sau nÃ y
function Timer() {
  const [count, setCount] = useState(0);
  let intervalId; // âš ï¸ Sáº½ bá»‹ reset má»—i láº§n render!

  const startTimer = () => {
    intervalId = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    clearInterval(intervalId); // âš ï¸ intervalId luÃ´n lÃ  undefined!
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**Váº¥n Ä‘á»:**

- Biáº¿n `intervalId` Ä‘Æ°á»£c declare láº¡i má»—i láº§n component re-render
- `stopTimer` khÃ´ng thá»ƒ access Ä‘Æ°á»£c `intervalId` tá»« `startTimer`
- Timer khÃ´ng thá»ƒ stop Ä‘Æ°á»£c! ğŸ˜±

**Báº¡n cÃ³ thá»ƒ nghÄ©:** "DÃ¹ng useState Ä‘á»ƒ lÆ°u intervalId?"

```jsx
// âŒ GIáº¢I PHÃP SAI: DÃ¹ng useState
function Timer() {
  const [count, setCount] = useState(0);
  const [intervalId, setIntervalId] = useState(null); // âš ï¸ Overkill!

  const startTimer = () => {
    const id = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
    setIntervalId(id); // âš ï¸ GÃ¢y re-render khÃ´ng cáº§n thiáº¿t!
  };

  const stopTimer = () => {
    clearInterval(intervalId);
    setIntervalId(null); // âš ï¸ Láº¡i re-render!
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**Táº¡i sao sai?**

- `intervalId` khÃ´ng pháº£i UI data, khÃ´ng cáº§n render
- Má»—i láº§n set intervalId â†’ re-render khÃ´ng cáº§n thiáº¿t
- Performance waste! ğŸ“‰

### 1.2 Giáº£i PhÃ¡p: useRef

```jsx
// âœ… GIáº¢I PHÃP ÄÃšNG: DÃ¹ng useRef
import { useState, useRef } from 'react';

function Timer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null); // ğŸ¯ Perfect!

  const startTimer = () => {
    intervalRef.current = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**Táº¡i sao tá»‘t hÆ¡n?**

- `intervalRef.current` persists across renders
- Update `intervalRef.current` KHÃ”NG trigger re-render
- Chá»‰ re-render khi `count` thay Ä‘á»•i (cáº§n thiáº¿t cho UI)

### 1.3 Mental Model

HÃ£y tÆ°á»Ÿng tÆ°á»£ng useRef nhÆ° **má»™t chiáº¿c há»™p cÃ³ ngÄƒn kÃ©o**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   useRef Container              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚   â”‚  .current         â”‚        â”‚ â† NgÄƒn kÃ©o nÃ y luÃ´n á»Ÿ Ä‘Ã³
â”‚   â”‚  (mutable value)  â”‚        â”‚   giá»¯a cÃ¡c láº§n render
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Äáº·c Ä‘iá»ƒm:
âœ… Há»™p (ref object) khÃ´ng bao giá» thay Ä‘á»•i
âœ… NgÄƒn kÃ©o (.current) cÃ³ thá»ƒ má»Ÿ ra vÃ  thay Ä‘á»•i ná»™i dung
âœ… Thay Ä‘á»•i ná»™i dung ngÄƒn kÃ©o KHÃ”NG lÃ m React nháº­n biáº¿t
```

**So sÃ¡nh vá»›i useState:**

```
useState                    useRef
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const [value, setValue]     const ref = useRef(value)
setValue(newValue)          ref.current = newValue
â†’ Trigger re-render        â†’ KHÃ”NG re-render
â†’ Async update             â†’ Sync update
â†’ Cho UI data              â†’ Cho non-UI data
```

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

#### âŒ Hiá»ƒu láº§m 1: "useRef chá»‰ dÃ¹ng Ä‘á»ƒ access DOM"

**Thá»±c táº¿:** useRef cÃ³ 2 use cases chÃ­nh:

1. **Mutable values** (hÃ´m nay há»c)
2. **DOM references** (ngÃ y mai há»c)

```jsx
// âœ… Use case 1: Mutable value
const countRef = useRef(0);
countRef.current += 1; // KhÃ´ng re-render

// âœ… Use case 2: DOM reference (sáº½ há»c ngÃ y mai)
const inputRef = useRef(null);
// <input ref={inputRef} />
```

#### âŒ Hiá»ƒu láº§m 2: "ref.current thay Ä‘á»•i thÃ¬ component re-render"

```jsx
// âŒ SAI: NghÄ© ref.current thay Ä‘á»•i â†’ re-render
function Counter() {
  const countRef = useRef(0);

  const increment = () => {
    countRef.current += 1;
    console.log(countRef.current); // GiÃ¡ trá»‹ tÄƒng
    // âš ï¸ NhÆ°ng UI KHÃ”NG update!
  };

  return (
    <div>
      <p>Count: {countRef.current}</p> {/* LuÃ´n hiá»ƒn thá»‹ 0 */}
      <button onClick={increment}>+1</button>
    </div>
  );
}
```

#### âŒ Hiá»ƒu láº§m 3: "CÃ³ thá»ƒ dÃ¹ng useRef thay useState Ä‘á»ƒ trÃ¡nh re-render"

```jsx
// âŒ ANTI-PATTERN: DÃ¹ng ref cho UI data
function BadCounter() {
  const countRef = useRef(0);

  const increment = () => {
    countRef.current += 1;
    // âš ï¸ UI khÃ´ng update vÃ¬ khÃ´ng re-render!
  };

  return <p>Count: {countRef.current}</p>;
}

// âœ… ÄÃšNG: DÃ¹ng useState cho UI data
function GoodCounter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount((c) => c + 1); // UI updates correctly
  };

  return <p>Count: {count}</p>;
}
```

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Pattern CÆ¡ Báº£n - Tracking Render Count â­

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Äáº¿m sá»‘ láº§n component render
 * ğŸ’¡ Insight: useRef perfect cho tracking mÃ  khÃ´ng gÃ¢y re-render
 */

import { useState, useRef, useEffect } from 'react';

function RenderCounter() {
  const [count, setCount] = useState(0);
  const renderCount = useRef(0);

  // âš ï¸ CHÃš Ã: KhÃ´ng dÃ¹ng useEffect Ä‘á»ƒ increment!
  // VÃ¬ useEffect cháº¡y AFTER render

  // âœ… Increment ngay trong render phase
  renderCount.current += 1;

  console.log(`Render #${renderCount.current}`);

  return (
    <div>
      <h2>Render Counter Demo</h2>
      <p>This component has rendered: {renderCount.current} times</p>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment Count</button>
    </div>
  );
}

// ğŸ” Output khi click button:
// Render #1 (initial)
// Click button â†’ Render #2
// Click button â†’ Render #3
```

**Giáº£i thÃ­ch chi tiáº¿t:**

```jsx
// âŒ SAI: DÃ¹ng useState Ä‘á»ƒ count renders
function BadRenderCounter() {
  const [count, setCount] = useState(0);
  const [renderCount, setRenderCount] = useState(0);

  // âš ï¸ GÃ¢y infinite loop!
  setRenderCount(renderCount + 1); // Trigger re-render â†’ láº¡i gá»i setRenderCount â†’ loop!

  return <p>Renders: {renderCount}</p>;
}

// âŒ SAI: DÃ¹ng biáº¿n thÆ°á»ng
function BadRenderCounter2() {
  const [count, setCount] = useState(0);
  let renderCount = 0; // âš ï¸ Reset vá» 0 má»—i render!

  renderCount += 1; // LuÃ´n lÃ  1

  return <p>Renders: {renderCount}</p>; // LuÃ´n hiá»ƒn thá»‹ 1
}

// âœ… ÄÃšNG: DÃ¹ng useRef
function GoodRenderCounter() {
  const [count, setCount] = useState(0);
  const renderCount = useRef(0);

  renderCount.current += 1; // Persists, khÃ´ng trigger re-render

  return <p>Renders: {renderCount.current}</p>;
}
```

### Demo 2: Ká»‹ch Báº£n Thá»±c Táº¿ - Previous Value Tracking â­â­

```jsx
/**
 * ğŸ¯ Use case: So sÃ¡nh giÃ¡ trá»‹ hiá»‡n táº¡i vá»›i giÃ¡ trá»‹ trÆ°á»›c Ä‘Ã³
 * ğŸ’¼ Real-world: Analytics, change detection, diff calculation
 */

import { useState, useRef, useEffect } from 'react';

function PriceTracker() {
  const [price, setPrice] = useState(100);
  const previousPrice = useRef(price);

  // âœ… Pattern: Update previous value AFTER render
  useEffect(() => {
    previousPrice.current = price;
  }, [price]); // Chá»‰ update khi price thay Ä‘á»•i

  // Calculate change
  const priceChange = price - previousPrice.current;
  const changePercent = ((priceChange / previousPrice.current) * 100).toFixed(
    2,
  );

  // Random price change (demo purpose)
  const updatePrice = () => {
    const change = Math.random() * 20 - 10; // -10 to +10
    setPrice((prev) => Math.max(1, prev + change)); // KhÃ´ng Ã¢m
  };

  return (
    <div style={{ padding: '20px', border: '1px solid #ccc' }}>
      <h2>Stock Price Tracker</h2>

      <div style={{ fontSize: '32px', fontWeight: 'bold' }}>
        ${price.toFixed(2)}
      </div>

      <div
        style={{
          color: priceChange >= 0 ? 'green' : 'red',
          fontSize: '18px',
        }}
      >
        {priceChange >= 0 ? 'â–²' : 'â–¼'}${Math.abs(priceChange).toFixed(2)}(
        {changePercent}%)
      </div>

      <div style={{ marginTop: '10px', color: '#666' }}>
        Previous: ${previousPrice.current.toFixed(2)}
      </div>

      <button
        onClick={updatePrice}
        style={{ marginTop: '10px' }}
      >
        Update Price
      </button>
    </div>
  );
}
```

**Táº¡i sao dÃ¹ng useRef thay vÃ¬ useState?**

```jsx
// âŒ CÃ¡ch 1: DÃ¹ng useState (khÃ´ng tá»‘t)
function BadPriceTracker() {
  const [price, setPrice] = useState(100);
  const [previousPrice, setPreviousPrice] = useState(100);

  const updatePrice = () => {
    setPreviousPrice(price); // âš ï¸ GÃ¢y thÃªm 1 re-render!
    setPrice(newPrice); // âš ï¸ Láº¡i 1 re-render!
    // â†’ 2 renders thay vÃ¬ 1!
  };

  return (
    <div>
      <p>Current: ${price}</p>
      <p>Previous: ${previousPrice}</p>
    </div>
  );
}

// âœ… CÃ¡ch 2: DÃ¹ng useRef (tá»‘t)
function GoodPriceTracker() {
  const [price, setPrice] = useState(100);
  const previousPrice = useRef(100);

  useEffect(() => {
    previousPrice.current = price; // KhÃ´ng gÃ¢y re-render
  }, [price]);

  const updatePrice = () => {
    setPrice(newPrice); // Chá»‰ 1 re-render!
  };

  return (
    <div>
      <p>Current: ${price}</p>
      <p>Previous: ${previousPrice.current}</p>
    </div>
  );
}
```

**Timeline so sÃ¡nh:**

```
useState approach:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Initial render â†’ price: 100, prev: 100
Click button:
  1. setPreviousPrice(100) â†’ Render #2
  2. setPrice(120) â†’ Render #3
â†’ 2 unnecessary renders!

useRef approach:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Initial render â†’ price: 100, prev.current: 100
Click button:
  1. setPrice(120) â†’ Render #2
  2. useEffect: prev.current = 120 (no render)
â†’ Only 1 necessary render!
```

### Demo 3: Edge Cases - Timer Management â­â­â­

```jsx
/**
 * ğŸ¯ Use case: Quáº£n lÃ½ multiple timers, cleanup Ä‘Ãºng cÃ¡ch
 * âš ï¸ Edge cases:
 *    - Start timer nhiá»u láº§n
 *    - Clear timer khi component unmount
 *    - Prevent memory leaks
 */

import { useState, useRef, useEffect } from 'react';

function MultiTimer() {
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);
  const startTimeRef = useRef(null);

  // âœ… Pattern: Start timer
  const startTimer = () => {
    if (intervalRef.current) {
      // âš ï¸ Edge case: Timer already running
      console.warn('Timer is already running!');
      return;
    }

    setIsRunning(true);
    startTimeRef.current = Date.now() - time * 1000; // Resume from current time

    intervalRef.current = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTimeRef.current) / 1000);
      setTime(elapsed);
    }, 100); // Update má»—i 100ms cho smooth
  };

  // âœ… Pattern: Stop timer
  const stopTimer = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
    setIsRunning(false);
  };

  // âœ… Pattern: Reset timer
  const resetTimer = () => {
    stopTimer();
    setTime(0);
    startTimeRef.current = null;
  };

  // âœ… Pattern: Cleanup on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []); // Empty deps = chá»‰ cleanup khi unmount

  // Format time: MM:SS
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div style={{ padding: '20px', textAlign: 'center' }}>
      <h2>Multi Timer with useRef</h2>

      <div
        style={{ fontSize: '48px', fontFamily: 'monospace', margin: '20px 0' }}
      >
        {formatTime(time)}
      </div>

      <div style={{ display: 'flex', gap: '10px', justifyContent: 'center' }}>
        <button
          onClick={startTimer}
          disabled={isRunning}
          style={{ padding: '10px 20px' }}
        >
          Start
        </button>

        <button
          onClick={stopTimer}
          disabled={!isRunning}
          style={{ padding: '10px 20px' }}
        >
          Stop
        </button>

        <button
          onClick={resetTimer}
          style={{ padding: '10px 20px' }}
        >
          Reset
        </button>
      </div>

      {/* Debug info */}
      <div style={{ marginTop: '20px', fontSize: '12px', color: '#666' }}>
        <p>Is Running: {isRunning ? 'Yes' : 'No'}</p>
        <p>Interval ID: {intervalRef.current || 'null'}</p>
      </div>
    </div>
  );
}
```

**Edge Cases Ä‘Æ°á»£c handle:**

```jsx
// âš ï¸ Edge Case 1: Spam start button
const startTimer = () => {
  if (intervalRef.current) {
    // âœ… Prevent multiple intervals
    console.warn('Timer is already running!');
    return;
  }
  // ... start logic
};

// âš ï¸ Edge Case 2: Component unmount khi timer running
useEffect(() => {
  return () => {
    if (intervalRef.current) {
      // âœ… Cleanup Ä‘á»ƒ trÃ¡nh memory leak
      clearInterval(intervalRef.current);
    }
  };
}, []);

// âš ï¸ Edge Case 3: Reset khi Ä‘ang cháº¡y
const resetTimer = () => {
  stopTimer(); // âœ… Stop trÆ°á»›c khi reset
  setTime(0);
  startTimeRef.current = null;
};
```

**Common Mistakes:**

```jsx
// âŒ Mistake 1: KhÃ´ng check timer Ä‘Ã£ running
const badStart = () => {
  // KhÃ´ng check â†’ táº¡o nhiá»u intervals!
  intervalRef.current = setInterval(/* ... */);
};

// âŒ Mistake 2: KhÃ´ng cleanup
// KhÃ´ng cÃ³ useEffect cleanup â†’ memory leak khi unmount!

// âŒ Mistake 3: Clear wrong interval
const badStop = () => {
  clearInterval(intervalRef.current);
  // âš ï¸ QuÃªn set null â†’ ref váº«n giá»¯ invalid ID
};

// âœ… ÄÃšNG:
const goodStop = () => {
  clearInterval(intervalRef.current);
  intervalRef.current = null; // Reset ref
};
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Exercise 1: Click Counter vá»›i Previous Value (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Thá»±c hÃ nh useRef cÆ¡ báº£n vá»›i previous value tracking
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useReducer, useContext, custom hooks
 *
 * Requirements:
 * 1. Hiá»ƒn thá»‹ sá»‘ láº§n click hiá»‡n táº¡i
 * 2. Hiá»ƒn thá»‹ sá»‘ láº§n click trÆ°á»›c Ä‘Ã³
 * 3. Hiá»ƒn thá»‹ difference (current - previous)
 * 4. Button reset vá» 0
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - DÃ¹ng useState cho click count (UI data)
 * - DÃ¹ng useRef cho previous count (non-UI data)
 * - useEffect Ä‘á»ƒ update previous sau má»—i click
 */

// âŒ CÃ¡ch SAI: DÃ¹ng 2 useState
function BadClickCounter() {
  const [count, setCount] = useState(0);
  const [prevCount, setPrevCount] = useState(0);

  const handleClick = () => {
    setPrevCount(count); // âš ï¸ Extra re-render!
    setCount(count + 1); // âš ï¸ Another re-render!
  };

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={handleClick}>Click Me</button>
    </div>
  );
}

// âœ… CÃ¡ch ÄÃšNG: useState + useRef
function GoodClickCounter() {
  // TODO: Implement using useState + useRef
  // Step 1: Create state for current count
  // Step 2: Create ref for previous count
  // Step 3: useEffect to update previous after count changes
  // Step 4: Calculate difference
  // Step 5: Reset button
}

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
function ClickCounter() {
  // TODO: Your implementation here

  return (
    <div style={{ padding: '20px', border: '2px solid #333' }}>
      <h2>Click Counter</h2>

      {/* TODO: Display current count */}
      {/* TODO: Display previous count */}
      {/* TODO: Display difference with color (green if +, red if -) */}

      {/* TODO: Click button */}
      {/* TODO: Reset button */}
    </div>
  );
}

// âœ… Expected behavior:
// Initial: Current: 0, Previous: 0, Diff: 0
// Click 1: Current: 1, Previous: 0, Diff: +1 (green)
// Click 2: Current: 2, Previous: 1, Diff: +1 (green)
// Reset: Current: 0, Previous: 2, Diff: -2 (red)
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Click Counter with Previous Value Tracking
 * @returns {JSX.Element}
 */
function ClickCounter() {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef(0);

  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);

  const difference = count - prevCountRef.current;

  const handleReset = () => {
    setCount(0);
    // prevCountRef sáº½ Ä‘Æ°á»£c cáº­p nháº­t tá»± Ä‘á»™ng qua useEffect
  };

  return (
    <div style={{ padding: '20px', border: '2px solid #333' }}>
      <h2>Click Counter</h2>

      <p>Current: {count}</p>
      <p>Previous: {prevCountRef.current}</p>

      <p
        style={{
          color: difference > 0 ? 'green' : difference < 0 ? 'red' : 'inherit',
        }}
      >
        Difference: {difference > 0 ? '+' : ''}
        {difference}
      </p>

      <div style={{ marginTop: '16px' }}>
        <button
          onClick={() => setCount((c) => c + 1)}
          style={{ marginRight: '12px' }}
        >
          Click Me
        </button>

        <button
          onClick={handleReset}
          style={{
            backgroundColor: '#dc3545',
            color: 'white',
          }}
        >
          Reset
        </button>
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i:

Initial: 
  Current: 0
  Previous: 0
  Difference: 0

Sau 1 láº§n click:
  Current: 1
  Previous: 0
  Difference: +1 (mÃ u xanh)

Sau 2 láº§n click:
  Current: 2
  Previous: 1
  Difference: +1 (mÃ u xanh)

Sau khi Reset:
  Current: 0
  Previous: 2
  Difference: -2 (mÃ u Ä‘á»)
*/
```

</details>

### â­â­ Exercise 2: Debounced Search Input (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Hiá»ƒu khi nÃ o dÃ¹ng useRef vs useState
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario:
 * Báº¡n Ä‘ang build search box. Má»—i láº§n user type, báº¡n muá»‘n gá»i API.
 * NhÆ°ng KHÃ”NG muá»‘n gá»i API má»—i keystroke â†’ dÃ¹ng debounce.
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 *
 * Approach A: DÃ¹ng setTimeout trong useEffect, store timeout ID trong useState
 * Pros:
 * - Straightforward
 * Cons:
 * - setState gÃ¢y unnecessary re-render
 * - Performance waste
 *
 * Approach B: DÃ¹ng setTimeout trong useEffect, store timeout ID trong useRef
 * Pros:
 * - No unnecessary re-renders
 * - Better performance
 * - Timeout ID lÃ  non-UI data
 * Cons:
 * - None (this is the correct approach!)
 *
 * ğŸ’­ Báº N CHá»ŒN GÃŒ VÃ€ Táº I SAO?
 * Document quyáº¿t Ä‘á»‹nh cá»§a báº¡n, sau Ä‘Ã³ implement.
 */

import { useState, useRef, useEffect } from 'react';

function DebouncedSearch() {
  const [searchTerm, setSearchTerm] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);

  // TODO: Decide - useState hay useRef cho timeout ID?
  // const [timeoutId, setTimeoutId] = useState(null); // Approach A?
  // const timeoutRef = useRef(null); // Approach B?

  // TODO: Implement debounced search
  // Requirements:
  // 1. Wait 500ms after user stops typing
  // 2. Then "search" (mock vá»›i setTimeout)
  // 3. Show loading state while searching
  // 4. Display results
  // 5. Clear previous timeout khi user types again

  useEffect(() => {
    // TODO: Your debounce logic here

    // Pattern structure:
    // 1. Clear previous timeout (if exists)
    // 2. If searchTerm empty â†’ clear results, return
    // 3. Set new timeout:
    //    - After 500ms: setIsSearching(true)
    //    - Mock API call (setTimeout 1000ms)
    //    - setSearchResults, setIsSearching(false)

    return () => {
      // TODO: Cleanup
    };
  }, [searchTerm]);

  // Mock search function
  const mockSearch = (term) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        // Fake results
        const results = [
          `Result 1 for "${term}"`,
          `Result 2 for "${term}"`,
          `Result 3 for "${term}"`,
        ];
        resolve(results);
      }, 1000);
    });
  };

  return (
    <div style={{ padding: '20px' }}>
      <h2>Debounced Search</h2>

      <input
        type='text'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder='Type to search...'
        style={{
          width: '300px',
          padding: '10px',
          fontSize: '16px',
        }}
      />

      {isSearching && <p>Searching...</p>}

      <ul>
        {searchResults.map((result, index) => (
          <li key={index}>{result}</li>
        ))}
      </ul>

      {/* Debug info */}
      <div style={{ marginTop: '20px', fontSize: '12px', color: '#666' }}>
        <p>Search term: "{searchTerm}"</p>
        <p>Results count: {searchResults.length}</p>
      </div>
    </div>
  );
}

// ğŸ¯ Expected behavior:
// - Type "react" â†’ wait â†’ see "Searching..." â†’ see results
// - Type "react hooks" â†’ debounce cancels first search â†’ only search "react hooks"
// - Clear input â†’ results disappear immediately
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Debounced Search Input
 * Demonstrates proper use of useRef for timeout management to avoid unnecessary re-renders
 * @returns {JSX.Element}
 */
function DebouncedSearch() {
  const [searchTerm, setSearchTerm] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);

  // Use useRef â†’ timeout ID is not UI data & changing it shouldn't cause re-render
  const timeoutRef = useRef(null);

  useEffect(() => {
    // 1. Clear any existing timeout (previous search)
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }

    // 2. If search term is empty â†’ clear results immediately
    if (!searchTerm.trim()) {
      setSearchResults([]);
      setIsSearching(false);
      return;
    }

    // 3. Set new debounced timeout
    setIsSearching(true);

    timeoutRef.current = setTimeout(async () => {
      try {
        const results = await mockSearch(searchTerm);
        setSearchResults(results);
      } catch (err) {
        console.error('Search failed:', err);
        setSearchResults([]);
      } finally {
        setIsSearching(false);
        timeoutRef.current = null;
      }
    }, 500);

    // 4. Cleanup: clear timeout when effect re-runs or component unmounts
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
    };
  }, [searchTerm]);

  // Mock search function (simulates API delay)
  const mockSearch = (term) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        const results = [
          `Result 1 for "${term}"`,
          `Result 2 for "${term}"`,
          `Result 3 for "${term}"`,
          `Result 4 for "${term}"`,
        ];
        resolve(results);
      }, 1000);
    });
  };

  return (
    <div style={{ padding: '20px' }}>
      <h2>Debounced Search</h2>

      <input
        type='text'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder='Type to search...'
        style={{
          width: '300px',
          padding: '10px',
          fontSize: '16px',
        }}
      />

      {isSearching && (
        <p style={{ color: '#007bff', marginTop: '12px' }}>Searching...</p>
      )}

      {searchResults.length > 0 && (
        <ul style={{ marginTop: '16px', paddingLeft: '20px' }}>
          {searchResults.map((result, index) => (
            <li
              key={index}
              style={{ marginBottom: '8px' }}
            >
              {result}
            </li>
          ))}
        </ul>
      )}

      {searchTerm && searchResults.length === 0 && !isSearching && (
        <p style={{ color: '#666', marginTop: '12px' }}>No results found</p>
      )}

      {/* Debug info */}
      <div style={{ marginTop: '30px', fontSize: '13px', color: '#555' }}>
        <p>Current search term: "{searchTerm}"</p>
        <p>Results count: {searchResults.length}</p>
        <p>Timeout active: {timeoutRef.current ? 'Yes' : 'No'}</p>
      </div>
    </div>
  );
}

/*
Expected behavior:

â€¢ Type "react" slowly â†’ after ~500ms debounce â†’ shows "Searching..." â†’ after ~1s shows 4 results
â€¢ Type quickly "react hooks" â†’ previous timeout is cancelled â†’ only one search for "react hooks" runs
â€¢ Delete all text â†’ results disappear immediately (no loading state)
â€¢ Type â†’ stop for >500ms â†’ search triggers
â€¢ Rapid typing â†’ only the last term (after pause) triggers search
*/
```

</details>

### â­â­â­ Exercise 3: Stopwatch vá»›i Lap Times (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Ká»‹ch báº£n thá»±c táº¿ vá»›i multiple refs
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  má»™t runner, tÃ´i muá»‘n track lap times Ä‘á»ƒ phÃ¢n tÃ­ch performance"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Start/Stop stopwatch
 * - [ ] Record lap times (array)
 * - [ ] Display current lap time
 * - [ ] Display all lap times vá»›i fastest/slowest highlight
 * - [ ] Reset clears everything
 * - [ ] Precise timing (use Date.now() not interval count)
 *
 * ğŸ¨ Technical Constraints:
 * - Chá»‰ dÃ¹ng useState, useRef, useEffect (NgÃ y 11-21)
 * - KHÃ”NG dÃ¹ng useReducer (chÆ°a há»c)
 * - KHÃ”NG dÃ¹ng custom hooks (chÆ°a há»c deep dive)
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Click Start nhiá»u láº§n
 * - Click Lap khi chÆ°a start
 * - Component unmount khi stopwatch Ä‘ang cháº¡y
 * - Lap khi stopwatch Ä‘ang stop
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] Core stopwatch functionality
 * - [ ] Lap recording
 * - [ ] Precise timing calculation
 * - [ ] Fastest/Slowest lap detection
 * - [ ] Edge cases handling
 * - [ ] Cleanup on unmount
 */

import { useState, useRef, useEffect } from 'react';

function Stopwatch() {
  // TODO: State for laps array
  const [laps, setLaps] = useState([]);

  // TODO: State for UI
  const [isRunning, setIsRunning] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);

  // TODO: Refs for timing
  // - intervalRef: store interval ID
  // - startTimeRef: store start timestamp
  // - lastLapTimeRef: store last lap timestamp

  // TODO: Implement start
  const handleStart = () => {
    // Edge case: already running?
  };

  // TODO: Implement stop
  const handleStop = () => {
    // Clear interval, keep time
  };

  // TODO: Implement lap
  const handleLap = () => {
    // Edge case: not running?
    // Calculate lap time
    // Add to laps array
    // Update lastLapTimeRef
  };

  // TODO: Implement reset
  const handleReset = () => {
    // Stop if running
    // Clear all state
    // Reset all refs
  };

  // TODO: Calculate fastest/slowest
  const getFastestLap = () => {
    // Return index of fastest lap
  };

  const getSlowestLap = () => {
    // Return index of slowest lap
  };

  // TODO: Cleanup
  useEffect(() => {
    return () => {
      // Clear interval on unmount
    };
  }, []);

  // Format time helper
  const formatTime = (ms) => {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const milliseconds = Math.floor((ms % 1000) / 10);

    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(2, '0')}`;
  };

  return (
    <div style={{ padding: '20px', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Stopwatch with Laps</h2>

      {/* Main timer display */}
      <div
        style={{
          fontSize: '48px',
          fontFamily: 'monospace',
          textAlign: 'center',
          margin: '20px 0',
          padding: '20px',
          backgroundColor: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        {formatTime(currentTime)}
      </div>

      {/* Control buttons */}
      <div
        style={{
          display: 'flex',
          gap: '10px',
          justifyContent: 'center',
          marginBottom: '20px',
        }}
      >
        {/* TODO: Start/Stop button (toggle based on isRunning) */}
        {/* TODO: Lap button (disabled if not running) */}
        {/* TODO: Reset button */}
      </div>

      {/* Lap times list */}
      <div
        style={{
          maxHeight: '300px',
          overflowY: 'auto',
          border: '1px solid #ccc',
          borderRadius: '4px',
          padding: '10px',
        }}
      >
        <h3>Lap Times</h3>
        {laps.length === 0 ? (
          <p style={{ color: '#999', textAlign: 'center' }}>No laps yet</p>
        ) : (
          <ol style={{ padding: '0 0 0 20px' }}>
            {/* TODO: Map through laps */}
            {/* TODO: Highlight fastest (green) and slowest (red) */}
            {/* Format: "Lap 1: 00:05.23" */}
          </ol>
        )}
      </div>
    </div>
  );
}

// ğŸ¯ Expected behavior:
// 1. Click Start â†’ timer runs
// 2. Click Lap â†’ records lap time, continues timing
// 3. Multiple laps â†’ fastest is green, slowest is red
// 4. Click Stop â†’ timer stops, can resume
// 5. Click Reset â†’ everything clears
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Stopwatch with Lap Times
 * Precise timing using Date.now(), multiple refs for timers, lap tracking, fastest/slowest highlighting
 * @returns {JSX.Element}
 */
function Stopwatch() {
  const [laps, setLaps] = useState([]);
  const [isRunning, setIsRunning] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);

  // Refs for timing control
  const intervalRef = useRef(null);
  const startTimeRef = useRef(null);
  const lastLapTimeRef = useRef(null);

  // Start / Resume
  const handleStart = () => {
    if (isRunning) return; // Prevent multiple intervals

    setIsRunning(true);
    const now = Date.now();
    startTimeRef.current = now - currentTime; // Resume from current time
    lastLapTimeRef.current = lastLapTimeRef.current ?? now;

    intervalRef.current = setInterval(() => {
      setCurrentTime(Date.now() - startTimeRef.current);
    }, 10); // 10ms for smooth display
  };

  // Stop
  const handleStop = () => {
    if (!isRunning) return;

    setIsRunning(false);
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
    // Keep currentTime as is for resume
  };

  // Lap
  const handleLap = () => {
    if (!isRunning) return; // Can't lap when stopped

    const now = Date.now();
    const lapTime = now - (lastLapTimeRef.current || startTimeRef.current);
    lastLapTimeRef.current = now;

    setLaps((prev) => [
      ...prev,
      {
        time: lapTime,
        totalTime: currentTime,
      },
    ]);
  };

  // Reset
  const handleReset = () => {
    handleStop();
    setCurrentTime(0);
    setLaps([]);
    startTimeRef.current = null;
    lastLapTimeRef.current = null;
  };

  // Find fastest & slowest lap indices
  const getFastestLapIndex = () => {
    if (laps.length < 2) return -1;
    let min = laps[0].time;
    let index = 0;
    laps.forEach((lap, i) => {
      if (lap.time < min) {
        min = lap.time;
        index = i;
      }
    });
    return index;
  };

  const getSlowestLapIndex = () => {
    if (laps.length < 2) return -1;
    let max = laps[0].time;
    let index = 0;
    laps.forEach((lap, i) => {
      if (lap.time > max) {
        max = lap.time;
        index = i;
      }
    });
    return index;
  };

  const fastestIndex = getFastestLapIndex();
  const slowestIndex = getSlowestLapIndex();

  // Format time (mm:ss.ss)
  const formatTime = (ms) => {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const centiseconds = Math.floor((ms % 1000) / 10);
    return `${minutes.toString().padStart(2, '0')}:${seconds
      .toString()
      .padStart(2, '0')}.${centiseconds.toString().padStart(2, '0')}`;
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  return (
    <div style={{ padding: '20px', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Stopwatch with Laps</h2>

      {/* Main timer */}
      <div
        style={{
          fontSize: '48px',
          fontFamily: 'monospace',
          textAlign: 'center',
          margin: '20px 0',
          padding: '20px',
          backgroundColor: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        {formatTime(currentTime)}
      </div>

      {/* Controls */}
      <div
        style={{
          display: 'flex',
          gap: '10px',
          justifyContent: 'center',
          marginBottom: '20px',
        }}
      >
        {isRunning ? (
          <button
            onClick={handleStop}
            style={{
              padding: '10px 20px',
              backgroundColor: '#dc3545',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
            }}
          >
            Stop
          </button>
        ) : (
          <button
            onClick={handleStart}
            style={{
              padding: '10px 20px',
              backgroundColor: '#28a745',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
            }}
          >
            {currentTime === 0 ? 'Start' : 'Resume'}
          </button>
        )}

        <button
          onClick={handleLap}
          disabled={!isRunning}
          style={{
            padding: '10px 20px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            opacity: isRunning ? 1 : 0.6,
          }}
        >
          Lap
        </button>

        <button
          onClick={handleReset}
          style={{
            padding: '10px 20px',
            backgroundColor: '#6c757d',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
          }}
        >
          Reset
        </button>
      </div>

      {/* Lap list */}
      <div
        style={{
          maxHeight: '300px',
          overflowY: 'auto',
          border: '1px solid #ccc',
          borderRadius: '4px',
          padding: '10px',
        }}
      >
        <h3>Lap Times</h3>
        {laps.length === 0 ? (
          <p style={{ color: '#999', textAlign: 'center' }}>No laps yet</p>
        ) : (
          <ol style={{ padding: '0 0 0 20px', margin: 0 }}>
            {laps.map((lap, index) => {
              const isFastest = index === fastestIndex;
              const isSlowest = index === slowestIndex;
              const style = {
                color: isFastest ? 'green' : isSlowest ? 'red' : 'inherit',
                fontWeight: isFastest || isSlowest ? 'bold' : 'normal',
              };
              return (
                <li
                  key={index}
                  style={style}
                >
                  Lap {index + 1}: {formatTime(lap.time)} (Total:{' '}
                  {formatTime(lap.totalTime)})
                </li>
              );
            })}
          </ol>
        )}
      </div>
    </div>
  );
}

/*
Expected behavior:

1. Click Start â†’ timer runs smoothly
2. Click Lap â†’ records current lap time, continues timing
3. Multiple laps â†’ fastest lap is green, slowest is red
4. Click Stop â†’ timer pauses, can resume
5. Click Reset â†’ timer and laps clear
6. Edge cases handled:
   - Cannot lap when stopped
   - Cannot start multiple intervals
   - Cleanup on unmount prevents memory leak
   - Precise timing using Date.now()
*/
```

</details>

### â­â­â­â­ Exercise 4: Form with Auto-save (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Architectural decision vá»›i multiple approaches
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Scenario:
 * Build form tá»± Ä‘á»™ng save draft sau khi user stop typing 2 giÃ¢y.
 * Hiá»ƒn thá»‹ last saved time vÃ  saving status.
 *
 * Nhiá»‡m vá»¥:
 * 1. So sÃ¡nh Ã­t nháº¥t 3 approaches:
 *    - Approach A: All useState (including timeout ID)
 *    - Approach B: useState + useRef for timeout
 *    - Approach C: useState + useRef for timeout + last save time
 * 2. Document pros/cons má»—i approach
 * 3. Chá»n approach phÃ¹ há»£p nháº¥t
 * 4. Viáº¿t ADR (Architecture Decision Record)
 *
 * ADR Template:
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Context:
 * - Form cÃ³ nhiá»u fields
 * - Auto-save sau 2s khÃ´ng type
 * - Hiá»ƒn thá»‹ saving status
 * - Hiá»ƒn thá»‹ last saved time
 *
 * Decision: [Approach báº¡n chá»n]
 *
 * Rationale:
 * - [LÃ½ do 1]
 * - [LÃ½ do 2]
 * - [LÃ½ do 3]
 *
 * Consequences:
 * Trade-offs accepted:
 * - [Trade-off 1]
 * - [Trade-off 2]
 *
 * Alternatives Considered:
 * - Approach A: [Brief summary + why rejected]
 * - Approach B: [Brief summary + why rejected]
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 */

import { useState, useRef, useEffect } from 'react';

function AutoSaveForm() {
  // Form data
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    category: 'general',
  });

  // UI states
  const [savingStatus, setSavingStatus] = useState('idle'); // 'idle' | 'saving' | 'saved'
  const [lastSavedAt, setLastSavedAt] = useState(null);

  // TODO: Decide architecture
  // What refs do you need?
  // - Timeout ID?
  // - Last saved data (Ä‘á»ƒ compare)?
  // - Save timestamp?

  // TODO: Implement auto-save logic
  useEffect(() => {
    // Debounce logic (2 seconds)
    // 1. Clear previous timeout
    // 2. Set new timeout
    // 3. Compare current data vá»›i last saved
    // 4. If different â†’ save
    // 5. Update saving status

    return () => {
      // Cleanup
    };
  }, [formData]);

  // Mock save function
  const saveDraft = async (data) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log('Saved:', data);
        resolve();
      }, 1000);
    });
  };

  const handleChange = (field) => (e) => {
    setFormData((prev) => ({
      ...prev,
      [field]: e.target.value,
    }));
  };

  // Manual save
  const handleManualSave = async () => {
    setSavingStatus('saving');
    await saveDraft(formData);
    setSavingStatus('saved');
    setLastSavedAt(new Date());
  };

  // Format last saved time
  const formatLastSaved = () => {
    if (!lastSavedAt) return 'Never';

    const now = Date.now();
    const diff = now - lastSavedAt.getTime();
    const seconds = Math.floor(diff / 1000);

    if (seconds < 60) return `${seconds} seconds ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes} minutes ago`;
    return lastSavedAt.toLocaleTimeString();
  };

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h2>Auto-save Form</h2>

      {/* Saving status indicator */}
      <div
        style={{
          padding: '10px',
          marginBottom: '20px',
          backgroundColor:
            savingStatus === 'saving'
              ? '#fff3cd'
              : savingStatus === 'saved'
                ? '#d1e7dd'
                : '#f8f9fa',
          border: '1px solid',
          borderColor:
            savingStatus === 'saving'
              ? '#ffc107'
              : savingStatus === 'saved'
                ? '#28a745'
                : '#dee2e6',
          borderRadius: '4px',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <span>
          {savingStatus === 'saving' && 'ğŸ’¾ Saving...'}
          {savingStatus === 'saved' && 'âœ… Saved'}
          {savingStatus === 'idle' && 'ğŸ“ Draft'}
        </span>
        <span style={{ fontSize: '12px', color: '#666' }}>
          Last saved: {formatLastSaved()}
        </span>
      </div>

      {/* Form fields */}
      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Title
        </label>
        <input
          type='text'
          value={formData.title}
          onChange={handleChange('title')}
          placeholder='Enter title...'
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            border: '1px solid #ccc',
            borderRadius: '4px',
          }}
        />
      </div>

      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Content
        </label>
        <textarea
          value={formData.content}
          onChange={handleChange('content')}
          placeholder='Enter content...'
          rows={6}
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            border: '1px solid #ccc',
            borderRadius: '4px',
            fontFamily: 'inherit',
          }}
        />
      </div>

      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Category
        </label>
        <select
          value={formData.category}
          onChange={handleChange('category')}
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            border: '1px solid #ccc',
            borderRadius: '4px',
          }}
        >
          <option value='general'>General</option>
          <option value='work'>Work</option>
          <option value='personal'>Personal</option>
        </select>
      </div>

      <button
        onClick={handleManualSave}
        disabled={savingStatus === 'saving'}
        style={{
          padding: '10px 20px',
          fontSize: '16px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: savingStatus === 'saving' ? 'not-allowed' : 'pointer',
          opacity: savingStatus === 'saving' ? 0.6 : 1,
        }}
      >
        Save Now
      </button>

      {/* Debug info */}
      <div
        style={{
          marginTop: '30px',
          padding: '10px',
          backgroundColor: '#f8f9fa',
          borderRadius: '4px',
          fontSize: '12px',
          fontFamily: 'monospace',
        }}
      >
        <p>
          <strong>Debug Info:</strong>
        </p>
        <p>Status: {savingStatus}</p>
        <p>Form Data: {JSON.stringify(formData)}</p>
      </div>
    </div>
  );
}

// ğŸ§ª PHASE 3: Testing (10 phÃºt)
// Manual testing checklist:
// - [ ] Type in title â†’ waits 2s â†’ auto-saves
// - [ ] Type quickly â†’ only saves once after stop typing
// - [ ] Change category â†’ auto-saves
// - [ ] Click "Save Now" â†’ saves immediately
// - [ ] Status indicator updates correctly
// - [ ] Last saved time updates
// - [ ] No unnecessary re-renders (check React DevTools)
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Auto-save Form with Debounced Saving
 * Uses useRef for timeout management to prevent unnecessary re-renders
 * Shows saving status and last saved timestamp
 * @returns {JSX.Element}
 */
function AutoSaveForm() {
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    category: 'general',
  });

  const [savingStatus, setSavingStatus] = useState('idle'); // 'idle' | 'saving' | 'saved'
  const [lastSavedAt, setLastSavedAt] = useState(null);

  // Refs for non-UI mutable values
  const timeoutRef = useRef(null);
  const lastSavedDataRef = useRef(null); // to compare and avoid unnecessary saves

  // Mock save function
  const saveDraft = async (data) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log('Saved draft:', data);
        resolve();
      }, 1000);
    });
  };

  // Format time since last save
  const formatLastSaved = () => {
    if (!lastSavedAt) return 'Never';
    const diffMs = Date.now() - lastSavedAt;
    const seconds = Math.floor(diffMs / 1000);
    if (seconds < 60) return `${seconds} seconds ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes} minutes ago`;
    return new Date(lastSavedAt).toLocaleTimeString();
  };

  // Handle form changes
  const handleChange = (field) => (e) => {
    setFormData((prev) => ({
      ...prev,
      [field]: e.target.value,
    }));
  };

  // Manual save button
  const handleManualSave = async () => {
    setSavingStatus('saving');
    try {
      await saveDraft(formData);
      setLastSavedAt(Date.now());
      lastSavedDataRef.current = { ...formData };
      setSavingStatus('saved');
    } catch (err) {
      console.error('Manual save failed:', err);
      setSavingStatus('idle');
    }
  };

  // Auto-save logic with debounce
  useEffect(() => {
    // Clear any existing timeout
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }

    // Skip save if data hasn't actually changed since last save
    if (
      lastSavedDataRef.current &&
      JSON.stringify(lastSavedDataRef.current) === JSON.stringify(formData)
    ) {
      return;
    }

    // Set new debounced save (2 seconds)
    timeoutRef.current = setTimeout(async () => {
      setSavingStatus('saving');

      try {
        await saveDraft(formData);
        setLastSavedAt(Date.now());
        lastSavedDataRef.current = { ...formData };
        setSavingStatus('saved');

        // Reset to idle after a short delay so user sees "saved" feedback
        setTimeout(() => {
          setSavingStatus('idle');
        }, 2000);
      } catch (err) {
        console.error('Auto-save failed:', err);
        setSavingStatus('idle');
      }
    }, 2000);

    // Cleanup on unmount or when formData changes
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
    };
  }, [formData]);

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h2>Auto-save Form</h2>

      {/* Status indicator */}
      <div
        style={{
          padding: '12px',
          marginBottom: '20px',
          backgroundColor:
            savingStatus === 'saving'
              ? '#fff3cd'
              : savingStatus === 'saved'
                ? '#d1e7dd'
                : '#f8f9fa',
          border: '1px solid',
          borderColor:
            savingStatus === 'saving'
              ? '#ffc107'
              : savingStatus === 'saved'
                ? '#28a745'
                : '#dee2e6',
          borderRadius: '6px',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <span style={{ fontWeight: '500' }}>
          {savingStatus === 'saving' && 'ğŸ’¾ Saving...'}
          {savingStatus === 'saved' && 'âœ… Saved'}
          {savingStatus === 'idle' && 'ğŸ“ Draft ready to save'}
        </span>
        <span style={{ fontSize: '14px', color: '#555' }}>
          Last saved: {formatLastSaved()}
        </span>
      </div>

      {/* Form fields */}
      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '6px', fontWeight: 'bold' }}
        >
          Title
        </label>
        <input
          type='text'
          value={formData.title}
          onChange={handleChange('title')}
          placeholder='Enter title...'
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            borderRadius: '4px',
            border: '1px solid #ccc',
          }}
        />
      </div>

      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '6px', fontWeight: 'bold' }}
        >
          Content
        </label>
        <textarea
          value={formData.content}
          onChange={handleChange('content')}
          placeholder='Enter content...'
          rows={6}
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            borderRadius: '4px',
            border: '1px solid #ccc',
            fontFamily: 'inherit',
          }}
        />
      </div>

      <div style={{ marginBottom: '24px' }}>
        <label
          style={{ display: 'block', marginBottom: '6px', fontWeight: 'bold' }}
        >
          Category
        </label>
        <select
          value={formData.category}
          onChange={handleChange('category')}
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            borderRadius: '4px',
            border: '1px solid #ccc',
          }}
        >
          <option value='general'>General</option>
          <option value='work'>Work</option>
          <option value='personal'>Personal</option>
        </select>
      </div>

      <button
        onClick={handleManualSave}
        disabled={savingStatus === 'saving'}
        style={{
          padding: '12px 24px',
          fontSize: '16px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '6px',
          cursor: savingStatus === 'saving' ? 'not-allowed' : 'pointer',
          opacity: savingStatus === 'saving' ? 0.6 : 1,
        }}
      >
        Save Now
      </button>

      {/* Debug panel */}
      <div
        style={{
          marginTop: '40px',
          padding: '12px',
          backgroundColor: '#f8f9fa',
          borderRadius: '6px',
          fontSize: '13px',
          color: '#444',
        }}
      >
        <strong>Debug Info:</strong>
        <br />
        Status: {savingStatus}
        <br />
        Auto-save timeout active: {timeoutRef.current ? 'Yes' : 'No'}
        <br />
        Form data changed since last save:{' '}
        {lastSavedDataRef.current
          ? JSON.stringify(lastSavedDataRef.current) !==
            JSON.stringify(formData)
          : 'Yes (first save)'}
      </div>
    </div>
  );
}

/*
Expected behavior:

â€¢ Type in any field â†’ after 2 seconds of inactivity â†’ shows "Saving..." â†’ then "Saved" â†’ status returns to idle
â€¢ Rapid typing â†’ only one save attempt after user stops for 2s
â€¢ Changing category also triggers auto-save
â€¢ Click "Save Now" â†’ saves immediately, bypasses debounce
â€¢ If content doesn't change â†’ no unnecessary save attempts
â€¢ Status indicator changes color appropriately
â€¢ Last saved time updates correctly
*/
```

</details>

### â­â­â­â­â­ Exercise 5: Advanced Polling Component (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Production-ready component vá»›i complex ref management
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 *
 * Build má»™t component fetch data tá»« API vá»›i:
 * 1. Auto-refresh má»—i X giÃ¢y (configurable)
 * 2. Pause/Resume polling
 * 3. Manual refresh button
 * 4. Show time since last update
 * 5. Show connection status
 * 6. Handle visibility change (pause khi tab inactive)
 * 7. Exponential backoff on errors
 * 8. Request cancellation
 *
 * ğŸ—ï¸ Technical Design Doc:
 *
 * 1. Component Architecture:
 *    - State: data, loading, error, status, lastUpdate
 *    - Refs: intervalId, retryCount, abortController
 *    - Props: url, interval, onData, onError
 *
 * 2. State Management Strategy:
 *    - useState cho UI-critical data
 *    - useRef cho timers, counters, abort controllers
 *    - KhÃ´ng dÃ¹ng useReducer (chÆ°a há»c)
 *
 * 3. API Integration:
 *    - fetch vá»›i AbortController
 *    - Error handling vá»›i retry logic
 *    - Response validation
 *
 * 4. Performance Considerations:
 *    - Cleanup táº¥t cáº£ subscriptions
 *    - Cancel in-flight requests
 *    - Pause khi tab hidden
 *
 * 5. Error Handling Strategy:
 *    - Try exponential backoff: 1s, 2s, 4s, 8s, 16s
 *    - Max 5 retries
 *    - Reset retry count on success
 *    - Display error message
 *
 * âœ… Production Checklist:
 * - [ ] TypeScript types Ä‘áº§y Ä‘á»§ (á»Ÿ Ä‘Ã¢y dÃ¹ng JSDoc comments)
 * - [ ] Comprehensive error handling
 * - [ ] Loading states
 * - [ ] Empty states
 * - [ ] Edge case handling (rapid pause/resume, unmount during fetch)
 * - [ ] Performance optimization (unnecessary re-renders)
 * - [ ] Memory leak prevention
 * - [ ] Visibility API integration
 * - [ ] Request cancellation
 * - [ ] Console logging cho debugging
 */

import { useState, useRef, useEffect } from 'react';

/**
 * @typedef {Object} PollingConfig
 * @property {string} url - API endpoint
 * @property {number} interval - Polling interval in ms (default: 5000)
 * @property {boolean} pauseOnHidden - Pause when tab hidden (default: true)
 * @property {Function} onData - Callback khi cÃ³ data má»›i
 * @property {Function} onError - Callback khi cÃ³ error
 */

/**
 * Advanced Polling Component
 * @param {PollingConfig} props
 */
function AdvancedPolling({
  url,
  interval = 5000,
  pauseOnHidden = true,
  onData,
  onError,
}) {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STATE MANAGEMENT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [status, setStatus] = useState('idle'); // 'idle' | 'polling' | 'paused' | 'error'
  const [lastUpdate, setLastUpdate] = useState(null);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // REFS FOR NON-UI DATA
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // TODO: Implement refs
  // - intervalRef: store setInterval ID
  // - retryCountRef: track consecutive failures
  // - abortControllerRef: cancel requests
  // - isPausedRef: track pause state (sync with visibility)

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORE FETCHING LOGIC
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const fetchData = async () => {
    // TODO: Implement vá»›i:
    // 1. Check if paused
    // 2. Create AbortController
    // 3. setLoading(true)
    // 4. try-catch fetch
    // 5. Validate response
    // 6. Update data, lastUpdate, reset retryCount
    // 7. Call onData callback
    // 8. catch: handle errors, exponential backoff
    // 9. finally: setLoading(false)
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // POLLING CONTROL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const startPolling = () => {
    // TODO:
    // 1. Check if already polling
    // 2. Clear existing interval
    // 3. Fetch immediately
    // 4. Set up interval
    // 5. Update status
  };

  const pausePolling = () => {
    // TODO:
    // 1. Clear interval
    // 2. Update status
    // 3. Set isPausedRef
  };

  const resumePolling = () => {
    // TODO:
    // 1. Reset isPausedRef
    // 2. Start polling
  };

  const manualRefresh = () => {
    // TODO:
    // 1. Cancel current request if any
    // 2. Reset retry count
    // 3. Fetch immediately
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VISIBILITY CHANGE HANDLING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  useEffect(() => {
    if (!pauseOnHidden) return;

    // TODO: Implement Visibility API
    // 1. Add event listener for 'visibilitychange'
    // 2. If hidden â†’ pause polling
    // 3. If visible â†’ resume polling
    // 4. Cleanup listener

    return () => {
      // Cleanup
    };
  }, [pauseOnHidden]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INITIAL START & CLEANUP
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  useEffect(() => {
    // TODO:
    // 1. Start polling on mount
    // 2. Cleanup everything on unmount
    //    - Clear interval
    //    - Abort in-flight request

    return () => {
      // Critical cleanup
    };
  }, [url, interval]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HELPER: Calculate time since last update
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const getTimeSinceUpdate = () => {
    if (!lastUpdate) return 'Never';

    const diff = Date.now() - lastUpdate;
    const seconds = Math.floor(diff / 1000);

    if (seconds < 60) return `${seconds}s ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m ago`;
    const hours = Math.floor(minutes / 60);
    return `${hours}h ago`;
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HELPER: Get status color
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const getStatusColor = () => {
    switch (status) {
      case 'polling':
        return '#28a745';
      case 'paused':
        return '#ffc107';
      case 'error':
        return '#dc3545';
      default:
        return '#6c757d';
    }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RENDER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  return (
    <div
      style={{
        padding: '20px',
        maxWidth: '800px',
        margin: '0 auto',
        fontFamily: 'system-ui, -apple-system, sans-serif',
      }}
    >
      <h2>Advanced Polling Component</h2>

      {/* Status Bar */}
      <div
        style={{
          padding: '15px',
          marginBottom: '20px',
          backgroundColor: '#f8f9fa',
          border: '2px solid',
          borderColor: getStatusColor(),
          borderRadius: '8px',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <div>
          <span
            style={{
              display: 'inline-block',
              width: '10px',
              height: '10px',
              borderRadius: '50%',
              backgroundColor: getStatusColor(),
              marginRight: '10px',
            }}
          />
          <strong>Status:</strong> {status}
        </div>
        <div style={{ fontSize: '14px', color: '#666' }}>
          Last update: {getTimeSinceUpdate()}
        </div>
      </div>

      {/* Control Buttons */}
      <div
        style={{
          display: 'flex',
          gap: '10px',
          marginBottom: '20px',
        }}
      >
        {status === 'polling' ? (
          <button
            onClick={pausePolling}
            style={{
              padding: '10px 20px',
              backgroundColor: '#ffc107',
              color: '#000',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontWeight: 'bold',
            }}
          >
            â¸ Pause
          </button>
        ) : (
          <button
            onClick={resumePolling}
            style={{
              padding: '10px 20px',
              backgroundColor: '#28a745',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontWeight: 'bold',
            }}
          >
            â–¶ Resume
          </button>
        )}

        <button
          onClick={manualRefresh}
          disabled={loading}
          style={{
            padding: '10px 20px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: loading ? 'not-allowed' : 'pointer',
            opacity: loading ? 0.6 : 1,
            fontWeight: 'bold',
          }}
        >
          ğŸ”„ Refresh Now
        </button>
      </div>

      {/* Loading Indicator */}
      {loading && (
        <div
          style={{
            padding: '10px',
            backgroundColor: '#e3f2fd',
            border: '1px solid #2196f3',
            borderRadius: '4px',
            marginBottom: '20px',
            textAlign: 'center',
          }}
        >
          â³ Fetching data...
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div
          style={{
            padding: '15px',
            backgroundColor: '#f8d7da',
            border: '1px solid #dc3545',
            borderRadius: '4px',
            marginBottom: '20px',
            color: '#721c24',
          }}
        >
          <strong>âŒ Error:</strong> {error}
          <div style={{ marginTop: '10px', fontSize: '14px' }}>
            Retry attempt: {/* TODO: show retryCount */}
          </div>
        </div>
      )}

      {/* Data Display */}
      <div
        style={{
          padding: '20px',
          backgroundColor: 'white',
          border: '1px solid #dee2e6',
          borderRadius: '8px',
          minHeight: '200px',
        }}
      >
        <h3>Data:</h3>
        {data ? (
          <pre
            style={{
              backgroundColor: '#f8f9fa',
              padding: '15px',
              borderRadius: '4px',
              overflow: 'auto',
              fontSize: '14px',
            }}
          >
            {JSON.stringify(data, null, 2)}
          </pre>
        ) : (
          <p style={{ color: '#999', textAlign: 'center' }}>
            No data yet. Waiting for first poll...
          </p>
        )}
      </div>

      {/* Debug Info */}
      <details style={{ marginTop: '20px' }}>
        <summary style={{ cursor: 'pointer', fontWeight: 'bold' }}>
          ğŸ” Debug Information
        </summary>
        <div
          style={{
            marginTop: '10px',
            padding: '15px',
            backgroundColor: '#f8f9fa',
            borderRadius: '4px',
            fontSize: '12px',
            fontFamily: 'monospace',
          }}
        >
          <p>
            <strong>URL:</strong> {url}
          </p>
          <p>
            <strong>Interval:</strong> {interval}ms
          </p>
          <p>
            <strong>Status:</strong> {status}
          </p>
          <p>
            <strong>Loading:</strong> {loading ? 'Yes' : 'No'}
          </p>
          <p>
            <strong>Has Data:</strong> {data ? 'Yes' : 'No'}
          </p>
          <p>
            <strong>Has Error:</strong> {error ? 'Yes' : 'No'}
          </p>
          <p>
            <strong>Pause on Hidden:</strong> {pauseOnHidden ? 'Yes' : 'No'}
          </p>
          {/* TODO: Add more debug info from refs */}
        </div>
      </details>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXAMPLE USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function App() {
  return (
    <AdvancedPolling
      url='https://jsonplaceholder.typicode.com/posts/1'
      interval={5000}
      pauseOnHidden={true}
      onData={(data) => console.log('New data:', data)}
      onError={(error) => console.error('Polling error:', error)}
    />
  );
}

// ğŸ“ Documentation Requirements:
//
// Write a README.md explaining:
// 1. Component API (props)
// 2. Features
// 3. Usage examples
// 4. Edge cases handled
// 5. Performance considerations
//
// ğŸ” Code Review Self-Checklist:
// - [ ] All refs properly initialized
// - [ ] All intervals/timeouts cleared
// - [ ] All requests cancellable
// - [ ] No memory leaks
// - [ ] Error handling comprehensive
// - [ ] Loading states accurate
// - [ ] Status updates correct
// - [ ] Visibility API working
// - [ ] Exponential backoff implemented
// - [ ] Console logs helpful for debugging
// - [ ] Code readable and maintainable
// - [ ] Edge cases handled
// - [ ] Comments explain complex logic
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Advanced Polling Component
 * Features: auto-polling, pause/resume, manual refresh, visibility handling,
 *           exponential backoff on error, request cancellation
 * @param {Object} props
 * @param {string} props.url - API endpoint to poll
 * @param {number} [props.interval=5000] - Polling interval in ms
 * @param {boolean} [props.pauseOnHidden=true] - Pause polling when tab is hidden
 * @param {Function} [props.onData] - Optional callback when new data arrives
 * @param {Function} [props.onError] - Optional callback on error
 */
function AdvancedPolling({
  url,
  interval = 5000,
  pauseOnHidden = true,
  onData,
  onError,
}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [status, setStatus] = useState('idle'); // idle | polling | paused | error

  const [lastUpdate, setLastUpdate] = useState(null);

  // Refs for mutable, non-UI values
  const intervalRef = useRef(null);
  const abortControllerRef = useRef(null);
  const retryCountRef = useRef(0);
  const isPausedRef = useRef(false);
  const isMountedRef = useRef(true);

  // Exponential backoff delays (in ms)
  const backoffDelays = [1000, 2000, 4000, 8000, 16000];

  const fetchData = async (isManual = false) => {
    if (isPausedRef.current && !isManual) return;

    // Cancel any previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    abortControllerRef.current = new AbortController();
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(url, {
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }

      const result = await response.json();

      setData(result);
      setLastUpdate(Date.now());
      setStatus('polling');
      retryCountRef.current = 0; // Reset retry on success

      if (onData) onData(result);
    } catch (err) {
      if (err.name === 'AbortError') return;

      console.error('Fetch error:', err);
      const message = err.message || 'Failed to fetch data';

      setError(message);
      setStatus('error');

      if (onError) onError(err);

      // Exponential backoff retry (only for automatic polling)
      if (!isManual && retryCountRef.current < backoffDelays.length) {
        const delay = backoffDelays[retryCountRef.current];
        retryCountRef.current += 1;

        setTimeout(() => {
          if (isMountedRef.current && !isPausedRef.current) {
            fetchData();
          }
        }, delay);
      }
    } finally {
      setLoading(false);
      abortControllerRef.current = null;
    }
  };

  const startPolling = () => {
    if (intervalRef.current) return;

    isPausedRef.current = false;
    setStatus('polling');

    // Initial fetch
    fetchData();

    // Then set interval
    intervalRef.current = setInterval(() => {
      if (!isPausedRef.current) {
        fetchData();
      }
    }, interval);
  };

  const pausePolling = () => {
    isPausedRef.current = true;
    setStatus('paused');

    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  const resumePolling = () => {
    isPausedRef.current = false;
    setStatus('polling');
    startPolling(); // Will do initial fetch + set new interval
  };

  const manualRefresh = () => {
    fetchData(true); // Force fetch regardless of pause state
  };

  // Handle page visibility
  useEffect(() => {
    if (!pauseOnHidden) return;

    const handleVisibilityChange = () => {
      if (document.hidden) {
        pausePolling();
      } else if (status !== 'paused' && status !== 'error') {
        resumePolling();
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [pauseOnHidden, status]);

  // Main polling lifecycle
  useEffect(() => {
    isMountedRef.current = true;
    startPolling();

    return () => {
      isMountedRef.current = false;

      // Comprehensive cleanup
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }

      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
    };
  }, [url, interval]); // Re-start polling if url or interval changes

  // Helpers
  const getTimeSinceUpdate = () => {
    if (!lastUpdate) return 'Never';
    const diff = Date.now() - lastUpdate;
    const seconds = Math.floor(diff / 1000);
    if (seconds < 60) return `${seconds}s ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m ago`;
    return `${Math.floor(minutes / 60)}h ago`;
  };

  const getStatusColor = () => {
    switch (status) {
      case 'polling':
        return '#28a745';
      case 'paused':
        return '#ffc107';
      case 'error':
        return '#dc3545';
      default:
        return '#6c757d';
    }
  };

  return (
    <div
      style={{
        padding: '20px',
        maxWidth: '800px',
        margin: '0 auto',
        fontFamily: 'system-ui, sans-serif',
      }}
    >
      <h2>Advanced Polling Component</h2>

      {/* Status bar */}
      <div
        style={{
          padding: '14px',
          marginBottom: '20px',
          backgroundColor: '#f8f9fa',
          border: `2px solid ${getStatusColor()}`,
          borderRadius: '8px',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <div
            style={{
              width: '12px',
              height: '12px',
              borderRadius: '50%',
              backgroundColor: getStatusColor(),
            }}
          />
          <strong>Status:</strong>{' '}
          {status.charAt(0).toUpperCase() + status.slice(1)}
          {retryCountRef.current > 0 && status === 'error' && (
            <span style={{ marginLeft: '12px', color: '#dc3545' }}>
              Retry attempt {retryCountRef.current}
            </span>
          )}
        </div>
        <div style={{ fontSize: '14px', color: '#555' }}>
          Last update: {getTimeSinceUpdate()}
        </div>
      </div>

      {/* Controls */}
      <div style={{ display: 'flex', gap: '12px', marginBottom: '24px' }}>
        {status === 'polling' ? (
          <button
            onClick={pausePolling}
            style={{
              padding: '10px 20px',
              backgroundColor: '#ffc107',
              color: '#000',
              border: 'none',
              borderRadius: '6px',
              cursor: 'pointer',
              fontWeight: 600,
            }}
          >
            â¸ Pause
          </button>
        ) : (
          <button
            onClick={resumePolling}
            style={{
              padding: '10px 20px',
              backgroundColor: '#28a745',
              color: 'white',
              border: 'none',
              borderRadius: '6px',
              cursor: 'pointer',
              fontWeight: 600,
            }}
          >
            â–¶ Resume
          </button>
        )}

        <button
          onClick={manualRefresh}
          disabled={loading}
          style={{
            padding: '10px 20px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '6px',
            cursor: loading ? 'not-allowed' : 'pointer',
            opacity: loading ? 0.6 : 1,
            fontWeight: 600,
          }}
        >
          {loading ? 'Fetching...' : 'ğŸ”„ Refresh Now'}
        </button>
      </div>

      {/* Loading */}
      {loading && (
        <div
          style={{
            padding: '12px',
            backgroundColor: '#e3f2fd',
            border: '1px solid #2196f3',
            borderRadius: '6px',
            textAlign: 'center',
            marginBottom: '20px',
          }}
        >
          â³ Fetching latest data...
        </div>
      )}

      {/* Error */}
      {error && (
        <div
          style={{
            padding: '16px',
            backgroundColor: '#f8d7da',
            border: '1px solid #dc3545',
            borderRadius: '6px',
            marginBottom: '20px',
            color: '#721c24',
          }}
        >
          <strong>Error:</strong> {error}
          {retryCountRef.current > 0 && (
            <div style={{ marginTop: '8px', fontSize: '14px' }}>
              Will retry in{' '}
              {Math.round(backoffDelays[retryCountRef.current - 1] / 1000)}s...
            </div>
          )}
        </div>
      )}

      {/* Data display */}
      <div
        style={{
          padding: '20px',
          backgroundColor: 'white',
          border: '1px solid #dee2e6',
          borderRadius: '8px',
          minHeight: '220px',
        }}
      >
        <h3>Data</h3>
        {data ? (
          <pre
            style={{
              backgroundColor: '#f8f9fa',
              padding: '16px',
              borderRadius: '6px',
              overflow: 'auto',
              fontSize: '14px',
            }}
          >
            {JSON.stringify(data, null, 2)}
          </pre>
        ) : (
          <p style={{ color: '#777', textAlign: 'center', marginTop: '60px' }}>
            Waiting for first successful poll...
          </p>
        )}
      </div>
    </div>
  );
}

/*
Expected behavior:

â€¢ Mounts â†’ starts polling immediately
â€¢ Data updates every `interval` ms (default 5000)
â€¢ Pause button â†’ stops polling, status â†’ paused
â€¢ Resume button â†’ restarts polling + immediate fetch
â€¢ Refresh Now â†’ forces fetch even when paused
â€¢ Tab hidden (if pauseOnHidden) â†’ auto-pauses
â€¢ Tab visible again â†’ auto-resumes (if was polling before)
â€¢ Network error â†’ shows error + exponential backoff retries
â€¢ Request in progress â†’ can be cancelled on new request / unmount
â€¢ Unmount â†’ clears interval + aborts fetch â†’ no memory leak
*/
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: useState vs useRef

| TiÃªu chÃ­           | useState                                | useRef                            | Khi nÃ o dÃ¹ng?                                           |
| ------------------ | --------------------------------------- | --------------------------------- | ------------------------------------------------------- |
| **Re-render**      | âœ… Trigger re-render                    | âŒ KHÃ”NG trigger re-render        | useState: UI data<br>useRef: Non-UI data                |
| **Update timing**  | Async (batched)                         | Sync (immediate)                  | useState: Cáº§n consistency<br>useRef: Cáº§n instant access |
| **Purpose**        | UI state management                     | Mutable values persistence        | useState: Hiá»ƒn thá»‹ lÃªn UI<br>useRef: Internal tracking  |
| **Access pattern** | `value`                                 | `ref.current`                     | -                                                       |
| **Persistence**    | âœ… Persists across renders              | âœ… Persists across renders        | Cáº£ hai Ä‘á»u persist                                      |
| **Initial value**  | `useState(initial)`                     | `useRef(initial)`                 | -                                                       |
| **Performance**    | Can cause re-renders                    | No re-render overhead             | useRef: Better cho high-frequency updates               |
| **Use cases**      | Form inputs, toggles, counters hiá»ƒn thá»‹ | Timer IDs, previous values, flags | -                                                       |

### Trade-offs Chi Tiáº¿t

#### âœ… Khi nÃ o PHáº¢I dÃ¹ng useState:

```jsx
// 1. UI data - cáº§n hiá»ƒn thá»‹ lÃªn mÃ n hÃ¬nh
const [count, setCount] = useState(0);
return <p>Count: {count}</p>; // âœ… UI needs this

// 2. Conditional rendering
const [isOpen, setIsOpen] = useState(false);
return isOpen ? <Modal /> : null; // âœ… Affects what renders

// 3. Derived values dÃ¹ng trong JSX
const [items, setItems] = useState([]);
return <p>Total: {items.length}</p>; // âœ… UI depends on this

// 4. Props passed to children
const [theme, setTheme] = useState('dark');
return <Button theme={theme} />; // âœ… Child needs this
```

#### âœ… Khi nÃ o PHáº¢I dÃ¹ng useRef:

```jsx
// 1. Timer/Interval IDs
const intervalRef = useRef(null);
intervalRef.current = setInterval(/* ... */); // âœ… Non-UI, no need to render

// 2. Previous values
const prevCountRef = useRef(count);
useEffect(() => {
  prevCountRef.current = count;
}); // âœ… Tracking, not displaying

// 3. Flags khÃ´ng áº£nh hÆ°á»Ÿng UI
const isMountedRef = useRef(true);
useEffect(() => () => {
  isMountedRef.current = false;
}); // âœ… Internal flag

// 4. Mutable values thay Ä‘á»•i thÆ°á»ng xuyÃªn
const renderCountRef = useRef(0);
renderCountRef.current += 1; // âœ… Would cause infinite loop with useState
```

### Decision Tree

```
                    Cáº§n lÆ°u giÃ¡ trá»‹?
                           â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚                               â”‚
      CÃ³ (persist)                    KhÃ´ng (local variable)
           â”‚
    GiÃ¡ trá»‹ nÃ y hiá»ƒn thá»‹ UI?
           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚
   CÃ³           KhÃ´ng
    â”‚             â”‚
useState       useRef

    VÃ­ dá»¥ useState:      VÃ­ dá»¥ useRef:
    - Counter display    - Timer ID
    - Form values        - Previous value
    - Toggle state       - Render count
    - Loading state      - Abort controller
    - Error message      - Flag variables
```

### Pattern Combinations

#### Pattern 1: useState + useRef cho Derived State

```jsx
// âœ… GOOD: useState cho source, useRef cho derived
function SearchWithHistory() {
  const [searchTerm, setSearchTerm] = useState('');
  const previousSearchRef = useRef('');

  useEffect(() => {
    previousSearchRef.current = searchTerm;
  }, [searchTerm]);

  const searchChanged = searchTerm !== previousSearchRef.current;

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      {searchChanged && <p>Search term changed!</p>}
    </div>
  );
}
```

#### Pattern 2: Multiple Refs cho Related Data

```jsx
// âœ… GOOD: Group related refs
function ComplexTimer() {
  const timerRefs = useRef({
    intervalId: null,
    startTime: null,
    pausedTime: null
  });

  const start = () => {
    timerRefs.current.startTime = Date.now();
    timerRefs.current.intervalId = setInterval(/* ... */);
  };

  const pause = () => {
    timerRefs.current.pausedTime = Date.now();
    clearInterval(timerRefs.current.intervalId);
  };

  return (/* ... */);
}
```

#### Pattern 3: Ref cho Optimization

```jsx
// âœ… GOOD: useRef trÃ¡nh unnecessary re-renders
function ChatRoom() {
  const [messages, setMessages] = useState([]);
  const scrollRef = useRef(null);
  const prevMessagesLengthRef = useRef(messages.length);

  useEffect(() => {
    // Chá»‰ scroll náº¿u cÃ³ message má»›i
    if (messages.length > prevMessagesLengthRef.current) {
      scrollRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
    prevMessagesLengthRef.current = messages.length;
  }, [messages]);

  return (
    <div>
      {messages.map((msg) => (
        <div key={msg.id}>{msg.text}</div>
      ))}
      <div ref={scrollRef} />
    </div>
  );
}
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Stale Ref Value â­

```jsx
// âŒ BUG: Ref value khÃ´ng update nhÆ° mong Ä‘á»£i
function BuggyCounter() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  const logCount = () => {
    console.log('Ref value:', countRef.current); // âš ï¸ LuÃ´n 0!
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <button onClick={logCount}>Log Ref</button>
    </div>
  );
}
```

**ğŸ” Debug Questions:**

1. Táº¡i sao `countRef.current` luÃ´n lÃ  0?
2. Ref Ä‘Æ°á»£c update khi nÃ o?
3. LÃ m sao fix?

**ğŸ’¡ Giáº£i thÃ­ch:**

```jsx
// âŒ Váº¤N Äá»€:
const countRef = useRef(count);
// useRef chá»‰ cháº¡y láº§n Ä‘áº§u (mount)
// count thay Ä‘á»•i nhÆ°ng ref KHÃ”NG tá»± Ä‘á»™ng sync!

// âœ… SOLUTION 1: Manual sync vá»›i useEffect
function FixedCounter() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  useEffect(() => {
    countRef.current = count; // Sync manually
  }, [count]);

  const logCount = () => {
    console.log('Ref value:', countRef.current); // âœ… Correct!
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <button onClick={logCount}>Log Ref</button>
    </div>
  );
}

// âœ… SOLUTION 2: Äá»c trá»±c tiáº¿p tá»« state (náº¿u cÃ³ thá»ƒ)
function BetterCounter() {
  const [count, setCount] = useState(0);

  const logCount = () => {
    console.log('Count value:', count); // âœ… Always correct
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <button onClick={logCount}>Log Count</button>
    </div>
  );
}
```

### Bug 2: Memory Leak - KhÃ´ng Cleanup Timer â­â­

```jsx
// âŒ BUG: Memory leak khi component unmount
function BuggyTimer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null);

  const startTimer = () => {
    intervalRef.current = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  };

  // âš ï¸ THIáº¾U CLEANUP!

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**ğŸ” Debug Questions:**

1. Äiá»u gÃ¬ xáº£y ra náº¿u component unmount khi timer Ä‘ang cháº¡y?
2. LÃ m sao detect memory leak?
3. CÃ¡ch fix Ä‘Ãºng?

**ğŸ’¡ Giáº£i thÃ­ch:**

```jsx
// âŒ Váº¤N Äá»€:
// Component unmount â†’ interval váº«n cháº¡y â†’ call setCount â†’ error + memory leak

// âš ï¸ Error trong console:
// "Warning: Can't perform a React state update on an unmounted component"

// âœ… SOLUTION: useEffect cleanup
function FixedTimer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null);

  const startTimer = () => {
    if (intervalRef.current) return; // Prevent multiple intervals

    intervalRef.current = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  // âœ… Cleanup on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []); // Empty deps = chá»‰ mount/unmount

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**ğŸ” CÃ¡ch test memory leak:**

```jsx
function App() {
  const [showTimer, setShowTimer] = useState(true);

  return (
    <div>
      <button onClick={() => setShowTimer(!showTimer)}>Toggle Timer</button>

      {showTimer && <FixedTimer />}
    </div>
  );
}

// Test steps:
// 1. Start timer
// 2. Click "Toggle Timer" (unmount component)
// 3. Check console - khÃ´ng cÃ³ warning = good!
// 4. Open DevTools â†’ Memory â†’ Take heap snapshot
// 5. Unmount/remount nhiá»u láº§n
// 6. Take another snapshot
// 7. Compare â†’ detached intervals = memory leak
```

### Bug 3: Ref vs State Confusion â­â­â­

```jsx
// âŒ BUG: DÃ¹ng ref cho UI data
function BuggyTodoList() {
  const todosRef = useRef([]);

  const addTodo = (text) => {
    todosRef.current = [...todosRef.current, { id: Date.now(), text }];
    console.log('Todos:', todosRef.current); // âœ… Updated in ref
  };

  return (
    <div>
      <button onClick={() => addTodo('New todo')}>Add Todo</button>

      <ul>
        {todosRef.current.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
      {/* âš ï¸ UI never updates! */}
    </div>
  );
}
```

**ğŸ” Debug Questions:**

1. Táº¡i sao UI khÃ´ng update?
2. Console.log shows correct data nhÆ°ng UI stale?
3. Khi nÃ o thÃ¬ UI update?

**ğŸ’¡ Giáº£i thÃ­ch:**

```jsx
// âŒ Váº¤N Äá»€:
// - todosRef.current thay Ä‘á»•i âœ…
// - NhÆ°ng khÃ´ng trigger re-render âŒ
// - UI chá»‰ render láº§n Ä‘áº§u vá»›i empty array

// âœ… SOLUTION: DÃ¹ng useState cho UI data
function FixedTodoList() {
  const [todos, setTodos] = useState([]);

  const addTodo = (text) => {
    setTodos((prev) => [...prev, { id: Date.now(), text }]); // âœ… Triggers re-render
  };

  return (
    <div>
      <button onClick={() => addTodo('New todo')}>Add Todo</button>

      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}

// ğŸ’¡ QUY Táº®C:
// If it's displayed in JSX â†’ useState
// If it's internal tracking â†’ useRef
```

**Khi nÃ o UI sáº½ update náº¿u dÃ¹ng ref?**

```jsx
function WhenRefUpdates() {
  const countRef = useRef(0);
  const [, forceRender] = useState({});

  const increment = () => {
    countRef.current += 1;
    // UI váº«n khÃ´ng update!
  };

  const incrementAndRender = () => {
    countRef.current += 1;
    forceRender({}); // âœ… Force re-render
    // BÃ¢y giá» UI má»›i update!
  };

  return (
    <div>
      <p>Count: {countRef.current}</p>
      <button onClick={increment}>Increment (no update)</button>
      <button onClick={incrementAndRender}>Increment (with update)</button>
    </div>
  );
}

// âš ï¸ NhÆ°ng Ä‘Ã¢y lÃ  ANTI-PATTERN!
// Náº¿u cáº§n UI update â†’ dÃ¹ng useState!
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u cÃ¡c cÃ¢u báº¡n cÃ³ thá»ƒ tráº£ lá»i tá»± tin:

- [ ] useRef tráº£ vá» gÃ¬ vÃ  object Ä‘Ã³ cÃ³ cáº¥u trÃºc nhÆ° tháº¿ nÃ o?
- [ ] Táº¡i sao update `ref.current` khÃ´ng trigger re-render?
- [ ] Sá»± khÃ¡c biá»‡t chÃ­nh giá»¯a useState vÃ  useRef lÃ  gÃ¬?
- [ ] Khi nÃ o nÃªn dÃ¹ng useRef thay vÃ¬ useState?
- [ ] LÃ m sao track previous value cá»§a má»™t state?
- [ ] Táº¡i sao cáº§n cleanup timers trong useEffect?
- [ ] useRef cÃ³ thá»ƒ thay tháº¿ useState Ä‘á»ƒ tá»‘i Æ°u performance khÃ´ng?
- [ ] Ref object cÃ³ thay Ä‘á»•i giá»¯a cÃ¡c láº§n render khÃ´ng?
- [ ] CÃ³ thá»ƒ dÃ¹ng useRef Ä‘á»ƒ store object/array khÃ´ng?
- [ ] LÃ m sao debug memory leak tá»« timers?

### Code Review Checklist

Khi review code cÃ³ useRef, check:

#### âœ… Correct Usage:

- [ ] DÃ¹ng ref cho non-UI data (timer IDs, flags, previous values)
- [ ] DÃ¹ng state cho UI data
- [ ] Update ref.current synchronously khi cáº§n
- [ ] KhÃ´ng dá»±a vÃ o ref.current Ä‘á»ƒ trigger re-renders

#### âœ… Cleanup:

- [ ] Táº¥t cáº£ timers Ä‘á»u Ä‘Æ°á»£c cleared
- [ ] useEffect cÃ³ return cleanup function
- [ ] Cleanup cháº¡y on unmount vÃ  trÆ°á»›c next effect
- [ ] Refs Ä‘Æ°á»£c reset khi cáº§n (set vá» null)

#### âœ… Edge Cases:

- [ ] Handle multiple starts (prevent duplicate timers)
- [ ] Handle unmount mid-operation
- [ ] Validate ref.current trÆ°á»›c khi dÃ¹ng
- [ ] Consider race conditions

#### âœ… Performance:

- [ ] KhÃ´ng setState unnecessarily
- [ ] Refs Ä‘Æ°á»£c dÃ¹ng Ä‘Ãºng chá»— (khÃ´ng gÃ¢y extra renders)
- [ ] No memory leaks

#### âŒ Common Mistakes:

- [ ] KhÃ´ng dÃ¹ng ref cho UI data
- [ ] KhÃ´ng quÃªn cleanup
- [ ] KhÃ´ng expect ref thay Ä‘á»•i trigger render
- [ ] KhÃ´ng dÃ¹ng ref initial value nhÆ° useState

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

#### Exercise: Custom useTimeout Hook

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Táº¡o custom hook wrap setTimeout
 *
 * Requirements:
 * 1. Hook nháº­n callback vÃ  delay
 * 2. Tá»± Ä‘á»™ng cleanup on unmount
 * 3. CÃ³ thá»ƒ reset timer
 * 4. CÃ³ thá»ƒ cancel timer
 *
 * API:
 * const { reset, cancel } = useTimeout(callback, delay);
 */

// TODO: Implement useTimeout
function useTimeout(callback, delay) {
  // Hints:
  // - useRef cho timeout ID
  // - useRef cho callback (Ä‘á»ƒ trÃ¡nh stale closure)
  // - useEffect Ä‘á»ƒ setup/cleanup
  // - Return reset vÃ  cancel functions
}

// Usage example:
function NotificationDemo() {
  const [show, setShow] = useState(false);

  const { reset, cancel } = useTimeout(() => {
    setShow(false);
  }, 3000);

  const showNotification = () => {
    setShow(true);
    reset(); // Reset timer
  };

  return (
    <div>
      <button onClick={showNotification}>Show Notification</button>
      {show && (
        <div>
          <p>This will disappear in 3 seconds</p>
          <button onClick={cancel}>Keep it</button>
        </div>
      )}
    </div>
  );
}
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom useTimeout Hook
 * Wraps setTimeout with proper cleanup and control methods
 * Uses useRef to store timeout ID and latest callback
 * @param {Function} callback - Function to execute after delay
 * @param {number} delay - Delay in milliseconds (null/undefined to not set timer)
 * @returns {{ reset: Function, cancel: Function }} - Control methods
 */
function useTimeout(callback, delay) {
  const timeoutRef = useRef(null);
  const callbackRef = useRef(callback);

  // Always keep the latest callback in ref (avoid stale closures)
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // Setup / cleanup timeout
  useEffect(() => {
    // If delay is null/undefined â†’ don't set timer
    if (delay == null) {
      return;
    }

    // Clear any existing timeout
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // Set new timeout using latest callback
    timeoutRef.current = setTimeout(() => {
      callbackRef.current();
      timeoutRef.current = null; // Clean up after execution
    }, delay);

    // Cleanup on unmount or when delay/callback changes
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
    };
  }, [delay]); // Re-run when delay changes

  const reset = () => {
    // Clear existing and set new one with current delay
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    if (delay != null) {
      timeoutRef.current = setTimeout(() => {
        callbackRef.current();
        timeoutRef.current = null;
      }, delay);
    }
  };

  const cancel = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };

  return { reset, cancel };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage:
function NotificationDemo() {
  const [show, setShow] = useState(false);

  const { reset, cancel } = useTimeout(() => {
    setShow(false);
  }, 3000);

  const showNotification = () => {
    setShow(true);
    reset(); // (re)start the 3-second timer
  };

  return (
    <div style={{ padding: '20px' }}>
      <button
        onClick={showNotification}
        style={{ padding: '10px 20px', fontSize: '16px' }}
      >
        Show Notification
      </button>

      {show && (
        <div
          style={{
            marginTop: '16px',
            padding: '16px',
            backgroundColor: '#d4edda',
            border: '1px solid #c3e6cb',
            borderRadius: '6px',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
          }}
        >
          <p style={{ margin: 0 }}>
            This notification will disappear in 3 seconds
          </p>
          <button
            onClick={() => {
              cancel();
              // Optional: keep it visible longer or forever
            }}
            style={{
              padding: '6px 12px',
              backgroundColor: '#fff',
              border: '1px solid #28a745',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Keep it
          </button>
        </div>
      )}
    </div>
  );
}

/*
Expected behavior:

â€¢ Click "Show Notification" â†’ message appears + 3s countdown starts
â€¢ After 3 seconds â†’ message disappears automatically
â€¢ Click "Show Notification" again before 3s â†’ timer resets â†’ another full 3s
â€¢ Click "Keep it" â†’ timer cancelled â†’ message stays visible
â€¢ Component unmount â†’ timeout cleaned up (no memory leak)
*/
```

</details>

### NÃ¢ng cao (60 phÃºt)

#### Exercise: Request Deduplication

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Prevent duplicate API requests
 *
 * Scenario:
 * User clicks "Load Data" nhiá»u láº§n nhanh.
 * Báº¡n chá»‰ muá»‘n gá»i API 1 láº§n, cÃ¡c request sau dÃ¹ng láº¡i káº¿t quáº£.
 *
 * Requirements:
 * 1. Track in-flight requests báº±ng ref
 * 2. If request pending â†’ return existing promise
 * 3. If request done â†’ return cached result (for 5s)
 * 4. After 5s â†’ allow new request
 *
 * Bonus:
 * - Support multiple URLs (cache by URL)
 * - Request cancellation
 * - Error handling with retry
 */

function useDeduplicatedFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // TODO: Implement vá»›i useRef
  // - Track pending request
  // - Cache results
  // - Deduplicate logic

  const fetchData = async () => {
    // TODO: Your implementation
  };

  return { data, loading, error, fetchData };
}
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * useDeduplicatedFetch - Hook with request deduplication & short-term caching
 * Prevents duplicate in-flight requests for the same URL
 * Caches successful result for 5 seconds
 * Supports cancellation via AbortController
 * @param {string} url - The API endpoint to fetch
 * @returns {{
 *   data: any,
 *   loading: boolean,
 *   error: string | null,
 *   fetchData: () => Promise<any>
 * }}
 */
function useDeduplicatedFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Refs for deduplication & caching
  const pendingPromiseRef = useRef(null); // current in-flight promise
  const abortControllerRef = useRef(null); // for cancellation
  const cacheRef = useRef({
    data: null,
    timestamp: 0,
    url: null,
  });

  const CACHE_DURATION = 5000; // 5 seconds

  const fetchData = useCallback(async () => {
    // 1. Check cache first (fast path)
    const now = Date.now();
    if (
      cacheRef.current.url === url &&
      cacheRef.current.data !== null &&
      now - cacheRef.current.timestamp < CACHE_DURATION
    ) {
      setData(cacheRef.current.data);
      setError(null);
      setLoading(false);
      return cacheRef.current.data;
    }

    // 2. If there's already a pending request for this URL â†’ reuse it
    if (pendingPromiseRef.current) {
      setLoading(true);
      try {
        const result = await pendingPromiseRef.current;
        return result;
      } catch (err) {
        throw err;
      } finally {
        setLoading(false);
      }
    }

    // 3. No cache & no pending request â†’ start new fetch
    setLoading(true);
    setError(null);

    const controller = new AbortController();
    abortControllerRef.current = controller;
    const signal = controller.signal;

    const promise = (async () => {
      try {
        const response = await fetch(url, { signal });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();

        // Update cache
        cacheRef.current = {
          data: result,
          timestamp: Date.now(),
          url,
        };

        setData(result);
        setError(null);
        return result;
      } catch (err) {
        if (err.name === 'AbortError') {
          throw err; // let caller handle abort if needed
        }

        const message = err.message || 'Failed to fetch';
        setError(message);
        throw err;
      } finally {
        setLoading(false);
        // Clean up refs
        if (pendingPromiseRef.current === promise) {
          pendingPromiseRef.current = null;
        }
        if (abortControllerRef.current === controller) {
          abortControllerRef.current = null;
        }
      }
    })();

    // Store the promise for deduplication
    pendingPromiseRef.current = promise;

    return promise;
  }, [url]);

  // Cleanup on unmount or url change
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
        abortControllerRef.current = null;
      }
      pendingPromiseRef.current = null;
    };
  }, [url]);

  return { data, loading, error, fetchData };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Example usage component
function DeduplicationDemo() {
  const { data, loading, error, fetchData } = useDeduplicatedFetch(
    'https://jsonplaceholder.typicode.com/posts/1',
  );

  const handleMultipleClicks = () => {
    // Simulate user clicking "Load" button 5 times quickly
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        fetchData().catch(() => {}); // ignore errors for demo
      }, i * 80); // slightly staggered
    }
  };

  return (
    <div style={{ padding: '24px', maxWidth: '700px', margin: '0 auto' }}>
      <h2>Request Deduplication Demo</h2>

      <button
        onClick={handleMultipleClicks}
        disabled={loading}
        style={{
          padding: '12px 24px',
          fontSize: '16px',
          marginBottom: '20px',
          backgroundColor: loading ? '#6c757d' : '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '6px',
          cursor: loading ? 'not-allowed' : 'pointer',
        }}
      >
        {loading ? 'Loading...' : 'Load Data (click many times)'}
      </button>

      {loading && (
        <div
          style={{
            padding: '12px',
            backgroundColor: '#e3f2fd',
            borderRadius: '6px',
            marginBottom: '16px',
          }}
        >
          Loading (only one real request sent)...
        </div>
      )}

      {error && (
        <div
          style={{
            padding: '16px',
            backgroundColor: '#f8d7da',
            color: '#721c24',
            borderRadius: '6px',
            marginBottom: '16px',
          }}
        >
          Error: {error}
        </div>
      )}

      {data && (
        <div
          style={{
            backgroundColor: '#f8f9fa',
            padding: '20px',
            borderRadius: '8px',
            border: '1px solid #dee2e6',
          }}
        >
          <h3>Data (fetched once):</h3>
          <pre style={{ fontSize: '14px', overflow: 'auto' }}>
            {JSON.stringify(data, null, 2)}
          </pre>
          <p style={{ color: '#666', fontSize: '14px', marginTop: '16px' }}>
            Subsequent clicks within 5 seconds will use cached result (no
            network)
          </p>
        </div>
      )}
    </div>
  );
}

/*
Expected behavior:

â€¢ Click "Load Data" once â†’ real network request â†’ data shown
â€¢ Click many times quickly (within ~100ms) â†’ only ONE real request sent
  â†’ all calls receive the same promise â†’ same result
â€¢ After 5+ seconds â†’ cache expires â†’ next click triggers new request
â€¢ Rapid clicks after first success â†’ instantly return cached data
â€¢ Component unmount / url change â†’ pending request aborted
â€¢ No race conditions between multiple overlapping calls
*/
```

</details>

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - useRef:**
   https://react.dev/reference/react/useRef
2. **React Docs - Referencing Values with Refs:**
   https://react.dev/learn/referencing-values-with-refs

### Äá»c thÃªm

1. **When to use Ref vs State:**
   https://kentcdodds.com/blog/usememo-and-usecallback
2. **Avoiding Memory Leaks:**
   https://felixgerschau.com/react-hooks-memory-leaks/

3. **Understanding Refs:**
   https://daveceddia.com/useref-hook/

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (cáº§n biáº¿t tá»« trÆ°á»›c)

- **NgÃ y 11-12:** useState fundamentals
- **NgÃ y 16-20:** useEffect vÃ  cleanup
- **NgÃ y 19-20:** Data fetching patterns

### HÆ°á»›ng tá»›i (sáº½ dÃ¹ng á»Ÿ)

- **NgÃ y 22:** useRef cho DOM manipulation
- **NgÃ y 23:** useLayoutEffect vá»›i refs
- **NgÃ y 24:** Custom hooks vá»›i useRef
- **NgÃ y 25:** Project - Real-time Dashboard (combine táº¥t cáº£)

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

#### 1. Performance Optimization

```jsx
// âœ… GOOD: DÃ¹ng ref trÃ¡nh unnecessary re-renders
function ExpensiveComponent({ data }) {
  const previousDataRef = useRef(data);
  const hasChanged = !shallowEqual(data, previousDataRef.current);

  useEffect(() => {
    if (hasChanged) {
      // Heavy computation
      previousDataRef.current = data;
    }
  }, [data, hasChanged]);

  return (/* ... */);
}
```

#### 2. Debugging Tips

```jsx
// âœ… GOOD: Add debug info vá»›i useRef
function DebuggedComponent() {
  const renderCount = useRef(0);
  const prevPropsRef = useRef();

  useEffect(() => {
    renderCount.current += 1;

    if (import.meta.env.DEV) {
      console.log('Render #', renderCount.current);
      console.log('Prev props:', prevPropsRef.current);
      console.log('Current props:', props);
    }

    prevPropsRef.current = props;
  });

  return (/* ... */);
}
```

#### 3. Resource Management

```jsx
// âœ… GOOD: Centralized resource cleanup
function useResourceManager() {
  const resourcesRef = useRef({
    timers: [],
    listeners: [],
    requests: [],
  });

  const addTimer = (id) => {
    resourcesRef.current.timers.push(id);
  };

  const addListener = (element, event, handler) => {
    element.addEventListener(event, handler);
    resourcesRef.current.listeners.push({ element, event, handler });
  };

  useEffect(() => {
    return () => {
      // Cleanup all resources
      resourcesRef.current.timers.forEach(clearInterval);
      resourcesRef.current.listeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      resourcesRef.current.requests.forEach((req) => req.abort());
    };
  }, []);

  return { addTimer, addListener };
}
```

### CÃ¢u Há»i Phá»ng Váº¥n

#### Junior Level:

**Q1: "useRef vÃ  useState khÃ¡c nhau nhÆ° tháº¿ nÃ o?"**

Expected answer:

- useState trigger re-render khi update, useRef khÃ´ng
- useState cho UI data, useRef cho non-UI tracking
- useState async update, useRef sync update
- Cáº£ hai Ä‘á»u persist across renders

**Q2: "LÃ m sao store timer ID trong React?"**

Expected answer:

- DÃ¹ng useRef Ä‘á»ƒ store
- VÃ­ dá»¥: `const timerRef = useRef(null)`
- Update: `timerRef.current = setInterval(...)`
- Cleanup: `clearInterval(timerRef.current)`

#### Mid Level:

**Q3: "Giáº£i thÃ­ch use case cá»§a useRef ngoÃ i DOM manipulation."**

Expected answer:

- Previous value tracking
- Timer/interval IDs
- Flags (isMounted, isPaused)
- Mutable instance variables
- Avoiding stale closures
- Request cancellation (AbortController)

**Q4: "CÃ³ thá»ƒ dÃ¹ng useRef thay useState Ä‘á»ƒ optimize performance khÃ´ng?"**

Expected answer:

- KhÃ´ng thá»ƒ replace hoÃ n toÃ n
- useRef phÃ¹ há»£p cho non-UI data
- Náº¿u data hiá»ƒn thá»‹ lÃªn UI â†’ pháº£i dÃ¹ng useState
- useRef trÃ¡nh unnecessary re-renders cho internal tracking
- Trade-off: Lose automatic UI sync

#### Senior Level:

**Q5: "Design má»™t system Ä‘á»ƒ track vÃ  cleanup táº¥t cáº£ subscriptions trong má»™t component."**

Expected answer:

```jsx
function useSubscriptionManager() {
  const subscriptionsRef = useRef([]);

  const subscribe = (cleanup) => {
    subscriptionsRef.current.push(cleanup);
    return () => {
      const index = subscriptionsRef.current.indexOf(cleanup);
      if (index > -1) {
        subscriptionsRef.current.splice(index, 1);
      }
    };
  };

  useEffect(() => {
    return () => {
      subscriptionsRef.current.forEach((cleanup) => cleanup());
    };
  }, []);

  return subscribe;
}
```

**Q6: "Explain memory leak patterns vá»›i useRef vÃ  cÃ¡ch prevent."**

Expected answer:

- Timers khÃ´ng cleared
- Event listeners khÃ´ng removed
- Refs trá» Ä‘áº¿n large objects
- Solutions:
  - useEffect cleanup
  - WeakRef cho circular references
  - Null out refs sau khi dÃ¹ng
  - Resource tracking systems

### War Stories

#### Story 1: The Infinite Loop Mystery

```jsx
// âŒ BUG thá»±c táº¿ trong production:
function ChatRoom() {
  const [messages, setMessages] = useState([]);
  const wsRef = useRef(null);

  useEffect(() => {
    wsRef.current = new WebSocket(url);

    wsRef.current.onmessage = (e) => {
      setMessages([...messages, e.data]); // âš ï¸ STALE CLOSURE!
    };
  }, []); // Missing dependency!

  return (/* ... */);
}

// âœ… FIX:
function ChatRoom() {
  const [messages, setMessages] = useState([]);
  const wsRef = useRef(null);

  useEffect(() => {
    wsRef.current = new WebSocket(url);

    wsRef.current.onmessage = (e) => {
      setMessages(prev => [...prev, e.data]); // âœ… Functional update
    };

    return () => wsRef.current?.close();
  }, []); // Safe now

  return (/* ... */);
}
```

**Lesson learned:**

- LuÃ´n dÃ¹ng functional updates trong callbacks lÃ¢u dÃ i
- Refs giÃºp trÃ¡nh stale closures
- useEffect dependencies pháº£i chÃ­nh xÃ¡c

#### Story 2: The Memory Leak That Cost $1000

Real story: Dashboard component khÃ´ng cleanup intervals â†’ memory tÄƒng dáº§n â†’ server crash â†’ AWS bill spike.

```jsx
// âŒ Production bug:
function Dashboard() {
  useEffect(() => {
    const interval = setInterval(fetchData, 5000);
    // âš ï¸ No cleanup!
  }, []);
}

// âœ… Fix:
function Dashboard() {
  const intervalRef = useRef(null);

  useEffect(() => {
    intervalRef.current = setInterval(fetchData, 5000);

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);
}
```

**Lesson learned:**

- ALWAYS cleanup resources
- Monitor memory usage in production
- Test component unmount scenarios

---

## ğŸ¯ PREVIEW NGÃ€Y MAI

**NgÃ y 22: useRef - DOM Manipulation** ğŸ¨

NgÃ y mai chÃºng ta sáº½ há»c use case thá»© 2 cá»§a useRef: **accessing DOM nodes**.

Báº¡n sáº½ há»c:

- Ref forwarding vá»›i DOM elements
- Focus management
- Scroll control
- Measuring DOM nodes
- Third-party library integration
- When to use refs vs state for DOM

Chuáº©n bá»‹ mental model:

```
useRef = {
  Use Case 1: Mutable values (hÃ´m nay) âœ…
  Use Case 2: DOM references (ngÃ y mai) ğŸ¯
}
```

See you tomorrow! ğŸš€

---

## âœ… CHECKLIST HOÃ€N THÃ€NH

TrÆ°á»›c khi káº¿t thÃºc ngÃ y há»c, check:

- [ ] Hiá»ƒu sÃ¢u useRef vs useState
- [ ] LÃ m Ä‘á»§ 5 exercises
- [ ] Äá»c React docs vá» useRef
- [ ] LÃ m bÃ i táº­p vá» nhÃ 
- [ ] Review debug lab
- [ ] Chuáº©n bá»‹ cho ngÃ y mai

**ğŸ‰ Congratulations! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 21!**
