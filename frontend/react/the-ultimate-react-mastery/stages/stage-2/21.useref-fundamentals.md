# ğŸ“… NGÃ€Y 21: useRef - Fundamentals & Mutable Values

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] Hiá»ƒu báº£n cháº¥t cá»§a useRef vÃ  khi nÃ o cáº§n dÃ¹ng thay vÃ¬ useState
- [ ] Náº¯m vá»¯ng cÃ¡ch useRef lÆ°u trá»¯ giÃ¡ trá»‹ mutable khÃ´ng trigger re-render
- [ ] Biáº¿t cÃ¡ch persist values across renders mÃ  khÃ´ng gÃ¢y side effects
- [ ] PhÃ¢n biá»‡t rÃµ rÃ ng use cases cá»§a useRef vs useState
- [ ] Ãp dá»¥ng useRef Ä‘á»ƒ giáº£i quyáº¿t cÃ¡c váº¥n Ä‘á» thá»±c táº¿ nhÆ° tracking previous values, storing timer IDs

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i nÃ y:

1. **Äiá»u gÃ¬ xáº£y ra khi báº¡n update state báº±ng setState?**
   - Component re-render vá»›i giÃ¡ trá»‹ má»›i

2. **useEffect cleanup function cháº¡y khi nÃ o?**
   - TrÆ°á»›c khi effect cháº¡y láº§n tiáº¿p theo hoáº·c khi component unmount

3. **LÃ m sao Ä‘á»ƒ store má»™t giÃ¡ trá»‹ persists across renders nhÆ°ng khÃ´ng muá»‘n trigger re-render khi thay Ä‘á»•i?**
   - ÄÃ¢y chÃ­nh lÃ  váº¥n Ä‘á» useRef giáº£i quyáº¿t! ğŸ¯

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

HÃ£y xem xÃ©t tÃ¬nh huá»‘ng nÃ y:

```jsx
// âŒ Váº¤N Äá»€: Muá»‘n store interval ID Ä‘á»ƒ clear sau nÃ y
function Timer() {
  const [count, setCount] = useState(0);
  let intervalId; // âš ï¸ Sáº½ bá»‹ reset má»—i láº§n render!

  const startTimer = () => {
    intervalId = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    clearInterval(intervalId); // âš ï¸ intervalId luÃ´n lÃ  undefined!
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**Váº¥n Ä‘á»:**

- Biáº¿n `intervalId` Ä‘Æ°á»£c declare láº¡i má»—i láº§n component re-render
- `stopTimer` khÃ´ng thá»ƒ access Ä‘Æ°á»£c `intervalId` tá»« `startTimer`
- Timer khÃ´ng thá»ƒ stop Ä‘Æ°á»£c! ğŸ˜±

**Báº¡n cÃ³ thá»ƒ nghÄ©:** "DÃ¹ng useState Ä‘á»ƒ lÆ°u intervalId?"

```jsx
// âŒ GIáº¢I PHÃP SAI: DÃ¹ng useState
function Timer() {
  const [count, setCount] = useState(0);
  const [intervalId, setIntervalId] = useState(null); // âš ï¸ Overkill!

  const startTimer = () => {
    const id = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
    setIntervalId(id); // âš ï¸ GÃ¢y re-render khÃ´ng cáº§n thiáº¿t!
  };

  const stopTimer = () => {
    clearInterval(intervalId);
    setIntervalId(null); // âš ï¸ Láº¡i re-render!
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**Táº¡i sao sai?**

- `intervalId` khÃ´ng pháº£i UI data, khÃ´ng cáº§n render
- Má»—i láº§n set intervalId â†’ re-render khÃ´ng cáº§n thiáº¿t
- Performance waste! ğŸ“‰

### 1.2 Giáº£i PhÃ¡p: useRef

```jsx
// âœ… GIáº¢I PHÃP ÄÃšNG: DÃ¹ng useRef
import { useState, useRef } from 'react';

function Timer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null); // ğŸ¯ Perfect!

  const startTimer = () => {
    intervalRef.current = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**Táº¡i sao tá»‘t hÆ¡n?**

- `intervalRef.current` persists across renders
- Update `intervalRef.current` KHÃ”NG trigger re-render
- Chá»‰ re-render khi `count` thay Ä‘á»•i (cáº§n thiáº¿t cho UI)

### 1.3 Mental Model

HÃ£y tÆ°á»Ÿng tÆ°á»£ng useRef nhÆ° **má»™t chiáº¿c há»™p cÃ³ ngÄƒn kÃ©o**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   useRef Container              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚   â”‚  .current         â”‚        â”‚ â† NgÄƒn kÃ©o nÃ y luÃ´n á»Ÿ Ä‘Ã³
â”‚   â”‚  (mutable value)  â”‚        â”‚   giá»¯a cÃ¡c láº§n render
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Äáº·c Ä‘iá»ƒm:
âœ… Há»™p (ref object) khÃ´ng bao giá» thay Ä‘á»•i
âœ… NgÄƒn kÃ©o (.current) cÃ³ thá»ƒ má»Ÿ ra vÃ  thay Ä‘á»•i ná»™i dung
âœ… Thay Ä‘á»•i ná»™i dung ngÄƒn kÃ©o KHÃ”NG lÃ m React nháº­n biáº¿t
```

**So sÃ¡nh vá»›i useState:**

```
useState                    useRef
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const [value, setValue]     const ref = useRef(value)
setValue(newValue)          ref.current = newValue
â†’ Trigger re-render        â†’ KHÃ”NG re-render
â†’ Async update             â†’ Sync update
â†’ Cho UI data              â†’ Cho non-UI data
```

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

#### âŒ Hiá»ƒu láº§m 1: "useRef chá»‰ dÃ¹ng Ä‘á»ƒ access DOM"

**Thá»±c táº¿:** useRef cÃ³ 2 use cases chÃ­nh:

1. **Mutable values** (hÃ´m nay há»c)
2. **DOM references** (ngÃ y mai há»c)

```jsx
// âœ… Use case 1: Mutable value
const countRef = useRef(0);
countRef.current += 1; // KhÃ´ng re-render

// âœ… Use case 2: DOM reference (sáº½ há»c ngÃ y mai)
const inputRef = useRef(null);
// <input ref={inputRef} />
```

#### âŒ Hiá»ƒu láº§m 2: "ref.current thay Ä‘á»•i thÃ¬ component re-render"

```jsx
// âŒ SAI: NghÄ© ref.current thay Ä‘á»•i â†’ re-render
function Counter() {
  const countRef = useRef(0);

  const increment = () => {
    countRef.current += 1;
    console.log(countRef.current); // GiÃ¡ trá»‹ tÄƒng
    // âš ï¸ NhÆ°ng UI KHÃ”NG update!
  };

  return (
    <div>
      <p>Count: {countRef.current}</p> {/* LuÃ´n hiá»ƒn thá»‹ 0 */}
      <button onClick={increment}>+1</button>
    </div>
  );
}
```

#### âŒ Hiá»ƒu láº§m 3: "CÃ³ thá»ƒ dÃ¹ng useRef thay useState Ä‘á»ƒ trÃ¡nh re-render"

```jsx
// âŒ ANTI-PATTERN: DÃ¹ng ref cho UI data
function BadCounter() {
  const countRef = useRef(0);

  const increment = () => {
    countRef.current += 1;
    // âš ï¸ UI khÃ´ng update vÃ¬ khÃ´ng re-render!
  };

  return <p>Count: {countRef.current}</p>;
}

// âœ… ÄÃšNG: DÃ¹ng useState cho UI data
function GoodCounter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount((c) => c + 1); // UI updates correctly
  };

  return <p>Count: {count}</p>;
}
```

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Pattern CÆ¡ Báº£n - Tracking Render Count â­

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Äáº¿m sá»‘ láº§n component render
 * ğŸ’¡ Insight: useRef perfect cho tracking mÃ  khÃ´ng gÃ¢y re-render
 */

import { useState, useRef, useEffect } from 'react';

function RenderCounter() {
  const [count, setCount] = useState(0);
  const renderCount = useRef(0);

  // âš ï¸ CHÃš Ã: KhÃ´ng dÃ¹ng useEffect Ä‘á»ƒ increment!
  // VÃ¬ useEffect cháº¡y AFTER render

  // âœ… Increment ngay trong render phase
  renderCount.current += 1;

  console.log(`Render #${renderCount.current}`);

  return (
    <div>
      <h2>Render Counter Demo</h2>
      <p>This component has rendered: {renderCount.current} times</p>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment Count</button>
    </div>
  );
}

// ğŸ” Output khi click button:
// Render #1 (initial)
// Click button â†’ Render #2
// Click button â†’ Render #3
```

**Giáº£i thÃ­ch chi tiáº¿t:**

```jsx
// âŒ SAI: DÃ¹ng useState Ä‘á»ƒ count renders
function BadRenderCounter() {
  const [count, setCount] = useState(0);
  const [renderCount, setRenderCount] = useState(0);

  // âš ï¸ GÃ¢y infinite loop!
  setRenderCount(renderCount + 1); // Trigger re-render â†’ láº¡i gá»i setRenderCount â†’ loop!

  return <p>Renders: {renderCount}</p>;
}

// âŒ SAI: DÃ¹ng biáº¿n thÆ°á»ng
function BadRenderCounter2() {
  const [count, setCount] = useState(0);
  let renderCount = 0; // âš ï¸ Reset vá» 0 má»—i render!

  renderCount += 1; // LuÃ´n lÃ  1

  return <p>Renders: {renderCount}</p>; // LuÃ´n hiá»ƒn thá»‹ 1
}

// âœ… ÄÃšNG: DÃ¹ng useRef
function GoodRenderCounter() {
  const [count, setCount] = useState(0);
  const renderCount = useRef(0);

  renderCount.current += 1; // Persists, khÃ´ng trigger re-render

  return <p>Renders: {renderCount.current}</p>;
}
```

### Demo 2: Ká»‹ch Báº£n Thá»±c Táº¿ - Previous Value Tracking â­â­

```jsx
/**
 * ğŸ¯ Use case: So sÃ¡nh giÃ¡ trá»‹ hiá»‡n táº¡i vá»›i giÃ¡ trá»‹ trÆ°á»›c Ä‘Ã³
 * ğŸ’¼ Real-world: Analytics, change detection, diff calculation
 */

import { useState, useRef, useEffect } from 'react';

function PriceTracker() {
  const [price, setPrice] = useState(100);
  const previousPrice = useRef(price);

  // âœ… Pattern: Update previous value AFTER render
  useEffect(() => {
    previousPrice.current = price;
  }, [price]); // Chá»‰ update khi price thay Ä‘á»•i

  // Calculate change
  const priceChange = price - previousPrice.current;
  const changePercent = ((priceChange / previousPrice.current) * 100).toFixed(
    2,
  );

  // Random price change (demo purpose)
  const updatePrice = () => {
    const change = Math.random() * 20 - 10; // -10 to +10
    setPrice((prev) => Math.max(1, prev + change)); // KhÃ´ng Ã¢m
  };

  return (
    <div style={{ padding: '20px', border: '1px solid #ccc' }}>
      <h2>Stock Price Tracker</h2>

      <div style={{ fontSize: '32px', fontWeight: 'bold' }}>
        ${price.toFixed(2)}
      </div>

      <div
        style={{
          color: priceChange >= 0 ? 'green' : 'red',
          fontSize: '18px',
        }}
      >
        {priceChange >= 0 ? 'â–²' : 'â–¼'}${Math.abs(priceChange).toFixed(2)}(
        {changePercent}%)
      </div>

      <div style={{ marginTop: '10px', color: '#666' }}>
        Previous: ${previousPrice.current.toFixed(2)}
      </div>

      <button
        onClick={updatePrice}
        style={{ marginTop: '10px' }}
      >
        Update Price
      </button>
    </div>
  );
}
```

**Táº¡i sao dÃ¹ng useRef thay vÃ¬ useState?**

```jsx
// âŒ CÃ¡ch 1: DÃ¹ng useState (khÃ´ng tá»‘t)
function BadPriceTracker() {
  const [price, setPrice] = useState(100);
  const [previousPrice, setPreviousPrice] = useState(100);

  const updatePrice = () => {
    setPreviousPrice(price); // âš ï¸ GÃ¢y thÃªm 1 re-render!
    setPrice(newPrice); // âš ï¸ Láº¡i 1 re-render!
    // â†’ 2 renders thay vÃ¬ 1!
  };

  return (
    <div>
      <p>Current: ${price}</p>
      <p>Previous: ${previousPrice}</p>
    </div>
  );
}

// âœ… CÃ¡ch 2: DÃ¹ng useRef (tá»‘t)
function GoodPriceTracker() {
  const [price, setPrice] = useState(100);
  const previousPrice = useRef(100);

  useEffect(() => {
    previousPrice.current = price; // KhÃ´ng gÃ¢y re-render
  }, [price]);

  const updatePrice = () => {
    setPrice(newPrice); // Chá»‰ 1 re-render!
  };

  return (
    <div>
      <p>Current: ${price}</p>
      <p>Previous: ${previousPrice.current}</p>
    </div>
  );
}
```

**Timeline so sÃ¡nh:**

```
useState approach:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Initial render â†’ price: 100, prev: 100
Click button:
  1. setPreviousPrice(100) â†’ Render #2
  2. setPrice(120) â†’ Render #3
â†’ 2 unnecessary renders!

useRef approach:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Initial render â†’ price: 100, prev.current: 100
Click button:
  1. setPrice(120) â†’ Render #2
  2. useEffect: prev.current = 120 (no render)
â†’ Only 1 necessary render!
```

### Demo 3: Edge Cases - Timer Management â­â­â­

```jsx
/**
 * ğŸ¯ Use case: Quáº£n lÃ½ multiple timers, cleanup Ä‘Ãºng cÃ¡ch
 * âš ï¸ Edge cases:
 *    - Start timer nhiá»u láº§n
 *    - Clear timer khi component unmount
 *    - Prevent memory leaks
 */

import { useState, useRef, useEffect } from 'react';

function MultiTimer() {
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);
  const startTimeRef = useRef(null);

  // âœ… Pattern: Start timer
  const startTimer = () => {
    if (intervalRef.current) {
      // âš ï¸ Edge case: Timer already running
      console.warn('Timer is already running!');
      return;
    }

    setIsRunning(true);
    startTimeRef.current = Date.now() - time * 1000; // Resume from current time

    intervalRef.current = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTimeRef.current) / 1000);
      setTime(elapsed);
    }, 100); // Update má»—i 100ms cho smooth
  };

  // âœ… Pattern: Stop timer
  const stopTimer = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
    setIsRunning(false);
  };

  // âœ… Pattern: Reset timer
  const resetTimer = () => {
    stopTimer();
    setTime(0);
    startTimeRef.current = null;
  };

  // âœ… Pattern: Cleanup on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []); // Empty deps = chá»‰ cleanup khi unmount

  // Format time: MM:SS
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div style={{ padding: '20px', textAlign: 'center' }}>
      <h2>Multi Timer with useRef</h2>

      <div
        style={{ fontSize: '48px', fontFamily: 'monospace', margin: '20px 0' }}
      >
        {formatTime(time)}
      </div>

      <div style={{ display: 'flex', gap: '10px', justifyContent: 'center' }}>
        <button
          onClick={startTimer}
          disabled={isRunning}
          style={{ padding: '10px 20px' }}
        >
          Start
        </button>

        <button
          onClick={stopTimer}
          disabled={!isRunning}
          style={{ padding: '10px 20px' }}
        >
          Stop
        </button>

        <button
          onClick={resetTimer}
          style={{ padding: '10px 20px' }}
        >
          Reset
        </button>
      </div>

      {/* Debug info */}
      <div style={{ marginTop: '20px', fontSize: '12px', color: '#666' }}>
        <p>Is Running: {isRunning ? 'Yes' : 'No'}</p>
        <p>Interval ID: {intervalRef.current || 'null'}</p>
      </div>
    </div>
  );
}
```

**Edge Cases Ä‘Æ°á»£c handle:**

```jsx
// âš ï¸ Edge Case 1: Spam start button
const startTimer = () => {
  if (intervalRef.current) {
    // âœ… Prevent multiple intervals
    console.warn('Timer is already running!');
    return;
  }
  // ... start logic
};

// âš ï¸ Edge Case 2: Component unmount khi timer running
useEffect(() => {
  return () => {
    if (intervalRef.current) {
      // âœ… Cleanup Ä‘á»ƒ trÃ¡nh memory leak
      clearInterval(intervalRef.current);
    }
  };
}, []);

// âš ï¸ Edge Case 3: Reset khi Ä‘ang cháº¡y
const resetTimer = () => {
  stopTimer(); // âœ… Stop trÆ°á»›c khi reset
  setTime(0);
  startTimeRef.current = null;
};
```

**Common Mistakes:**

```jsx
// âŒ Mistake 1: KhÃ´ng check timer Ä‘Ã£ running
const badStart = () => {
  // KhÃ´ng check â†’ táº¡o nhiá»u intervals!
  intervalRef.current = setInterval(/* ... */);
};

// âŒ Mistake 2: KhÃ´ng cleanup
// KhÃ´ng cÃ³ useEffect cleanup â†’ memory leak khi unmount!

// âŒ Mistake 3: Clear wrong interval
const badStop = () => {
  clearInterval(intervalRef.current);
  // âš ï¸ QuÃªn set null â†’ ref váº«n giá»¯ invalid ID
};

// âœ… ÄÃšNG:
const goodStop = () => {
  clearInterval(intervalRef.current);
  intervalRef.current = null; // Reset ref
};
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Exercise 1: Click Counter vá»›i Previous Value (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Thá»±c hÃ nh useRef cÆ¡ báº£n vá»›i previous value tracking
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useReducer, useContext, custom hooks
 *
 * Requirements:
 * 1. Hiá»ƒn thá»‹ sá»‘ láº§n click hiá»‡n táº¡i
 * 2. Hiá»ƒn thá»‹ sá»‘ láº§n click trÆ°á»›c Ä‘Ã³
 * 3. Hiá»ƒn thá»‹ difference (current - previous)
 * 4. Button reset vá» 0
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - DÃ¹ng useState cho click count (UI data)
 * - DÃ¹ng useRef cho previous count (non-UI data)
 * - useEffect Ä‘á»ƒ update previous sau má»—i click
 */

// âŒ CÃ¡ch SAI: DÃ¹ng 2 useState
function BadClickCounter() {
  const [count, setCount] = useState(0);
  const [prevCount, setPrevCount] = useState(0);

  const handleClick = () => {
    setPrevCount(count); // âš ï¸ Extra re-render!
    setCount(count + 1); // âš ï¸ Another re-render!
  };

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={handleClick}>Click Me</button>
    </div>
  );
}

// âœ… CÃ¡ch ÄÃšNG: useState + useRef
function GoodClickCounter() {
  // TODO: Implement using useState + useRef
  // Step 1: Create state for current count
  // Step 2: Create ref for previous count
  // Step 3: useEffect to update previous after count changes
  // Step 4: Calculate difference
  // Step 5: Reset button
}

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
function ClickCounter() {
  // TODO: Your implementation here

  return (
    <div style={{ padding: '20px', border: '2px solid #333' }}>
      <h2>Click Counter</h2>

      {/* TODO: Display current count */}
      {/* TODO: Display previous count */}
      {/* TODO: Display difference with color (green if +, red if -) */}

      {/* TODO: Click button */}
      {/* TODO: Reset button */}
    </div>
  );
}

// âœ… Expected behavior:
// Initial: Current: 0, Previous: 0, Diff: 0
// Click 1: Current: 1, Previous: 0, Diff: +1 (green)
// Click 2: Current: 2, Previous: 1, Diff: +1 (green)
// Reset: Current: 0, Previous: 2, Diff: -2 (red)
```

### â­â­ Exercise 2: Debounced Search Input (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Hiá»ƒu khi nÃ o dÃ¹ng useRef vs useState
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario:
 * Báº¡n Ä‘ang build search box. Má»—i láº§n user type, báº¡n muá»‘n gá»i API.
 * NhÆ°ng KHÃ”NG muá»‘n gá»i API má»—i keystroke â†’ dÃ¹ng debounce.
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 *
 * Approach A: DÃ¹ng setTimeout trong useEffect, store timeout ID trong useState
 * Pros:
 * - Straightforward
 * Cons:
 * - setState gÃ¢y unnecessary re-render
 * - Performance waste
 *
 * Approach B: DÃ¹ng setTimeout trong useEffect, store timeout ID trong useRef
 * Pros:
 * - No unnecessary re-renders
 * - Better performance
 * - Timeout ID lÃ  non-UI data
 * Cons:
 * - None (this is the correct approach!)
 *
 * ğŸ’­ Báº N CHá»ŒN GÃŒ VÃ€ Táº I SAO?
 * Document quyáº¿t Ä‘á»‹nh cá»§a báº¡n, sau Ä‘Ã³ implement.
 */

import { useState, useRef, useEffect } from 'react';

function DebouncedSearch() {
  const [searchTerm, setSearchTerm] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);

  // TODO: Decide - useState hay useRef cho timeout ID?
  // const [timeoutId, setTimeoutId] = useState(null); // Approach A?
  // const timeoutRef = useRef(null); // Approach B?

  // TODO: Implement debounced search
  // Requirements:
  // 1. Wait 500ms after user stops typing
  // 2. Then "search" (mock vá»›i setTimeout)
  // 3. Show loading state while searching
  // 4. Display results
  // 5. Clear previous timeout khi user types again

  useEffect(() => {
    // TODO: Your debounce logic here

    // Pattern structure:
    // 1. Clear previous timeout (if exists)
    // 2. If searchTerm empty â†’ clear results, return
    // 3. Set new timeout:
    //    - After 500ms: setIsSearching(true)
    //    - Mock API call (setTimeout 1000ms)
    //    - setSearchResults, setIsSearching(false)

    return () => {
      // TODO: Cleanup
    };
  }, [searchTerm]);

  // Mock search function
  const mockSearch = (term) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        // Fake results
        const results = [
          `Result 1 for "${term}"`,
          `Result 2 for "${term}"`,
          `Result 3 for "${term}"`,
        ];
        resolve(results);
      }, 1000);
    });
  };

  return (
    <div style={{ padding: '20px' }}>
      <h2>Debounced Search</h2>

      <input
        type='text'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder='Type to search...'
        style={{
          width: '300px',
          padding: '10px',
          fontSize: '16px',
        }}
      />

      {isSearching && <p>Searching...</p>}

      <ul>
        {searchResults.map((result, index) => (
          <li key={index}>{result}</li>
        ))}
      </ul>

      {/* Debug info */}
      <div style={{ marginTop: '20px', fontSize: '12px', color: '#666' }}>
        <p>Search term: "{searchTerm}"</p>
        <p>Results count: {searchResults.length}</p>
      </div>
    </div>
  );
}

// ğŸ¯ Expected behavior:
// - Type "react" â†’ wait â†’ see "Searching..." â†’ see results
// - Type "react hooks" â†’ debounce cancels first search â†’ only search "react hooks"
// - Clear input â†’ results disappear immediately
```

### â­â­â­ Exercise 3: Stopwatch vá»›i Lap Times (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Ká»‹ch báº£n thá»±c táº¿ vá»›i multiple refs
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  má»™t runner, tÃ´i muá»‘n track lap times Ä‘á»ƒ phÃ¢n tÃ­ch performance"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Start/Stop stopwatch
 * - [ ] Record lap times (array)
 * - [ ] Display current lap time
 * - [ ] Display all lap times vá»›i fastest/slowest highlight
 * - [ ] Reset clears everything
 * - [ ] Precise timing (use Date.now() not interval count)
 *
 * ğŸ¨ Technical Constraints:
 * - Chá»‰ dÃ¹ng useState, useRef, useEffect (NgÃ y 11-21)
 * - KHÃ”NG dÃ¹ng useReducer (chÆ°a há»c)
 * - KHÃ”NG dÃ¹ng custom hooks (chÆ°a há»c deep dive)
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Click Start nhiá»u láº§n
 * - Click Lap khi chÆ°a start
 * - Component unmount khi stopwatch Ä‘ang cháº¡y
 * - Lap khi stopwatch Ä‘ang stop
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] Core stopwatch functionality
 * - [ ] Lap recording
 * - [ ] Precise timing calculation
 * - [ ] Fastest/Slowest lap detection
 * - [ ] Edge cases handling
 * - [ ] Cleanup on unmount
 */

import { useState, useRef, useEffect } from 'react';

function Stopwatch() {
  // TODO: State for laps array
  const [laps, setLaps] = useState([]);

  // TODO: State for UI
  const [isRunning, setIsRunning] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);

  // TODO: Refs for timing
  // - intervalRef: store interval ID
  // - startTimeRef: store start timestamp
  // - lastLapTimeRef: store last lap timestamp

  // TODO: Implement start
  const handleStart = () => {
    // Edge case: already running?
  };

  // TODO: Implement stop
  const handleStop = () => {
    // Clear interval, keep time
  };

  // TODO: Implement lap
  const handleLap = () => {
    // Edge case: not running?
    // Calculate lap time
    // Add to laps array
    // Update lastLapTimeRef
  };

  // TODO: Implement reset
  const handleReset = () => {
    // Stop if running
    // Clear all state
    // Reset all refs
  };

  // TODO: Calculate fastest/slowest
  const getFastestLap = () => {
    // Return index of fastest lap
  };

  const getSlowestLap = () => {
    // Return index of slowest lap
  };

  // TODO: Cleanup
  useEffect(() => {
    return () => {
      // Clear interval on unmount
    };
  }, []);

  // Format time helper
  const formatTime = (ms) => {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const milliseconds = Math.floor((ms % 1000) / 10);

    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(2, '0')}`;
  };

  return (
    <div style={{ padding: '20px', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Stopwatch with Laps</h2>

      {/* Main timer display */}
      <div
        style={{
          fontSize: '48px',
          fontFamily: 'monospace',
          textAlign: 'center',
          margin: '20px 0',
          padding: '20px',
          backgroundColor: '#f0f0f0',
          borderRadius: '8px',
        }}
      >
        {formatTime(currentTime)}
      </div>

      {/* Control buttons */}
      <div
        style={{
          display: 'flex',
          gap: '10px',
          justifyContent: 'center',
          marginBottom: '20px',
        }}
      >
        {/* TODO: Start/Stop button (toggle based on isRunning) */}
        {/* TODO: Lap button (disabled if not running) */}
        {/* TODO: Reset button */}
      </div>

      {/* Lap times list */}
      <div
        style={{
          maxHeight: '300px',
          overflowY: 'auto',
          border: '1px solid #ccc',
          borderRadius: '4px',
          padding: '10px',
        }}
      >
        <h3>Lap Times</h3>
        {laps.length === 0 ? (
          <p style={{ color: '#999', textAlign: 'center' }}>No laps yet</p>
        ) : (
          <ol style={{ padding: '0 0 0 20px' }}>
            {/* TODO: Map through laps */}
            {/* TODO: Highlight fastest (green) and slowest (red) */}
            {/* Format: "Lap 1: 00:05.23" */}
          </ol>
        )}
      </div>
    </div>
  );
}

// ğŸ¯ Expected behavior:
// 1. Click Start â†’ timer runs
// 2. Click Lap â†’ records lap time, continues timing
// 3. Multiple laps â†’ fastest is green, slowest is red
// 4. Click Stop â†’ timer stops, can resume
// 5. Click Reset â†’ everything clears
```

### â­â­â­â­ Exercise 4: Form with Auto-save (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Architectural decision vá»›i multiple approaches
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Scenario:
 * Build form tá»± Ä‘á»™ng save draft sau khi user stop typing 2 giÃ¢y.
 * Hiá»ƒn thá»‹ last saved time vÃ  saving status.
 *
 * Nhiá»‡m vá»¥:
 * 1. So sÃ¡nh Ã­t nháº¥t 3 approaches:
 *    - Approach A: All useState (including timeout ID)
 *    - Approach B: useState + useRef for timeout
 *    - Approach C: useState + useRef for timeout + last save time
 * 2. Document pros/cons má»—i approach
 * 3. Chá»n approach phÃ¹ há»£p nháº¥t
 * 4. Viáº¿t ADR (Architecture Decision Record)
 *
 * ADR Template:
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 * Context:
 * - Form cÃ³ nhiá»u fields
 * - Auto-save sau 2s khÃ´ng type
 * - Hiá»ƒn thá»‹ saving status
 * - Hiá»ƒn thá»‹ last saved time
 *
 * Decision: [Approach báº¡n chá»n]
 *
 * Rationale:
 * - [LÃ½ do 1]
 * - [LÃ½ do 2]
 * - [LÃ½ do 3]
 *
 * Consequences:
 * Trade-offs accepted:
 * - [Trade-off 1]
 * - [Trade-off 2]
 *
 * Alternatives Considered:
 * - Approach A: [Brief summary + why rejected]
 * - Approach B: [Brief summary + why rejected]
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 */

import { useState, useRef, useEffect } from 'react';

function AutoSaveForm() {
  // Form data
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    category: 'general',
  });

  // UI states
  const [savingStatus, setSavingStatus] = useState('idle'); // 'idle' | 'saving' | 'saved'
  const [lastSavedAt, setLastSavedAt] = useState(null);

  // TODO: Decide architecture
  // What refs do you need?
  // - Timeout ID?
  // - Last saved data (Ä‘á»ƒ compare)?
  // - Save timestamp?

  // TODO: Implement auto-save logic
  useEffect(() => {
    // Debounce logic (2 seconds)
    // 1. Clear previous timeout
    // 2. Set new timeout
    // 3. Compare current data vá»›i last saved
    // 4. If different â†’ save
    // 5. Update saving status

    return () => {
      // Cleanup
    };
  }, [formData]);

  // Mock save function
  const saveDraft = async (data) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log('Saved:', data);
        resolve();
      }, 1000);
    });
  };

  const handleChange = (field) => (e) => {
    setFormData((prev) => ({
      ...prev,
      [field]: e.target.value,
    }));
  };

  // Manual save
  const handleManualSave = async () => {
    setSavingStatus('saving');
    await saveDraft(formData);
    setSavingStatus('saved');
    setLastSavedAt(new Date());
  };

  // Format last saved time
  const formatLastSaved = () => {
    if (!lastSavedAt) return 'Never';

    const now = Date.now();
    const diff = now - lastSavedAt.getTime();
    const seconds = Math.floor(diff / 1000);

    if (seconds < 60) return `${seconds} seconds ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes} minutes ago`;
    return lastSavedAt.toLocaleTimeString();
  };

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h2>Auto-save Form</h2>

      {/* Saving status indicator */}
      <div
        style={{
          padding: '10px',
          marginBottom: '20px',
          backgroundColor:
            savingStatus === 'saving'
              ? '#fff3cd'
              : savingStatus === 'saved'
                ? '#d1e7dd'
                : '#f8f9fa',
          border: '1px solid',
          borderColor:
            savingStatus === 'saving'
              ? '#ffc107'
              : savingStatus === 'saved'
                ? '#28a745'
                : '#dee2e6',
          borderRadius: '4px',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <span>
          {savingStatus === 'saving' && 'ğŸ’¾ Saving...'}
          {savingStatus === 'saved' && 'âœ… Saved'}
          {savingStatus === 'idle' && 'ğŸ“ Draft'}
        </span>
        <span style={{ fontSize: '12px', color: '#666' }}>
          Last saved: {formatLastSaved()}
        </span>
      </div>

      {/* Form fields */}
      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Title
        </label>
        <input
          type='text'
          value={formData.title}
          onChange={handleChange('title')}
          placeholder='Enter title...'
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            border: '1px solid #ccc',
            borderRadius: '4px',
          }}
        />
      </div>

      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Content
        </label>
        <textarea
          value={formData.content}
          onChange={handleChange('content')}
          placeholder='Enter content...'
          rows={6}
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            border: '1px solid #ccc',
            borderRadius: '4px',
            fontFamily: 'inherit',
          }}
        />
      </div>

      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Category
        </label>
        <select
          value={formData.category}
          onChange={handleChange('category')}
          style={{
            width: '100%',
            padding: '10px',
            fontSize: '16px',
            border: '1px solid #ccc',
            borderRadius: '4px',
          }}
        >
          <option value='general'>General</option>
          <option value='work'>Work</option>
          <option value='personal'>Personal</option>
        </select>
      </div>

      <button
        onClick={handleManualSave}
        disabled={savingStatus === 'saving'}
        style={{
          padding: '10px 20px',
          fontSize: '16px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: savingStatus === 'saving' ? 'not-allowed' : 'pointer',
          opacity: savingStatus === 'saving' ? 0.6 : 1,
        }}
      >
        Save Now
      </button>

      {/* Debug info */}
      <div
        style={{
          marginTop: '30px',
          padding: '10px',
          backgroundColor: '#f8f9fa',
          borderRadius: '4px',
          fontSize: '12px',
          fontFamily: 'monospace',
        }}
      >
        <p>
          <strong>Debug Info:</strong>
        </p>
        <p>Status: {savingStatus}</p>
        <p>Form Data: {JSON.stringify(formData)}</p>
      </div>
    </div>
  );
}

// ğŸ§ª PHASE 3: Testing (10 phÃºt)
// Manual testing checklist:
// - [ ] Type in title â†’ waits 2s â†’ auto-saves
// - [ ] Type quickly â†’ only saves once after stop typing
// - [ ] Change category â†’ auto-saves
// - [ ] Click "Save Now" â†’ saves immediately
// - [ ] Status indicator updates correctly
// - [ ] Last saved time updates
// - [ ] No unnecessary re-renders (check React DevTools)
```

### â­â­â­â­â­ Exercise 5: Advanced Polling Component (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Production-ready component vá»›i complex ref management
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 *
 * Build má»™t component fetch data tá»« API vá»›i:
 * 1. Auto-refresh má»—i X giÃ¢y (configurable)
 * 2. Pause/Resume polling
 * 3. Manual refresh button
 * 4. Show time since last update
 * 5. Show connection status
 * 6. Handle visibility change (pause khi tab inactive)
 * 7. Exponential backoff on errors
 * 8. Request cancellation
 *
 * ğŸ—ï¸ Technical Design Doc:
 *
 * 1. Component Architecture:
 *    - State: data, loading, error, status, lastUpdate
 *    - Refs: intervalId, retryCount, abortController
 *    - Props: url, interval, onData, onError
 *
 * 2. State Management Strategy:
 *    - useState cho UI-critical data
 *    - useRef cho timers, counters, abort controllers
 *    - KhÃ´ng dÃ¹ng useReducer (chÆ°a há»c)
 *
 * 3. API Integration:
 *    - fetch vá»›i AbortController
 *    - Error handling vá»›i retry logic
 *    - Response validation
 *
 * 4. Performance Considerations:
 *    - Cleanup táº¥t cáº£ subscriptions
 *    - Cancel in-flight requests
 *    - Pause khi tab hidden
 *
 * 5. Error Handling Strategy:
 *    - Try exponential backoff: 1s, 2s, 4s, 8s, 16s
 *    - Max 5 retries
 *    - Reset retry count on success
 *    - Display error message
 *
 * âœ… Production Checklist:
 * - [ ] TypeScript types Ä‘áº§y Ä‘á»§ (á»Ÿ Ä‘Ã¢y dÃ¹ng JSDoc comments)
 * - [ ] Comprehensive error handling
 * - [ ] Loading states
 * - [ ] Empty states
 * - [ ] Edge case handling (rapid pause/resume, unmount during fetch)
 * - [ ] Performance optimization (unnecessary re-renders)
 * - [ ] Memory leak prevention
 * - [ ] Visibility API integration
 * - [ ] Request cancellation
 * - [ ] Console logging cho debugging
 */

import { useState, useRef, useEffect } from 'react';

/**
 * @typedef {Object} PollingConfig
 * @property {string} url - API endpoint
 * @property {number} interval - Polling interval in ms (default: 5000)
 * @property {boolean} pauseOnHidden - Pause when tab hidden (default: true)
 * @property {Function} onData - Callback khi cÃ³ data má»›i
 * @property {Function} onError - Callback khi cÃ³ error
 */

/**
 * Advanced Polling Component
 * @param {PollingConfig} props
 */
function AdvancedPolling({
  url,
  interval = 5000,
  pauseOnHidden = true,
  onData,
  onError,
}) {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STATE MANAGEMENT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [status, setStatus] = useState('idle'); // 'idle' | 'polling' | 'paused' | 'error'
  const [lastUpdate, setLastUpdate] = useState(null);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // REFS FOR NON-UI DATA
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  // TODO: Implement refs
  // - intervalRef: store setInterval ID
  // - retryCountRef: track consecutive failures
  // - abortControllerRef: cancel requests
  // - isPausedRef: track pause state (sync with visibility)

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CORE FETCHING LOGIC
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const fetchData = async () => {
    // TODO: Implement vá»›i:
    // 1. Check if paused
    // 2. Create AbortController
    // 3. setLoading(true)
    // 4. try-catch fetch
    // 5. Validate response
    // 6. Update data, lastUpdate, reset retryCount
    // 7. Call onData callback
    // 8. catch: handle errors, exponential backoff
    // 9. finally: setLoading(false)
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // POLLING CONTROL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const startPolling = () => {
    // TODO:
    // 1. Check if already polling
    // 2. Clear existing interval
    // 3. Fetch immediately
    // 4. Set up interval
    // 5. Update status
  };

  const pausePolling = () => {
    // TODO:
    // 1. Clear interval
    // 2. Update status
    // 3. Set isPausedRef
  };

  const resumePolling = () => {
    // TODO:
    // 1. Reset isPausedRef
    // 2. Start polling
  };

  const manualRefresh = () => {
    // TODO:
    // 1. Cancel current request if any
    // 2. Reset retry count
    // 3. Fetch immediately
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VISIBILITY CHANGE HANDLING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  useEffect(() => {
    if (!pauseOnHidden) return;

    // TODO: Implement Visibility API
    // 1. Add event listener for 'visibilitychange'
    // 2. If hidden â†’ pause polling
    // 3. If visible â†’ resume polling
    // 4. Cleanup listener

    return () => {
      // Cleanup
    };
  }, [pauseOnHidden]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // INITIAL START & CLEANUP
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  useEffect(() => {
    // TODO:
    // 1. Start polling on mount
    // 2. Cleanup everything on unmount
    //    - Clear interval
    //    - Abort in-flight request

    return () => {
      // Critical cleanup
    };
  }, [url, interval]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HELPER: Calculate time since last update
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const getTimeSinceUpdate = () => {
    if (!lastUpdate) return 'Never';

    const diff = Date.now() - lastUpdate;
    const seconds = Math.floor(diff / 1000);

    if (seconds < 60) return `${seconds}s ago`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m ago`;
    const hours = Math.floor(minutes / 60);
    return `${hours}h ago`;
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HELPER: Get status color
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const getStatusColor = () => {
    switch (status) {
      case 'polling':
        return '#28a745';
      case 'paused':
        return '#ffc107';
      case 'error':
        return '#dc3545';
      default:
        return '#6c757d';
    }
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RENDER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  return (
    <div
      style={{
        padding: '20px',
        maxWidth: '800px',
        margin: '0 auto',
        fontFamily: 'system-ui, -apple-system, sans-serif',
      }}
    >
      <h2>Advanced Polling Component</h2>

      {/* Status Bar */}
      <div
        style={{
          padding: '15px',
          marginBottom: '20px',
          backgroundColor: '#f8f9fa',
          border: '2px solid',
          borderColor: getStatusColor(),
          borderRadius: '8px',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
        }}
      >
        <div>
          <span
            style={{
              display: 'inline-block',
              width: '10px',
              height: '10px',
              borderRadius: '50%',
              backgroundColor: getStatusColor(),
              marginRight: '10px',
            }}
          />
          <strong>Status:</strong> {status}
        </div>
        <div style={{ fontSize: '14px', color: '#666' }}>
          Last update: {getTimeSinceUpdate()}
        </div>
      </div>

      {/* Control Buttons */}
      <div
        style={{
          display: 'flex',
          gap: '10px',
          marginBottom: '20px',
        }}
      >
        {status === 'polling' ? (
          <button
            onClick={pausePolling}
            style={{
              padding: '10px 20px',
              backgroundColor: '#ffc107',
              color: '#000',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontWeight: 'bold',
            }}
          >
            â¸ Pause
          </button>
        ) : (
          <button
            onClick={resumePolling}
            style={{
              padding: '10px 20px',
              backgroundColor: '#28a745',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              fontWeight: 'bold',
            }}
          >
            â–¶ Resume
          </button>
        )}

        <button
          onClick={manualRefresh}
          disabled={loading}
          style={{
            padding: '10px 20px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: loading ? 'not-allowed' : 'pointer',
            opacity: loading ? 0.6 : 1,
            fontWeight: 'bold',
          }}
        >
          ğŸ”„ Refresh Now
        </button>
      </div>

      {/* Loading Indicator */}
      {loading && (
        <div
          style={{
            padding: '10px',
            backgroundColor: '#e3f2fd',
            border: '1px solid #2196f3',
            borderRadius: '4px',
            marginBottom: '20px',
            textAlign: 'center',
          }}
        >
          â³ Fetching data...
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div
          style={{
            padding: '15px',
            backgroundColor: '#f8d7da',
            border: '1px solid #dc3545',
            borderRadius: '4px',
            marginBottom: '20px',
            color: '#721c24',
          }}
        >
          <strong>âŒ Error:</strong> {error}
          <div style={{ marginTop: '10px', fontSize: '14px' }}>
            Retry attempt: {/* TODO: show retryCount */}
          </div>
        </div>
      )}

      {/* Data Display */}
      <div
        style={{
          padding: '20px',
          backgroundColor: 'white',
          border: '1px solid #dee2e6',
          borderRadius: '8px',
          minHeight: '200px',
        }}
      >
        <h3>Data:</h3>
        {data ? (
          <pre
            style={{
              backgroundColor: '#f8f9fa',
              padding: '15px',
              borderRadius: '4px',
              overflow: 'auto',
              fontSize: '14px',
            }}
          >
            {JSON.stringify(data, null, 2)}
          </pre>
        ) : (
          <p style={{ color: '#999', textAlign: 'center' }}>
            No data yet. Waiting for first poll...
          </p>
        )}
      </div>

      {/* Debug Info */}
      <details style={{ marginTop: '20px' }}>
        <summary style={{ cursor: 'pointer', fontWeight: 'bold' }}>
          ğŸ” Debug Information
        </summary>
        <div
          style={{
            marginTop: '10px',
            padding: '15px',
            backgroundColor: '#f8f9fa',
            borderRadius: '4px',
            fontSize: '12px',
            fontFamily: 'monospace',
          }}
        >
          <p>
            <strong>URL:</strong> {url}
          </p>
          <p>
            <strong>Interval:</strong> {interval}ms
          </p>
          <p>
            <strong>Status:</strong> {status}
          </p>
          <p>
            <strong>Loading:</strong> {loading ? 'Yes' : 'No'}
          </p>
          <p>
            <strong>Has Data:</strong> {data ? 'Yes' : 'No'}
          </p>
          <p>
            <strong>Has Error:</strong> {error ? 'Yes' : 'No'}
          </p>
          <p>
            <strong>Pause on Hidden:</strong> {pauseOnHidden ? 'Yes' : 'No'}
          </p>
          {/* TODO: Add more debug info from refs */}
        </div>
      </details>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXAMPLE USAGE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function App() {
  return (
    <AdvancedPolling
      url='https://jsonplaceholder.typicode.com/posts/1'
      interval={5000}
      pauseOnHidden={true}
      onData={(data) => console.log('New data:', data)}
      onError={(error) => console.error('Polling error:', error)}
    />
  );
}

// ğŸ“ Documentation Requirements:
//
// Write a README.md explaining:
// 1. Component API (props)
// 2. Features
// 3. Usage examples
// 4. Edge cases handled
// 5. Performance considerations
//
// ğŸ” Code Review Self-Checklist:
// - [ ] All refs properly initialized
// - [ ] All intervals/timeouts cleared
// - [ ] All requests cancellable
// - [ ] No memory leaks
// - [ ] Error handling comprehensive
// - [ ] Loading states accurate
// - [ ] Status updates correct
// - [ ] Visibility API working
// - [ ] Exponential backoff implemented
// - [ ] Console logs helpful for debugging
// - [ ] Code readable and maintainable
// - [ ] Edge cases handled
// - [ ] Comments explain complex logic
```

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: useState vs useRef

| TiÃªu chÃ­           | useState                                | useRef                            | Khi nÃ o dÃ¹ng?                                           |
| ------------------ | --------------------------------------- | --------------------------------- | ------------------------------------------------------- |
| **Re-render**      | âœ… Trigger re-render                    | âŒ KHÃ”NG trigger re-render        | useState: UI data<br>useRef: Non-UI data                |
| **Update timing**  | Async (batched)                         | Sync (immediate)                  | useState: Cáº§n consistency<br>useRef: Cáº§n instant access |
| **Purpose**        | UI state management                     | Mutable values persistence        | useState: Hiá»ƒn thá»‹ lÃªn UI<br>useRef: Internal tracking  |
| **Access pattern** | `value`                                 | `ref.current`                     | -                                                       |
| **Persistence**    | âœ… Persists across renders              | âœ… Persists across renders        | Cáº£ hai Ä‘á»u persist                                      |
| **Initial value**  | `useState(initial)`                     | `useRef(initial)`                 | -                                                       |
| **Performance**    | Can cause re-renders                    | No re-render overhead             | useRef: Better cho high-frequency updates               |
| **Use cases**      | Form inputs, toggles, counters hiá»ƒn thá»‹ | Timer IDs, previous values, flags | -                                                       |

### Trade-offs Chi Tiáº¿t

#### âœ… Khi nÃ o PHáº¢I dÃ¹ng useState:

```jsx
// 1. UI data - cáº§n hiá»ƒn thá»‹ lÃªn mÃ n hÃ¬nh
const [count, setCount] = useState(0);
return <p>Count: {count}</p>; // âœ… UI needs this

// 2. Conditional rendering
const [isOpen, setIsOpen] = useState(false);
return isOpen ? <Modal /> : null; // âœ… Affects what renders

// 3. Derived values dÃ¹ng trong JSX
const [items, setItems] = useState([]);
return <p>Total: {items.length}</p>; // âœ… UI depends on this

// 4. Props passed to children
const [theme, setTheme] = useState('dark');
return <Button theme={theme} />; // âœ… Child needs this
```

#### âœ… Khi nÃ o PHáº¢I dÃ¹ng useRef:

```jsx
// 1. Timer/Interval IDs
const intervalRef = useRef(null);
intervalRef.current = setInterval(/* ... */); // âœ… Non-UI, no need to render

// 2. Previous values
const prevCountRef = useRef(count);
useEffect(() => {
  prevCountRef.current = count;
}); // âœ… Tracking, not displaying

// 3. Flags khÃ´ng áº£nh hÆ°á»Ÿng UI
const isMountedRef = useRef(true);
useEffect(() => () => {
  isMountedRef.current = false;
}); // âœ… Internal flag

// 4. Mutable values thay Ä‘á»•i thÆ°á»ng xuyÃªn
const renderCountRef = useRef(0);
renderCountRef.current += 1; // âœ… Would cause infinite loop with useState
```

### Decision Tree

```
                    Cáº§n lÆ°u giÃ¡ trá»‹?
                           â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚                               â”‚
      CÃ³ (persist)                    KhÃ´ng (local variable)
           â”‚
    GiÃ¡ trá»‹ nÃ y hiá»ƒn thá»‹ UI?
           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚
   CÃ³           KhÃ´ng
    â”‚             â”‚
useState       useRef

    VÃ­ dá»¥ useState:      VÃ­ dá»¥ useRef:
    - Counter display    - Timer ID
    - Form values        - Previous value
    - Toggle state       - Render count
    - Loading state      - Abort controller
    - Error message      - Flag variables
```

### Pattern Combinations

#### Pattern 1: useState + useRef cho Derived State

```jsx
// âœ… GOOD: useState cho source, useRef cho derived
function SearchWithHistory() {
  const [searchTerm, setSearchTerm] = useState('');
  const previousSearchRef = useRef('');

  useEffect(() => {
    previousSearchRef.current = searchTerm;
  }, [searchTerm]);

  const searchChanged = searchTerm !== previousSearchRef.current;

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      {searchChanged && <p>Search term changed!</p>}
    </div>
  );
}
```

#### Pattern 2: Multiple Refs cho Related Data

```jsx
// âœ… GOOD: Group related refs
function ComplexTimer() {
  const timerRefs = useRef({
    intervalId: null,
    startTime: null,
    pausedTime: null
  });

  const start = () => {
    timerRefs.current.startTime = Date.now();
    timerRefs.current.intervalId = setInterval(/* ... */);
  };

  const pause = () => {
    timerRefs.current.pausedTime = Date.now();
    clearInterval(timerRefs.current.intervalId);
  };

  return (/* ... */);
}
```

#### Pattern 3: Ref cho Optimization

```jsx
// âœ… GOOD: useRef trÃ¡nh unnecessary re-renders
function ChatRoom() {
  const [messages, setMessages] = useState([]);
  const scrollRef = useRef(null);
  const prevMessagesLengthRef = useRef(messages.length);

  useEffect(() => {
    // Chá»‰ scroll náº¿u cÃ³ message má»›i
    if (messages.length > prevMessagesLengthRef.current) {
      scrollRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
    prevMessagesLengthRef.current = messages.length;
  }, [messages]);

  return (
    <div>
      {messages.map((msg) => (
        <div key={msg.id}>{msg.text}</div>
      ))}
      <div ref={scrollRef} />
    </div>
  );
}
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Stale Ref Value â­

```jsx
// âŒ BUG: Ref value khÃ´ng update nhÆ° mong Ä‘á»£i
function BuggyCounter() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  const logCount = () => {
    console.log('Ref value:', countRef.current); // âš ï¸ LuÃ´n 0!
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <button onClick={logCount}>Log Ref</button>
    </div>
  );
}
```

**ğŸ” Debug Questions:**

1. Táº¡i sao `countRef.current` luÃ´n lÃ  0?
2. Ref Ä‘Æ°á»£c update khi nÃ o?
3. LÃ m sao fix?

**ğŸ’¡ Giáº£i thÃ­ch:**

```jsx
// âŒ Váº¤N Äá»€:
const countRef = useRef(count);
// useRef chá»‰ cháº¡y láº§n Ä‘áº§u (mount)
// count thay Ä‘á»•i nhÆ°ng ref KHÃ”NG tá»± Ä‘á»™ng sync!

// âœ… SOLUTION 1: Manual sync vá»›i useEffect
function FixedCounter() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);

  useEffect(() => {
    countRef.current = count; // Sync manually
  }, [count]);

  const logCount = () => {
    console.log('Ref value:', countRef.current); // âœ… Correct!
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <button onClick={logCount}>Log Ref</button>
    </div>
  );
}

// âœ… SOLUTION 2: Äá»c trá»±c tiáº¿p tá»« state (náº¿u cÃ³ thá»ƒ)
function BetterCounter() {
  const [count, setCount] = useState(0);

  const logCount = () => {
    console.log('Count value:', count); // âœ… Always correct
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
      <button onClick={logCount}>Log Count</button>
    </div>
  );
}
```

### Bug 2: Memory Leak - KhÃ´ng Cleanup Timer â­â­

```jsx
// âŒ BUG: Memory leak khi component unmount
function BuggyTimer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null);

  const startTimer = () => {
    intervalRef.current = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  };

  // âš ï¸ THIáº¾U CLEANUP!

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**ğŸ” Debug Questions:**

1. Äiá»u gÃ¬ xáº£y ra náº¿u component unmount khi timer Ä‘ang cháº¡y?
2. LÃ m sao detect memory leak?
3. CÃ¡ch fix Ä‘Ãºng?

**ğŸ’¡ Giáº£i thÃ­ch:**

```jsx
// âŒ Váº¤N Äá»€:
// Component unmount â†’ interval váº«n cháº¡y â†’ call setCount â†’ error + memory leak

// âš ï¸ Error trong console:
// "Warning: Can't perform a React state update on an unmounted component"

// âœ… SOLUTION: useEffect cleanup
function FixedTimer() {
  const [count, setCount] = useState(0);
  const intervalRef = useRef(null);

  const startTimer = () => {
    if (intervalRef.current) return; // Prevent multiple intervals

    intervalRef.current = setInterval(() => {
      setCount((c) => c + 1);
    }, 1000);
  };

  const stopTimer = () => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  };

  // âœ… Cleanup on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []); // Empty deps = chá»‰ mount/unmount

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}
```

**ğŸ” CÃ¡ch test memory leak:**

```jsx
function App() {
  const [showTimer, setShowTimer] = useState(true);

  return (
    <div>
      <button onClick={() => setShowTimer(!showTimer)}>Toggle Timer</button>

      {showTimer && <FixedTimer />}
    </div>
  );
}

// Test steps:
// 1. Start timer
// 2. Click "Toggle Timer" (unmount component)
// 3. Check console - khÃ´ng cÃ³ warning = good!
// 4. Open DevTools â†’ Memory â†’ Take heap snapshot
// 5. Unmount/remount nhiá»u láº§n
// 6. Take another snapshot
// 7. Compare â†’ detached intervals = memory leak
```

### Bug 3: Ref vs State Confusion â­â­â­

```jsx
// âŒ BUG: DÃ¹ng ref cho UI data
function BuggyTodoList() {
  const todosRef = useRef([]);

  const addTodo = (text) => {
    todosRef.current = [...todosRef.current, { id: Date.now(), text }];
    console.log('Todos:', todosRef.current); // âœ… Updated in ref
  };

  return (
    <div>
      <button onClick={() => addTodo('New todo')}>Add Todo</button>

      <ul>
        {todosRef.current.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
      {/* âš ï¸ UI never updates! */}
    </div>
  );
}
```

**ğŸ” Debug Questions:**

1. Táº¡i sao UI khÃ´ng update?
2. Console.log shows correct data nhÆ°ng UI stale?
3. Khi nÃ o thÃ¬ UI update?

**ğŸ’¡ Giáº£i thÃ­ch:**

```jsx
// âŒ Váº¤N Äá»€:
// - todosRef.current thay Ä‘á»•i âœ…
// - NhÆ°ng khÃ´ng trigger re-render âŒ
// - UI chá»‰ render láº§n Ä‘áº§u vá»›i empty array

// âœ… SOLUTION: DÃ¹ng useState cho UI data
function FixedTodoList() {
  const [todos, setTodos] = useState([]);

  const addTodo = (text) => {
    setTodos((prev) => [...prev, { id: Date.now(), text }]); // âœ… Triggers re-render
  };

  return (
    <div>
      <button onClick={() => addTodo('New todo')}>Add Todo</button>

      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}

// ğŸ’¡ QUY Táº®C:
// If it's displayed in JSX â†’ useState
// If it's internal tracking â†’ useRef
```

**Khi nÃ o UI sáº½ update náº¿u dÃ¹ng ref?**

```jsx
function WhenRefUpdates() {
  const countRef = useRef(0);
  const [, forceRender] = useState({});

  const increment = () => {
    countRef.current += 1;
    // UI váº«n khÃ´ng update!
  };

  const incrementAndRender = () => {
    countRef.current += 1;
    forceRender({}); // âœ… Force re-render
    // BÃ¢y giá» UI má»›i update!
  };

  return (
    <div>
      <p>Count: {countRef.current}</p>
      <button onClick={increment}>Increment (no update)</button>
      <button onClick={incrementAndRender}>Increment (with update)</button>
    </div>
  );
}

// âš ï¸ NhÆ°ng Ä‘Ã¢y lÃ  ANTI-PATTERN!
// Náº¿u cáº§n UI update â†’ dÃ¹ng useState!
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u cÃ¡c cÃ¢u báº¡n cÃ³ thá»ƒ tráº£ lá»i tá»± tin:

- [ ] useRef tráº£ vá» gÃ¬ vÃ  object Ä‘Ã³ cÃ³ cáº¥u trÃºc nhÆ° tháº¿ nÃ o?
- [ ] Táº¡i sao update `ref.current` khÃ´ng trigger re-render?
- [ ] Sá»± khÃ¡c biá»‡t chÃ­nh giá»¯a useState vÃ  useRef lÃ  gÃ¬?
- [ ] Khi nÃ o nÃªn dÃ¹ng useRef thay vÃ¬ useState?
- [ ] LÃ m sao track previous value cá»§a má»™t state?
- [ ] Táº¡i sao cáº§n cleanup timers trong useEffect?
- [ ] useRef cÃ³ thá»ƒ thay tháº¿ useState Ä‘á»ƒ tá»‘i Æ°u performance khÃ´ng?
- [ ] Ref object cÃ³ thay Ä‘á»•i giá»¯a cÃ¡c láº§n render khÃ´ng?
- [ ] CÃ³ thá»ƒ dÃ¹ng useRef Ä‘á»ƒ store object/array khÃ´ng?
- [ ] LÃ m sao debug memory leak tá»« timers?

### Code Review Checklist

Khi review code cÃ³ useRef, check:

#### âœ… Correct Usage:

- [ ] DÃ¹ng ref cho non-UI data (timer IDs, flags, previous values)
- [ ] DÃ¹ng state cho UI data
- [ ] Update ref.current synchronously khi cáº§n
- [ ] KhÃ´ng dá»±a vÃ o ref.current Ä‘á»ƒ trigger re-renders

#### âœ… Cleanup:

- [ ] Táº¥t cáº£ timers Ä‘á»u Ä‘Æ°á»£c cleared
- [ ] useEffect cÃ³ return cleanup function
- [ ] Cleanup cháº¡y on unmount vÃ  trÆ°á»›c next effect
- [ ] Refs Ä‘Æ°á»£c reset khi cáº§n (set vá» null)

#### âœ… Edge Cases:

- [ ] Handle multiple starts (prevent duplicate timers)
- [ ] Handle unmount mid-operation
- [ ] Validate ref.current trÆ°á»›c khi dÃ¹ng
- [ ] Consider race conditions

#### âœ… Performance:

- [ ] KhÃ´ng setState unnecessarily
- [ ] Refs Ä‘Æ°á»£c dÃ¹ng Ä‘Ãºng chá»— (khÃ´ng gÃ¢y extra renders)
- [ ] No memory leaks

#### âŒ Common Mistakes:

- [ ] KhÃ´ng dÃ¹ng ref cho UI data
- [ ] KhÃ´ng quÃªn cleanup
- [ ] KhÃ´ng expect ref thay Ä‘á»•i trigger render
- [ ] KhÃ´ng dÃ¹ng ref initial value nhÆ° useState

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

#### Exercise: Custom useTimeout Hook

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Táº¡o custom hook wrap setTimeout
 *
 * Requirements:
 * 1. Hook nháº­n callback vÃ  delay
 * 2. Tá»± Ä‘á»™ng cleanup on unmount
 * 3. CÃ³ thá»ƒ reset timer
 * 4. CÃ³ thá»ƒ cancel timer
 *
 * API:
 * const { reset, cancel } = useTimeout(callback, delay);
 */

// TODO: Implement useTimeout
function useTimeout(callback, delay) {
  // Hints:
  // - useRef cho timeout ID
  // - useRef cho callback (Ä‘á»ƒ trÃ¡nh stale closure)
  // - useEffect Ä‘á»ƒ setup/cleanup
  // - Return reset vÃ  cancel functions
}

// Usage example:
function NotificationDemo() {
  const [show, setShow] = useState(false);

  const { reset, cancel } = useTimeout(() => {
    setShow(false);
  }, 3000);

  const showNotification = () => {
    setShow(true);
    reset(); // Reset timer
  };

  return (
    <div>
      <button onClick={showNotification}>Show Notification</button>
      {show && (
        <div>
          <p>This will disappear in 3 seconds</p>
          <button onClick={cancel}>Keep it</button>
        </div>
      )}
    </div>
  );
}
```

### NÃ¢ng cao (60 phÃºt)

#### Exercise: Request Deduplication

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Prevent duplicate API requests
 *
 * Scenario:
 * User clicks "Load Data" nhiá»u láº§n nhanh.
 * Báº¡n chá»‰ muá»‘n gá»i API 1 láº§n, cÃ¡c request sau dÃ¹ng láº¡i káº¿t quáº£.
 *
 * Requirements:
 * 1. Track in-flight requests báº±ng ref
 * 2. If request pending â†’ return existing promise
 * 3. If request done â†’ return cached result (for 5s)
 * 4. After 5s â†’ allow new request
 *
 * Bonus:
 * - Support multiple URLs (cache by URL)
 * - Request cancellation
 * - Error handling with retry
 */

function useDeduplicatedFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // TODO: Implement vá»›i useRef
  // - Track pending request
  // - Cache results
  // - Deduplicate logic

  const fetchData = async () => {
    // TODO: Your implementation
  };

  return { data, loading, error, fetchData };
}
```

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - useRef:**
   https://react.dev/reference/react/useRef
2. **React Docs - Referencing Values with Refs:**
   https://react.dev/learn/referencing-values-with-refs

### Äá»c thÃªm

1. **When to use Ref vs State:**
   https://kentcdodds.com/blog/usememo-and-usecallback
2. **Avoiding Memory Leaks:**
   https://felixgerschau.com/react-hooks-memory-leaks/

3. **Understanding Refs:**
   https://daveceddia.com/useref-hook/

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (cáº§n biáº¿t tá»« trÆ°á»›c)

- **NgÃ y 11-12:** useState fundamentals
- **NgÃ y 16-20:** useEffect vÃ  cleanup
- **NgÃ y 19-20:** Data fetching patterns

### HÆ°á»›ng tá»›i (sáº½ dÃ¹ng á»Ÿ)

- **NgÃ y 22:** useRef cho DOM manipulation
- **NgÃ y 23:** useLayoutEffect vá»›i refs
- **NgÃ y 24:** Custom hooks vá»›i useRef
- **NgÃ y 25:** Project - Real-time Dashboard (combine táº¥t cáº£)

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

#### 1. Performance Optimization

```jsx
// âœ… GOOD: DÃ¹ng ref trÃ¡nh unnecessary re-renders
function ExpensiveComponent({ data }) {
  const previousDataRef = useRef(data);
  const hasChanged = !shallowEqual(data, previousDataRef.current);

  useEffect(() => {
    if (hasChanged) {
      // Heavy computation
      previousDataRef.current = data;
    }
  }, [data, hasChanged]);

  return (/* ... */);
}
```

#### 2. Debugging Tips

```jsx
// âœ… GOOD: Add debug info vá»›i useRef
function DebuggedComponent() {
  const renderCount = useRef(0);
  const prevPropsRef = useRef();

  useEffect(() => {
    renderCount.current += 1;

    if (import.meta.env.DEV) {
      console.log('Render #', renderCount.current);
      console.log('Prev props:', prevPropsRef.current);
      console.log('Current props:', props);
    }

    prevPropsRef.current = props;
  });

  return (/* ... */);
}
```

#### 3. Resource Management

```jsx
// âœ… GOOD: Centralized resource cleanup
function useResourceManager() {
  const resourcesRef = useRef({
    timers: [],
    listeners: [],
    requests: [],
  });

  const addTimer = (id) => {
    resourcesRef.current.timers.push(id);
  };

  const addListener = (element, event, handler) => {
    element.addEventListener(event, handler);
    resourcesRef.current.listeners.push({ element, event, handler });
  };

  useEffect(() => {
    return () => {
      // Cleanup all resources
      resourcesRef.current.timers.forEach(clearInterval);
      resourcesRef.current.listeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
      });
      resourcesRef.current.requests.forEach((req) => req.abort());
    };
  }, []);

  return { addTimer, addListener };
}
```

### CÃ¢u Há»i Phá»ng Váº¥n

#### Junior Level:

**Q1: "useRef vÃ  useState khÃ¡c nhau nhÆ° tháº¿ nÃ o?"**

Expected answer:

- useState trigger re-render khi update, useRef khÃ´ng
- useState cho UI data, useRef cho non-UI tracking
- useState async update, useRef sync update
- Cáº£ hai Ä‘á»u persist across renders

**Q2: "LÃ m sao store timer ID trong React?"**

Expected answer:

- DÃ¹ng useRef Ä‘á»ƒ store
- VÃ­ dá»¥: `const timerRef = useRef(null)`
- Update: `timerRef.current = setInterval(...)`
- Cleanup: `clearInterval(timerRef.current)`

#### Mid Level:

**Q3: "Giáº£i thÃ­ch use case cá»§a useRef ngoÃ i DOM manipulation."**

Expected answer:

- Previous value tracking
- Timer/interval IDs
- Flags (isMounted, isPaused)
- Mutable instance variables
- Avoiding stale closures
- Request cancellation (AbortController)

**Q4: "CÃ³ thá»ƒ dÃ¹ng useRef thay useState Ä‘á»ƒ optimize performance khÃ´ng?"**

Expected answer:

- KhÃ´ng thá»ƒ replace hoÃ n toÃ n
- useRef phÃ¹ há»£p cho non-UI data
- Náº¿u data hiá»ƒn thá»‹ lÃªn UI â†’ pháº£i dÃ¹ng useState
- useRef trÃ¡nh unnecessary re-renders cho internal tracking
- Trade-off: Lose automatic UI sync

#### Senior Level:

**Q5: "Design má»™t system Ä‘á»ƒ track vÃ  cleanup táº¥t cáº£ subscriptions trong má»™t component."**

Expected answer:

```jsx
function useSubscriptionManager() {
  const subscriptionsRef = useRef([]);

  const subscribe = (cleanup) => {
    subscriptionsRef.current.push(cleanup);
    return () => {
      const index = subscriptionsRef.current.indexOf(cleanup);
      if (index > -1) {
        subscriptionsRef.current.splice(index, 1);
      }
    };
  };

  useEffect(() => {
    return () => {
      subscriptionsRef.current.forEach((cleanup) => cleanup());
    };
  }, []);

  return subscribe;
}
```

**Q6: "Explain memory leak patterns vá»›i useRef vÃ  cÃ¡ch prevent."**

Expected answer:

- Timers khÃ´ng cleared
- Event listeners khÃ´ng removed
- Refs trá» Ä‘áº¿n large objects
- Solutions:
  - useEffect cleanup
  - WeakRef cho circular references
  - Null out refs sau khi dÃ¹ng
  - Resource tracking systems

### War Stories

#### Story 1: The Infinite Loop Mystery

```jsx
// âŒ BUG thá»±c táº¿ trong production:
function ChatRoom() {
  const [messages, setMessages] = useState([]);
  const wsRef = useRef(null);

  useEffect(() => {
    wsRef.current = new WebSocket(url);

    wsRef.current.onmessage = (e) => {
      setMessages([...messages, e.data]); // âš ï¸ STALE CLOSURE!
    };
  }, []); // Missing dependency!

  return (/* ... */);
}

// âœ… FIX:
function ChatRoom() {
  const [messages, setMessages] = useState([]);
  const wsRef = useRef(null);

  useEffect(() => {
    wsRef.current = new WebSocket(url);

    wsRef.current.onmessage = (e) => {
      setMessages(prev => [...prev, e.data]); // âœ… Functional update
    };

    return () => wsRef.current?.close();
  }, []); // Safe now

  return (/* ... */);
}
```

**Lesson learned:**

- LuÃ´n dÃ¹ng functional updates trong callbacks lÃ¢u dÃ i
- Refs giÃºp trÃ¡nh stale closures
- useEffect dependencies pháº£i chÃ­nh xÃ¡c

#### Story 2: The Memory Leak That Cost $1000

Real story: Dashboard component khÃ´ng cleanup intervals â†’ memory tÄƒng dáº§n â†’ server crash â†’ AWS bill spike.

```jsx
// âŒ Production bug:
function Dashboard() {
  useEffect(() => {
    const interval = setInterval(fetchData, 5000);
    // âš ï¸ No cleanup!
  }, []);
}

// âœ… Fix:
function Dashboard() {
  const intervalRef = useRef(null);

  useEffect(() => {
    intervalRef.current = setInterval(fetchData, 5000);

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);
}
```

**Lesson learned:**

- ALWAYS cleanup resources
- Monitor memory usage in production
- Test component unmount scenarios

---

## ğŸ¯ PREVIEW NGÃ€Y MAI

**NgÃ y 22: useRef - DOM Manipulation** ğŸ¨

NgÃ y mai chÃºng ta sáº½ há»c use case thá»© 2 cá»§a useRef: **accessing DOM nodes**.

Báº¡n sáº½ há»c:

- Ref forwarding vá»›i DOM elements
- Focus management
- Scroll control
- Measuring DOM nodes
- Third-party library integration
- When to use refs vs state for DOM

Chuáº©n bá»‹ mental model:

```
useRef = {
  Use Case 1: Mutable values (hÃ´m nay) âœ…
  Use Case 2: DOM references (ngÃ y mai) ğŸ¯
}
```

See you tomorrow! ğŸš€

---

## âœ… CHECKLIST HOÃ€N THÃ€NH

TrÆ°á»›c khi káº¿t thÃºc ngÃ y há»c, check:

- [ ] Hiá»ƒu sÃ¢u useRef vs useState
- [ ] LÃ m Ä‘á»§ 5 exercises
- [ ] Äá»c React docs vá» useRef
- [ ] LÃ m bÃ i táº­p vá» nhÃ 
- [ ] Review debug lab
- [ ] Chuáº©n bá»‹ cho ngÃ y mai

**ğŸ‰ Congratulations! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 21!**
