# üìÖ NG√ÄY 23: useLayoutEffect - Synchronous DOM Measurements & Updates

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:

- [ ] Hi·ªÉu s·ª± kh√°c bi·ªát gi·ªØa useEffect v√† useLayoutEffect v·ªÅ timing
- [ ] Bi·∫øt khi n√†o PH·∫¢I d√πng useLayoutEffect (v√† khi n√†o KH√îNG n√™n)
- [ ] ƒêo l∆∞·ªùng DOM properties (size, position) tr∆∞·ªõc khi browser paint
- [ ] NgƒÉn ch·∫∑n visual flickering v·ªõi synchronous updates
- [ ] Position tooltips, popovers, dropdowns ch√≠nh x√°c
- [ ] Setup animations m∆∞·ª£t m√† kh√¥ng b·ªã flash
- [ ] Hi·ªÉu performance trade-offs c·ªßa synchronous effects

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu, h√£y tr·∫£ l·ªùi 3 c√¢u h·ªèi n√†y:

1. **useRef c√≥ th·ªÉ d√πng ƒë·ªÉ l√†m g√¨ v·ªõi DOM?**
   - Access DOM nodes, call imperative methods (focus, scroll), measure dimensions

2. **useEffect ch·∫°y khi n√†o trong React lifecycle?**
   - Sau khi React ƒë√£ commit changes to DOM v√† browser ƒë√£ paint

3. **T·∫°i sao ƒë√¥i khi b·∫°n th·∫•y "flash" khi update UI trong useEffect?**
   - V√¨ useEffect ch·∫°y SAU khi paint ‚Üí user nh√¨n th·∫•y intermediate state ‚Üí update ‚Üí repaint

**H√¥m nay:** Ch√∫ng ta s·∫Ω h·ªçc c√°ch lo·∫°i b·ªè "flash" n√†y v·ªõi **useLayoutEffect** üéØ

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

H√£y xem t√¨nh hu·ªëng n√†y - tooltip c·∫ßn hi·ªÉn th·ªã ·ªü v·ªã tr√≠ ch√≠nh x√°c:

```jsx
// ‚ùå V·∫§N ƒê·ªÄ: Tooltip "nh·∫£y" v·ªã tr√≠
function Tooltip({ targetRef, children }) {
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const tooltipRef = useRef(null);

  useEffect(() => {
    // Measure target element
    const targetRect = targetRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();

    // Calculate position
    setPosition({
      top: targetRect.bottom + 5,
      left: targetRect.left,
    });
  }, [targetRef]);

  return (
    <div
      ref={tooltipRef}
      style={{
        position: 'fixed',
        top: position.top,
        left: position.left,
        backgroundColor: 'black',
        color: 'white',
        padding: '5px 10px',
        borderRadius: '4px',
      }}
    >
      {children}
    </div>
  );
}
```

**V·∫•n ƒë·ªÅ:**

- L·∫ßn ƒë·∫ßu render: position = { top: 0, left: 0 } ‚Üí tooltip xu·∫•t hi·ªán ·ªü g√≥c tr√™n-tr√°i
- Browser paint tooltip ·ªü v·ªã tr√≠ (0, 0)
- useEffect ch·∫°y ‚Üí calculate position m·ªõi
- setState ‚Üí re-render
- Browser paint l·∫°i ·ªü v·ªã tr√≠ ƒë√∫ng
- **User nh√¨n th·∫•y tooltip "nh·∫£y" t·ª´ (0,0) sang v·ªã tr√≠ ƒë√∫ng! üò±**

**Timeline v·ªõi useEffect:**

```
1. [Render]     ‚Üí tooltip at (0, 0)
2. [Paint]      ‚Üí User SEES tooltip at (0, 0) ‚ö†Ô∏è FLASH!
3. [useEffect]  ‚Üí Calculate correct position
4. [setState]   ‚Üí Trigger re-render
5. [Render]     ‚Üí tooltip at correct position
6. [Paint]      ‚Üí User SEES tooltip move ‚ö†Ô∏è JUMP!
```

### 1.2 Gi·∫£i Ph√°p: useLayoutEffect

```jsx
// ‚úÖ GI·∫¢I PH√ÅP: useLayoutEffect - no flash!
import { useLayoutEffect } from 'react';

function Tooltip({ targetRef, children }) {
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const tooltipRef = useRef(null);

  useLayoutEffect(() => {
    // üéØ Changed from useEffect
    // Measure target element
    const targetRect = targetRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();

    // Calculate position
    setPosition({
      top: targetRect.bottom + 5,
      left: targetRect.left,
    });
  }, [targetRef]);

  return (
    <div
      ref={tooltipRef}
      style={{
        position: 'fixed',
        top: position.top,
        left: position.left,
        backgroundColor: 'black',
        color: 'white',
        padding: '5px 10px',
        borderRadius: '4px',
      }}
    >
      {children}
    </div>
  );
}
```

**Timeline v·ªõi useLayoutEffect:**

```
1. [Render]           ‚Üí tooltip at (0, 0)
2. [useLayoutEffect]  ‚Üí Calculate BEFORE paint
3. [setState]         ‚Üí Synchronous update
4. [Re-render]        ‚Üí tooltip at correct position
5. [Paint]            ‚Üí User SEES tooltip at correct position ‚úÖ NO FLASH!
```

**S·ª± kh√°c bi·ªát ch√≠nh:**

```
useEffect:
[Render] ‚Üí [Commit to DOM] ‚Üí [Browser Paint] ‚Üí [useEffect runs]
                                     ‚Üë
                        User sees intermediate state!

useLayoutEffect:
[Render] ‚Üí [Commit to DOM] ‚Üí [useLayoutEffect runs] ‚Üí [Browser Paint]
                                        ‚Üë
                            Blocks painting until done!
```

### 1.3 Mental Model

H√£y t∆∞·ªüng t∆∞·ª£ng React lifecycle nh∆∞ **quay phim**:

```
useEffect = POST-PRODUCTION
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1. Film scene (render)
2. Show to audience (paint)
3. Add effects later (useEffect)
‚Üí Audience sees scene BEFORE effects

useLayoutEffect = LIVE EDITING
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1. Film scene (render)
2. Edit immediately (useLayoutEffect)
3. Show final version (paint)
‚Üí Audience only sees edited version
```

**Visual comparison:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         useEffect (Asynchronous)            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                             ‚îÇ
‚îÇ  Render    Paint    Effect    Re-paint     ‚îÇ
‚îÇ    ‚îÇ        ‚îÇ         ‚îÇ          ‚îÇ         ‚îÇ
‚îÇ    ‚ñº        ‚ñº         ‚ñº          ‚ñº         ‚îÇ
‚îÇ   [A] ‚îÄ‚îÄ> [A] ‚îÄ‚îÄ‚îÄ> [calc] ‚îÄ‚îÄ> [A‚ÜíB]       ‚îÇ
‚îÇ            üëÅÔ∏è                   üëÅÔ∏è         ‚îÇ
‚îÇ         FLASH!              JUMP!          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      useLayoutEffect (Synchronous)          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                             ‚îÇ
‚îÇ  Render    Effect    Re-render    Paint    ‚îÇ
‚îÇ    ‚îÇ         ‚îÇ          ‚îÇ           ‚îÇ      ‚îÇ
‚îÇ    ‚ñº         ‚ñº          ‚ñº           ‚ñº      ‚îÇ
‚îÇ   [A] ‚îÄ‚îÄ> [calc] ‚îÄ‚îÄ> [A‚ÜíB] ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> [B]    ‚îÇ
‚îÇ                                     üëÅÔ∏è     ‚îÇ
‚îÇ                                  SMOOTH!   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

#### ‚ùå Hi·ªÉu l·∫ßm 1: "N√™n d√πng useLayoutEffect cho m·ªçi effect"

```jsx
// ‚ùå SAI: D√πng useLayoutEffect khi kh√¥ng c·∫ßn
function BadComponent() {
  const [data, setData] = useState(null);

  // ‚ö†Ô∏è Data fetching KH√îNG c·∫ßn synchronous!
  useLayoutEffect(() => {
    fetch('/api/data')
      .then((res) => res.json())
      .then(setData);
  }, []);

  return <div>{data?.title}</div>;
}

// ‚úÖ ƒê√öNG: useEffect cho async operations
function GoodComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // ‚úÖ Async operations use useEffect
    fetch('/api/data')
      .then((res) => res.json())
      .then(setData);
  }, []);

  return <div>{data?.title}</div>;
}
```

**T·∫°i sao sai?**

- useLayoutEffect **blocks browser painting**
- Data fetching m·∫•t th·ªùi gian ‚Üí freeze UI
- User th·∫•y blank screen l√¢u h∆°n
- Performance regression!

#### ‚ùå Hi·ªÉu l·∫ßm 2: "useLayoutEffect v√† useEffect c√≥ API kh√°c nhau"

```jsx
// API ho√†n to√†n gi·ªëng nhau!
useEffect(() => {
  // effect code
  return () => {
    // cleanup
  };
}, [dependencies]);

useLayoutEffect(() => {
  // effect code (same syntax!)
  return () => {
    // cleanup (same!)
  };
}, [dependencies]);
```

**Ch·ªâ kh√°c v·ªÅ TIMING, kh√¥ng kh√°c v·ªÅ API!**

#### ‚ùå Hi·ªÉu l·∫ßm 3: "useLayoutEffect lu√¥n t·ªët h∆°n v√¨ kh√¥ng c√≥ flash"

```jsx
// ‚ùå ANTI-PATTERN: useLayoutEffect cho heavy computation
function BadExpensiveComponent() {
  const [result, setResult] = useState(null);

  useLayoutEffect(() => {
    // Heavy computation that takes 500ms
    const computed = heavyCalculation(); // ‚ö†Ô∏è Blocks painting for 500ms!
    setResult(computed);
  }, []);

  return <div>{result}</div>;
}

// ‚úÖ ƒê√öNG: useEffect cho heavy work
function GoodExpensiveComponent() {
  const [result, setResult] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Heavy computation doesn't block paint
    const computed = heavyCalculation();
    setResult(computed);
    setLoading(false);
  }, []);

  if (loading) return <div>Loading...</div>; // User sees loading state

  return <div>{result}</div>;
}
```

**Trade-off:**

- useLayoutEffect: No flash, but blocks painting (slower initial render)
- useEffect: Possible flash, but faster initial render (better UX for slow operations)

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Pattern C∆° B·∫£n - Measuring DOM Elements ‚≠ê

```jsx
/**
 * üéØ M·ª•c ti√™u: ƒêo k√≠ch th∆∞·ªõc element v√† adjust UI accordingly
 * üí° Pattern: useLayoutEffect cho measurements tr∆∞·ªõc khi paint
 */

import { useState, useRef, useLayoutEffect } from 'react';

function ResizableText({ text }) {
  const [fontSize, setFontSize] = useState(16);
  const containerRef = useRef(null);
  const textRef = useRef(null);

  useLayoutEffect(() => {
    // Measure container v√† text
    const containerWidth = containerRef.current.offsetWidth;
    const textWidth = textRef.current.scrollWidth;

    // N·∫øu text qu√° d√†i ‚Üí gi·∫£m font size
    if (textWidth > containerWidth) {
      const ratio = containerWidth / textWidth;
      setFontSize((prev) => Math.max(12, prev * ratio * 0.95)); // Min 12px
    } else if (textWidth < containerWidth * 0.8 && fontSize < 24) {
      // N·∫øu text qu√° ng·∫Øn ‚Üí tƒÉng font size
      setFontSize((prev) => Math.min(24, prev * 1.1)); // Max 24px
    }
  }, [text]); // Re-measure when text changes

  return (
    <div style={{ padding: '20px' }}>
      <h2>Auto-sizing Text</h2>

      <div
        ref={containerRef}
        style={{
          width: '300px',
          padding: '10px',
          border: '2px solid #007bff',
          borderRadius: '8px',
          overflow: 'hidden',
        }}
      >
        <div
          ref={textRef}
          style={{
            fontSize: `${fontSize}px`,
            fontWeight: 'bold',
            whiteSpace: 'nowrap',
            transition: 'font-size 0.2s ease',
          }}
        >
          {text}
        </div>
      </div>

      <div style={{ marginTop: '10px', fontSize: '12px', color: '#666' }}>
        Current font size: {fontSize.toFixed(1)}px
      </div>
    </div>
  );
}

// Demo app
function MeasurementDemo() {
  const [text, setText] = useState('Hello World');

  return (
    <div>
      <ResizableText text={text} />

      <div style={{ marginTop: '20px' }}>
        <input
          type='text'
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder='Enter text...'
          style={{
            width: '300px',
            padding: '10px',
            fontSize: '16px',
          }}
        />
      </div>

      <div style={{ marginTop: '10px' }}>
        <button onClick={() => setText('Hi')}>Short</button>
        <button
          onClick={() => setText('This is a very long text that should shrink')}
        >
          Long
        </button>
      </div>
    </div>
  );
}
```

**Comparison: useEffect vs useLayoutEffect:**

```jsx
// ‚ùå V·ªõi useEffect: User th·∫•y flash
function BadResizableText({ text }) {
  const [fontSize, setFontSize] = useState(16);
  const containerRef = useRef(null);
  const textRef = useRef(null);

  useEffect(() => {
    // ‚ö†Ô∏è useEffect
    const containerWidth = containerRef.current.offsetWidth;
    const textWidth = textRef.current.scrollWidth;

    if (textWidth > containerWidth) {
      setFontSize((prev) =>
        Math.max(12, prev * (containerWidth / textWidth) * 0.95),
      );
    }
  }, [text]);

  return (
    <div
      ref={containerRef}
      style={{ width: '300px' }}
    >
      <div
        ref={textRef}
        style={{ fontSize: `${fontSize}px` }}
      >
        {text}
      </div>
    </div>
  );
}

// Timeline:
// 1. Render v·ªõi fontSize = 16
// 2. Paint ‚Üí User sees overflowing text ‚ö†Ô∏è FLASH!
// 3. useEffect measures ‚Üí setText(12)
// 4. Re-render v√† re-paint ‚Üí Text now fits

// ‚úÖ V·ªõi useLayoutEffect: Smooth!
function GoodResizableText({ text }) {
  const [fontSize, setFontSize] = useState(16);
  const containerRef = useRef(null);
  const textRef = useRef(null);

  useLayoutEffect(() => {
    // ‚úÖ useLayoutEffect
    const containerWidth = containerRef.current.offsetWidth;
    const textWidth = textRef.current.scrollWidth;

    if (textWidth > containerWidth) {
      setFontSize((prev) =>
        Math.max(12, prev * (containerWidth / textWidth) * 0.95),
      );
    }
  }, [text]);

  return (
    <div
      ref={containerRef}
      style={{ width: '300px' }}
    >
      <div
        ref={textRef}
        style={{ fontSize: `${fontSize}px` }}
      >
        {text}
      </div>
    </div>
  );
}

// Timeline:
// 1. Render v·ªõi fontSize = 16
// 2. useLayoutEffect measures ‚Üí setText(12)
// 3. Re-render v·ªõi fontSize = 12
// 4. Paint ‚Üí User sees correctly sized text ‚úÖ NO FLASH!
```

### Demo 2: K·ªãch B·∫£n Th·ª±c T·∫ø - Smart Tooltip Positioning ‚≠ê‚≠ê

```jsx
/**
 * üéØ Use case: Tooltip t·ª± ƒë·ªông adjust v·ªã tr√≠ ƒë·ªÉ kh√¥ng b·ªã overflow
 * üíº Real-world: Tooltips, popovers, dropdown menus
 * ‚ö†Ô∏è Challenge: T√≠nh to√°n viewport bounds v√† flip direction n·∫øu c·∫ßn
 */

import { useState, useRef, useLayoutEffect } from 'react';

function SmartTooltip({
  children,
  content,
  preferredPosition = 'bottom', // 'top' | 'bottom' | 'left' | 'right'
}) {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const [actualPosition, setActualPosition] = useState(preferredPosition);

  const triggerRef = useRef(null);
  const tooltipRef = useRef(null);

  useLayoutEffect(() => {
    if (!isVisible || !triggerRef.current || !tooltipRef.current) return;

    // Get bounding boxes
    const triggerRect = triggerRef.current.getBoundingClientRect();
    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    const gap = 8; // Gap between trigger and tooltip
    let finalPosition = preferredPosition;
    let top = 0;
    let left = 0;

    // Calculate position based on preferred direction
    switch (preferredPosition) {
      case 'bottom':
        top = triggerRect.bottom + gap;
        left = triggerRect.left + (triggerRect.width - tooltipRect.width) / 2;

        // Check if overflows bottom ‚Üí flip to top
        if (top + tooltipRect.height > viewportHeight) {
          finalPosition = 'top';
          top = triggerRect.top - tooltipRect.height - gap;
        }
        break;

      case 'top':
        top = triggerRect.top - tooltipRect.height - gap;
        left = triggerRect.left + (triggerRect.width - tooltipRect.width) / 2;

        // Check if overflows top ‚Üí flip to bottom
        if (top < 0) {
          finalPosition = 'bottom';
          top = triggerRect.bottom + gap;
        }
        break;

      case 'right':
        top = triggerRect.top + (triggerRect.height - tooltipRect.height) / 2;
        left = triggerRect.right + gap;

        // Check if overflows right ‚Üí flip to left
        if (left + tooltipRect.width > viewportWidth) {
          finalPosition = 'left';
          left = triggerRect.left - tooltipRect.width - gap;
        }
        break;

      case 'left':
        top = triggerRect.top + (triggerRect.height - tooltipRect.height) / 2;
        left = triggerRect.left - tooltipRect.width - gap;

        // Check if overflows left ‚Üí flip to right
        if (left < 0) {
          finalPosition = 'right';
          left = triggerRect.right + gap;
        }
        break;
    }

    // Clamp to viewport
    left = Math.max(
      gap,
      Math.min(left, viewportWidth - tooltipRect.width - gap),
    );
    top = Math.max(
      gap,
      Math.min(top, viewportHeight - tooltipRect.height - gap),
    );

    setPosition({ top, left });
    setActualPosition(finalPosition);
  }, [isVisible, preferredPosition, content]);

  return (
    <>
      {/* Trigger element */}
      <span
        ref={triggerRef}
        onMouseEnter={() => setIsVisible(true)}
        onMouseLeave={() => setIsVisible(false)}
        style={{
          cursor: 'help',
          borderBottom: '1px dashed #007bff',
          color: '#007bff',
        }}
      >
        {children}
      </span>

      {/* Tooltip */}
      {isVisible && (
        <div
          ref={tooltipRef}
          style={{
            position: 'fixed',
            top: `${position.top}px`,
            left: `${position.left}px`,
            backgroundColor: '#333',
            color: 'white',
            padding: '8px 12px',
            borderRadius: '4px',
            fontSize: '14px',
            maxWidth: '200px',
            zIndex: 9999,
            pointerEvents: 'none',
            boxShadow: '0 2px 8px rgba(0,0,0,0.2)',
          }}
        >
          {content}

          {/* Arrow indicator */}
          <div
            style={{
              position: 'absolute',
              width: 0,
              height: 0,
              borderStyle: 'solid',
              ...(actualPosition === 'bottom' && {
                top: '-6px',
                left: '50%',
                transform: 'translateX(-50%)',
                borderWidth: '0 6px 6px 6px',
                borderColor: 'transparent transparent #333 transparent',
              }),
              ...(actualPosition === 'top' && {
                bottom: '-6px',
                left: '50%',
                transform: 'translateX(-50%)',
                borderWidth: '6px 6px 0 6px',
                borderColor: '#333 transparent transparent transparent',
              }),
              ...(actualPosition === 'right' && {
                left: '-6px',
                top: '50%',
                transform: 'translateY(-50%)',
                borderWidth: '6px 6px 6px 0',
                borderColor: 'transparent #333 transparent transparent',
              }),
              ...(actualPosition === 'left' && {
                right: '-6px',
                top: '50%',
                transform: 'translateY(-50%)',
                borderWidth: '6px 0 6px 6px',
                borderColor: 'transparent transparent transparent #333',
              }),
            }}
          />
        </div>
      )}
    </>
  );
}

// Demo app
function TooltipDemo() {
  return (
    <div style={{ padding: '100px 20px', minHeight: '150vh' }}>
      <h2>Smart Tooltip Positioning</h2>
      <p>
        Hover over the blue text to see tooltips. Scroll to test edge detection.
      </p>

      <div style={{ marginTop: '50px' }}>
        <p>
          This is a{' '}
          <SmartTooltip
            content='This tooltip prefers bottom but will flip to top if needed'
            preferredPosition='bottom'
          >
            bottom tooltip
          </SmartTooltip>{' '}
          example.
        </p>

        <p>
          This is a{' '}
          <SmartTooltip
            content='This tooltip prefers top but will flip to bottom if needed'
            preferredPosition='top'
          >
            top tooltip
          </SmartTooltip>{' '}
          example.
        </p>

        <p>
          This is a{' '}
          <SmartTooltip
            content='This tooltip prefers right but will flip to left if needed'
            preferredPosition='right'
          >
            right tooltip
          </SmartTooltip>{' '}
          example.
        </p>

        <p>
          This is a{' '}
          <SmartTooltip
            content='This tooltip prefers left but will flip to right if needed'
            preferredPosition='left'
          >
            left tooltip
          </SmartTooltip>{' '}
          example.
        </p>
      </div>

      <div style={{ marginTop: '100vh' }}>
        <p>Scroll to bottom to test edge detection:</p>
        <p>
          <SmartTooltip
            content='I should flip to top when near bottom edge'
            preferredPosition='bottom'
          >
            Bottom tooltip near edge
          </SmartTooltip>
        </p>
      </div>
    </div>
  );
}
```

**Why useLayoutEffect is CRITICAL here:**

```jsx
// ‚ùå V·ªõi useEffect: Tooltip flashes at wrong position
// Timeline:
// 1. Render tooltip at (0, 0)
// 2. Paint ‚Üí User SEES tooltip at (0, 0) ‚ö†Ô∏è
// 3. useEffect calculates position
// 4. Update position state
// 5. Re-paint ‚Üí Tooltip jumps to correct position ‚ö†Ô∏è

// ‚úÖ V·ªõi useLayoutEffect: Smooth positioning
// Timeline:
// 1. Render tooltip at (0, 0)
// 2. useLayoutEffect calculates position (BEFORE paint)
// 3. Update position state synchronously
// 4. Re-render with correct position
// 5. Paint ‚Üí User sees tooltip at correct position ‚úÖ
```

### Demo 3: Edge Cases - Animation Initialization ‚≠ê‚≠ê‚≠ê

```jsx
/**
 * üéØ Use case: Initialize animation library (GSAP, Framer Motion)
 * ‚ö†Ô∏è Edge cases:
 *    - Animation must start from measured position
 *    - Must run before first paint to avoid flash
 *    - Cleanup animations on unmount
 *    - Handle window resize
 */

import { useState, useRef, useLayoutEffect } from 'react';

function AnimatedCard({ title, content, index }) {
  const cardRef = useRef(null);
  const animationRef = useRef(null);

  useLayoutEffect(() => {
    if (!cardRef.current) return;

    // Get initial position
    const rect = cardRef.current.getBoundingClientRect();

    // Setup initial state (before paint!)
    cardRef.current.style.opacity = '0';
    cardRef.current.style.transform = 'translateY(50px)';

    // Start animation immediately after layout
    // (In real app, use GSAP or Framer Motion)
    const startAnimation = () => {
      cardRef.current.style.transition = 'all 0.5s ease';
      cardRef.current.style.opacity = '1';
      cardRef.current.style.transform = 'translateY(0)';
    };

    // Stagger animations
    const delay = index * 100;
    animationRef.current = setTimeout(startAnimation, delay);

    return () => {
      if (animationRef.current) {
        clearTimeout(animationRef.current);
      }
    };
  }, []); // Only run once on mount

  return (
    <div
      ref={cardRef}
      style={{
        padding: '20px',
        margin: '10px 0',
        backgroundColor: 'white',
        border: '1px solid #ddd',
        borderRadius: '8px',
        boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
      }}
    >
      <h3 style={{ margin: '0 0 10px 0' }}>{title}</h3>
      <p style={{ margin: 0, color: '#666' }}>{content}</p>
    </div>
  );
}

// Staggered list animation
function AnimatedList() {
  const [items, setItems] = useState([
    { id: 1, title: 'Card 1', content: 'This card animates in first' },
    { id: 2, title: 'Card 2', content: 'This card animates in second' },
    { id: 3, title: 'Card 3', content: 'This card animates in third' },
  ]);

  const [showList, setShowList] = useState(true);

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h2>Animated List</h2>

      <button
        onClick={() => {
          setShowList(false);
          setTimeout(() => setShowList(true), 100);
        }}
        style={{
          padding: '10px 20px',
          marginBottom: '20px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
        }}
      >
        Replay Animation
      </button>

      {showList && (
        <div>
          {items.map((item, index) => (
            <AnimatedCard
              key={item.id}
              title={item.title}
              content={item.content}
              index={index}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

**Comparison:**

```jsx
// ‚ùå V·ªõi useEffect: Flash of unstyled content
function BadAnimatedCard({ title, content }) {
  const cardRef = useRef(null);

  useEffect(() => {
    // ‚ö†Ô∏è useEffect
    // Set initial state
    cardRef.current.style.opacity = '0';
    cardRef.current.style.transform = 'translateY(50px)';

    // Animate
    setTimeout(() => {
      cardRef.current.style.opacity = '1';
      cardRef.current.style.transform = 'translateY(0)';
    }, 100);
  }, []);

  return <div ref={cardRef}>{title}</div>;
}

// Timeline:
// 1. Render with default styles
// 2. Paint ‚Üí User SEES card at full opacity ‚ö†Ô∏è FLASH!
// 3. useEffect sets opacity 0
// 4. Re-paint ‚Üí Card disappears
// 5. setTimeout animates in
// Result: Awkward flash then disappear then animate

// ‚úÖ V·ªõi useLayoutEffect: Smooth from start
function GoodAnimatedCard({ title, content }) {
  const cardRef = useRef(null);

  useLayoutEffect(() => {
    // ‚úÖ useLayoutEffect
    // Set initial state BEFORE first paint
    cardRef.current.style.opacity = '0';
    cardRef.current.style.transform = 'translateY(50px)';

    // Animate
    setTimeout(() => {
      cardRef.current.style.transition = 'all 0.5s ease';
      cardRef.current.style.opacity = '1';
      cardRef.current.style.transform = 'translateY(0)';
    }, 100);
  }, []);

  return <div ref={cardRef}>{title}</div>;
}

// Timeline:
// 1. Render with default styles
// 2. useLayoutEffect sets opacity 0 (BEFORE paint)
// 3. Paint ‚Üí User sees card at opacity 0
// 4. setTimeout animates in smoothly
// Result: Smooth animation from start ‚úÖ
```

**Real GSAP integration example:**

```jsx
// üí° Real-world pattern v·ªõi GSAP
import { useLayoutEffect, useRef } from 'react';
// import gsap from 'gsap';

function GSAPAnimatedCard({ children }) {
  const cardRef = useRef(null);
  const tlRef = useRef(null); // Timeline ref

  useLayoutEffect(() => {
    // Create GSAP timeline
    // tlRef.current = gsap.timeline();

    // Setup animation (runs before paint!)
    // tlRef.current.fromTo(
    //   cardRef.current,
    //   {
    //     opacity: 0,
    //     y: 50
    //   },
    //   {
    //     opacity: 1,
    //     y: 0,
    //     duration: 0.5,
    //     ease: 'power2.out'
    //   }
    // );

    return () => {
      // Cleanup timeline
      // tlRef.current?.kill();
    };
  }, []);

  return <div ref={cardRef}>{children}</div>;
}
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Exercise 1: Highlight Active Section on Scroll (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Table of contents v·ªõi active section highlighting
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: useReducer, Context
 *
 * Requirements:
 * 1. Scroll spy - highlight current section in TOC
 * 2. Smooth scroll to section on click
 * 3. Update active section d·ª±a tr√™n scroll position
 * 4. No flash khi update active state
 *
 * üí° G·ª£i √Ω:
 * - useLayoutEffect ƒë·ªÉ measure section positions
 * - Scroll listener ƒë·ªÉ detect active section
 * - IntersectionObserver c√≥ th·ªÉ d√πng nh∆∞ng kh√¥ng b·∫Øt bu·ªôc
 */

import { useState, useRef, useLayoutEffect, useEffect } from 'react';

function TableOfContents() {
  const [activeSection, setActiveSection] = useState('section1');
  const [sectionPositions, setSectionPositions] = useState({});

  const section1Ref = useRef(null);
  const section2Ref = useRef(null);
  const section3Ref = useRef(null);

  // TODO: Measure section positions v·ªõi useLayoutEffect
  useLayoutEffect(() => {
    // Measure t·∫•t c·∫£ sections
    // const positions = {
    //   section1: section1Ref.current.offsetTop,
    //   section2: section2Ref.current.offsetTop,
    //   section3: section3Ref.current.offsetTop
    // };
    // setSectionPositions(positions);
  }, []);

  // TODO: Scroll listener v·ªõi useEffect
  useEffect(() => {
    const handleScroll = () => {
      const scrollPos = window.scrollY + 100; // Offset

      // Determine active section based on scroll position
      // if (scrollPos >= sectionPositions.section3) {
      //   setActiveSection('section3');
      // } else if (scrollPos >= sectionPositions.section2) {
      //   setActiveSection('section2');
      // } else {
      //   setActiveSection('section1');
      // }
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, [sectionPositions]);

  const scrollToSection = (ref) => {
    ref.current?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  };

  return (
    <div style={{ display: 'flex', minHeight: '200vh' }}>
      {/* Table of Contents - Fixed */}
      <nav
        style={{
          position: 'fixed',
          width: '200px',
          padding: '20px',
          backgroundColor: '#f8f9fa',
          borderRight: '2px solid #ddd',
          height: '100vh',
        }}
      >
        <h3>Table of Contents</h3>
        <ul style={{ listStyle: 'none', padding: 0 }}>
          <li
            onClick={() => scrollToSection(section1Ref)}
            style={{
              padding: '10px',
              cursor: 'pointer',
              backgroundColor:
                activeSection === 'section1' ? '#007bff' : 'transparent',
              color: activeSection === 'section1' ? 'white' : 'black',
              borderRadius: '4px',
              marginBottom: '5px',
              transition: 'all 0.2s',
            }}
          >
            Section 1
          </li>
          <li
            onClick={() => scrollToSection(section2Ref)}
            style={{
              padding: '10px',
              cursor: 'pointer',
              backgroundColor:
                activeSection === 'section2' ? '#007bff' : 'transparent',
              color: activeSection === 'section2' ? 'white' : 'black',
              borderRadius: '4px',
              marginBottom: '5px',
              transition: 'all 0.2s',
            }}
          >
            Section 2
          </li>
          <li
            onClick={() => scrollToSection(section3Ref)}
            style={{
              padding: '10px',
              cursor: 'pointer',
              backgroundColor:
                activeSection === 'section3' ? '#007bff' : 'transparent',
              color: activeSection === 'section3' ? 'white' : 'black',
              borderRadius: '4px',
              transition: 'all 0.2s',
            }}
          >
            Section 3
          </li>
        </ul>
      </nav>

      {/* Content */}
      <main style={{ marginLeft: '220px', padding: '20px', width: '100%' }}>
        <section
          ref={section1Ref}
          style={{ minHeight: '100vh', paddingTop: '20px' }}
        >
          <h2>Section 1</h2>
          <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit...</p>
          {Array.from({ length: 10 }).map((_, i) => (
            <p key={i}>Content paragraph {i + 1}</p>
          ))}
        </section>

        <section
          ref={section2Ref}
          style={{ minHeight: '100vh', paddingTop: '20px' }}
        >
          <h2>Section 2</h2>
          <p>
            Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua...
          </p>
          {Array.from({ length: 10 }).map((_, i) => (
            <p key={i}>Content paragraph {i + 1}</p>
          ))}
        </section>

        <section
          ref={section3Ref}
          style={{ minHeight: '100vh', paddingTop: '20px' }}
        >
          <h2>Section 3</h2>
          <p>
            Ut enim ad minim veniam, quis nostrud exercitation ullamco
            laboris...
          </p>
          {Array.from({ length: 10 }).map((_, i) => (
            <p key={i}>Content paragraph {i + 1}</p>
          ))}
        </section>
      </main>
    </div>
  );
}

// ‚úÖ Expected behavior:
// - Active section highlights in TOC as you scroll
// - Click section ‚Üí smooth scroll
// - No flash when updating active state
```

### ‚≠ê‚≠ê Exercise 2: Masonry Layout (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Pinterest-style masonry layout v·ªõi height calculations
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario:
 * Images v·ªõi different heights c·∫ßn ƒë∆∞·ª£c arrange trong masonry grid.
 * Ph·∫£i calculate heights v√† positions BEFORE paint ƒë·ªÉ avoid layout shift.
 *
 * Requirements:
 * 1. 3 columns masonry layout
 * 2. Items arranged theo shortest column
 * 3. Calculate positions v·ªõi useLayoutEffect
 * 4. Smooth loading without jumps
 * 5. Handle window resize
 */

import { useState, useRef, useLayoutEffect } from 'react';

function MasonryLayout({ items }) {
  const [itemPositions, setItemPositions] = useState({});
  const containerRef = useRef(null);
  const itemRefs = useRef({});

  useLayoutEffect(() => {
    if (!containerRef.current) return;

    // TODO: Calculate masonry positions
    // Algorithm:
    // 1. Initialize column heights = [0, 0, 0]
    // 2. For each item:
    //    a. Find shortest column
    //    b. Place item in that column
    //    c. Update column height
    //    d. Store position (left, top)

    const columns = 3;
    const gap = 16;
    const containerWidth = containerRef.current.offsetWidth;
    const columnWidth = (containerWidth - gap * (columns - 1)) / columns;

    const columnHeights = Array(columns).fill(0);
    const positions = {};

    items.forEach((item, index) => {
      // Get item height
      const itemElement = itemRefs.current[item.id];
      if (!itemElement) return;

      const itemHeight = itemElement.offsetHeight;

      // Find shortest column
      const shortestColumn = columnHeights.indexOf(Math.min(...columnHeights));

      // Calculate position
      const left = shortestColumn * (columnWidth + gap);
      const top = columnHeights[shortestColumn];

      positions[item.id] = { left, top };

      // Update column height
      columnHeights[shortestColumn] += itemHeight + gap;
    });

    setItemPositions(positions);

    // Set container height
    const maxHeight = Math.max(...columnHeights);
    containerRef.current.style.height = `${maxHeight}px`;
  }, [items]);

  // TODO: Handle resize
  useLayoutEffect(() => {
    const handleResize = () => {
      // Recalculate positions on resize
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [items]);

  return (
    <div style={{ padding: '20px' }}>
      <h2>Masonry Layout</h2>

      <div
        ref={containerRef}
        style={{
          position: 'relative',
          width: '100%',
          maxWidth: '900px',
          margin: '0 auto',
        }}
      >
        {items.map((item) => {
          const pos = itemPositions[item.id] || { left: 0, top: 0 };

          return (
            <div
              key={item.id}
              ref={(el) => (itemRefs.current[item.id] = el)}
              style={{
                position: 'absolute',
                left: `${pos.left}px`,
                top: `${pos.top}px`,
                width: 'calc(33.333% - 11px)',
                transition: 'all 0.3s ease',
                backgroundColor: 'white',
                border: '1px solid #ddd',
                borderRadius: '8px',
                overflow: 'hidden',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
              }}
            >
              <img
                src={item.image}
                alt={item.title}
                style={{
                  width: '100%',
                  display: 'block',
                }}
              />
              <div style={{ padding: '10px' }}>
                <h3 style={{ margin: '0 0 5px 0', fontSize: '16px' }}>
                  {item.title}
                </h3>
                <p style={{ margin: 0, fontSize: '14px', color: '#666' }}>
                  {item.description}
                </p>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}

// Demo
function MasonryDemo() {
  const [items] = useState([
    {
      id: 1,
      image: 'https://picsum.photos/300/200',
      title: 'Item 1',
      description: 'Short description',
    },
    {
      id: 2,
      image: 'https://picsum.photos/300/400',
      title: 'Item 2',
      description: 'This is a longer description that takes more space',
    },
    {
      id: 3,
      image: 'https://picsum.photos/300/250',
      title: 'Item 3',
      description: 'Medium length',
    },
    {
      id: 4,
      image: 'https://picsum.photos/300/350',
      title: 'Item 4',
      description: 'Another item',
    },
    {
      id: 5,
      image: 'https://picsum.photos/300/180',
      title: 'Item 5',
      description: 'Small one',
    },
    {
      id: 6,
      image: 'https://picsum.photos/300/300',
      title: 'Item 6',
      description: 'Square-ish',
    },
  ]);

  return <MasonryLayout items={items} />;
}

// üéØ Expected behavior:
// - Items arranged in 3 columns
// - Shortest column gets next item
// - No layout shift/jump when rendering
// - Smooth transitions when resizing
```

### ‚≠ê‚≠ê‚≠ê Exercise 3: Modal v·ªõi Focus Trap (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Accessible modal v·ªõi focus management
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† keyboard user, t√¥i mu·ªën focus trap trong modal ƒë·ªÉ navigate d·ªÖ d√†ng"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Focus first element khi modal m·ªü
 * - [ ] Tab cycles through focusable elements trong modal
 * - [ ] Shift+Tab cycles backward
 * - [ ] Escape closes modal
 * - [ ] Restore focus khi modal ƒë√≥ng
 * - [ ] Prevent body scroll khi modal open
 *
 * üé® Technical Constraints:
 * - useLayoutEffect cho focus management
 * - useEffect cho body scroll lock
 * - Proper cleanup
 *
 * üö® Edge Cases c·∫ßn handle:
 * - Modal content changes (refocus first element)
 * - No focusable elements in modal
 * - Nested modals (bonus)
 * - Unmount during animation
 */

import { useState, useRef, useLayoutEffect, useEffect } from 'react';

function AccessibleModal({ isOpen, onClose, children, title }) {
  const modalRef = useRef(null);
  const previousFocusRef = useRef(null);
  const firstFocusableRef = useRef(null);
  const lastFocusableRef = useRef(null);

  // TODO: Focus management v·ªõi useLayoutEffect
  useLayoutEffect(() => {
    if (!isOpen || !modalRef.current) return;

    // Save currently focused element
    previousFocusRef.current = document.activeElement;

    // Get all focusable elements
    const focusableElements = modalRef.current.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
    );

    if (focusableElements.length === 0) {
      // No focusable elements ‚Üí focus modal itself
      modalRef.current.focus();
      return;
    }

    firstFocusableRef.current = focusableElements[0];
    lastFocusableRef.current = focusableElements[focusableElements.length - 1];

    // Focus first element
    firstFocusableRef.current.focus();

    // Cleanup: restore focus
    return () => {
      previousFocusRef.current?.focus();
    };
  }, [isOpen]);

  // TODO: Keyboard navigation
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e) => {
      // Escape to close
      if (e.key === 'Escape') {
        onClose();
        return;
      }

      // Tab key for focus trap
      if (e.key === 'Tab') {
        if (e.shiftKey) {
          // Shift + Tab
          if (document.activeElement === firstFocusableRef.current) {
            e.preventDefault();
            lastFocusableRef.current?.focus();
          }
        } else {
          // Tab
          if (document.activeElement === lastFocusableRef.current) {
            e.preventDefault();
            firstFocusableRef.current?.focus();
          }
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, onClose]);

  // TODO: Prevent body scroll
  useEffect(() => {
    if (!isOpen) return;

    // Save current scroll position
    const scrollY = window.scrollY;

    // Lock body scroll
    document.body.style.position = 'fixed';
    document.body.style.top = `-${scrollY}px`;
    document.body.style.width = '100%';

    return () => {
      // Restore scroll
      document.body.style.position = '';
      document.body.style.top = '';
      document.body.style.width = '';
      window.scrollTo(0, scrollY);
    };
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
      }}
      onClick={onClose}
    >
      <div
        ref={modalRef}
        role='dialog'
        aria-modal='true'
        aria-labelledby='modal-title'
        tabIndex={-1}
        onClick={(e) => e.stopPropagation()}
        style={{
          backgroundColor: 'white',
          borderRadius: '8px',
          padding: '24px',
          maxWidth: '500px',
          width: '90%',
          maxHeight: '90vh',
          overflow: 'auto',
          boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
        }}
      >
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: '16px',
          }}
        >
          <h2
            id='modal-title'
            style={{ margin: 0 }}
          >
            {title}
          </h2>
          <button
            onClick={onClose}
            aria-label='Close modal'
            style={{
              background: 'none',
              border: 'none',
              fontSize: '24px',
              cursor: 'pointer',
              padding: '4px 8px',
            }}
          >
            √ó
          </button>
        </div>

        {children}
      </div>
    </div>
  );
}

// Demo
function ModalDemo() {
  const [isOpen, setIsOpen] = useState(false);
  const [formData, setFormData] = useState({ name: '', email: '' });

  return (
    <div style={{ padding: '20px' }}>
      <h2>Accessible Modal Demo</h2>

      <button
        onClick={() => setIsOpen(true)}
        style={{
          padding: '10px 20px',
          backgroundColor: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
        }}
      >
        Open Modal
      </button>

      <div style={{ marginTop: '20px', padding: '100vh 0' }}>
        <p>Scroll down to test body scroll lock</p>
        <p>Bottom of page</p>
      </div>

      <AccessibleModal
        isOpen={isOpen}
        onClose={() => setIsOpen(false)}
        title='Contact Form'
      >
        <form
          onSubmit={(e) => {
            e.preventDefault();
            console.log('Submitted:', formData);
            setIsOpen(false);
          }}
        >
          <div style={{ marginBottom: '16px' }}>
            <label style={{ display: 'block', marginBottom: '4px' }}>
              Name:
            </label>
            <input
              type='text'
              value={formData.name}
              onChange={(e) =>
                setFormData({ ...formData, name: e.target.value })
              }
              style={{
                width: '100%',
                padding: '8px',
                fontSize: '14px',
                border: '1px solid #ccc',
                borderRadius: '4px',
              }}
            />
          </div>

          <div style={{ marginBottom: '16px' }}>
            <label style={{ display: 'block', marginBottom: '4px' }}>
              Email:
            </label>
            <input
              type='email'
              value={formData.email}
              onChange={(e) =>
                setFormData({ ...formData, email: e.target.value })
              }
              style={{
                width: '100%',
                padding: '8px',
                fontSize: '14px',
                border: '1px solid #ccc',
                borderRadius: '4px',
              }}
            />
          </div>

          <div
            style={{ display: 'flex', gap: '8px', justifyContent: 'flex-end' }}
          >
            <button
              type='button'
              onClick={() => setIsOpen(false)}
              style={{
                padding: '8px 16px',
                backgroundColor: '#6c757d',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
              }}
            >
              Cancel
            </button>
            <button
              type='submit'
              style={{
                padding: '8px 16px',
                backgroundColor: '#28a745',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
              }}
            >
              Submit
            </button>
          </div>
        </form>
      </AccessibleModal>
    </div>
  );
}

// üéØ Expected behavior:
// - Focus jumps to first input when modal opens
// - Tab cycles through: name input ‚Üí email input ‚Üí Cancel ‚Üí Submit ‚Üí name input
// - Shift+Tab cycles backward
// - Escape closes modal
// - Body scroll locked while modal open
// - Focus returns to trigger button when closed
```

### ‚≠ê‚≠ê‚≠ê‚≠ê Exercise 4: Dropdown Menu v·ªõi Smart Positioning (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Production-ready dropdown v·ªõi collision detection
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Nhi·ªám v·ª•:
 * 1. So s√°nh positioning strategies:
 *    A. Fixed position v·ªõi viewport calculations
 *    B. Absolute position relative to trigger
 *    C. Portal v·ªõi global positioning
 * 2. Document pros/cons
 * 3. Ch·ªçn approach
 * 4. Write ADR
 *
 * Requirements:
 * - Dropdown flips n·∫øu kh√¥ng ƒë·ªß space
 * - Clamps to viewport boundaries
 * - Updates position on scroll/resize
 * - Smooth animations
 * - Keyboard navigation
 * - Click outside to close
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 * üß™ PHASE 3: Testing (10 ph√∫t)
 */

import { useState, useRef, useLayoutEffect, useEffect } from 'react';

function SmartDropdown({ trigger, items, align = 'left' }) {
  const [isOpen, setIsOpen] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const [flipped, setFlipped] = useState(false);

  const triggerRef = useRef(null);
  const dropdownRef = useRef(null);

  // TODO: Calculate position v·ªõi useLayoutEffect
  useLayoutEffect(() => {
    if (!isOpen || !triggerRef.current || !dropdownRef.current) return;

    const calculatePosition = () => {
      const triggerRect = triggerRef.current.getBoundingClientRect();
      const dropdownRect = dropdownRef.current.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const viewportWidth = window.innerWidth;

      let top = triggerRect.bottom + 4;
      let left =
        align === 'left'
          ? triggerRect.left
          : triggerRect.right - dropdownRect.width;
      let shouldFlip = false;

      // Check bottom overflow
      if (top + dropdownRect.height > viewportHeight) {
        // Try flipping to top
        const topPosition = triggerRect.top - dropdownRect.height - 4;
        if (topPosition > 0) {
          top = topPosition;
          shouldFlip = true;
        } else {
          // Clamp to viewport
          top = viewportHeight - dropdownRect.height - 8;
        }
      }

      // Check horizontal overflow
      if (left + dropdownRect.width > viewportWidth) {
        left = viewportWidth - dropdownRect.width - 8;
      }
      if (left < 0) {
        left = 8;
      }

      setPosition({ top, left });
      setFlipped(shouldFlip);
    };

    calculatePosition();

    // Recalculate on scroll/resize
    window.addEventListener('scroll', calculatePosition, true);
    window.addEventListener('resize', calculatePosition);

    return () => {
      window.removeEventListener('scroll', calculatePosition, true);
      window.removeEventListener('resize', calculatePosition);
    };
  }, [isOpen, align]);

  // TODO: Click outside
  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (e) => {
      if (
        triggerRef.current &&
        !triggerRef.current.contains(e.target) &&
        dropdownRef.current &&
        !dropdownRef.current.contains(e.target)
      ) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isOpen]);

  // TODO: Keyboard navigation
  useEffect(() => {
    if (!isOpen) return;

    const handleKeyDown = (e) => {
      if (e.key === 'Escape') {
        setIsOpen(false);
        triggerRef.current?.focus();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen]);

  return (
    <div style={{ position: 'relative', display: 'inline-block' }}>
      <div
        ref={triggerRef}
        onClick={() => setIsOpen(!isOpen)}
      >
        {trigger}
      </div>

      {isOpen && (
        <div
          ref={dropdownRef}
          style={{
            position: 'fixed',
            top: `${position.top}px`,
            left: `${position.left}px`,
            backgroundColor: 'white',
            border: '1px solid #ddd',
            borderRadius: '4px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
            minWidth: '200px',
            zIndex: 1000,
            opacity: position.top === 0 ? 0 : 1,
            transition: 'opacity 0.15s ease',
          }}
        >
          {items.map((item, index) => (
            <div
              key={index}
              onClick={() => {
                item.onClick?.();
                setIsOpen(false);
              }}
              style={{
                padding: '10px 16px',
                cursor: 'pointer',
                transition: 'background-color 0.15s',
                borderBottom:
                  index < items.length - 1 ? '1px solid #f0f0f0' : 'none',
              }}
              onMouseEnter={(e) =>
                (e.currentTarget.style.backgroundColor = '#f5f5f5')
              }
              onMouseLeave={(e) =>
                (e.currentTarget.style.backgroundColor = 'white')
              }
            >
              {item.label}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

// Demo
function DropdownDemo() {
  return (
    <div>
      <div style={{ padding: '20px', marginBottom: '100vh' }}>
        <h2>Smart Dropdown Demo</h2>
        <p>Try dropdowns at different positions:</p>

        <div style={{ marginTop: '20px' }}>
          <SmartDropdown
            trigger={
              <button style={{ padding: '10px 20px', cursor: 'pointer' }}>
                Top of Page
              </button>
            }
            items={[
              { label: 'Option 1', onClick: () => console.log('Option 1') },
              { label: 'Option 2', onClick: () => console.log('Option 2') },
              { label: 'Option 3', onClick: () => console.log('Option 3') },
            ]}
          />
        </div>
      </div>

      <div style={{ padding: '20px' }}>
        <SmartDropdown
          trigger={
            <button style={{ padding: '10px 20px', cursor: 'pointer' }}>
              Bottom of Page (Should Flip)
            </button>
          }
          items={[
            { label: 'Option 1', onClick: () => console.log('Option 1') },
            { label: 'Option 2', onClick: () => console.log('Option 2') },
            { label: 'Option 3', onClick: () => console.log('Option 3') },
            { label: 'Option 4', onClick: () => console.log('Option 4') },
            { label: 'Option 5', onClick: () => console.log('Option 5') },
          ]}
        />
      </div>
    </div>
  );
}

// üß™ PHASE 3: Testing Checklist
// - [ ] Dropdown appears at correct position
// - [ ] Flips to top when near bottom edge
// - [ ] Clamps to viewport boundaries
// - [ ] Updates position on scroll
// - [ ] Closes on click outside
// - [ ] Closes on Escape
// - [ ] No flash/jump on open
```

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Exercise 5: Virtualized List v·ªõi Smooth Scrolling (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Virtual scroll list cho 10,000+ items
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 *
 * Build virtualized list ƒë·ªÉ render large datasets efficiently:
 * 1. Only render visible items
 * 2. Smooth scrolling experience
 * 3. Dynamic item heights
 * 4. Scroll position preservation
 * 5. Jump to index
 * 6. Measurement caching
 *
 * üèóÔ∏è Technical Design Doc:
 *
 * 1. Component Architecture:
 *    - useLayoutEffect ƒë·ªÉ measure item heights
 *    - Cache measurements trong ref
 *    - Calculate visible range
 *    - Render only visible items
 *
 * 2. Performance Strategy:
 *    - Overscan ƒë·ªÉ prevent white space
 *    - Debounced scroll handler
 *    - Memoized calculations
 *    - Height estimation for unmeasured items
 *
 * 3. Challenges:
 *    - Dynamic heights unknown upfront
 *    - Scroll position jumps
 *    - Performance with rapid scrolling
 *
 * ‚úÖ Production Checklist:
 * - [ ] Measure all rendered items
 * - [ ] Cache measurements
 * - [ ] Calculate visible range correctly
 * - [ ] Smooth scrolling
 * - [ ] No white space/jumps
 * - [ ] Jump to index works
 * - [ ] Memory efficient
 */

import { useState, useRef, useLayoutEffect, useEffect, useMemo } from 'react';

function VirtualizedList({
  items,
  estimatedItemHeight = 50,
  overscan = 3,
  containerHeight = 600,
}) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef(null);
  const heightCache = useRef({});
  const itemRefs = useRef({});

  // TODO: Measure item heights v·ªõi useLayoutEffect
  useLayoutEffect(() => {
    // Measure all rendered items
    Object.keys(itemRefs.current).forEach((key) => {
      const element = itemRefs.current[key];
      if (element) {
        const height = element.getBoundingClientRect().height;
        heightCache.current[key] = height;
      }
    });
  });

  // Calculate visible range
  const { virtualItems, totalHeight } = useMemo(() => {
    const heights = [];
    let totalHeight = 0;

    // Calculate cumulative heights
    items.forEach((item, index) => {
      const height = heightCache.current[index] || estimatedItemHeight;
      heights.push({ index, height, offset: totalHeight });
      totalHeight += height;
    });

    // Find visible range
    const startIndex = heights.findIndex(
      (h) => h.offset + h.height > scrollTop,
    );
    const endIndex = heights.findIndex(
      (h) => h.offset > scrollTop + containerHeight,
    );

    const start = Math.max(0, startIndex - overscan);
    const end = Math.min(
      heights.length,
      (endIndex === -1 ? heights.length : endIndex) + overscan,
    );

    const virtualItems = heights.slice(start, end).map((h) => ({
      index: h.index,
      offset: h.offset,
      height: h.height,
    }));

    return { virtualItems, totalHeight };
  }, [items, scrollTop, estimatedItemHeight, overscan, containerHeight]);

  // Scroll handler
  const handleScroll = (e) => {
    setScrollTop(e.target.scrollTop);
  };

  // Jump to index
  const scrollToIndex = (index) => {
    if (!containerRef.current) return;

    let offset = 0;
    for (let i = 0; i < index; i++) {
      offset += heightCache.current[i] || estimatedItemHeight;
    }

    containerRef.current.scrollTop = offset;
  };

  return (
    <div style={{ padding: '20px' }}>
      <h2>Virtualized List ({items.length.toLocaleString()} items)</h2>

      <div style={{ marginBottom: '10px' }}>
        <input
          type='number'
          placeholder='Jump to index...'
          onKeyPress={(e) => {
            if (e.key === 'Enter') {
              scrollToIndex(parseInt(e.target.value));
            }
          }}
          style={{ padding: '5px', marginRight: '10px' }}
        />
        <button onClick={() => scrollToIndex(0)}>Top</button>
        <button onClick={() => scrollToIndex(Math.floor(items.length / 2))}>
          Middle
        </button>
        <button onClick={() => scrollToIndex(items.length - 1)}>Bottom</button>
      </div>

      <div
        ref={containerRef}
        onScroll={handleScroll}
        style={{
          height: `${containerHeight}px`,
          overflow: 'auto',
          border: '1px solid #ccc',
          borderRadius: '4px',
          position: 'relative',
        }}
      >
        <div style={{ height: `${totalHeight}px`, position: 'relative' }}>
          {virtualItems.map((virtualItem) => {
            const item = items[virtualItem.index];

            return (
              <div
                key={virtualItem.index}
                ref={(el) => (itemRefs.current[virtualItem.index] = el)}
                style={{
                  position: 'absolute',
                  top: `${virtualItem.offset}px`,
                  left: 0,
                  right: 0,
                  padding: '10px',
                  borderBottom: '1px solid #eee',
                  backgroundColor:
                    virtualItem.index % 2 === 0 ? 'white' : '#f9f9f9',
                }}
              >
                <div style={{ fontWeight: 'bold' }}>
                  Item #{virtualItem.index}
                </div>
                <div style={{ color: '#666', fontSize: '14px' }}>
                  {item.content}
                </div>
              </div>
            );
          })}
        </div>
      </div>

      <div style={{ marginTop: '10px', fontSize: '12px', color: '#666' }}>
        Scroll position: {scrollTop.toFixed(0)}px | Rendering{' '}
        {virtualItems.length} / {items.length} items
      </div>
    </div>
  );
}

// Demo
function VirtualListDemo() {
  const items = useMemo(() => {
    return Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      content: `This is item ${i}. ${i % 3 === 0 ? 'This item has extra content to make it taller and test dynamic heights.' : ''}`,
    }));
  }, []);

  return <VirtualizedList items={items} />;
}

// üìù Implementation Notes:
//
// Algorithm breakdown:
// 1. Initialize with estimated heights
// 2. Render visible items based on scrollTop
// 3. Measure actual heights after render
// 4. Cache measurements
// 5. Recalculate on scroll with cached heights
// 6. Repeat 2-5
//
// Performance tips:
// - Use refs for caching (no re-renders)
// - Memoize calculations
// - Overscan prevents white space
// - Don't measure on every scroll (use actual heights from cache)
```

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh: useEffect vs useLayoutEffect

| Ti√™u ch√≠           | useEffect                    | useLayoutEffect              | Khi n√†o d√πng?                                         |
| ------------------ | ---------------------------- | ---------------------------- | ----------------------------------------------------- |
| **Timing**         | After paint                  | Before paint                 | useLayoutEffect: C·∫ßn update tr∆∞·ªõc paint               |
| **Synchronous**    | ‚ùå Async                     | ‚úÖ Sync (blocks paint)       | useLayoutEffect: DOM measurements                     |
| **Performance**    | ‚úÖ T·ªët h∆°n (non-blocking)    | ‚ö†Ô∏è C√≥ th·ªÉ slow (blocks)      | useEffect: M·∫∑c ƒë·ªãnh<br>useLayoutEffect: Khi c·∫ßn thi·∫øt |
| **Visual flash**   | ‚ö†Ô∏è C√≥ th·ªÉ c√≥                 | ‚úÖ Kh√¥ng c√≥                  | useLayoutEffect: Tooltip positioning                  |
| **Use cases**      | Data fetching, subscriptions | DOM measurements, animations | -                                                     |
| **SSR**            | ‚úÖ Safe                      | ‚ö†Ô∏è Warning                   | useEffect cho SSR                                     |
| **Browser paint**  | Happens before effect        | Blocked until effect done    | -                                                     |
| **Default choice** | ‚úÖ Yes                       | ‚ùå No                        | Start with useEffect                                  |

### Decision Tree

```
           C·∫ßn DOM operation?
                   ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                     ‚îÇ
       C√≥                   Kh√¥ng
        ‚îÇ                     ‚îÇ
  User nh√¨n th·∫•y         useEffect
  intermediate state
  c√≥ v·∫•n ƒë·ªÅ kh√¥ng?
        ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ       ‚îÇ
   C√≥     Kh√¥ng
    ‚îÇ       ‚îÇ
useLayout useEffect
Effect
    ‚îÇ
Examples:
- Tooltip position
- Animation init
- Measure‚ÜíUpdate
- Prevent flicker
```

### Trade-offs Analysis

#### useLayoutEffect Pros:

```jsx
‚úÖ No visual flash
‚úÖ Synchronous measurements
‚úÖ Guaranteed before paint
‚úÖ Perfect cho positioning
‚úÖ Animation initialization
```

#### useLayoutEffect Cons:

```jsx
‚ùå Blocks browser painting
‚ùå Slower initial render
‚ùå Can cause jank if slow
‚ùå SSR warnings
‚ùå Overuse hurts performance
```

### Pattern Combinations

#### Pattern 1: Measure then Update

```jsx
// ‚úÖ GOOD: Measure ‚Üí Update pattern
function ResizableComponent({ content }) {
  const [size, setSize] = useState({ width: 0, height: 0 });
  const ref = useRef(null);

  useLayoutEffect(() => {
    // 1. Measure
    const rect = ref.current.getBoundingClientRect();

    // 2. Update (synchronously before paint)
    setSize({ width: rect.width, height: rect.height });
  }, [content]); // Re-measure when content changes

  return (
    <div ref={ref}>
      {content}
      <div>
        Size: {size.width} x {size.height}
      </div>
    </div>
  );
}
```

#### Pattern 2: Hybrid Approach

```jsx
// ‚úÖ PATTERN: useLayoutEffect cho measurement, useEffect cho side effects
function HybridComponent() {
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
  const [data, setData] = useState(null);
  const ref = useRef(null);

  // Measurement: useLayoutEffect
  useLayoutEffect(() => {
    const rect = ref.current.getBoundingClientRect();
    setDimensions({ width: rect.width, height: rect.height });
  }, []);

  // Data fetching: useEffect
  useEffect(() => {
    fetchData(dimensions).then(setData);
  }, [dimensions]);

  return <div ref={ref}>{/* ... */}</div>;
}
```

#### Pattern 3: Conditional Sync

```jsx
// ‚úÖ PATTERN: useLayoutEffect ch·ªâ khi c·∫ßn, fallback to useEffect
function SmartComponent({ needsSyncUpdate }) {
  const [value, setValue] = useState(0);
  const effectHook = needsSyncUpdate ? useLayoutEffect : useEffect;

  effectHook(() => {
    // Logic here
  }, []);

  return <div>{value}</div>;
}
```

### Common Patterns

#### Pattern: Tooltip/Popover Positioning

```jsx
const [position, setPosition] = useState({ top: 0, left: 0 });

useLayoutEffect(() => {
  // Measure trigger
  const triggerRect = triggerRef.current.getBoundingClientRect();
  const tooltipRect = tooltipRef.current.getBoundingClientRect();

  // Calculate position
  let top = triggerRect.bottom + 5;
  let left = triggerRect.left;

  // Adjust for viewport
  if (top + tooltipRect.height > window.innerHeight) {
    top = triggerRect.top - tooltipRect.height - 5;
  }

  setPosition({ top, left });
}, []);
```

#### Pattern: Animation Setup

```jsx
useLayoutEffect(() => {
  // Set initial state BEFORE paint
  element.style.opacity = '0';
  element.style.transform = 'scale(0.8)';

  // Trigger animation
  requestAnimationFrame(() => {
    element.style.transition = 'all 0.3s ease';
    element.style.opacity = '1';
    element.style.transform = 'scale(1)';
  });
}, []);
```

#### Pattern: Scroll Position Restoration

```jsx
useLayoutEffect(() => {
  // Restore scroll BEFORE paint
  const savedPosition = sessionStorage.getItem('scrollPos');
  if (savedPosition) {
    window.scrollTo(0, parseInt(savedPosition));
  }
}, []);

useEffect(() => {
  // Save scroll position
  const handleScroll = () => {
    sessionStorage.setItem('scrollPos', window.scrollY);
  };

  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Using useLayoutEffect for Async Operations ‚≠ê

```jsx
// ‚ùå BUG: Async operation trong useLayoutEffect
function BuggyDataFetcher() {
  const [data, setData] = useState(null);

  useLayoutEffect(() => {
    // ‚ö†Ô∏è Async operation blocks painting!
    fetch('/api/data')
      .then((res) => res.json())
      .then(setData);
  }, []);

  return <div>{data?.title}</div>;
}
```

**üîç Debug Questions:**

1. T·∫°i sao ƒë√¢y l√† bad practice?
2. Impact l√™n user experience?
3. C√°ch fix?

**üí° Gi·∫£i th√≠ch:**

```jsx
// ‚ùå V·∫§N ƒê·ªÄ:
// - useLayoutEffect blocks painting
// - Fetch takes time (100ms - 1s+)
// - User sees BLANK SCREEN during fetch
// - Terrible UX!

// Timeline:
// 1. Render
// 2. useLayoutEffect runs
// 3. fetch() starts... (blocks paint!)
// 4. ...waiting... (user sees nothing!)
// 5. ...still waiting...
// 6. Response arrives
// 7. setData ‚Üí re-render
// 8. FINALLY paint

// ‚úÖ SOLUTION: useEffect cho async operations
function FixedDataFetcher() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // ‚úÖ useEffect
    fetch('/api/data')
      .then((res) => res.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>; // User sees loading state

  return <div>{data?.title}</div>;
}

// Timeline:
// 1. Render with loading state
// 2. Paint ‚Üí User SEES "Loading..." ‚úÖ
// 3. useEffect runs (async, doesn't block)
// 4. fetch() in background
// 5. Response arrives
// 6. Update state ‚Üí re-render ‚Üí paint new data

// üìä RULE:
// useLayoutEffect: Only for SYNCHRONOUS DOM operations
// useEffect: For async operations, side effects, subscriptions
```

### Bug 2: Measuring Wrong Element ‚≠ê‚≠ê

```jsx
// ‚ùå BUG: Measuring element that hasn't rendered yet
function BuggyConditional() {
  const [show, setShow] = useState(false);
  const [height, setHeight] = useState(0);
  const divRef = useRef(null);

  useLayoutEffect(() => {
    // ‚ö†Ô∏è divRef.current might be null!
    const h = divRef.current.offsetHeight; // TypeError!
    setHeight(h);
  }, []); // ‚ö†Ô∏è Missing dependency: show

  return (
    <div>
      <button onClick={() => setShow(!show)}>Toggle</button>
      {show && <div ref={divRef}>Content</div>}
      <p>Height: {height}</p>
    </div>
  );
}
```

**üîç Debug Questions:**

1. T·∫°i sao divRef.current l√† null?
2. Effect ch·∫°y khi n√†o?
3. Fix nh∆∞ th·∫ø n√†o?

**üí° Gi·∫£i th√≠ch:**

```jsx
// ‚ùå V·∫§N ƒê·ªÄ:
// - useLayoutEffect with [] runs only on mount
// - At mount: show = false ‚Üí div doesn't exist
// - divRef.current = null ‚Üí crash!

// ‚úÖ SOLUTION 1: Add show to dependencies
function Fixed1() {
  const [show, setShow] = useState(false);
  const [height, setHeight] = useState(0);
  const divRef = useRef(null);

  useLayoutEffect(() => {
    if (divRef.current) {
      // ‚úÖ Null check
      const h = divRef.current.offsetHeight;
      setHeight(h);
    }
  }, [show]); // ‚úÖ Re-run when show changes

  return (
    <div>
      <button onClick={() => setShow(!show)}>Toggle</button>
      {show && <div ref={divRef}>Content</div>}
      <p>Height: {height}</p>
    </div>
  );
}

// ‚úÖ SOLUTION 2: Callback ref
function Fixed2() {
  const [show, setShow] = useState(false);
  const [height, setHeight] = useState(0);

  const measureRef = (element) => {
    if (element) {
      // Called when element mounts
      setHeight(element.offsetHeight);
    }
  };

  return (
    <div>
      <button onClick={() => setShow(!show)}>Toggle</button>
      {show && <div ref={measureRef}>Content</div>}
      <p>Height: {height}</p>
    </div>
  );
}

// üìä LESSON:
// - Always null-check refs
// - Include relevant dependencies
// - Callback refs useful cho conditional elements
```

### Bug 3: Infinite Loop v·ªõi Measurements ‚≠ê‚≠ê‚≠ê

```jsx
// ‚ùå BUG: useLayoutEffect causes infinite render loop
function BuggyInfiniteLoop() {
  const [size, setSize] = useState({ width: 0, height: 0 });
  const divRef = useRef(null);

  useLayoutEffect(() => {
    const rect = divRef.current.getBoundingClientRect();

    // ‚ö†Ô∏è Always sets new object ‚Üí always triggers re-render!
    setSize({ width: rect.width, height: rect.height });

    // ‚ö†Ô∏è No dependencies ‚Üí runs after EVERY render!
  }); // Missing dependency array!

  return (
    <div
      ref={divRef}
      style={{ width: `${size.width}px` }}
    >
      Content
    </div>
  );
}
```

**üîç Debug Questions:**

1. T·∫°i sao component re-render v√¥ t·∫≠n?
2. Dependency array missing impact?
3. C√°ch break loop?

**üí° Gi·∫£i th√≠ch:**

```jsx
// ‚ùå V·∫§N ƒê·ªÄ:
// Loop:
// 1. Render
// 2. useLayoutEffect runs (no deps ‚Üí always runs)
// 3. Measure DOM
// 4. setSize({ width: 100, height: 50 })
// 5. Re-render (state changed)
// 6. useLayoutEffect runs again
// 7. setSize({ width: 100, height: 50 }) // Same values but new object!
// 8. Re-render (React sees different object reference)
// 9. Loop continues forever! üí•

// ‚úÖ SOLUTION 1: Add empty dependency array
function Fixed1() {
  const [size, setSize] = useState({ width: 0, height: 0 });
  const divRef = useRef(null);

  useLayoutEffect(() => {
    const rect = divRef.current.getBoundingClientRect();
    setSize({ width: rect.width, height: rect.height });
  }, []); // ‚úÖ Only run once on mount

  return (
    <div
      ref={divRef}
      style={{ width: `${size.width}px` }}
    >
      Content
    </div>
  );
}

// ‚úÖ SOLUTION 2: Check if size actually changed
function Fixed2() {
  const [size, setSize] = useState({ width: 0, height: 0 });
  const divRef = useRef(null);

  useLayoutEffect(() => {
    const rect = divRef.current.getBoundingClientRect();

    // ‚úÖ Only update if actually changed
    setSize((prev) => {
      if (prev.width === rect.width && prev.height === rect.height) {
        return prev; // Same object reference ‚Üí no re-render
      }
      return { width: rect.width, height: rect.height };
    });
  }); // Can run every render now - safe!

  return <div ref={divRef}>Content</div>;
}

// ‚úÖ SOLUTION 3: Use ResizeObserver
function Fixed3() {
  const [size, setSize] = useState({ width: 0, height: 0 });
  const divRef = useRef(null);

  useLayoutEffect(() => {
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      setSize({
        width: entry.contentRect.width,
        height: entry.contentRect.height,
      });
    });

    observer.observe(divRef.current);

    return () => observer.disconnect();
  }, []); // Only setup once

  return <div ref={divRef}>Content</div>;
}

// üìä LESSONS:
// 1. ALWAYS use dependency array
// 2. Check if values actually changed before setState
// 3. Prefer ResizeObserver for size changes
// 4. Be careful with object references
```

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

ƒê√°nh d·∫•u c√°c c√¢u b·∫°n c√≥ th·ªÉ tr·∫£ l·ªùi t·ª± tin:

- [ ] S·ª± kh√°c bi·ªát ch√≠nh gi·ªØa useEffect v√† useLayoutEffect?
- [ ] useLayoutEffect ch·∫°y khi n√†o trong React lifecycle?
- [ ] Khi n√†o PH·∫¢I d√πng useLayoutEffect?
- [ ] Khi n√†o KH√îNG n√™n d√πng useLayoutEffect?
- [ ] T·∫°i sao useLayoutEffect c√≥ th·ªÉ g√¢y performance issues?
- [ ] "Flash of unstyled content" l√† g√¨ v√† l√†m sao prevent?
- [ ] useLayoutEffect c√≥ API kh√°c useEffect kh√¥ng?
- [ ] SSR v·ªõi useLayoutEffect c√≥ v·∫•n ƒë·ªÅ g√¨?
- [ ] L√†m sao measure DOM element tr∆∞·ªõc khi paint?
- [ ] Trade-offs gi·ªØa useEffect vs useLayoutEffect?

### Code Review Checklist

Khi review code c√≥ useLayoutEffect, check:

#### ‚úÖ Correct Usage:

- [ ] useLayoutEffect ch·ªâ cho synchronous DOM operations
- [ ] No async operations (fetch, setTimeout) trong useLayoutEffect
- [ ] Measurements c·∫ßn thi·∫øt tr∆∞·ªõc paint
- [ ] Preventing visual flash l√† justified

#### ‚úÖ Performance:

- [ ] Effect code ch·∫°y nhanh (<16ms ideal)
- [ ] Kh√¥ng block painting qu√° l√¢u
- [ ] Consider useEffect n·∫øu flash kh√¥ng noticeable
- [ ] Memoize expensive calculations

#### ‚úÖ Dependencies:

- [ ] Dependency array correct
- [ ] No infinite loops
- [ ] Re-runs khi c·∫ßn thi·∫øt

#### ‚úÖ Cleanup:

- [ ] Event listeners removed
- [ ] Observers disconnected
- [ ] Timers cleared

#### ‚ùå Red Flags:

- [ ] Data fetching trong useLayoutEffect
- [ ] Heavy computations blocking paint
- [ ] No dependency array (runs every render)
- [ ] Overuse (should be rare!)

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

#### Exercise: Custom useWindowSize Hook

```jsx
/**
 * üéØ M·ª•c ti√™u: Hook track window size v·ªõi useLayoutEffect
 *
 * Requirements:
 * 1. Return current window size
 * 2. Update on resize
 * 3. Use useLayoutEffect ƒë·ªÉ prevent flash
 * 4. Debounce resize events
 *
 * API:
 * const { width, height } = useWindowSize();
 */

function useWindowSize() {
  const [size, setSize] = useState({ width: 0, height: 0 });

  // TODO: Implement v·ªõi useLayoutEffect
  // Hints:
  // - Initial measurement v·ªõi useLayoutEffect
  // - Resize listener v·ªõi useEffect (debounced)
  // - Cleanup listener

  return size;
}

// Usage:
function ResponsiveComponent() {
  const { width, height } = useWindowSize();

  return (
    <div>
      <p>
        Window: {width} x {height}
      </p>
      {width < 768 ? <MobileView /> : <DesktopView />}
    </div>
  );
}
```

### N√¢ng cao (60 ph√∫t)

#### Exercise: Sticky Header v·ªõi Height Detection

```jsx
/**
 * üéØ M·ª•c ti√™u: Sticky header adjust content padding dynamically
 *
 * Scenario:
 * Header height thay ƒë·ªïi (responsive, content changes).
 * Content padding ph·∫£i match header height ƒë·ªÉ kh√¥ng b·ªã overlap.
 *
 * Requirements:
 * 1. Measure header height
 * 2. Apply padding to content
 * 3. No flash/jump
 * 4. Update on resize
 * 5. Update when header content changes
 */

function StickyHeaderLayout({ headerContent, children }) {
  const [headerHeight, setHeaderHeight] = useState(0);
  const headerRef = useRef(null);

  // TODO: Implement measurement logic
  // Use useLayoutEffect ƒë·ªÉ measure
  // ResizeObserver ƒë·ªÉ track changes

  return (
    <div>
      <header
        ref={headerRef}
        style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          backgroundColor: 'white',
          borderBottom: '1px solid #ccc',
          zIndex: 100,
        }}
      >
        {headerContent}
      </header>

      <main style={{ paddingTop: `${headerHeight}px` }}>{children}</main>
    </div>
  );
}
```

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - useLayoutEffect:**
   https://react.dev/reference/react/useLayoutEffect

2. **React Docs - useEffect vs useLayoutEffect:**
   https://react.dev/learn/synchronizing-with-effects#step-2-specify-the-effect-dependencies

### ƒê·ªçc th√™m

1. **When to useLayoutEffect Instead of useEffect:**
   https://kentcdodds.com/blog/useeffect-vs-uselayouteffect

2. **Understanding React useLayoutEffect:**
   https://blog.logrocket.com/understanding-react-uselayouteffect-hook/

3. **Browser Paint Timing:**
   https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (c·∫ßn bi·∫øt t·ª´ tr∆∞·ªõc)

- **Ng√†y 16-20:** useEffect fundamentals, cleanup, dependencies
- **Ng√†y 21-22:** useRef cho DOM access v√† measurements
- **Ng√†y 11-14:** useState v√† state updates

### H∆∞·ªõng t·ªõi (s·∫Ω d√πng ·ªü)

- **Ng√†y 24:** Custom hooks - combine useLayoutEffect patterns
- **Ng√†y 25:** Project - tooltips, modals, animations
- **Ng√†y 29-34:** Advanced patterns v·ªõi measurements

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

#### 1. Performance Budget

```jsx
// ‚úÖ GOOD: Monitor useLayoutEffect performance
function MonitoredComponent() {
  useLayoutEffect(() => {
    const start = performance.now();

    // Your DOM operations
    measureAndUpdate();

    const duration = performance.now() - start;
```
