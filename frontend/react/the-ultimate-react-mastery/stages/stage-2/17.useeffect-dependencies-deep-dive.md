# ğŸ“… NGÃ€Y 17: useEffect - Dependencies Deep Dive

## ğŸ“ Phase 2, Tuáº§n 4, NgÃ y 17 cá»§a 45

## â±ï¸ Thá»i lÆ°á»£ng: 3-4 giá»

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] Hiá»ƒu vÃ  sá»­ dá»¥ng thÃ nh tháº¡o **Dependencies Array** trong useEffect
- [ ] PhÃ¢n biá»‡t Ä‘Æ°á»£c 3 patterns: no deps, empty deps `[]`, specific deps `[a, b]`
- [ ] Giáº£i quyáº¿t Ä‘Æ°á»£c **Stale Closure** problem trong effects
- [ ] Ãp dá»¥ng Ä‘Æ°á»£c **ESLint exhaustive-deps** rule Ä‘á»ƒ trÃ¡nh bugs
- [ ] Tá»‘i Æ°u dependencies vá»›i objects vÃ  arrays

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i sau:

1. **CÃ¢u 1:** useEffect khÃ´ng cÃ³ dependencies array cháº¡y khi nÃ o?
   - _ÄÃ¡p Ã¡n: SAU Má»–I render (Ä‘Ã£ há»c NgÃ y 16)_

2. **CÃ¢u 2:** Náº¿u báº¡n muá»‘n effect chá»‰ cháº¡y 1 Láº¦N khi component mount, lÃ m tháº¿ nÃ o?
   - _ÄÃ¡p Ã¡n: ChÆ°a biáº¿t! (HÃ´m nay sáº½ há»c: empty deps `[]`)_

3. **CÃ¢u 3:** Náº¿u báº¡n muá»‘n effect chá»‰ cháº¡y khi `count` thay Ä‘á»•i, khÃ´ng pháº£i khi `name` thay Ä‘á»•i, lÃ m sao?
   - _ÄÃ¡p Ã¡n: CÅ©ng chÆ°a biáº¿t! (HÃ´m nay sáº½ há»c: `[count]`)_

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

Nhá»› láº¡i vÃ­ dá»¥ tá»« NgÃ y 16:

```jsx
function DocumentTitleDemo() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState("Guest");

  // âŒ PROBLEM: Effect cháº¡y cho Cáº¢ count VÃ€ name
  useEffect(() => {
    document.title = `Count: ${count}`;
    console.log("Effect ran");
  }); // No dependencies â†’ Runs EVERY render

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>

      <input value={name} onChange={(e) => setName(e.target.value)} />
    </div>
  );
}

// BEHAVIOR:
// Type "A" â†’ name changes â†’ Re-render â†’ Effect runs (khÃ´ng cáº§n thiáº¿t!)
// Click +1 â†’ count changes â†’ Re-render â†’ Effect runs (cáº§n thiáº¿t!)
```

**Váº¥n Ä‘á»:**

- Effect chá»‰ quan tÃ¢m Ä‘áº¿n `count`, KHÃ”NG quan tÃ¢m `name`
- NhÆ°ng effect váº«n cháº¡y khi `name` thay Ä‘á»•i
- LÃ£ng phÃ­ performance, logic khÃ´ng rÃµ rÃ ng

**â“ LÃ m sao Ä‘á»ƒ effect CHá»ˆ cháº¡y khi `count` thay Ä‘á»•i?**

---

### 1.2 Giáº£i PhÃ¡p: Dependencies Array

**Dependencies Array** lÃ  tham sá»‘ thá»© 2 cá»§a useEffect, cho phÃ©p báº¡n kiá»ƒm soÃ¡t KHI NÃ€O effect cháº¡y.

**CÃº phÃ¡p:**

```jsx
useEffect(
  () => {
    // Effect logic
  },
  [dependencies], // â† Dependencies Array
);
```

**3 Patterns CÆ¡ Báº£n:**

```jsx
// PATTERN 1: No Dependencies
useEffect(() => {
  console.log("Runs after EVERY render");
});

// PATTERN 2: Empty Dependencies []
useEffect(() => {
  console.log("Runs ONCE after mount");
}, []); // â† Empty array

// PATTERN 3: Specific Dependencies [a, b]
useEffect(() => {
  console.log("Runs when a OR b changes");
}, [a, b]); // â† Specific values
```

---

### 1.3 Mental Model: Dependencies nhÆ° Subscription

HÃ£y nghÄ© vá» Dependencies nhÆ° **"Subscription List"** - danh sÃ¡ch nhá»¯ng giÃ¡ trá»‹ mÃ  effect "Ä‘Äƒng kÃ½" Ä‘á»ƒ theo dÃµi:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              DEPENDENCIES MENTAL MODEL                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

useEffect(() => {
  // Do something with `count`
}, [count]);

â†“ Hiá»ƒu nhÆ°:

"React Æ¡i, hÃ£y cháº¡y effect nÃ y má»—i khi `count` thay Ä‘á»•i.
 Náº¿u chá»‰ `name` thay Ä‘á»•i mÃ  `count` khÃ´ng Ä‘á»•i â†’ Äá»ªNG cháº¡y effect!"

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMPARISON TABLE:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Dependencies     â”‚ Effect Runs    â”‚ Use Case                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ (no array)       â”‚ Every render   â”‚ Log all renders         â”‚
â”‚ []               â”‚ Once (mount)   â”‚ Initial data fetch      â”‚
â”‚ [a]              â”‚ When a changes â”‚ Sync with specific val  â”‚
â”‚ [a, b, c]        â”‚ When any changesâ”‚ Sync with multiple vals â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Analogy dá»… hiá»ƒu:**

> Dependencies Array nhÆ° **Netflix Watch List**:
>
> - No deps: Watch Má»ŒI show (every render)
> - Empty deps `[]`: Watch chá»‰ 1 show duy nháº¥t, xem xong thÃ´i (mount)
> - `[showA, showB]`: Chá»‰ watch ShowA vÃ  ShowB, náº¿u cÃ³ episode má»›i thÃ¬ xem (re-run when changed)

---

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

#### âŒ Hiá»ƒu láº§m #1: "Empty deps [] = effect KHÃ”NG BAO GIá»œ cháº¡y"

```jsx
function Wrong() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("I run!");
  }, []); // Empty deps

  // Effect VáºªN CHáº Y 1 láº§n sau mount!
  // KhÃ´ng pháº£i "khÃ´ng cháº¡y"
}
```

**âœ… ÄÃºng:** Empty deps `[]` = Effect cháº¡y 1 Láº¦N sau mount, sau Ä‘Ã³ KHÃ”NG BAO GIá»œ cháº¡y láº¡i.

---

#### âŒ Hiá»ƒu láº§m #2: "Dependencies lÃ  optional, cÃ³ thá»ƒ bá» qua"

```jsx
function Wrong() {
  const [count, setCount] = useState(0);

  // âŒ BAD: DÃ¹ng count trong effect nhÆ°ng khÃ´ng khai bÃ¡o trong deps
  useEffect(() => {
    document.title = `Count: ${count}`;
  }, []); // Missing dependency!

  // ESLint warning: "React Hook useEffect has a missing dependency: 'count'"
}
```

**âœ… ÄÃºng:** Náº¿u effect dÃ¹ng giÃ¡ trá»‹ nÃ o tá»« component scope, Báº®T BUá»˜C pháº£i khai bÃ¡o trong deps.

---

#### âŒ Hiá»ƒu láº§m #3: "Deps so sÃ¡nh báº±ng === lÃ  Ä‘á»§"

```jsx
function Wrong() {
  const [user, setUser] = useState({ name: "John", age: 30 });

  useEffect(() => {
    console.log("User changed");
  }, [user]); // Object reference

  const updateAge = () => {
    // âŒ Táº¡o object Má»šI â†’ Reference khÃ¡c â†’ Effect cháº¡y!
    setUser({ ...user, age: 31 });
  };

  // Effect cháº¡y ngay cáº£ khi chá»‰ thay Ä‘á»•i age!
}
```

**âœ… ÄÃºng:** React so sÃ¡nh dependencies báº±ng `Object.is()` (tÆ°Æ¡ng tá»± `===`). Objects/Arrays luÃ´n cÃ³ reference má»›i â†’ Effect cháº¡y láº¡i.

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Pattern CÆ¡ Báº£n - 3 Dependencies Patterns â­

```jsx
/**
 * Demo: So sÃ¡nh 3 patterns cá»§a dependencies
 * Concepts: No deps, Empty deps [], Specific deps [value]
 */

import { useState, useEffect } from "react";

function DependenciesComparison() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState("");

  // Pattern 1: NO DEPENDENCIES
  useEffect(() => {
    console.log("1ï¸âƒ£ No Deps - Runs after EVERY render");
  });

  // Pattern 2: EMPTY DEPENDENCIES []
  useEffect(() => {
    console.log("2ï¸âƒ£ Empty Deps [] - Runs ONCE after mount");
  }, []);

  // Pattern 3: SPECIFIC DEPENDENCIES [count]
  useEffect(() => {
    console.log("3ï¸âƒ£ Specific Deps [count] - Runs when count changes");
  }, [count]);

  return (
    <div>
      <h2>Dependencies Comparison</h2>

      <div>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>Increment Count</button>
      </div>

      <div>
        <input
          placeholder="Type your name"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </div>

      <div>
        <h3>ğŸ“‹ Test Instructions:</h3>
        <ol>
          <li>Má»Ÿ Console</li>
          <li>Click "Increment Count" â†’ Quan sÃ¡t logs</li>
          <li>Type vÃ o input â†’ Quan sÃ¡t logs</li>
        </ol>

        <h3>ğŸ” Expected Behavior:</h3>
        <table border="1" cellPadding="8">
          <thead>
            <tr>
              <th>Action</th>
              <th>No Deps</th>
              <th>Empty []</th>
              <th>Specific [count]</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Initial mount</td>
              <td>âœ… Runs</td>
              <td>âœ… Runs</td>
              <td>âœ… Runs</td>
            </tr>
            <tr>
              <td>Click button (count++)</td>
              <td>âœ… Runs</td>
              <td>âŒ No</td>
              <td>âœ… Runs</td>
            </tr>
            <tr>
              <td>Type in input (name change)</td>
              <td>âœ… Runs</td>
              <td>âŒ No</td>
              <td>âŒ No</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  );
}

export default DependenciesComparison;
```

**Quan sÃ¡t Console Output:**

```
// Initial mount:
1ï¸âƒ£ No Deps - Runs after EVERY render
2ï¸âƒ£ Empty Deps [] - Runs ONCE after mount
3ï¸âƒ£ Specific Deps [count] - Runs when count changes

// Click button (count: 0 â†’ 1):
1ï¸âƒ£ No Deps - Runs after EVERY render
3ï¸âƒ£ Specific Deps [count] - Runs when count changes

// Type "A" (name: "" â†’ "A"):
1ï¸âƒ£ No Deps - Runs after EVERY render
// â† Notice: Effect 2 vÃ  3 KHÃ”NG cháº¡y!
```

---

### Demo 2: Ká»‹ch Báº£n Thá»±c Táº¿ - Document Title Sync â­â­

```jsx
/**
 * Demo: Update document title khi specific state thay Ä‘á»•i
 * Use case: Browser tab title reflects app state
 */

import { useState, useEffect } from "react";

function DocumentTitleSync() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState("Guest");
  const [page, setPage] = useState("Home");

  // Effect 1: Sync title vá»›i count (CHá»ˆ khi count thay Ä‘á»•i)
  useEffect(() => {
    document.title = `Count: ${count}`;
    console.log("ğŸ“„ Title updated with count:", count);
  }, [count]); // â† Only re-run when count changes

  // Effect 2: Log khi name thay Ä‘á»•i
  useEffect(() => {
    console.log("ğŸ‘¤ Name changed to:", name);
  }, [name]); // â† Only re-run when name changes

  // Effect 3: Log khi page thay Ä‘á»•i
  useEffect(() => {
    console.log("ğŸ“ Page changed to:", page);
  }, [page]); // â† Only re-run when page changes

  return (
    <div>
      <h2>Document Title Sync</h2>

      <div>
        <h3>Count: {count}</h3>
        <button onClick={() => setCount(count + 1)}>+1</button>
        <button onClick={() => setCount(count - 1)}>-1</button>
        <button onClick={() => setCount(0)}>Reset</button>
      </div>

      <div>
        <h3>Name: {name}</h3>
        <input
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="Your name"
        />
      </div>

      <div>
        <h3>Current Page: {page}</h3>
        <button onClick={() => setPage("Home")}>Home</button>
        <button onClick={() => setPage("Profile")}>Profile</button>
        <button onClick={() => setPage("Settings")}>Settings</button>
      </div>

      <div>
        <h3>ğŸ’¡ Key Observations:</h3>
        <ul>
          <li>âœ… document.title CHá»ˆ update khi count thay Ä‘á»•i</li>
          <li>âœ… Typing name KHÃ”NG trigger title effect</li>
          <li>âœ… Changing page KHÃ”NG trigger title effect</li>
          <li>âœ… Má»—i effect Ä‘á»™c láº­p, chá»‰ cháº¡y khi deps cá»§a nÃ³ thay Ä‘á»•i</li>
        </ul>
      </div>
    </div>
  );
}

export default DocumentTitleSync;
```

**So sÃ¡nh vá»›i NgÃ y 16:**

| NgÃ y 16 (No Deps)          | NgÃ y 17 (Specific Deps)           |
| -------------------------- | --------------------------------- |
| Effect cháº¡y Má»–I láº§n render | Effect chá»‰ cháº¡y khi deps thay Ä‘á»•i |
| Type name â†’ Effect runs    | Type name â†’ Effect KHÃ”NG cháº¡y âœ…  |
| Click count â†’ Effect runs  | Click count â†’ Effect cháº¡y âœ…      |
| KhÃ´ng kiá»ƒm soÃ¡t            | Kiá»ƒm soÃ¡t chÃ­nh xÃ¡c               |

---

### Demo 3: Edge Cases - Stale Closure Problem â­â­â­

```jsx
/**
 * Demo: Stale Closure - Bug phá»• biáº¿n vá»›i dependencies
 * Edge case: Values "cÅ©" trong effect
 */

import { useState, useEffect } from 'react';

function StaleClosureDemo() {
  const [count, setCount] = useState(0);

  // âŒ BUG: Stale Closure
  useEffect(() => {
    const id = setInterval(() => {
      console.log('Count in interval:', count);
      // âš ï¸ PROBLEM: `count` á»Ÿ Ä‘Ã¢y LUÃ”N lÃ  giÃ¡ trá»‹ lÃºc effect Ä‘Æ°á»£c táº¡o!
      setCount(count + 1); // count luÃ´n = 0!
    }, 1000);

    return () => clearInterval(id);
  }, []); // Empty deps â†’ Effect chá»‰ run 1 láº§n

  // BEHAVIOR:
  // Interval Ä‘Æ°á»£c táº¡o 1 láº§n vá»›i count = 0
  // setCount(0 + 1) â†’ count = 1
  // NhÆ°ng interval KHÃ”NG Ä‘Æ°á»£c re-create â†’ count trong closure váº«n = 0
  // setCount(0 + 1) â†’ count = 1 (láº¡i!)
  // â†’ Count bá»‹ stuck á»Ÿ 1!

  return (
    <div>
      <h2>âŒ Stale Closure Bug</h2>
      <p>Count: {count}</p>
      <p>âš ï¸ Count sáº½ tÄƒng lÃªn 1, rá»“i STUCK!</p>

      <h3>ğŸ› Why?</h3>
      <pre>{`
useEffect(() => {
  setInterval(() => {
    setCount(count + 1); // count = 0 (closure!)
  }, 1000);
}, []); // Effect chá»‰ cháº¡y 1 láº§n

â†’ Interval capture `count = 0` tá»« láº§n render Ä‘áº§u
â†’ KhÃ´ng bao giá» update!
      `}</pre>
    </div>
  );
}

// âœ… FIX #1: Functional Update
function FixedWithFunctionalUpdate() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      // âœ… SOLUTION: DÃ¹ng functional update
      setCount(prevCount => {
        console.log('Previous count:', prevCount);
        return prevCount + 1; // Always use LATEST value
      });
    }, 1000);

    return () => clearInterval(id);
  }, []); // Empty deps OK now!

  return (
    <div>
      <h2>âœ… Fixed with Functional Update</h2>
      <p>Count: {count}</p>
      <p>âœ… Count tÄƒng liÃªn tá»¥c: 1, 2, 3, 4...</p>

      <h3>ğŸ’¡ How it works:</h3>
      <pre>{`
setCount(prevCount => prevCount + 1);

â†’ React Ä‘áº£m báº£o prevCount LUÃ”N lÃ  giÃ¡ trá»‹ má»›i nháº¥t
â†’ KhÃ´ng phá»¥ thuá»™c vÃ o closure!
      `}</pre>
    </div>
  );
}

// âœ… FIX #2: Add count to dependencies
function FixedWithDependencies() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      console.log('Count in interval:', count);
      setCount(count + 1); // Now `count` is always fresh
    }, 1000);

    return () => clearInterval(id);
  }, [count]); // â† Re-run effect when count changes

  // BEHAVIOR:
  // count = 0 â†’ Effect runs â†’ Create interval
  // 1 second later â†’ setCount(1) â†’ count = 1
  // count changed â†’ Cleanup old interval â†’ Effect runs again
  // â†’ Create NEW interval with count = 1
  // â†’ Works, but creates/destroys interval every second!

  return (
    <div>
      <h2>âœ… Fixed with Dependencies</h2>
      <p>Count: {count}</p>
      <p>âœ… Count tÄƒng, nhÆ°ng interval bá»‹ recreate má»—i giÃ¢y</p>

      <h3>âš ï¸ Trade-off:</h3>
      <ul>
        <li>âœ… Pros: Logic rÃµ rÃ ng, count luÃ´n fresh</li>
        <li>âŒ Cons: Performance - interval recreated every second</li>
        <li>ğŸ’¡ Fix #1 (Functional Update) tá»‘t hÆ¡n cho use case nÃ y!</li>
      </ul>
    </div>
  );
}

// ğŸ“Š Comparison Component
function StaleClosureComparison() {
  const [demo, setDemo] = useState('buggy');

  return (
    <div>
      <div>
        <button onClick={() => setDemo('buggy')}>Show Bug</button>
        <button onClick={() => setDemo('fix1')}>Fix #1 (Functional)</button>
        <button onClick={() => setDemo('fix2')}>Fix #2 (Deps)</button>
      </div>

      <hr />

      {demo === 'buggy' && <StaleClosureDemo />}
      {demo === 'fix1' && <FixedWithFunctionalUpdate />}
      {demo === 'fix2' && <FixedWithDependencies />}
    </div>
  );
}

export default StaleClosureComparison;
```

**ğŸ”¥ QUAN TRá»ŒNG - Stale Closure Summary:**

```
PROBLEM: Effect vá»›i empty deps [] capture giÃ¡ trá»‹ lÃºc mount
â†’ Values trong effect KHÃ”NG update khi state thay Ä‘á»•i

SOLUTIONS:
1. Functional Update: setCount(prev => prev + 1)
   âœ… Best cho state updates

2. Add to deps: useEffect(() => {...}, [count])
   âœ… Best khi cáº§n dÃ¹ng latest value
   âš ï¸ Effect re-runs khi deps change

3. useRef (NgÃ y 21): Persist value without re-render
   âœ… Best cho mutable values
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Level 1: Ãp Dá»¥ng Concept (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Practice dependencies array syntax
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useRef, useCallback, useMemo (chÆ°a há»c)
 *
 * Requirements:
 * 1. Táº¡o component vá»›i 2 states: firstName, lastName
 * 2. Effect 1: Log fullName khi EITHER firstName HOáº¶C lastName thay Ä‘á»•i
 * 3. Effect 2: Update document.title vá»›i fullName (same deps)
 * 4. Effect 3: Log "Component mounted" CHá»ˆ 1 láº§n
 * 5. Inputs cho firstName vÃ  lastName
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - Effect vá»›i multiple deps: [a, b] â†’ Cháº¡y khi a HOáº¶C b thay Ä‘á»•i
 * - Empty deps [] â†’ Chá»‰ cháº¡y láº§n Ä‘áº§u
 */

// âŒ CÃ¡ch SAI (Anti-pattern):
function WrongFullNameTracker() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");

  // âŒ SAI: No dependencies â†’ Cháº¡y Má»ŒI render (lÃ£ng phÃ­)
  useEffect(() => {
    const fullName = firstName + " " + lastName;
    console.log("Full name:", fullName);
    document.title = fullName;
  }); // Missing dependencies!

  return (
    <div>
      <input
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
        placeholder="First Name"
      />
      <input
        value={lastName}
        onChange={(e) => setLastName(e.target.value)}
        placeholder="Last Name"
      />
    </div>
  );
}

// Táº¡i sao sai?
// - Effect cháº¡y Má»ŒI render, ká»ƒ cáº£ khi names khÃ´ng Ä‘á»•i
// - Náº¿u cÃ³ state khÃ¡c (vÃ­ dá»¥: age), effect váº«n cháº¡y khi age thay Ä‘á»•i
// - KhÃ´ng kiá»ƒm soÃ¡t Ä‘Æ°á»£c timing

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
function FullNameTracker() {
  // TODO: Khai bÃ¡o states

  // TODO: Effect 1 - Log fullName khi firstName hoáº·c lastName thay Ä‘á»•i

  // TODO: Effect 2 - Update document.title

  // TODO: Effect 3 - Log "Component mounted" 1 láº§n

  return (
    <div>
      <h2>Full Name Tracker</h2>
      {/* TODO: Inputs */}
      <p>ğŸ’¡ Má»Ÿ Console vÃ  test:</p>
      <ul>
        <li>Type firstName â†’ Effect 1, 2 cháº¡y</li>
        <li>Type lastName â†’ Effect 1, 2 cháº¡y</li>
        <li>Effect 3 chá»‰ cháº¡y lÃºc mount</li>
      </ul>
    </div>
  );
}

// âœ… Expected Console Output:
// Component mounted
// Full name changed:
// (Type "John")
// Full name changed: John
// (Type "Doe")
// Full name changed: John Doe
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * FullNameTracker - Level 1: Ãp dá»¥ng Dependencies Array
 *
 * YÃªu cáº§u:
 * - 2 inputs: firstName vÃ  lastName
 * - Effect 1: Log fullName khi firstName HOáº¶C lastName thay Ä‘á»•i
 * - Effect 2: Update document.title vá»›i fullName (hoáº·c fallback)
 * - Effect 3: Log "Component mounted" chá»‰ 1 láº§n khi mount
 */
import { useState, useEffect } from "react";

function FullNameTracker() {
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");

  // Effect 1: Log fullName khi báº¥t ká»³ tÃªn nÃ o thay Ä‘á»•i
  useEffect(() => {
    const fullName = `${firstName} ${lastName}`.trim();
    console.log("âœ… Full name changed:", fullName || "(empty)");
  }, [firstName, lastName]);

  // Effect 2: Äá»“ng bá»™ document title
  useEffect(() => {
    const fullName = `${firstName} ${lastName}`.trim();
    document.title = fullName || "Enter your name";
  }, [firstName, lastName]);

  // Effect 3: Chá»‰ cháº¡y má»™t láº§n khi component mount
  useEffect(() => {
    console.log("âœ… Component mounted");
  }, []); // empty deps â†’ chá»‰ cháº¡y sau láº§n render Ä‘áº§u tiÃªn

  return (
    <div>
      <h2>Full Name Tracker</h2>

      <div style={{ marginBottom: "16px" }}>
        <input
          value={firstName}
          onChange={(e) => setFirstName(e.target.value)}
          placeholder="First Name"
          style={{ marginRight: "8px", padding: "8px" }}
        />
        <input
          value={lastName}
          onChange={(e) => setLastName(e.target.value)}
          placeholder="Last Name"
          style={{ padding: "8px" }}
        />
      </div>

      <p>ğŸ’¡ Má»Ÿ Console vÃ  test:</p>
      <ul>
        <li>Type firstName â†’ Effect 1 & 2 cháº¡y</li>
        <li>Type lastName â†’ Effect 1 & 2 cháº¡y</li>
        <li>Effect 3 chá»‰ xuáº¥t hiá»‡n 1 láº§n lÃºc Ä‘áº§u</li>
      </ul>
    </div>
  );
}

export default FullNameTracker;

// Táº¡i sao tá»‘t hÆ¡n?
// âœ… Effects chá»‰ cháº¡y khi cáº§n
// âœ… Logic rÃµ rÃ ng: deps list chá»‰ ra effect phá»¥ thuá»™c vÃ o gÃ¬
// âœ… Performance tá»‘t hÆ¡n
// âœ… Dá»… debug: Biáº¿t chÃ­nh xÃ¡c khi nÃ o effect cháº¡y
```

**Káº¿t quáº£ vÃ­ dá»¥ trong console:**

```
// Khi component vá»«a mount
âœ… Component mounted

// GÃµ "Lan" vÃ o First Name
âœ… Full name changed: Lan
// â†’ document.title = "Lan"

// GÃµ " Nguyá»…n" vÃ o Last Name
âœ… Full name changed: Lan Nguyá»…n
// â†’ document.title = "Lan Nguyá»…n"

// XÃ³a háº¿t cáº£ hai Ã´ input
âœ… Full name changed: (empty)
// â†’ document.title = "Enter your name"
```

</details>

---

### â­â­ Level 2: Nháº­n Biáº¿t Pattern (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: PhÃ¡t hiá»‡n vÃ  fix stale closure bugs
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: Auto-save form vá»›i timer
 * YÃªu cáº§u: Form tá»± Ä‘á»™ng save sau 3 giÃ¢y khÃ´ng cÃ³ thay Ä‘á»•i
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 *
 * Approach A: setTimeout trong effect vá»›i empty deps []
 * Pros:
 * - ÄÆ¡n giáº£n, timer chá»‰ táº¡o 1 láº§n
 * Cons:
 * - âŒ STALE CLOSURE! formData trong setTimeout luÃ´n lÃ  giÃ¡ trá»‹ ban Ä‘áº§u
 * - KhÃ´ng save Ä‘Æ°á»£c data má»›i
 *
 * Approach B: setTimeout trong effect vá»›i [formData] deps
 * Pros:
 * - âœ… formData luÃ´n fresh
 * - Timer recreated má»—i khi formData thay Ä‘á»•i â†’ Reset countdown
 * Cons:
 * - Performance: Many timer creations/clearances
 * - Phá»©c táº¡p hÆ¡n
 *
 * Approach C: useRef + functional update (Preview NgÃ y 21)
 * Pros:
 * - Best performance
 * - No stale closure
 * Cons:
 * - Cáº§n useRef (chÆ°a há»c!)
 *
 * ğŸ’­ Báº N CHá»ŒN APPROACH NÃ€O VÃ€ Táº I SAO?
 * Vá»›i kiáº¿n thá»©c Ä‘áº¿n NgÃ y 17, chá»n Approach B!
 */

// âŒ Approach A: Stale Closure Bug
function AutoSaveFormBuggy() {
  const [formData, setFormData] = useState({ name: "", email: "" });
  const [lastSaved, setLastSaved] = useState(null);

  // âŒ BUG: formData trong setTimeout lÃ  stale!
  useEffect(() => {
    console.log("Effect ran, setting timeout...");

    const timerId = setTimeout(() => {
      console.log("ğŸ’¾ Saving:", formData); // formData = { name: '', email: '' }
      // LuÃ´n save empty object!
      setLastSaved(new Date().toLocaleTimeString());
    }, 3000);

    return () => {
      console.log("Cleanup: Clearing timeout");
      clearTimeout(timerId);
    };
  }, []); // Empty deps â†’ formData captured at mount!

  const updateField = (field, value) => {
    setFormData({ ...formData, [field]: value });
  };

  return (
    <div>
      <h2>âŒ Buggy Auto-Save (Stale Closure)</h2>

      <input
        placeholder="Name"
        value={formData.name}
        onChange={(e) => updateField("name", e.target.value)}
      />

      <input
        placeholder="Email"
        value={formData.email}
        onChange={(e) => updateField("email", e.target.value)}
      />

      <p>Last Saved: {lastSaved || "Not saved yet"}</p>

      <div>
        <h3>ğŸ› Bug:</h3>
        <p>3 giÃ¢y sau mount, sáº½ save EMPTY object, khÃ´ng pháº£i data hiá»‡n táº¡i!</p>
      </div>
    </div>
  );
}

// âœ… Approach B: Fixed vá»›i Dependencies
function AutoSaveFormFixed() {
  const [formData, setFormData] = useState({ name: "", email: "" });
  const [lastSaved, setLastSaved] = useState(null);

  useEffect(() => {
    console.log("Effect ran with formData:", formData);

    // Timer reset Má»–I khi formData thay Ä‘á»•i
    const timerId = setTimeout(() => {
      console.log("ğŸ’¾ Saving:", formData); // âœ… Fresh data!
      // TODO: API call here
      setLastSaved(new Date().toLocaleTimeString());
    }, 3000);

    // Cleanup: Clear timer khi formData thay Ä‘á»•i (reset countdown)
    return () => {
      console.log("Cleanup: Clearing timeout (formData changed)");
      clearTimeout(timerId);
    };
  }, [formData]); // â† Re-run khi formData thay Ä‘á»•i

  const updateField = (field, value) => {
    setFormData({ ...formData, [field]: value });
  };

  return (
    <div>
      <h2>âœ… Fixed Auto-Save</h2>

      <input
        placeholder="Name"
        value={formData.name}
        onChange={(e) => updateField("name", e.target.value)}
      />

      <input
        placeholder="Email"
        value={formData.email}
        onChange={(e) => updateField("email", e.target.value)}
      />

      <p>Last Saved: {lastSaved || "Not saved yet"}</p>

      <div>
        <h3>âœ… How it works:</h3>
        <ol>
          <li>Type "A" â†’ formData thay Ä‘á»•i</li>
          <li>Effect re-runs â†’ Clear old timer, táº¡o timer má»›i</li>
          <li>Type "B" trong 3s â†’ Clear timer, reset countdown</li>
          <li>Ngá»«ng typing 3s â†’ Timer triggers â†’ Save!</li>
        </ol>
        <p>ğŸ’¡ ÄÃ¢y lÃ  pattern "debounce" - sáº½ há»c ká»¹ hÆ¡n sau!</p>
      </div>
    </div>
  );
}

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
// 1. Implement Cáº¢ HAI versions trÃªn
// 2. Test vÃ  quan sÃ¡t Console logs
// 3. Giáº£i thÃ­ch Táº I SAO Approach A bá»‹ stale closure
// 4. Viáº¿t comment phÃ¢n tÃ­ch trade-offs cá»§a Approach B
// 5. Bonus: Thá»­ add thÃªm field (phone) vÃ  verify auto-save váº«n hoáº¡t Ä‘á»™ng

// ğŸ’¡ HINTS:
// - Stale closure xáº£y ra khi: Effect capture value lÃºc mount, khÃ´ng update
// - Cleanup function cháº¡y TRÆ¯á»šC khi effect cháº¡y láº¡i
// - setTimeout + cleanup = Debounce pattern

// ğŸ“ EXPECTED ANALYSIS:
// - Approach A: Nhanh, Ä‘Æ¡n giáº£n, NHÆ¯NG sai logic
// - Approach B: ÄÃºng logic, performance OK cho form nhá»
// - Production: Cáº§n optimize hÆ¡n (useRef, custom hook)
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * AutoSaveFormFixed - Level 2: Nháº­n biáº¿t vÃ  fix Stale Closure pattern
 *
 * YÃªu cáº§u:
 * - Form cÃ³ 2 fields: name vÃ  email (cÃ³ thá»ƒ má»Ÿ rá»™ng thÃªm phone)
 * - Tá»± Ä‘á»™ng save sau 3 giÃ¢y khÃ´ng cÃ³ thay Ä‘á»•i (debounce pattern)
 * - Sá»­ dá»¥ng useEffect + [formData] Ä‘á»ƒ reset timer má»—i khi dá»¯ liá»‡u thay Ä‘á»•i
 * - Cleanup timeout khi formData thay Ä‘á»•i hoáº·c component unmount
 * - Hiá»ƒn thá»‹ thá»i gian last saved
 */
import { useState, useEffect } from "react";

function AutoSaveFormFixed() {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    // Bonus: thÃªm field phone Ä‘á»ƒ test
    phone: "",
  });

  const [lastSaved, setLastSaved] = useState(null);

  useEffect(() => {
    console.log("Effect ran â†’ Setting new auto-save timer with:", formData);

    // Táº¡o timer má»›i má»—i khi formData thay Ä‘á»•i
    const timerId = setTimeout(() => {
      // Giáº£ láº­p API call / save logic
      console.log("ğŸ’¾ Auto-saving data:", formData);

      // Cáº­p nháº­t thá»i gian Ä‘Ã£ lÆ°u
      const now = new Date().toLocaleTimeString();
      setLastSaved(now);

      console.log(`Saved successfully at ${now}`);
    }, 3000);

    // Cleanup: há»§y timer cÅ© khi formData thay Ä‘á»•i hoáº·c unmount
    return () => {
      console.log("Cleanup: Clearing previous timeout");
      clearTimeout(timerId);
    };
  }, [formData]); // Dependency chÃ­nh lÃ  toÃ n bá»™ formData object

  const updateField = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  return (
    <div>
      <h2>âœ… Fixed Auto-Save Form (Debounce Pattern)</h2>

      <div
        style={{
          display: "flex",
          flexDirection: "column",
          gap: "12px",
          maxWidth: "400px",
        }}
      >
        <div>
          <label>Name:</label>
          <input
            placeholder="Your name"
            value={formData.name}
            onChange={(e) => updateField("name", e.target.value)}
            style={{ width: "100%", padding: "8px", marginTop: "4px" }}
          />
        </div>

        <div>
          <label>Email:</label>
          <input
            placeholder="your@email.com"
            value={formData.email}
            onChange={(e) => updateField("email", e.target.value)}
            style={{ width: "100%", padding: "8px", marginTop: "4px" }}
          />
        </div>

        <div>
          <label>Phone:</label>
          <input
            placeholder="0123 456 789"
            value={formData.phone}
            onChange={(e) => updateField("phone", e.target.value)}
            style={{ width: "100%", padding: "8px", marginTop: "4px" }}
          />
        </div>
      </div>

      <div style={{ marginTop: "20px" }}>
        <p>Last Saved: {lastSaved ? lastSaved : "Not saved yet"}</p>
      </div>

      <div style={{ marginTop: "24px", fontSize: "14px", color: "#555" }}>
        <h4>How it works:</h4>
        <ul style={{ margin: 0, paddingLeft: "20px" }}>
          <li>Má»—i láº§n gÃµ â†’ timer cÅ© bá»‹ há»§y, timer má»›i 3s Ä‘Æ°á»£c táº¡o</li>
          <li>Ngá»«ng gÃµ 3 giÃ¢y â†’ dá»¯ liá»‡u Ä‘Æ°á»£c "save"</li>
          <li>
            Approach nÃ y trÃ¡nh stale closure báº±ng cÃ¡ch Ä‘Æ°a formData vÃ o deps
          </li>
        </ul>
      </div>
    </div>
  );
}

export default AutoSaveFormFixed;
```

**Káº¿t quáº£ vÃ­ dá»¥ trong console (khi tÆ°Æ¡ng tÃ¡c):**

```
// Ban Ä‘áº§u
Effect ran â†’ Setting new auto-save timer with: {name: "", email: "", phone: ""}

// GÃµ "Nguyá»…n" vÃ o name â†’ sau ~0.2s
Cleanup: Clearing previous timeout
Effect ran â†’ Setting new auto-save timer with: {name: "Nguyá»…n", email: "", phone: ""}

// Tiáº¿p tá»¥c gÃµ " VÄƒn" â†’ timer láº¡i reset
Cleanup: Clearing previous timeout
Effect ran â†’ Setting new auto-save timer with: {name: "Nguyá»…n VÄƒn", email: "", phone: ""}

// Ngá»«ng gÃµ 3 giÃ¢y
ğŸ’¾ Auto-saving data: {name: "Nguyá»…n VÄƒn", email: "", phone: ""}
Saved successfully at 14:35:22

// GÃµ nhanh "A" rá»“i xÃ³a â†’ timer reset nhiá»u láº§n nhÆ°ng chá»‰ save 1 láº§n sau 3s ngá»«ng gÃµ
```

</details>

---

### â­â­â­ Level 3: Ká»‹ch Báº£n Thá»±c Táº¿ (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Search vá»›i Debounce (Real-world pattern)
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  user, tÃ´i muá»‘n search products, vÃ  káº¿t quáº£
 * chá»‰ xuáº¥t hiá»‡n SAU KHI tÃ´i ngá»«ng typing 500ms"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Input field cho search query
 * - [ ] Chá»‰ search khi user ngá»«ng typing 500ms
 * - [ ] Display "Searching..." khi Ä‘ang search
 * - [ ] Display results (giáº£ láº­p vá»›i array filter)
 * - [ ] Clear results khi query empty
 * - [ ] Show sá»‘ lÆ°á»£ng results found
 *
 * ğŸ¨ Technical Constraints:
 * - DÃ¹ng useEffect vá»›i dependencies
 * - setTimeout cho debounce
 * - Cleanup Ä‘á»ƒ clear timeout
 * - KHÃ”NG dÃ¹ng useRef, custom hooks (chÆ°a há»c)
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Query empty â†’ KhÃ´ng search
 * - Query quÃ¡ ngáº¯n (<2 chars) â†’ KhÃ´ng search
 * - Rapid typing â†’ Clear old timeout, chá»‰ search láº§n cuá»‘i
 * - Component unmount trong khi Ä‘ang search â†’ Cleanup
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] State cho searchQuery
 * - [ ] State cho debouncedQuery (query sau debounce)
 * - [ ] State cho isSearching
 * - [ ] State cho results
 * - [ ] Effect Ä‘á»ƒ debounce: searchQuery â†’ debouncedQuery
 * - [ ] Effect Ä‘á»ƒ search: debouncedQuery â†’ results
 * - [ ] Cleanup timeouts properly
 */

// Mock data
const PRODUCTS = [
  { id: 1, name: 'iPhone 15 Pro', category: 'Phone' },
  { id: 2, name: 'iPhone 15', category: 'Phone' },
  { id: 3, name: 'iPad Pro', category: 'Tablet' },
  { id: 4, name: 'iPad Air', category: 'Tablet' },
  { id: 5, name: 'MacBook Pro', category: 'Laptop' },
  { id: 6, name: 'MacBook Air', category: 'Laptop' },
  { id: 7, name: 'AirPods Pro', category: 'Audio' },
  { id: 8, name: 'AirPods Max', category: 'Audio' },
];

// ğŸ¯ STARTER CODE:
function ProductSearch() {
  const [searchQuery, setSearchQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [results, setResults] = useState([]);

  // TODO: Effect 1 - Debounce searchQuery â†’ debouncedQuery
  // Logic:
  // 1. Set isSearching = true
  // 2. setTimeout 500ms, sau Ä‘Ã³ setDebouncedQuery(searchQuery)
  // 3. Cleanup: clearTimeout náº¿u searchQuery thay Ä‘á»•i
  // 4. Dependencies: [searchQuery]

  useEffect(() => {
    // TODO: Implement debounce logic
    // setIsSearching(true);

    // const timerId = setTimeout(() => {
    //   setDebouncedQuery(searchQuery);
    //   setIsSearching(false);
    // }, 500);

    // return () => clearTimeout(timerId);
  }, [searchQuery]);

  // TODO: Effect 2 - Search khi debouncedQuery thay Ä‘á»•i
  // Logic:
  // 1. Náº¿u debouncedQuery empty hoáº·c < 2 chars â†’ Clear results
  // 2. NgÆ°á»£c láº¡i, filter PRODUCTS
  // 3. setResults(filtered)
  // 4. Dependencies: [debouncedQuery]

  useEffect(() => {
    // TODO: Implement search logic
    // if (!debouncedQuery || debouncedQuery.length < 2) {
    //   setResults([]);
    //   return;
    // }

    // const filtered = PRODUCTS.filter(product =>
    //   product.name.toLowerCase().includes(debouncedQuery.toLowerCase())
    // );

    // setResults(filtered);
  }, [debouncedQuery]);

  const handleSearchChange = (e) => {
    setSearchQuery(e.target.value);
  };

  return (
    <div>
      <h2>Product Search with Debounce</h2>

      {/* Search Input */}
      <div>
        <input
          type="text"
          placeholder="Search products... (min 2 chars)"
          value={searchQuery}
          onChange={handleSearchChange}
          style={{
            padding: '10px',
            fontSize: '16px',
            width: '300px'
          }}
        />
      </div>

      {/* Status */}
      <div style={{ marginTop: '10px' }}>
        {isSearching && <p>ğŸ” Searching...</p>}
        {!isSearching && debouncedQuery && (
          <p>Found {results.length} result(s) for "{debouncedQuery}"</p>
        )}
      </div>

      {/* Results */}
      <div style={{ marginTop: '20px' }}>
        {results.length > 0 ? (
          <ul>
            {results.map(product => (
              <li key={product.id}>
                <strong>{product.name}</strong> - {product.category}
              </li>
            ))}
          </ul>
        ) : (
          debouncedQuery && debouncedQuery.length >= 2 && (
            <p>No results found.</p>
          )
        )}
      </div>

      {/* Debug Info */}
      <div style={{ marginTop: '30px', padding: '10px', background: '#f0f0f0' }}>
        <h3>ğŸ” Debug Info:</h3>
        <p>Search Query: "{searchQuery}"</p>
        <p>Debounced Query: "{debouncedQuery}"</p>
        <p>Is Searching: {isSearching ? 'Yes' : 'No'}</p>
        <p>Results Count: {results.length}</p>
      </div>

      {/* Instructions */}
      <div style={{ marginTop: '20px' }}>
        <h3>ğŸ“‹ Test Scenarios:</h3>
        <ol>
          <li>Type "iphone" nhanh â†’ Chá»‰ search 1 láº§n sau 500ms</li>
          <li>Type "ip" â†’ Pause â†’ "phone" â†’ 2 searches</li>
          <li>Type "xyz" â†’ No results</li>
          <li>Clear input â†’ Results cleared</li>
          <li>Type "a" â†’ No search (< 2 chars)</li>
        </ol>
      </div>
    </div>
  );
}

export default ProductSearch;

// ğŸ’¡ EXTENSION CHALLENGES:
// 1. Add loading spinner (isSearching state)
// 2. Highlight matching text trong results
// 3. Show "recent searches" history
// 4. Add category filter
// 5. Implement vá»›i API call (fake delay vá»›i setTimeout)
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * ProductSearch - Level 3: Real-world Debounce Search with useEffect
 *
 * YÃªu cáº§u chÃ­nh:
 * - Input tÃ¬m kiáº¿m sáº£n pháº©m
 * - Debounce 500ms: chá»‰ search khi ngÆ°á»i dÃ¹ng ngá»«ng gÃµ 500ms
 * - Hiá»ƒn thá»‹ "Searching..." trong lÃºc debounce
 * - Chá»‰ filter khi query â‰¥ 2 kÃ½ tá»±
 * - Hiá»ƒn thá»‹ sá»‘ lÆ°á»£ng káº¿t quáº£ vÃ  danh sÃ¡ch sáº£n pháº©m
 * - XÃ³a káº¿t quáº£ khi query rá»—ng hoáº·c < 2 kÃ½ tá»±
 */
import { useState, useEffect } from "react";

// Dá»¯ liá»‡u giáº£ láº­p
const PRODUCTS = [
  { id: 1, name: "iPhone 15 Pro", category: "Phone" },
  { id: 2, name: "iPhone 15", category: "Phone" },
  { id: 3, name: "iPad Pro", category: "Tablet" },
  { id: 4, name: "iPad Air", category: "Tablet" },
  { id: 5, name: "MacBook Pro", category: "Laptop" },
  { id: 6, name: "MacBook Air", category: "Laptop" },
  { id: 7, name: "AirPods Pro", category: "Audio" },
  { id: 8, name: "AirPods Max", category: "Audio" },
];

function ProductSearch() {
  const [searchQuery, setSearchQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);
  const [results, setResults] = useState([]);

  // Effect 1: Debounce logic - chuyá»ƒn searchQuery â†’ debouncedQuery sau 500ms
  useEffect(() => {
    setIsSearching(true);

    const timerId = setTimeout(() => {
      setDebouncedQuery(searchQuery);
      setIsSearching(false);
    }, 500);

    // Cleanup: há»§y timer náº¿u searchQuery thay Ä‘á»•i trÆ°á»›c 500ms
    return () => {
      clearTimeout(timerId);
      setIsSearching(false);
    };
  }, [searchQuery]);

  // Effect 2: Thá»±c hiá»‡n tÃ¬m kiáº¿m khi debouncedQuery thay Ä‘á»•i
  useEffect(() => {
    if (!debouncedQuery || debouncedQuery.length < 2) {
      setResults([]);
      return;
    }

    // Filter sáº£n pháº©m (case-insensitive)
    const filtered = PRODUCTS.filter((product) =>
      product.name.toLowerCase().includes(debouncedQuery.toLowerCase()),
    );

    setResults(filtered);
  }, [debouncedQuery]);

  const handleSearchChange = (e) => {
    setSearchQuery(e.target.value);
  };

  return (
    <div>
      <h2>Product Search with Debounce (500ms)</h2>

      <input
        type="text"
        placeholder="Search products... (min 2 characters)"
        value={searchQuery}
        onChange={handleSearchChange}
        style={{
          width: "100%",
          maxWidth: "400px",
          padding: "12px",
          fontSize: "16px",
          borderRadius: "6px",
          border: "1px solid #ccc",
          marginBottom: "16px",
        }}
      />

      <div style={{ minHeight: "24px", marginBottom: "16px" }}>
        {isSearching && <p style={{ color: "#666" }}>ğŸ” Searching...</p>}

        {!isSearching && debouncedQuery && (
          <p>
            Found <strong>{results.length}</strong> result(s) for "
            <strong>{debouncedQuery}</strong>"
          </p>
        )}
      </div>

      {results.length > 0 ? (
        <ul style={{ listStyle: "none", padding: 0 }}>
          {results.map((product) => (
            <li
              key={product.id}
              style={{
                padding: "12px",
                borderBottom: "1px solid #eee",
                background: "#f9f9f9",
                marginBottom: "8px",
                borderRadius: "4px",
              }}
            >
              <strong>{product.name}</strong>
              <span style={{ color: "#666", marginLeft: "12px" }}>
                ({product.category})
              </span>
            </li>
          ))}
        </ul>
      ) : (
        debouncedQuery &&
        debouncedQuery.length >= 2 &&
        !isSearching && <p style={{ color: "#888" }}>No products found.</p>
      )}

      {/* Debug info (cÃ³ thá»ƒ xÃ³a khi dÃ¹ng production) */}
      <div
        style={{
          marginTop: "32px",
          padding: "16px",
          background: "#f0f0f0",
          borderRadius: "8px",
          fontSize: "14px",
        }}
      >
        <strong>Debug:</strong>
        <br />
        Real-time query: "{searchQuery}"<br />
        Debounced query: "{debouncedQuery}"<br />
        Is searching: {isSearching ? "Yes" : "No"}
        <br />
        Results: {results.length}
      </div>
    </div>
  );
}

export default ProductSearch;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi tÆ°Æ¡ng tÃ¡c:**

```
// GÃµ nhanh "iph" â†’ "iphone" trong vÃ²ng 0.4 giÃ¢y
// â†’ Chá»‰ 1 láº§n debounce trigger sau 500ms ngá»«ng gÃµ
// Console khÃ´ng log liÃªn tá»¥c, chá»‰ cháº¡y effect khi thá»±c sá»± cáº§n

// Káº¿t quáº£ sau khi ngá»«ng gÃµ 500ms vá»›i "iphone":
Found 2 result(s) for "iphone"
â€¢ iPhone 15 Pro (Phone)
â€¢ iPhone 15 (Phone)

// GÃµ "ip" (2 kÃ½ tá»±) rá»“i ngá»«ng â†’ váº«n search
// GÃµ "i" (1 kÃ½ tá»±) â†’ káº¿t quáº£ bá»‹ xÃ³a ngay khi debounced

// XÃ³a háº¿t input â†’ results = [], khÃ´ng hiá»ƒn thá»‹ thÃ´ng bÃ¡o tÃ¬m kiáº¿m
```

</details>

---

### â­â­â­â­ Level 4: Quyáº¿t Äá»‹nh Kiáº¿n TrÃºc (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Multi-Step Form vá»›i Validation
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Context:
 * XÃ¢y dá»±ng multi-step registration form (3 steps):
 * - Step 1: Personal Info (name, email, phone)
 * - Step 2: Address (street, city, zip)
 * - Step 3: Preferences (newsletter, notifications)
 *
 * Validation requirements:
 * - Validate tá»«ng field khi user blur (rá»i khá»i field)
 * - Validate toÃ n bá»™ step trÆ°á»›c khi cho next
 * - Show errors immediately
 * - Auto-save draft má»—i 5 giÃ¢y
 *
 * CÃ³ 3 approaches khÃ¡c nhau:
 *
 * APPROACH 1: Separate effect cho má»—i field validation
 * Pros:
 * - RÃµ rÃ ng, dá»… hiá»ƒu
 * - Dá»… debug tá»«ng field
 * Cons:
 * - QuÃ¡ nhiá»u effects (9+ effects!)
 * - Performance khÃ´ng tá»‘t
 * - Code dÃ i, khÃ³ maintain
 *
 * APPROACH 2: 1 effect validate toÃ n bá»™ form
 * Pros:
 * - Gá»n hÆ¡n, Ã­t effects hÆ¡n
 * - Centralized validation logic
 * Cons:
 * - Effect cháº¡y cho Má»ŒI field change (unnecessary)
 * - KhÃ³ control validation timing (blur vs change)
 *
 * APPROACH 3: Hybrid - Effects cho specific concerns
 * Pros:
 * - Balance giá»¯a clarity vÃ  performance
 * - Effect 1: Validate current step khi chuyá»ƒn step
 * - Effect 2: Auto-save draft
 * - Event handlers: Validate on blur
 * Cons:
 * - Phá»©c táº¡p hÆ¡n
 * - Cáº§n hiá»ƒu rÃµ khi nÃ o dÃ¹ng effect vs event handler
 *
 * ğŸ’­ NHIá»†M Vá»¤ PHASE 1:
 * 1. Analyze requirements
 * 2. Chá»n approach (Recommend: Approach 3)
 * 3. Viáº¿t ADR
 *
 * ADR Template:
 * ---
 * # ADR: Multi-Step Form Validation Strategy
 *
 * ## Context
 * [MÃ´ táº£: Form 3 steps, validate trÃªn blur, auto-save]
 *
 * ## Decision
 * [Approach 3: Hybrid]
 *
 * ## Rationale
 * [Táº¡i sao:
 *  - Event handlers cho field-level validation (blur)
 *  - useEffect cho step-level validation (step change)
 *  - useEffect cho auto-save (timer-based)
 *  - Separation of concerns]
 *
 * ## Consequences
 * [Trade-offs:
 *  - More complex than Approach 1 or 2
 *  - Better performance
 *  - Clearer responsibilities]
 *
 * ## Alternatives Considered
 * [Approach 1, 2 vÃ  lÃ½ do khÃ´ng chá»n]
 * ---
 */

// ğŸ’» PHASE 2: Implementation (30 phÃºt)

import { useState, useEffect } from "react";

// Validation helpers
const validateEmail = (email) => {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(email);
};

const validatePhone = (phone) => {
  const re = /^\d{10}$/;
  return re.test(phone.replace(/\D/g, ""));
};

const validateZip = (zip) => {
  const re = /^\d{5}$/;
  return re.test(zip);
};

function MultiStepForm() {
  // Current step
  const [currentStep, setCurrentStep] = useState(1);

  // Form data
  const [formData, setFormData] = useState({
    // Step 1
    name: "",
    email: "",
    phone: "",
    // Step 2
    street: "",
    city: "",
    zip: "",
    // Step 3
    newsletter: false,
    notifications: false,
  });

  // Errors state
  const [errors, setErrors] = useState({});

  // Auto-save state
  const [lastSaved, setLastSaved] = useState(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  // TODO: Effect 1 - Auto-save draft every 5 seconds
  useEffect(() => {
    if (!hasUnsavedChanges) return;

    const timerId = setTimeout(() => {
      // Simulate API call
      console.log("ğŸ’¾ Auto-saving draft:", formData);
      localStorage.setItem("formDraft", JSON.stringify(formData));
      setLastSaved(new Date().toLocaleTimeString());
      setHasUnsavedChanges(false);
    }, 5000);

    return () => clearTimeout(timerId);
  }, [formData, hasUnsavedChanges]);

  // TODO: Effect 2 - Validate step khi chuyá»ƒn step
  useEffect(() => {
    console.log("Step changed to:", currentStep);
    // CÃ³ thá»ƒ validate previous step á»Ÿ Ä‘Ã¢y
    // Hoáº·c clear errors cá»§a step má»›i
  }, [currentStep]);

  // TODO: Effect 3 - Load draft tá»« localStorage khi mount
  useEffect(() => {
    const saved = localStorage.getItem("formDraft");
    if (saved) {
      const draft = JSON.parse(saved);
      setFormData(draft);
      console.log("âœ… Loaded draft from localStorage");
    }
  }, []); // Empty deps â†’ Chá»‰ cháº¡y lÃºc mount

  // Field update handler
  const updateField = (field, value) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
    setHasUnsavedChanges(true);

    // Clear error for this field
    if (errors[field]) {
      setErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };

  // Field validation (on blur)
  const validateField = (field) => {
    const value = formData[field];
    let error = null;

    switch (field) {
      case "name":
        if (!value || value.length < 2) {
          error = "Name must be at least 2 characters";
        }
        break;
      case "email":
        if (!value) {
          error = "Email is required";
        } else if (!validateEmail(value)) {
          error = "Invalid email format";
        }
        break;
      case "phone":
        if (!value) {
          error = "Phone is required";
        } else if (!validatePhone(value)) {
          error = "Phone must be 10 digits";
        }
        break;
      case "street":
        if (!value) error = "Street is required";
        break;
      case "city":
        if (!value) error = "City is required";
        break;
      case "zip":
        if (!value) {
          error = "ZIP code is required";
        } else if (!validateZip(value)) {
          error = "ZIP must be 5 digits";
        }
        break;
    }

    if (error) {
      setErrors((prev) => ({ ...prev, [field]: error }));
    }

    return !error;
  };

  // Step validation
  const validateStep = (step) => {
    let fields = [];

    if (step === 1) {
      fields = ["name", "email", "phone"];
    } else if (step === 2) {
      fields = ["street", "city", "zip"];
    }

    const isValid = fields.every((field) => validateField(field));
    return isValid;
  };

  // Navigation handlers
  const nextStep = () => {
    if (validateStep(currentStep)) {
      setCurrentStep((prev) => prev + 1);
    }
  };

  const prevStep = () => {
    setCurrentStep((prev) => prev - 1);
  };

  const handleSubmit = () => {
    if (validateStep(3)) {
      console.log("âœ… Form submitted:", formData);
      localStorage.removeItem("formDraft");
      alert("Registration complete!");
    }
  };

  // Render step content
  const renderStep = () => {
    switch (currentStep) {
      case 1:
        return (
          <div>
            <h3>Step 1: Personal Information</h3>

            <div>
              <label>Name:</label>
              <input
                value={formData.name}
                onChange={(e) => updateField("name", e.target.value)}
                onBlur={() => validateField("name")}
              />
              {errors.name && (
                <span style={{ color: "red" }}>{errors.name}</span>
              )}
            </div>

            <div>
              <label>Email:</label>
              <input
                type="email"
                value={formData.email}
                onChange={(e) => updateField("email", e.target.value)}
                onBlur={() => validateField("email")}
              />
              {errors.email && (
                <span style={{ color: "red" }}>{errors.email}</span>
              )}
            </div>

            <div>
              <label>Phone:</label>
              <input
                value={formData.phone}
                onChange={(e) => updateField("phone", e.target.value)}
                onBlur={() => validateField("phone")}
              />
              {errors.phone && (
                <span style={{ color: "red" }}>{errors.phone}</span>
              )}
            </div>
          </div>
        );

      case 2:
        return (
          <div>
            <h3>Step 2: Address</h3>

            <div>
              <label>Street:</label>
              <input
                value={formData.street}
                onChange={(e) => updateField("street", e.target.value)}
                onBlur={() => validateField("street")}
              />
              {errors.street && (
                <span style={{ color: "red" }}>{errors.street}</span>
              )}
            </div>

            <div>
              <label>City:</label>
              <input
                value={formData.city}
                onChange={(e) => updateField("city", e.target.value)}
                onBlur={() => validateField("city")}
              />
              {errors.city && (
                <span style={{ color: "red" }}>{errors.city}</span>
              )}
            </div>

            <div>
              <label>ZIP Code:</label>
              <input
                value={formData.zip}
                onChange={(e) => updateField("zip", e.target.value)}
                onBlur={() => validateField("zip")}
              />
              {errors.zip && <span style={{ color: "red" }}>{errors.zip}</span>}
            </div>
          </div>
        );

      case 3:
        return (
          <div>
            <h3>Step 3: Preferences</h3>

            <div>
              <label>
                <input
                  type="checkbox"
                  checked={formData.newsletter}
                  onChange={(e) => updateField("newsletter", e.target.checked)}
                />
                Subscribe to newsletter
              </label>
            </div>

            <div>
              <label>
                <input
                  type="checkbox"
                  checked={formData.notifications}
                  onChange={(e) =>
                    updateField("notifications", e.target.checked)
                  }
                />
                Enable notifications
              </label>
            </div>
          </div>
        );
    }
  };

  return (
    <div style={{ maxWidth: "600px", margin: "0 auto", padding: "20px" }}>
      <h2>Multi-Step Registration Form</h2>

      {/* Progress indicator */}
      <div style={{ marginBottom: "20px" }}>
        Step {currentStep} of 3
        <div style={{ display: "flex", gap: "5px", marginTop: "10px" }}>
          {[1, 2, 3].map((step) => (
            <div
              key={step}
              style={{
                flex: 1,
                height: "4px",
                background: step <= currentStep ? "#4CAF50" : "#ddd",
              }}
            />
          ))}
        </div>
      </div>

      {/* Auto-save indicator */}
      {hasUnsavedChanges && (
        <p style={{ color: "#ff9800" }}>âš ï¸ Unsaved changes...</p>
      )}
      {lastSaved && (
        <p style={{ color: "#4CAF50" }}>âœ… Last saved: {lastSaved}</p>
      )}

      {/* Step content */}
      {renderStep()}

      {/* Navigation */}
      <div style={{ marginTop: "20px", display: "flex", gap: "10px" }}>
        {currentStep > 1 && <button onClick={prevStep}>â† Previous</button>}

        {currentStep < 3 && <button onClick={nextStep}>Next â†’</button>}

        {currentStep === 3 && <button onClick={handleSubmit}>Submit</button>}
      </div>

      {/* Debug info */}
      <div
        style={{ marginTop: "30px", padding: "10px", background: "#f0f0f0" }}
      >
        <h4>Debug Info:</h4>
        <pre>{JSON.stringify({ formData, errors, currentStep }, null, 2)}</pre>
      </div>
    </div>
  );
}

export default MultiStepForm;

// ğŸ§ª PHASE 3: Testing (10 phÃºt)
// Manual testing checklist:
// - [ ] Step 1: Fill all fields â†’ Validate on blur
// - [ ] Step 1: Try next with invalid data â†’ Blocked
// - [ ] Step 1: Fix errors â†’ Can proceed
// - [ ] Step 2: Validate address fields
// - [ ] Step 3: Toggle checkboxes
// - [ ] Auto-save: Wait 5s, check localStorage
// - [ ] Refresh page: Draft should load
// - [ ] Submit: Clear draft from storage
// - [ ] Navigation: Prev/Next buttons work
// - [ ] Errors: Show immediately on blur
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * MultiStepForm - Level 4: Multi-Step Registration Form vá»›i Validation & Auto-save
 *
 * Quyáº¿t Ä‘á»‹nh kiáº¿n trÃºc (Approach 3 - Hybrid):
 * - Validation onBlur â†’ dÃ¹ng event handler (khÃ´ng dÃ¹ng effect cho tá»«ng field)
 * - Validate toÃ n bá»™ step khi nháº¥n Next â†’ logic trong handler
 * - Auto-save draft má»—i 5 giÃ¢y khi cÃ³ thay Ä‘á»•i â†’ dÃ¹ng useEffect + timer
 * - Load draft tá»« localStorage khi mount â†’ empty deps
 * - Dependencies rÃµ rÃ ng, trÃ¡nh stale closure, tÃ¡ch biá»‡t concerns
 */
import { useState, useEffect } from "react";

// Validation helpers
const validateEmail = (email) => {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(email);
};

const validatePhone = (phone) => {
  const cleaned = phone.replace(/\D/g, "");
  return cleaned.length === 10;
};

const validateZip = (zip) => {
  return /^\d{5}$/.test(zip);
};

function MultiStepForm() {
  const [currentStep, setCurrentStep] = useState(1);

  const [formData, setFormData] = useState({
    name: "",
    email: "",
    phone: "",
    street: "",
    city: "",
    zip: "",
    newsletter: false,
    notifications: false,
  });

  const [errors, setErrors] = useState({});
  const [lastSaved, setLastSaved] = useState(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  // Effect: Auto-save draft má»—i 5 giÃ¢y khi cÃ³ thay Ä‘á»•i
  useEffect(() => {
    if (!hasUnsavedChanges) return;

    const timerId = setTimeout(() => {
      try {
        localStorage.setItem("registrationDraft", JSON.stringify(formData));
        setLastSaved(new Date().toLocaleTimeString());
        setHasUnsavedChanges(false);
        console.log("Draft auto-saved");
      } catch (err) {
        console.error("Auto-save failed:", err);
      }
    }, 5000);

    return () => clearTimeout(timerId);
  }, [formData, hasUnsavedChanges]);

  // Effect: Load draft khi component mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem("registrationDraft");
      if (saved) {
        const draft = JSON.parse(saved);
        setFormData(draft);
        console.log("Loaded draft from localStorage");
      }
    } catch (err) {
      console.error("Load draft failed:", err);
    }
  }, []); // empty deps â†’ chá»‰ cháº¡y 1 láº§n

  const updateField = (field, value) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
    setHasUnsavedChanges(true);

    // Clear error khi ngÆ°á»i dÃ¹ng sá»­a field
    if (errors[field]) {
      setErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };

  const validateField = (field) => {
    const value = formData[field];
    let error = null;

    switch (field) {
      case "name":
        if (!value.trim()) error = "Name is required";
        else if (value.trim().length < 2)
          error = "Name must be at least 2 characters";
        break;
      case "email":
        if (!value) error = "Email is required";
        else if (!validateEmail(value)) error = "Invalid email format";
        break;
      case "phone":
        if (!value) error = "Phone is required";
        else if (!validatePhone(value)) error = "Phone must be 10 digits";
        break;
      case "street":
        if (!value.trim()) error = "Street is required";
        break;
      case "city":
        if (!value.trim()) error = "City is required";
        break;
      case "zip":
        if (!value) error = "ZIP code is required";
        else if (!validateZip(value)) error = "ZIP must be 5 digits";
        break;
      default:
        break;
    }

    if (error) {
      setErrors((prev) => ({ ...prev, [field]: error }));
      return false;
    }
    return true;
  };

  const validateCurrentStep = () => {
    let fields = [];
    if (currentStep === 1) fields = ["name", "email", "phone"];
    if (currentStep === 2) fields = ["street", "city", "zip"];

    let isValid = true;
    fields.forEach((field) => {
      if (!validateField(field)) isValid = false;
    });

    return isValid;
  };

  const nextStep = () => {
    if (validateCurrentStep()) {
      setCurrentStep((prev) => prev + 1);
      // Clear errors cá»§a step cÅ© khi chuyá»ƒn sang step má»›i
      setErrors({});
    }
  };

  const prevStep = () => {
    setCurrentStep((prev) => prev - 1);
    setErrors({});
  };

  const handleSubmit = () => {
    if (validateCurrentStep()) {
      console.log("Form submitted successfully:", formData);
      localStorage.removeItem("registrationDraft");
      alert("Registration completed!");
      // Reset form náº¿u muá»‘n
      setFormData({
        name: "",
        email: "",
        phone: "",
        street: "",
        city: "",
        zip: "",
        newsletter: false,
        notifications: false,
      });
      setCurrentStep(1);
      setErrors({});
      setLastSaved(null);
      setHasUnsavedChanges(false);
    }
  };

  const renderStepContent = () => {
    switch (currentStep) {
      case 1:
        return (
          <>
            <h3>Step 1: Personal Information</h3>
            <div>
              <label>Name</label>
              <input
                value={formData.name}
                onChange={(e) => updateField("name", e.target.value)}
                onBlur={() => validateField("name")}
              />
              {errors.name && <span className="error">{errors.name}</span>}
            </div>
            <div>
              <label>Email</label>
              <input
                type="email"
                value={formData.email}
                onChange={(e) => updateField("email", e.target.value)}
                onBlur={() => validateField("email")}
              />
              {errors.email && <span className="error">{errors.email}</span>}
            </div>
            <div>
              <label>Phone</label>
              <input
                value={formData.phone}
                onChange={(e) => updateField("phone", e.target.value)}
                onBlur={() => validateField("phone")}
              />
              {errors.phone && <span className="error">{errors.phone}</span>}
            </div>
          </>
        );

      case 2:
        return (
          <>
            <h3>Step 2: Address</h3>
            <div>
              <label>Street</label>
              <input
                value={formData.street}
                onChange={(e) => updateField("street", e.target.value)}
                onBlur={() => validateField("street")}
              />
              {errors.street && <span className="error">{errors.street}</span>}
            </div>
            <div>
              <label>City</label>
              <input
                value={formData.city}
                onChange={(e) => updateField("city", e.target.value)}
                onBlur={() => validateField("city")}
              />
              {errors.city && <span className="error">{errors.city}</span>}
            </div>
            <div>
              <label>ZIP Code</label>
              <input
                value={formData.zip}
                onChange={(e) => updateField("zip", e.target.value)}
                onBlur={() => validateField("zip")}
              />
              {errors.zip && <span className="error">{errors.zip}</span>}
            </div>
          </>
        );

      case 3:
        return (
          <>
            <h3>Step 3: Preferences</h3>
            <label>
              <input
                type="checkbox"
                checked={formData.newsletter}
                onChange={(e) => updateField("newsletter", e.target.checked)}
              />
              Subscribe to newsletter
            </label>
            <label>
              <input
                type="checkbox"
                checked={formData.notifications}
                onChange={(e) => updateField("notifications", e.target.checked)}
              />
              Enable notifications
            </label>
          </>
        );

      default:
        return null;
    }
  };

  return (
    <div style={{ maxWidth: "500px", margin: "0 auto", padding: "20px" }}>
      <h2>Multi-Step Registration</h2>

      <div style={{ marginBottom: "20px" }}>
        Step {currentStep} of 3
        <div
          style={{
            display: "flex",
            gap: "8px",
            marginTop: "8px",
            height: "6px",
          }}
        >
          {[1, 2, 3].map((step) => (
            <div
              key={step}
              style={{
                flex: 1,
                background: step <= currentStep ? "#4caf50" : "#e0e0e0",
                borderRadius: "3px",
              }}
            />
          ))}
        </div>
      </div>

      {hasUnsavedChanges && (
        <p style={{ color: "#f57c00" }}>Saving draft in 5s...</p>
      )}
      {lastSaved && <p style={{ color: "#388e3c" }}>Last saved: {lastSaved}</p>}

      {renderStepContent()}

      <div
        style={{
          marginTop: "24px",
          display: "flex",
          gap: "12px",
          justifyContent: "space-between",
        }}
      >
        {currentStep > 1 && <button onClick={prevStep}>Previous</button>}

        {currentStep < 3 ? (
          <button onClick={nextStep}>Next</button>
        ) : (
          <button onClick={handleSubmit}>Submit</button>
        )}
      </div>

      {/* Minimal inline style cho error */}
      <style>{`
        .error { 
          color: #d32f2f; 
          font-size: 0.85em; 
          display: block; 
          margin-top: 4px; 
        }
        input, button { 
          padding: 10px; 
          margin: 8px 0; 
          width: 100%; 
          box-sizing: border-box; 
        }
        button { 
          background: #1976d2; 
          color: white; 
          border: none; 
          border-radius: 4px; 
          cursor: pointer; 
        }
        button:hover { background: #1565c0; }
        label { display: block; margin: 12px 0 4px; }
      `}</style>
    </div>
  );
}

export default MultiStepForm;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi tÆ°Æ¡ng tÃ¡c:**

```
// Mount â†’ load draft náº¿u cÃ³ â†’ console: "Loaded draft from localStorage"
// GÃµ name khÃ´ng há»£p lá»‡ â†’ blur â†’ error hiá»ƒn thá»‹ ngay
// GÃµ Ä‘á»§ há»£p lá»‡ cáº£ step 1 â†’ nháº¥n Next â†’ chuyá»ƒn sang step 2, error clear
// GÃµ vÃ i kÃ½ tá»± rá»“i ngá»«ng 5 giÃ¢y â†’ console: "Draft auto-saved"
// Refresh trang â†’ dá»¯ liá»‡u váº«n giá»¯ nguyÃªn tá»« localStorage
// HoÃ n thÃ nh step 3 â†’ Submit â†’ alert thÃ nh cÃ´ng + xÃ³a draft khá»i storage
```

</details>

---

### â­â­â­â­â­ Level 5: Production Challenge (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Real-time Collaborative Text Editor
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * XÃ¢y dá»±ng text editor vá»›i cÃ¡c tÃ­nh nÄƒng:
 * 1. Auto-save to localStorage (debounced)
 * 2. Character count + word count (real-time)
 * 3. Reading time estimation
 * 4. Undo/Redo history (last 10 actions)
 * 5. Collaborative indicator (simulate multiple users)
 * 6. Dark mode toggle
 * 7. Export to file
 *
 * ğŸ—ï¸ Technical Design Doc:
 *
 * 1. Component Architecture:
 *    - TextEditor (parent)
 *    - EditorToolbar (controls)
 *    - EditorStats (metrics)
 *    - EditorCanvas (textarea)
 *    - CollaboratorsList (fake users)
 *
 * 2. State Management Strategy:
 *    - content: Editor text
 *    - history: Array of past contents (undo/redo)
 *    - historyIndex: Current position in history
 *    - isDarkMode: Theme toggle
 *    - collaborators: Fake users list
 *    - lastSaved: Timestamp
 *
 * 3. Side Effects (useEffect usage):
 *    - Effect 1: Auto-save (debounced, deps: [content])
 *    - Effect 2: Update document.title with word count
 *    - Effect 3: Load from localStorage on mount
 *    - Effect 4: Simulate collaborators joining/leaving
 *    - Effect 5: Sync dark mode with localStorage
 *
 * 4. Performance Considerations:
 *    - Debounce auto-save (3 seconds)
 *    - Limit history size (max 10)
 *    - Throttle stats calculations (náº¿u content ráº¥t dÃ i)
 *
 * 5. Error Handling Strategy:
 *    - Try/catch localStorage access
 *    - Fallback náº¿u localStorage full
 *    - Graceful degradation
 *
 * âœ… Production Checklist:
 * - [ ] All states initialized
 * - [ ] All effects have proper dependencies
 * - [ ] Cleanup functions for timers
 * - [ ] LocalStorage error handling
 * - [ ] Keyboard shortcuts (Ctrl+Z, Ctrl+Y)
 * - [ ] Accessibility (ARIA labels)
 * - [ ] Visual feedback cho save status
 * - [ ] Responsive design
 * - [ ] Comments Ä‘áº§y Ä‘á»§
 *
 * ğŸ“ Documentation:
 * - Component responsibilities
 * - State structure
 * - Effect purposes
 * - How to extend
 */

import { useState, useEffect } from "react";

// Utility functions
const countWords = (text) => {
  return text.trim() ? text.trim().split(/\s+/).length : 0;
};

const estimateReadingTime = (text) => {
  const words = countWords(text);
  const minutes = Math.ceil(words / 200); // Average reading speed
  return minutes;
};

const saveToLocalStorage = (key, value) => {
  try {
    localStorage.setItem(key, JSON.stringify(value));
    return true;
  } catch (e) {
    console.error("LocalStorage error:", e);
    return false;
  }
};

const loadFromLocalStorage = (key) => {
  try {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  } catch (e) {
    console.error("LocalStorage error:", e);
    return null;
  }
};

function CollaborativeTextEditor() {
  // Core editor state
  const [content, setContent] = useState("");
  const [history, setHistory] = useState([""]);
  const [historyIndex, setHistoryIndex] = useState(0);

  // UI state
  const [isDarkMode, setIsDarkMode] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [lastSaved, setLastSaved] = useState(null);
  const [saveStatus, setSaveStatus] = useState("All changes saved");

  // Collaboration state (simulated)
  const [collaborators, setCollaborators] = useState([
    { id: 1, name: "Alice", color: "#FF6B6B", active: true },
    { id: 2, name: "Bob", color: "#4ECDC4", active: false },
  ]);

  // Computed values (derived state - KHÃ”NG cáº§n useEffect!)
  const charCount = content.length;
  const wordCount = countWords(content);
  const readingTime = estimateReadingTime(content);

  // TODO: Effect 1 - Load tá»« localStorage khi mount
  useEffect(() => {
    // Load content
    const savedContent = loadFromLocalStorage("editorContent");
    if (savedContent) {
      setContent(savedContent);
      setHistory([savedContent]);
      console.log("âœ… Loaded content from localStorage");
    }

    // Load dark mode preference
    const savedDarkMode = loadFromLocalStorage("editorDarkMode");
    if (savedDarkMode !== null) {
      setIsDarkMode(savedDarkMode);
    }
  }, []); // Empty deps â†’ Run once on mount

  // TODO: Effect 2 - Auto-save (debounced)
  useEffect(() => {
    // Don't save if content hasn't changed or is empty
    if (!content) return;

    setIsSaving(true);
    setSaveStatus("Saving...");

    const timerId = setTimeout(() => {
      const success = saveToLocalStorage("editorContent", content);
      setIsSaving(false);

      if (success) {
        setLastSaved(new Date());
        setSaveStatus("All changes saved");
        console.log("ğŸ’¾ Auto-saved at", new Date().toLocaleTimeString());
      } else {
        setSaveStatus("âš ï¸ Save failed");
      }
    }, 3000); // 3 second debounce

    return () => {
      clearTimeout(timerId);
      setSaveStatus("Unsaved changes...");
    };
  }, [content]); // Re-run khi content thay Ä‘á»•i

  // TODO: Effect 3 - Update document.title
  useEffect(() => {
    document.title = `Editor - ${wordCount} words`;
  }, [wordCount]);

  // TODO: Effect 4 - Sync dark mode preference
  useEffect(() => {
    saveToLocalStorage("editorDarkMode", isDarkMode);

    // Apply to body class
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
    } else {
      document.body.classList.remove("dark-mode");
    }
  }, [isDarkMode]);

  // TODO: Effect 5 - Simulate collaborators activity
  useEffect(() => {
    const interval = setInterval(() => {
      setCollaborators((prev) =>
        prev.map((collab) => ({
          ...collab,
          active: Math.random() > 0.5,
        })),
      );
    }, 5000); // Update every 5 seconds

    return () => clearInterval(interval);
  }, []); // No deps â†’ Continuous simulation

  // Content change handler
  const handleContentChange = (e) => {
    const newContent = e.target.value;
    setContent(newContent);

    // Add to history (limit to last 10)
    const newHistory = [...history.slice(0, historyIndex + 1), newContent];
    if (newHistory.length > 10) {
      newHistory.shift(); // Remove oldest
    } else {
      setHistoryIndex(historyIndex + 1);
    }
    setHistory(newHistory);
  };

  // Undo handler
  const handleUndo = () => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setContent(history[newIndex]);
    }
  };

  // Redo handler
  const handleRedo = () => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setContent(history[newIndex]);
    }
  };

  // Export handler
  const handleExport = () => {
    const blob = new Blob([content], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `document-${Date.now()}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  };

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === "z" && !e.shiftKey) {
          e.preventDefault();
          handleUndo();
        } else if (e.key === "y" || (e.key === "z" && e.shiftKey)) {
          e.preventDefault();
          handleRedo();
        }
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [historyIndex, history]); // Deps: values used in handler

  return (
    <div
      style={{
        minHeight: "100vh",
        background: isDarkMode ? "#1e1e1e" : "#ffffff",
        color: isDarkMode ? "#d4d4d4" : "#000000",
        transition: "all 0.3s ease",
      }}
    >
      <div style={{ maxWidth: "900px", margin: "0 auto", padding: "20px" }}>
        {/* Toolbar */}
        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: "20px",
            padding: "10px",
            background: isDarkMode ? "#2d2d2d" : "#f5f5f5",
            borderRadius: "8px",
          }}
        >
          <div style={{ display: "flex", gap: "10px" }}>
            <button
              onClick={handleUndo}
              disabled={historyIndex === 0}
              title="Undo (Ctrl+Z)"
            >
              â†¶ Undo
            </button>
            <button
              onClick={handleRedo}
              disabled={historyIndex === history.length - 1}
              title="Redo (Ctrl+Y)"
            >
              â†· Redo
            </button>
            <button onClick={handleExport}>ğŸ“¥ Export</button>
          </div>

          <div style={{ display: "flex", alignItems: "center", gap: "15px" }}>
            <span style={{ fontSize: "14px" }}>
              {isSaving ? "ğŸ’¾ Saving..." : saveStatus}
            </span>
            <label
              style={{
                display: "flex",
                alignItems: "center",
                gap: "5px",
                cursor: "pointer",
              }}
            >
              <input
                type="checkbox"
                checked={isDarkMode}
                onChange={(e) => setIsDarkMode(e.target.checked)}
              />
              ğŸŒ™ Dark Mode
            </label>
          </div>
        </div>

        {/* Stats Bar */}
        <div
          style={{
            display: "flex",
            gap: "20px",
            marginBottom: "20px",
            padding: "10px",
            background: isDarkMode ? "#2d2d2d" : "#f5f5f5",
            borderRadius: "8px",
            fontSize: "14px",
          }}
        >
          <span>ğŸ“ {charCount} characters</span>
          <span>ğŸ“Š {wordCount} words</span>
          <span>â±ï¸ {readingTime} min read</span>
          <span>
            ğŸ“š History: {historyIndex + 1}/{history.length}
          </span>
        </div>

        {/* Collaborators */}
        <div
          style={{
            marginBottom: "20px",
            padding: "10px",
            background: isDarkMode ? "#2d2d2d" : "#f5f5f5",
            borderRadius: "8px",
          }}
        >
          <strong>ğŸ‘¥ Collaborators:</strong>
          <div style={{ display: "flex", gap: "10px", marginTop: "5px" }}>
            {collaborators.map((collab) => (
              <div
                key={collab.id}
                style={{
                  padding: "5px 10px",
                  background: collab.color,
                  color: "white",
                  borderRadius: "20px",
                  fontSize: "12px",
                  opacity: collab.active ? 1 : 0.5,
                }}
              >
                {collab.name} {collab.active ? "ğŸŸ¢" : "âšª"}
              </div>
            ))}
          </div>
        </div>

        {/* Editor */}
        <textarea
          value={content}
          onChange={handleContentChange}
          placeholder="Start writing your masterpiece..."
          style={{
            width: "100%",
            minHeight: "400px",
            padding: "20px",
            fontSize: "16px",
            lineHeight: "1.6",
            border: "none",
            borderRadius: "8px",
            background: isDarkMode ? "#2d2d2d" : "#ffffff",
            color: isDarkMode ? "#d4d4d4" : "#000000",
            resize: "vertical",
            fontFamily: "monospace",
          }}
          aria-label="Text editor"
        />

        {/* Footer */}
        <div
          style={{
            marginTop: "20px",
            padding: "10px",
            textAlign: "center",
            fontSize: "12px",
            opacity: 0.7,
          }}
        >
          {lastSaved && (
            <span>Last saved: {lastSaved.toLocaleTimeString()}</span>
          )}
          <br />
          Tip: Use Ctrl+Z to undo, Ctrl+Y to redo
        </div>
      </div>
    </div>
  );
}

export default CollaborativeTextEditor;

// ğŸ“‹ TESTING CHECKLIST:
// - [ ] Type text â†’ Auto-save after 3s
// - [ ] Undo/Redo with buttons
// - [ ] Undo/Redo with Ctrl+Z/Ctrl+Y
// - [ ] Toggle dark mode â†’ Persists on refresh
// - [ ] Export to file
// - [ ] Stats update in real-time
// - [ ] Collaborators change active status
// - [ ] Refresh page â†’ Content loads
// - [ ] History limited to 10 items
// - [ ] Save status indicators accurate

// ğŸ’¡ EXTENSION IDEAS:
// 1. Rich text formatting (bold, italic)
// 2. Markdown preview
// 3. Real WebSocket collaboration
// 4. Version history timeline
// 5. Cloud sync (API integration)
// 6. Spell check
// 7. Find & Replace
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * CollaborativeTextEditor - Level 5: Production-grade Real-time Text Editor
 *
 * TÃ­nh nÄƒng chÃ­nh:
 * - Real-time character/word count + reading time estimation
 * - Debounced auto-save to localStorage (3 giÃ¢y)
 * - Undo / Redo (lÆ°u tá»‘i Ä‘a 10 bÆ°á»›c)
 * - Dark mode toggle + persist
 * - Simulated collaborators status
 * - Export to .txt file
 * - Keyboard shortcuts (Ctrl+Z / Ctrl+Y)
 * - Save status indicator
 */
import { useState, useEffect } from "react";

// Utility functions
const countWords = (text) =>
  text.trim() ? text.trim().split(/\s+/).length : 0;

const estimateReadingTime = (text) => {
  const words = countWords(text);
  return Math.ceil(words / 200); // ~200 tá»«/phÃºt
};

const saveToStorage = (key, value) => {
  try {
    localStorage.setItem(key, JSON.stringify(value));
    return true;
  } catch (e) {
    console.error("Storage save error:", e);
    return false;
  }
};

const loadFromStorage = (key) => {
  try {
    const item = localStorage.getItem(key);
    return item ? JSON.parse(item) : null;
  } catch (e) {
    console.error("Storage load error:", e);
    return null;
  }
};

function CollaborativeTextEditor() {
  // Editor core state
  const [content, setContent] = useState("");
  const [history, setHistory] = useState([""]);
  const [historyIndex, setHistoryIndex] = useState(0);

  // UI & feature states
  const [isDarkMode, setIsDarkMode] = useState(false);
  const [saveStatus, setSaveStatus] = useState("All changes saved");
  const [lastSaved, setLastSaved] = useState(null);
  const [isSaving, setIsSaving] = useState(false);

  // Simulated collaborators
  const [collaborators] = useState([
    { id: 1, name: "Alice", color: "#ef5350", active: true },
    { id: 2, name: "Bob", color: "#42a5f5", active: false },
    { id: 3, name: "Emma", color: "#66bb6a", active: true },
  ]);

  // Derived stats (khÃ´ng cáº§n useEffect)
  const charCount = content.length;
  const wordCount = countWords(content);
  const readingTime = estimateReadingTime(content);

  // Load saved content & dark mode preference on mount
  useEffect(() => {
    const savedContent = loadFromStorage("editorContent");
    if (savedContent !== null) {
      setContent(savedContent);
      setHistory([savedContent]);
      setHistoryIndex(0);
    }

    const savedDarkMode = loadFromStorage("editorDarkMode");
    if (savedDarkMode !== null) {
      setIsDarkMode(savedDarkMode);
    }
  }, []);

  // Auto-save with debounce (3 seconds)
  useEffect(() => {
    if (!content.trim()) {
      setSaveStatus("All changes saved");
      return;
    }

    setIsSaving(true);
    setSaveStatus("Saving...");

    const timer = setTimeout(() => {
      const success = saveToStorage("editorContent", content);
      setIsSaving(false);
      if (success) {
        setLastSaved(new Date());
        setSaveStatus("All changes saved");
      } else {
        setSaveStatus("Save failed â€“ storage may be full");
      }
    }, 3000);

    return () => {
      clearTimeout(timer);
      setIsSaving(false);
      setSaveStatus("Unsaved changes...");
    };
  }, [content]);

  // Sync dark mode to storage & apply class
  useEffect(() => {
    saveToStorage("editorDarkMode", isDarkMode);
    document.body.classList.toggle("dark-mode", isDarkMode);
  }, [isDarkMode]);

  // Simulate collaborator status changes
  useEffect(() => {
    const interval = setInterval(() => {
      // Randomly toggle active status cho demo
      setCollaborators((prev) =>
        prev.map((c) => ({
          ...c,
          active: Math.random() > 0.4,
        })),
      );
    }, 8000);

    return () => clearInterval(interval);
  }, []);

  // Undo / Redo keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key === "z") {
        e.preventDefault();
        handleUndo();
      }
      if (
        (e.ctrlKey || e.metaKey) &&
        (e.key === "y" || (e.shiftKey && e.key === "z"))
      ) {
        e.preventDefault();
        handleRedo();
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [historyIndex, history]);

  const handleContentChange = (e) => {
    const newContent = e.target.value;
    setContent(newContent);

    // Cáº­p nháº­t history (giá»›i háº¡n 10 bÆ°á»›c)
    const newHistory = [...history.slice(0, historyIndex + 1), newContent];
    setHistory(newHistory.slice(-10)); // Giá»¯ tá»‘i Ä‘a 10 items
    setHistoryIndex(newHistory.length - 1);
  };

  const handleUndo = () => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setContent(history[newIndex]);
    }
  };

  const handleRedo = () => {
    if (historyIndex < history.length - 1) {
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setContent(history[newIndex]);
    }
  };

  const handleExport = () => {
    const blob = new Blob([content], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `document-${new Date().toISOString().slice(0, 10)}.txt`;
    link.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div
      style={{
        minHeight: "100vh",
        background: isDarkMode ? "#121212" : "#f5f5f5",
        color: isDarkMode ? "#e0e0e0" : "#212121",
        transition: "all 0.25s ease",
      }}
    >
      <div style={{ maxWidth: "960px", margin: "0 auto", padding: "20px" }}>
        {/* Toolbar */}
        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            marginBottom: "20px",
            padding: "12px 16px",
            background: isDarkMode ? "#1e1e1e" : "#ffffff",
            borderRadius: "8px",
            boxShadow: "0 2px 10px rgba(0,0,0,0.1)",
          }}
        >
          <div style={{ display: "flex", gap: "12px" }}>
            <button
              onClick={handleUndo}
              disabled={historyIndex === 0}
              title="Undo (Ctrl+Z)"
            >
              â†¶ Undo
            </button>
            <button
              onClick={handleRedo}
              disabled={historyIndex === history.length - 1}
              title="Redo (Ctrl+Y)"
            >
              â†· Redo
            </button>
            <button onClick={handleExport} title="Export to .txt">
              Export
            </button>
          </div>

          <div style={{ display: "flex", alignItems: "center", gap: "20px" }}>
            <span
              style={{
                fontSize: "14px",
                color: isSaving
                  ? "#f57c00"
                  : saveStatus.includes("failed")
                    ? "#d32f2f"
                    : "#388e3c",
              }}
            >
              {isSaving ? "Saving..." : saveStatus}
            </span>

            <label
              style={{
                display: "flex",
                alignItems: "center",
                gap: "8px",
                cursor: "pointer",
              }}
            >
              <input
                type="checkbox"
                checked={isDarkMode}
                onChange={(e) => setIsDarkMode(e.target.checked)}
              />
              Dark Mode
            </label>
          </div>
        </div>

        {/* Stats */}
        <div
          style={{
            display: "flex",
            gap: "24px",
            marginBottom: "16px",
            fontSize: "14px",
            color: isDarkMode ? "#bbbbbb" : "#555",
          }}
        >
          <span>
            Characters: <strong>{charCount}</strong>
          </span>
          <span>
            Words: <strong>{wordCount}</strong>
          </span>
          <span>~{readingTime} min read</span>
          <span>
            History: {historyIndex + 1} / {history.length}
          </span>
        </div>

        {/* Collaborators */}
        <div
          style={{
            marginBottom: "20px",
            padding: "12px",
            background: isDarkMode ? "#1e1e1e" : "#ffffff",
            borderRadius: "8px",
            boxShadow: "0 1px 6px rgba(0,0,0,0.08)",
          }}
        >
          <strong>Collaborators now:</strong>
          <div
            style={{
              display: "flex",
              gap: "12px",
              marginTop: "8px",
              flexWrap: "wrap",
            }}
          >
            {collaborators.map((collab) => (
              <div
                key={collab.id}
                style={{
                  padding: "6px 12px",
                  background: collab.color,
                  color: "white",
                  borderRadius: "16px",
                  fontSize: "13px",
                  opacity: collab.active ? 1 : 0.45,
                  display: "flex",
                  alignItems: "center",
                  gap: "6px",
                }}
              >
                {collab.name}
                <span>{collab.active ? "ğŸŸ¢" : "âšª"}</span>
              </div>
            ))}
          </div>
        </div>

        {/* Editor Area */}
        <textarea
          value={content}
          onChange={handleContentChange}
          placeholder="Start writing here..."
          style={{
            width: "100%",
            minHeight: "500px",
            padding: "20px",
            fontSize: "16px",
            lineHeight: 1.6,
            border: "none",
            borderRadius: "8px",
            background: isDarkMode ? "#1e1e1e" : "#ffffff",
            color: isDarkMode ? "#e0e0e0" : "#212121",
            boxShadow: "0 2px 12px rgba(0,0,0,0.12)",
            resize: "vertical",
            fontFamily: "inherit",
          }}
        />

        {/* Footer info */}
        <div
          style={{
            marginTop: "16px",
            textAlign: "center",
            fontSize: "13px",
            color: isDarkMode ? "#888" : "#666",
          }}
        >
          {lastSaved && <>Last saved: {lastSaved.toLocaleTimeString()}</>}
          <br />
          <small>
            Tip: Ctrl+Z to undo â€¢ Ctrl+Y to redo â€¢ Auto-saves every 3 seconds
          </small>
        </div>
      </div>

      {/* Basic dark mode styles */}
      <style>{`
        body.dark-mode {
          background: #121212;
          color: #e0e0e0;
        }
        button {
          padding: 8px 16px;
          background: #1976d2;
          color: white;
          border: none;
          border-radius: 6px;
          cursor: pointer;
        }
        button:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }
        button:hover:not(:disabled) {
          background: #1565c0;
        }
      `}</style>
    </div>
  );
}

export default CollaborativeTextEditor;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi tÆ°Æ¡ng tÃ¡c:**

```
// Mount â†’ náº¿u cÃ³ draft â†’ load ná»™i dung cÅ©
// GÃµ vÃ i cÃ¢u â†’ sau 3 giÃ¢y â†’ "All changes saved" + lÆ°u localStorage
// Nháº¥n Undo (Ctrl+Z) â†’ ná»™i dung quay vá» bÆ°á»›c trÆ°á»›c, historyIndex giáº£m
// Báº­t Dark Mode â†’ giao diá»‡n chuyá»ƒn tá»‘i, lÆ°u preference
// Collaborators â†’ tráº¡ng thÃ¡i active thay Ä‘á»•i ngáº«u nhiÃªn má»—i ~8 giÃ¢y
// Nháº¥n Export â†’ táº£i file .txt vá»›i ná»™i dung hiá»‡n táº¡i
// Refresh trang â†’ ná»™i dung + dark mode preference Ä‘Æ°á»£c khÃ´i phá»¥c
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Dependencies Patterns

| Pattern            | Syntax                        | Runs When                    | Use Case             | Performance |
| ------------------ | ----------------------------- | ---------------------------- | -------------------- | ----------- |
| **No Deps**        | `useEffect(() => {})`         | Every render                 | Debug logs           | âš ï¸ Poor     |
| **Empty []**       | `useEffect(() => {}, [])`     | Once (mount)                 | Initial fetch, setup | âœ… Best     |
| **Single [a]**     | `useEffect(() => {}, [a])`    | When `a` changes             | Sync with one value  | âœ… Good     |
| **Multiple [a,b]** | `useEffect(() => {}, [a, b])` | When `a` OR `b` changes      | Sync with multiple   | âœ… Good     |
| **Object [obj]**   | `useEffect(() => {}, [obj])`  | When `obj` reference changes | âš ï¸ Often re-runs     | âŒ Poor     |
| **Array [arr]**    | `useEffect(() => {}, [arr])`  | When `arr` reference changes | âš ï¸ Often re-runs     | âŒ Poor     |

### Báº£ng So SÃ¡nh: Stale Closure Solutions

| Solution              | Code                              | Pros                             | Cons                 | When to Use                      |
| --------------------- | --------------------------------- | -------------------------------- | -------------------- | -------------------------------- |
| **Functional Update** | `setState(prev => prev + 1)`      | âœ… No stale closure<br>âœ… Simple | âŒ Only for setState | State updates trong effects      |
| **Add to Deps**       | `useEffect(() => {...}, [value])` | âœ… Always fresh<br>âœ… Clear      | âŒ Effect re-runs    | Need latest value                |
| **useRef**            | `ref.current = value`             | âœ… Mutable<br>âœ… No re-render    | âŒ More complex      | Persist without re-run (NgÃ y 21) |

### Decision Tree: Chá»n Dependencies

```
Cáº§n dÃ¹ng useEffect?
â”‚
â”œâ”€ Effect dÃ¹ng giÃ¡ trá»‹ nÃ o tá»« component?
â”‚  â”‚
â”‚  â”œâ”€ KHÃ”NG dÃ¹ng giÃ¡ trá»‹ nÃ o (pure side effect)
â”‚  â”‚  â†’ Empty deps []
â”‚  â”‚  â†’ VÃ­ dá»¥: window.addEventListener('resize', ...)
â”‚  â”‚
â”‚  â”œâ”€ DÃ¹ng giÃ¡ trá»‹ KHÃ”NG THAY Äá»”I (props, constants)
â”‚  â”‚  â†’ Empty deps [] (náº¿u truly constant)
â”‚  â”‚  â†’ Hoáº·c khai bÃ¡o trong deps cho safety
â”‚  â”‚
â”‚  â”œâ”€ DÃ¹ng STATE hoáº·c PROPS cÃ³ thá»ƒ thay Ä‘á»•i
â”‚  â”‚  â”‚
â”‚  â”‚  â”œâ”€ Effect cáº§n cháº¡y Má»–I KHI giÃ¡ trá»‹ thay Ä‘á»•i?
â”‚  â”‚  â”‚  â†’ Add to deps: [value]
â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€ Effect CHá»ˆ cáº§n value ban Ä‘áº§u?
â”‚  â”‚     â”‚
â”‚  â”‚     â”œâ”€ DÃ¹ng setState?
â”‚  â”‚     â”‚  â†’ Functional update: setState(prev => ...)
â”‚  â”‚     â”‚
â”‚  â”‚     â””â”€ DÃ¹ng cho logic khÃ¡c?
â”‚  â”‚        â†’ useRef (NgÃ y 21)
â”‚  â”‚
â”‚  â””â”€ DÃ¹ng FUNCTION tá»« props?
â”‚     â†’ Add to deps hoáº·c useCallback (NgÃ y 30+)
â”‚
â””â”€ ESLint warning?
   â†’ LUÃ”N LUÃ”N thÃªm vÃ o deps (trá»« khi cÃ³ lÃ½ do rÃµ rÃ ng)
   â†’ Comment giáº£i thÃ­ch náº¿u ignore
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug #1: Missing Dependencies ğŸš¨

```jsx
/**
 * ğŸ› BUG: ESLint warning - missing dependencies
 * ğŸ¯ Nhiá»‡m vá»¥: Fix theo Ä‘Ãºng quy táº¯c
 */

function BuggyUserGreeting() {
  const [user, setUser] = useState({ name: "John", age: 25 });
  const [greeting, setGreeting] = useState("");

  // âŒ BUG: ESLint warning
  // React Hook useEffect has a missing dependency: 'user'
  useEffect(() => {
    setGreeting(`Hello, ${user.name}! You are ${user.age} years old.`);
  }, []); // Empty deps, but uses `user`!

  return (
    <div>
      <p>{greeting}</p>
      <button onClick={() => setUser({ name: "Jane", age: 30 })}>
        Change User
      </button>
    </div>
  );
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. Táº¡i sao cÃ³ ESLint warning?
// 2. Click button â†’ greeting cÃ³ update khÃ´ng?
// 3. Behavior mong Ä‘á»£i lÃ  gÃ¬?

// ğŸ’¡ GIáº¢I THÃCH:
// - Effect chá»‰ cháº¡y 1 láº§n (empty deps)
// - `user` trong effect lÃ  giÃ¡ trá»‹ lÃºc mount: { name: 'John', age: 25 }
// - Click button â†’ user state thay Ä‘á»•i â†’ Effect KHÃ”NG cháº¡y láº¡i
// - greeting váº«n lÃ  "Hello, John! You are 25 years old."
// - âŒ STALE CLOSURE!

// âœ… FIX #1: Derived State (BEST cho case nÃ y!)
function FixedV1() {
  const [user, setUser] = useState({ name: "John", age: 25 });

  // âœ… TÃ­nh trá»±c tiáº¿p, khÃ´ng cáº§n effect
  const greeting = `Hello, ${user.name}! You are ${user.age} years old.`;

  return (
    <div>
      <p>{greeting}</p>
      <button onClick={() => setUser({ name: "Jane", age: 30 })}>
        Change User
      </button>
    </div>
  );
}

// âœ… FIX #2: Add user to deps (náº¿u thá»±c sá»± cáº§n effect)
function FixedV2() {
  const [user, setUser] = useState({ name: "John", age: 25 });
  const [greeting, setGreeting] = useState("");

  useEffect(() => {
    // Effect cháº¡y láº¡i khi user thay Ä‘á»•i
    setGreeting(`Hello, ${user.name}! You are ${user.age} years old.`);
  }, [user]); // â† Add dependency

  return (
    <div>
      <p>{greeting}</p>
      <button onClick={() => setUser({ name: "Jane", age: 30 })}>
        Change User
      </button>
    </div>
  );
}

// ğŸ“ BÃ€I Há»ŒC:
// - LUÃ”N khai bÃ¡o dependencies Ä‘áº§y Ä‘á»§
// - ESLint exhaustive-deps rule lÃ  báº¡n, khÃ´ng pháº£i káº» thÃ¹
// - Nhiá»u khi khÃ´ng cáº§n effect â†’ Derived state tá»‘t hÆ¡n
```

---

### Bug #2: Object/Array Dependencies ğŸ”„

```jsx
/**
 * ğŸ› BUG: Effect cháº¡y vÃ´ háº¡n vÃ¬ object dependency
 * ğŸ¯ Nhiá»‡m vá»¥: Hiá»ƒu táº¡i sao vÃ  fix
 */

function BuggyFilteredList() {
  const [items, setItems] = useState([
    { id: 1, name: "Apple", category: "Fruit" },
    { id: 2, name: "Carrot", category: "Vegetable" },
    { id: 3, name: "Banana", category: "Fruit" },
  ]);

  const [filters, setFilters] = useState({ category: "Fruit" });
  const [filteredItems, setFilteredItems] = useState([]);

  // âŒ BUG: Infinite loop!
  useEffect(() => {
    console.log("Effect ran");

    const filtered = items.filter((item) => {
      // Táº¡o object Má»šI má»—i láº§n!
      return item.category === filters.category;
    });

    setFilteredItems(filtered); // Array má»›i â†’ Trigger re-render
  }, [items, filters, filteredItems]); // âš ï¸ filteredItems trong deps!

  return (
    <div>
      <h3>Filtered Items:</h3>
      <ul>
        {filteredItems.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. Táº¡i sao effect cháº¡y vÃ´ háº¡n?
// 2. filteredItems cÃ³ nÃªn náº±m trong deps khÃ´ng?
// 3. Array.filter() return gÃ¬?

// ğŸ’¡ GIáº¢I THÃCH:
// 1. Effect runs â†’ filter() táº¡o array Má»šI
// 2. setFilteredItems(filtered) â†’ State thay Ä‘á»•i
// 3. filteredItems thay Ä‘á»•i â†’ Effect re-runs (trong deps!)
// 4. Loop láº·p láº¡i!
//
// Array/Object trong deps:
// - React so sÃ¡nh báº±ng Object.is() (=== comparison)
// - filter() LUÃ”N return array má»›i â†’ Reference khÃ¡c
// - Ngay cáº£ khi content giá»‘ng nhau!

// âœ… FIX #1: Remove filteredItems tá»« deps
function FixedV1() {
  const [items, setItems] = useState([
    { id: 1, name: "Apple", category: "Fruit" },
    { id: 2, name: "Carrot", category: "Vegetable" },
    { id: 3, name: "Banana", category: "Fruit" },
  ]);

  const [filters, setFilters] = useState({ category: "Fruit" });
  const [filteredItems, setFilteredItems] = useState([]);

  useEffect(() => {
    const filtered = items.filter((item) => item.category === filters.category);
    setFilteredItems(filtered);
  }, [items, filters]); // â† Remove filteredItems!

  // ...
}

// âœ… FIX #2: Derived State (BEST!)
function FixedV2() {
  const [items, setItems] = useState([
    { id: 1, name: "Apple", category: "Fruit" },
    { id: 2, name: "Carrot", category: "Vegetable" },
    { id: 3, name: "Banana", category: "Fruit" },
  ]);

  const [filters, setFilters] = useState({ category: "Fruit" });

  // âœ… TÃ­nh trá»±c tiáº¿p, KHÃ”NG cáº§n effect vÃ  state!
  const filteredItems = items.filter(
    (item) => item.category === filters.category,
  );

  return (
    <div>
      <h3>Filtered Items:</h3>
      <ul>
        {filteredItems.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
}

// ğŸ“ BÃ€I Há»ŒC:
// - Äá»ªNG bao giá» Ä‘áº·t "output" state cá»§a effect vÃ o deps!
// - Object/Array dependencies: Cáº©n tháº­n vá»›i reference changes
// - Nhiá»u khi derived state (tÃ­nh trá»±c tiáº¿p) tá»‘t hÆ¡n effect + state
// - useMemo (NgÃ y 28) sáº½ optimize derived state náº¿u cáº§n
```

---

### Bug #3: Effect vá»›i Primitive Wrapper ğŸ

```jsx
/**
 * ğŸ› BUG: Effect khÃ´ng cháº¡y dÃ¹ deps thay Ä‘á»•i
 * ğŸ¯ Nhiá»‡m vá»¥: Debug dependency comparison
 */

function BuggyCountDisplay() {
  const [count, setCount] = useState(0);
  const [displayCount, setDisplayCount] = useState(0);

  // Táº¡o object wrapper (BAD PATTERN!)
  const countWrapper = { value: count };

  useEffect(() => {
    console.log("Effect ran with count:", countWrapper.value);
    setDisplayCount(countWrapper.value);
  }, [countWrapper]); // âš ï¸ Object dependency!

  return (
    <div>
      <p>Display: {displayCount}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. Click button â†’ Effect cÃ³ cháº¡y khÃ´ng?
// 2. countWrapper cÃ³ thay Ä‘á»•i khÃ´ng?
// 3. Táº¡i sao effect cháº¡y má»—i render?

// ğŸ’¡ GIáº¢I THÃCH:
// - Má»—i render â†’ countWrapper = { value: count } Má»šI
// - Object má»›i â†’ Reference má»›i â†’ Always different
// - Effect cháº¡y Má»–I render (giá»‘ng no deps!)
// - âŒ KHÃ”NG kiá»ƒm soÃ¡t Ä‘Æ°á»£c

// âœ… FIX: DÃ¹ng primitive value trá»±c tiáº¿p
function Fixed() {
  const [count, setCount] = useState(0);
  const [displayCount, setDisplayCount] = useState(0);

  useEffect(() => {
    console.log("Effect ran with count:", count);
    setDisplayCount(count);
  }, [count]); // â† Primitive value, so sÃ¡nh báº±ng ===

  return (
    <div>
      <p>Display: {displayCount}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}

// ğŸ“ BÃ€I Há»ŒC:
// - Dependencies nÃªn lÃ  PRIMITIVE values (string, number, boolean)
// - Avoid wrapping primitives trong objects
// - Náº¿u cáº§n object deps â†’ useMemo (NgÃ y 28) hoáº·c stable reference
// - Keep dependencies simple vÃ  predictable
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u âœ… nhá»¯ng Ä‘iá»u báº¡n Ä‘Ã£ hiá»ƒu:

#### Concepts:

- [ ] TÃ´i hiá»ƒu 3 patterns: no deps, empty [], specific [a, b]
- [ ] TÃ´i biáº¿t empty [] = chá»‰ cháº¡y 1 láº§n sau mount
- [ ] TÃ´i hiá»ƒu [a, b] = cháº¡y khi a HOáº¶C b thay Ä‘á»•i
- [ ] TÃ´i biáº¿t stale closure lÃ  gÃ¬ vÃ  táº¡i sao xáº£y ra
- [ ] TÃ´i hiá»ƒu React so sÃ¡nh deps báº±ng Object.is()

#### Practices:

- [ ] TÃ´i cÃ³ thá»ƒ chá»n Ä‘Ãºng dependencies cho effect
- [ ] TÃ´i biáº¿t khi nÃ o dÃ¹ng functional update
- [ ] TÃ´i trÃ¡nh Ä‘Æ°á»£c stale closure bugs
- [ ] TÃ´i biáº¿t khi nÃ o nÃªn dÃ¹ng derived state thay vÃ¬ effect
- [ ] TÃ´i hiá»ƒu ESLint exhaustive-deps rule

#### Debugging:

- [ ] TÃ´i nháº­n biáº¿t Ä‘Æ°á»£c missing dependencies
- [ ] TÃ´i biáº¿t fix infinite loops vá»›i deps
- [ ] TÃ´i hiá»ƒu váº¥n Ä‘á» vá»›i object/array deps
- [ ] TÃ´i cÃ³ thá»ƒ debug deps comparison issues
- [ ] TÃ´i biáº¿t cÃ¡ch trace effect re-runs

---

### Code Review Checklist

Khi review code cÃ³ useEffect, kiá»ƒm tra:

#### Dependencies:

- [ ] Má»i giÃ¡ trá»‹ dÃ¹ng trong effect Ä‘á»u náº±m trong deps
- [ ] Dependencies lÃ  primitive values (trÃ¡nh objects)
- [ ] KhÃ´ng cÃ³ "output" state trong deps (gÃ¢y infinite loop)
- [ ] ESLint warnings Ä‘Æ°á»£c giáº£i quyáº¿t (khÃ´ng disable lung tung)

#### Logic:

- [ ] Effect Ä‘Ãºng purpose (side effect, khÃ´ng pháº£i derived state)
- [ ] Stale closure Ä‘Æ°á»£c trÃ¡nh (functional updates hoáº·c proper deps)
- [ ] Cleanup function náº¿u cáº§n (timers, listeners)

#### Performance:

- [ ] Dependencies tá»‘i thiá»ƒu cáº§n thiáº¿t
- [ ] Empty [] cho setup code (chá»‰ 1 láº§n)
- [ ] Specific deps cho sync logic
- [ ] Avoid no-deps pattern trá»« khi debug

#### Best Practices:

- [ ] Comments giáº£i thÃ­ch WHY effect cáº§n thiáº¿t
- [ ] Dependencies Ä‘Æ°á»£c document (náº¿u unusual)
- [ ] Alternatives considered (derived state? event handler?)

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**BÃ i 1: Window Size Tracker**

```jsx
/**
 * Táº¡o component track window size:
 * - State cho width vÃ  height
 * - useEffect vá»›i window.addEventListener('resize', ...)
 * - Update state khi resize
 * - Dependencies: []
 *
 * Requirements:
 * - Display current window size
 * - Update real-time khi resize
 * - Cleanup event listener
 *
 * Hints:
 * - window.innerWidth, window.innerHeight
 * - Effect vá»›i empty deps [] Ä‘á»ƒ add listener 1 láº§n
 * - Return cleanup function
 */
```

<details><summary>ğŸ’¡ Solution - BÃ i 1: Window Size Tracker</summary>

```jsx
/**
 * WindowSizeTracker - BÃ i táº­p vá» nhÃ  1
 * Hiá»ƒn thá»‹ kÃ­ch thÆ°á»›c cá»­a sá»• trÃ¬nh duyá»‡t hiá»‡n táº¡i
 * Cáº­p nháº­t real-time khi resize
 * Cleanup event listener Ä‘Ãºng cÃ¡ch
 */
import { useState, useEffect } from "react";

function WindowSizeTracker() {
  const [windowSize, setWindowSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.addEventListener("resize", handleResize);

    // Cleanup: gá»¡ listener khi component unmount
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []); // empty deps â†’ chá»‰ add listener 1 láº§n khi mount

  return (
    <div>
      <h2>Window Size Tracker</h2>
      <p>
        Current window size:
        <strong>
          {" "}
          {windowSize.width}px Ã— {windowSize.height}px
        </strong>
      </p>
      <p style={{ color: "#666", fontSize: "14px" }}>
        Thá»­ thay Ä‘á»•i kÃ­ch thÆ°á»›c cá»­a sá»• trÃ¬nh duyá»‡t Ä‘á»ƒ xem giÃ¡ trá»‹ cáº­p nháº­t
      </p>
    </div>
  );
}

export default WindowSizeTracker;
```

**Káº¿t quáº£ vÃ­ dá»¥:**

```
// Ban Ä‘áº§u (vÃ­ dá»¥ mÃ n hÃ¬nh 1440Ã—900)
Current window size: 1440px Ã— 900px

// Thu nhá» cá»­a sá»• trÃ¬nh duyá»‡t â†’ vÃ­ dá»¥ 768Ã—1024 (mobile portrait)
Current window size: 768px Ã— 1024px

// Má»Ÿ rá»™ng láº¡i full screen
Current window size: 1920px Ã— 1080px
```

</details>

**BÃ i 2: Counter vá»›i Auto-increment**

```jsx
/**
 * Táº¡o counter tá»± Ä‘á»™ng tÄƒng:
 * - State cho count
 * - State cho isRunning (true/false)
 * - useEffect Ä‘á»ƒ increment má»—i giÃ¢y khi isRunning = true
 * - Buttons: Start, Pause, Reset
 *
 * Requirements:
 * - Auto-increment CHá»ˆ khi isRunning = true
 * - Pause â†’ Stop incrementing
 * - Resume â†’ Continue from current value
 * - Fix stale closure vá»›i functional update
 *
 * Hints:
 * - setInterval trong effect
 * - Dependencies: [isRunning]
 * - setCount(prev => prev + 1)
 * - Cleanup: clearInterval
 */
```

<details><summary>ğŸ’¡ Solution - BÃ i 2: Counter vá»›i Auto-increment</summary>

```jsx
/**
 * AutoIncrementCounter - BÃ i táº­p vá» nhÃ  2
 * Counter tá»± Ä‘á»™ng tÄƒng má»—i giÃ¢y khi Ä‘ang cháº¡y
 * CÃ³ nÃºt Start / Pause / Reset
 * Sá»­ dá»¥ng functional update Ä‘á»ƒ trÃ¡nh stale closure
 */
import { useState, useEffect } from "react";

function AutoIncrementCounter() {
  const [count, setCount] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    if (!isRunning) return;

    const intervalId = setInterval(() => {
      // Functional update â†’ luÃ´n dÃ¹ng giÃ¡ trá»‹ má»›i nháº¥t
      setCount((prevCount) => prevCount + 1);
    }, 1000);

    // Cleanup: dá»«ng interval khi pause hoáº·c unmount
    return () => clearInterval(intervalId);
  }, [isRunning]); // deps chá»‰ isRunning â†’ effect cháº¡y láº¡i khi start/pause

  const handleReset = () => {
    setCount(0);
    setIsRunning(false); // tá»± Ä‘á»™ng pause khi reset
  };

  return (
    <div>
      <h2>Auto-Increment Counter</h2>

      <h1 style={{ fontSize: "3.5rem", margin: "20px 0" }}>{count}</h1>

      <div style={{ display: "flex", gap: "12px", justifyContent: "center" }}>
        <button onClick={() => setIsRunning(true)} disabled={isRunning}>
          Start
        </button>

        <button onClick={() => setIsRunning(false)} disabled={!isRunning}>
          Pause
        </button>

        <button onClick={handleReset}>Reset</button>
      </div>

      <p style={{ marginTop: "20px", color: "#555" }}>
        {isRunning ? "Äang tÄƒng má»—i giÃ¢y..." : "ÄÃ£ táº¡m dá»«ng"}
      </p>
    </div>
  );
}

export default AutoIncrementCounter;
```

**Káº¿t quáº£ vÃ­ dá»¥:**

```
// Ban Ä‘áº§u: count = 0, nÃºt Start enable
Click Start â†’ count tÄƒng: 1 â†’ 2 â†’ 3... má»—i giÃ¢y

Click Pause â†’ dá»«ng á»Ÿ vÃ­ dá»¥ 7
Click Start láº¡i â†’ tiáº¿p tá»¥c tá»« 8 â†’ 9...

Click Reset â†’ count vá» 0, tá»± Ä‘á»™ng pause
```

</details>

---

### NÃ¢ng cao (60 phÃºt)

**BÃ i 3: Scroll Progress Indicator**

```jsx
/**
 * Táº¡o component hiá»ƒn thá»‹ % trang Ä‘Ã£ scroll:
 * - Progress bar á»Ÿ top mÃ n hÃ¬nh
 * - Update real-time khi scroll
 * - Smooth animation
 *
 * Requirements:
 * - Calculate scroll percentage
 * - useEffect vá»›i scroll listener
 * - Throttle updates (má»—i 100ms)
 * - Dependencies: []
 *
 * Challenges:
 * - Throttle function implementation
 * - Fixed position progress bar
 * - Cleanup scroll listener
 * - Calculate: (scrollTop / (scrollHeight - clientHeight)) * 100
 */
```

<details><summary>ğŸ’¡ Solution - BÃ i 3: Scroll Progress Indicator (NÃ¢ng cao)</summary>

```jsx
/**
 * ScrollProgressBar - BÃ i táº­p vá» nhÃ  3 (nÃ¢ng cao)
 * Thanh tiáº¿n trÃ¬nh scroll á»Ÿ Ä‘áº§u trang
 * Cáº­p nháº­t mÆ°á»£t mÃ  khi scroll
 * Throttle Ä‘á»ƒ khÃ´ng cáº­p nháº­t quÃ¡ thÆ°á»ng xuyÃªn
 */
import { useState, useEffect } from "react";

function ScrollProgressBar() {
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    let timeoutId = null;

    const updateProgress = () => {
      const scrollTop = window.scrollY;
      const docHeight = document.documentElement.scrollHeight;
      const winHeight = window.innerHeight;

      const scrollable = docHeight - winHeight;
      const percentage =
        scrollable > 0 ? Math.min((scrollTop / scrollable) * 100, 100) : 0;

      setProgress(percentage);
    };

    const throttledUpdate = () => {
      if (timeoutId) return;
      timeoutId = setTimeout(() => {
        updateProgress();
        timeoutId = null;
      }, 100); // throttle 100ms
    };

    window.addEventListener("scroll", throttledUpdate);
    window.addEventListener("resize", throttledUpdate); // cÅ©ng update khi resize

    // Initial call
    updateProgress();

    return () => {
      window.removeEventListener("scroll", throttledUpdate);
      window.removeEventListener("resize", throttledUpdate);
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, []);

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        height: "4px",
        background: "#1976d2",
        transform: `scaleX(${progress / 100})`,
        transformOrigin: "left",
        transition: "transform 0.15s ease-out",
        zIndex: 9999,
      }}
    />
  );
}

// Äá»ƒ test: thÃªm ná»™i dung dÃ i vÃ o trang
function ScrollTestPage() {
  return (
    <div style={{ padding: "20px", minHeight: "300vh" }}>
      <ScrollProgressBar />
      <h1>Scroll xuá»‘ng Ä‘á»ƒ xem thanh tiáº¿n trÃ¬nh</h1>
      <p style={{ height: "200vh" }}>Ná»™i dung ráº¥t dÃ i Ä‘á»ƒ cÃ³ thá»ƒ scroll...</p>
      <p>Cuá»‘i trang</p>
    </div>
  );
}

export default ScrollTestPage;
```

**Káº¿t quáº£ vÃ­ dá»¥:**

```
// Scroll xuá»‘ng 25% trang â†’ thanh mÃ u xanh kÃ©o dÃ i 25% tá»« trÃ¡i sang
// Scroll lÃªn Ä‘áº§u â†’ thanh co vá» 0%
// Scroll xuá»‘ng cuá»‘i â†’ thanh full 100%
// Di chuyá»ƒn mÆ°á»£t, khÃ´ng giáº­t lag nhá» throttle
```

</details>

**BÃ i 4: Form vá»›i Validation Dependencies**

```jsx
/**
 * Táº¡o signup form vá»›i validation:
 * - Fields: username, email, password, confirmPassword
 * - useEffect Ä‘á»ƒ validate khi specific fields thay Ä‘á»•i
 * - Show errors immediately
 *
 * Requirements:
 * - Effect 1: Validate email khi email thay Ä‘á»•i
 * - Effect 2: Check passwords match khi password hoáº·c confirmPassword thay Ä‘á»•i
 * - Effect 3: Check username availability (fake async)
 * - Dependencies chÃ­nh xÃ¡c cho má»—i effect
 *
 * Challenges:
 * - Multiple effects vá»›i different deps
 * - Async validation (setTimeout)
 * - Cleanup Ä‘á»ƒ cancel pending checks
 * - Debounce username check
 */
```

<details><summary>ğŸ’¡ Solution - BÃ i 4: Form vá»›i Validation Dependencies</summary>

```jsx
/**
 * SignupFormWithValidation - BÃ i táº­p vá» nhÃ  4 (nÃ¢ng cao)
 *
 * YÃªu cáº§u:
 * - CÃ¡c field: username, email, password, confirmPassword
 * - Validation theo tá»«ng field / nhÃ³m field báº±ng useEffect vá»›i dependencies phÃ¹ há»£p
 * - Hiá»ƒn thá»‹ lá»—i ngay láº­p tá»©c khi field thay Ä‘á»•i (real-time validation)
 * - Username availability check giáº£ láº­p (async vá»›i setTimeout)
 * - Password match check khi password hoáº·c confirmPassword thay Ä‘á»•i
 * - Debounce username check Ä‘á»ƒ trÃ¡nh gá»i quÃ¡ nhiá»u
 */
import { useState, useEffect } from "react";

function SignupFormWithValidation() {
  const [form, setForm] = useState({
    username: "",
    email: "",
    password: "",
    confirmPassword: "",
  });

  const [errors, setErrors] = useState({
    username: "",
    email: "",
    password: "",
    confirmPassword: "",
  });

  const [isCheckingUsername, setIsCheckingUsername] = useState(false);
  const [usernameAvailable, setUsernameAvailable] = useState(null);

  // Helper: cáº­p nháº­t field vÃ  clear lá»—i liÃªn quan
  const updateField = (field, value) => {
    setForm((prev) => ({ ...prev, [field]: value }));
    // Clear lá»—i cá»§a field nÃ y ngay khi ngÆ°á»i dÃ¹ng gÃµ
    setErrors((prev) => ({ ...prev, [field]: "" }));
    // Reset username availability khi username thay Ä‘á»•i
    if (field === "username") {
      setUsernameAvailable(null);
    }
  };

  // Effect 1: Validate email real-time khi email thay Ä‘á»•i
  useEffect(() => {
    if (!form.email) {
      setErrors((prev) => ({ ...prev, email: "Email lÃ  báº¯t buá»™c" }));
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(form.email)) {
      setErrors((prev) => ({ ...prev, email: "Email khÃ´ng há»£p lá»‡" }));
    } else {
      setErrors((prev) => ({ ...prev, email: "" }));
    }
  }, [form.email]);

  // Effect 2: Kiá»ƒm tra password & confirmPassword match
  useEffect(() => {
    if (!form.password && !form.confirmPassword) {
      setErrors((prev) => ({
        ...prev,
        password: "",
        confirmPassword: "",
      }));
      return;
    }

    if (form.password && form.password.length < 6) {
      setErrors((prev) => ({
        ...prev,
        password: "Máº­t kháº©u pháº£i cÃ³ Ã­t nháº¥t 6 kÃ½ tá»±",
      }));
    } else {
      setErrors((prev) => ({ ...prev, password: "" }));
    }

    if (form.confirmPassword && form.password !== form.confirmPassword) {
      setErrors((prev) => ({
        ...prev,
        confirmPassword: "Máº­t kháº©u xÃ¡c nháº­n khÃ´ng khá»›p",
      }));
    } else if (form.confirmPassword) {
      setErrors((prev) => ({ ...prev, confirmPassword: "" }));
    }
  }, [form.password, form.confirmPassword]);

  // Effect 3: Debounce + check username availability (giáº£ láº­p async)
  useEffect(() => {
    if (!form.username || form.username.length < 3) {
      setUsernameAvailable(null);
      setErrors((prev) => ({
        ...prev,
        username: form.username
          ? "TÃªn ngÆ°á»i dÃ¹ng pháº£i â‰¥ 3 kÃ½ tá»±"
          : "TÃªn ngÆ°á»i dÃ¹ng lÃ  báº¯t buá»™c",
      }));
      return;
    }

    // Clear lá»—i cÅ© trÆ°á»›c khi check
    setErrors((prev) => ({ ...prev, username: "" }));
    setIsCheckingUsername(true);

    const timer = setTimeout(() => {
      // Giáº£ láº­p API check username (random 70% available)
      const isAvailable = Math.random() > 0.3;
      setUsernameAvailable(isAvailable);

      if (!isAvailable) {
        setErrors((prev) => ({
          ...prev,
          username: "TÃªn ngÆ°á»i dÃ¹ng Ä‘Ã£ Ä‘Æ°á»£c sá»­ dá»¥ng",
        }));
      } else {
        setErrors((prev) => ({ ...prev, username: "" }));
      }
      setIsCheckingUsername(false);
    }, 800); // debounce 800ms

    return () => {
      clearTimeout(timer);
      setIsCheckingUsername(false);
    };
  }, [form.username]);

  const isFormValid =
    !errors.username &&
    !errors.email &&
    !errors.password &&
    !errors.confirmPassword &&
    usernameAvailable === true &&
    form.username &&
    form.email &&
    form.password &&
    form.confirmPassword;

  const handleSubmit = (e) => {
    e.preventDefault();
    if (isFormValid) {
      alert("ÄÄƒng kÃ½ thÃ nh cÃ´ng!\n" + JSON.stringify(form, null, 2));
      // Reset form náº¿u muá»‘n
      setForm({ username: "", email: "", password: "", confirmPassword: "" });
      setUsernameAvailable(null);
    } else {
      alert("Vui lÃ²ng sá»­a cÃ¡c lá»—i trÆ°á»›c khi gá»­i.");
    }
  };

  return (
    <div style={{ maxWidth: "420px", margin: "40px auto", padding: "20px" }}>
      <h2>ÄÄƒng kÃ½ tÃ i khoáº£n</h2>

      <form onSubmit={handleSubmit}>
        <div style={{ marginBottom: "20px" }}>
          <label>TÃªn ngÆ°á»i dÃ¹ng</label>
          <input
            type="text"
            value={form.username}
            onChange={(e) => updateField("username", e.target.value)}
            placeholder="Ã­t nháº¥t 3 kÃ½ tá»±"
            style={{ width: "100%", padding: "10px", marginTop: "6px" }}
          />
          {errors.username && (
            <div
              style={{ color: "#d32f2f", fontSize: "14px", marginTop: "4px" }}
            >
              {errors.username}
            </div>
          )}
          {isCheckingUsername && (
            <div
              style={{ color: "#1976d2", fontSize: "14px", marginTop: "4px" }}
            >
              Äang kiá»ƒm tra tÃªn ngÆ°á»i dÃ¹ng...
            </div>
          )}
          {usernameAvailable === true && (
            <div
              style={{ color: "#388e3c", fontSize: "14px", marginTop: "4px" }}
            >
              TÃªn ngÆ°á»i dÃ¹ng cÃ³ sáºµn âœ“
            </div>
          )}
        </div>

        <div style={{ marginBottom: "20px" }}>
          <label>Email</label>
          <input
            type="email"
            value={form.email}
            onChange={(e) => updateField("email", e.target.value)}
            placeholder="example@domain.com"
            style={{ width: "100%", padding: "10px", marginTop: "6px" }}
          />
          {errors.email && (
            <div
              style={{ color: "#d32f2f", fontSize: "14px", marginTop: "4px" }}
            >
              {errors.email}
            </div>
          )}
        </div>

        <div style={{ marginBottom: "20px" }}>
          <label>Máº­t kháº©u</label>
          <input
            type="password"
            value={form.password}
            onChange={(e) => updateField("password", e.target.value)}
            placeholder="Tá»‘i thiá»ƒu 6 kÃ½ tá»±"
            style={{ width: "100%", padding: "10px", marginTop: "6px" }}
          />
          {errors.password && (
            <div
              style={{ color: "#d32f2f", fontSize: "14px", marginTop: "4px" }}
            >
              {errors.password}
            </div>
          )}
        </div>

        <div style={{ marginBottom: "28px" }}>
          <label>XÃ¡c nháº­n máº­t kháº©u</label>
          <input
            type="password"
            value={form.confirmPassword}
            onChange={(e) => updateField("confirmPassword", e.target.value)}
            placeholder="Nháº­p láº¡i máº­t kháº©u"
            style={{ width: "100%", padding: "10px", marginTop: "6px" }}
          />
          {errors.confirmPassword && (
            <div
              style={{ color: "#d32f2f", fontSize: "14px", marginTop: "4px" }}
            >
              {errors.confirmPassword}
            </div>
          )}
        </div>

        <button
          type="submit"
          disabled={!isFormValid}
          style={{
            width: "100%",
            padding: "12px",
            background: isFormValid ? "#1976d2" : "#90caf9",
            color: "white",
            border: "none",
            borderRadius: "6px",
            fontSize: "16px",
            cursor: isFormValid ? "pointer" : "not-allowed",
          }}
        >
          ÄÄƒng kÃ½
        </button>
      </form>

      <div style={{ marginTop: "24px", fontSize: "13px", color: "#555" }}>
        <strong>Validation theo dependencies:</strong>
        <br />
        â€¢ Email: useEffect([email])
        <br />
        â€¢ Password match: useEffect([password, confirmPassword])
        <br />â€¢ Username check (debounced): useEffect([username])
      </div>
    </div>
  );
}

export default SignupFormWithValidation;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi tÆ°Æ¡ng tÃ¡c:**

```
// GÃµ username "abc" â†’ sau ~800ms: "TÃªn ngÆ°á»i dÃ¹ng cÃ³ sáºµn âœ“" (hoáº·c "Ä‘Ã£ Ä‘Æ°á»£c sá»­ dá»¥ng")
// GÃµ username < 3 kÃ½ tá»± â†’ lá»—i ngay láº­p tá»©c
// GÃµ email khÃ´ng há»£p lá»‡ â†’ lá»—i "Email khÃ´ng há»£p lá»‡"
// GÃµ password 123 â†’ lá»—i "Máº­t kháº©u pháº£i cÃ³ Ã­t nháº¥t 6 kÃ½ tá»±"
// GÃµ confirmPassword khÃ¡c password â†’ lá»—i "Máº­t kháº©u xÃ¡c nháº­n khÃ´ng khá»›p"
// Khi táº¥t cáº£ há»£p lá»‡ + username available â†’ nÃºt ÄÄƒng kÃ½ sÃ¡ng lÃªn, cÃ³ thá»ƒ submit
```

</details>

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - useEffect Dependencies**
   - https://react.dev/reference/react/useEffect#specifying-reactive-dependencies
   - Äá»c ká»¹ pháº§n Dependencies
   - Hiá»ƒu Object.is() comparison

2. **Separating Events from Effects**
   - https://react.dev/learn/separating-events-from-effects
   - Khi nÃ o dÃ¹ng effect vs event handler
   - Dependency optimization

### Äá»c thÃªm

3. **A Complete Guide to useEffect** (Dan Abramov) - Part 2 -https://overreacted.io/a-complete-guide-to-useeffect/
   - Äá»c pháº§n vá» Dependencies
   - Stale Closure explained

4. **ESLint Plugin React Hooks**
   - https://www.npmjs.com/package/eslint-plugin-react-hooks
   - Hiá»ƒu exhaustive-deps rule
   - When to disable (rarely!)

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (Ä‘Ã£ há»c):

- **NgÃ y 16:** useEffect Introduction
  - ÄÃ£ há»c: Effect basic, timing, no deps
  - Káº¿t ná»‘i: HÃ´m nay há»c dependencies Ä‘á»ƒ kiá»ƒm soÃ¡t

- **NgÃ y 11-12:** useState patterns
  - ÄÃ£ há»c: Functional updates
  - Káº¿t ná»‘i: DÃ¹ng Ä‘á»ƒ fix stale closures

### HÆ°á»›ng tá»›i (sáº½ há»c):

- **NgÃ y 18:** Cleanup & Memory Leaks
  - Sáº½ há»c: Return cleanup function chi tiáº¿t
  - Sáº½ há»c: Event listeners, subscriptions cleanup
  - Dependencies + Cleanup = Complete picture

- **NgÃ y 28:** useMemo & useCallback
  - Sáº½ há»c: Optimize object/array dependencies
  - Sáº½ há»c: Memoization for performance
  - Sáº½ há»c: Stable references

- **NgÃ y 24:** Custom Hooks
  - Sáº½ há»c: Extract effect logic
  - Sáº½ há»c: Reusable patterns (useDebounce, useThrottle)

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. ESLint Rule - Your Best Friend:**

```jsx
// âŒ Äá»ªNG disable rule lightly
useEffect(() => {
  doSomething(value);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []); // â† Dangerous!

// âœ… Náº¿u thá»±c sá»± cáº§n, explain WHY
useEffect(() => {
  // We only want this to run once on mount,
  // even though it uses `value`.
  // `value` is guaranteed to be stable from props.
  doSomething(value);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []); // Intentionally empty - value is stable
```

**2. Dependencies Anti-patterns:**

```jsx
// âŒ BAD: Inline object
useEffect(() => {
  api.fetch({ userId: user.id });
}, [{ userId: user.id }]); // New object every render!

// âœ… GOOD: Primitive values
useEffect(() => {
  api.fetch({ userId: user.id });
}, [user.id]); // Primitive comparison

// âŒ BAD: Inline function
useEffect(() => {
  handler();
}, [() => handler()]); // New function every render!

// âœ… GOOD: Stable function (useCallback - NgÃ y 30)
// Hoáº·c define outside component náº¿u pure function
```

**3. Debugging Dependencies:**

```jsx
useEffect(() => {
  console.log("Effect ran");
  console.log("Dependencies:", { a, b, c });

  // Log previous values (advanced - needs useRef)
  // NgÃ y 21 sáº½ há»c cÃ¡ch implement
}, [a, b, c]);
```

---

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

1. **Q:** Dependencies array lÃ m gÃ¬?
   **A:** Cho React biáº¿t KHI NÃ€O cáº§n cháº¡y láº¡i effect. Effect chá»‰ re-run khi má»™t trong cÃ¡c dependencies thay Ä‘á»•i (so sÃ¡nh báº±ng Object.is).

2. **Q:** KhÃ¡c biá»‡t giá»¯a `[]` vÃ  khÃ´ng cÃ³ deps?
   **A:**
   - KhÃ´ng cÃ³ deps: Effect cháº¡y sau Má»–I render
   - Empty `[]`: Effect chá»‰ cháº¡y 1 Láº¦N sau mount
   - `[a, b]`: Effect cháº¡y khi a hoáº·c b thay Ä‘á»•i

3. **Q:** Stale closure lÃ  gÃ¬?
   **A:** Khi effect capture giÃ¡ trá»‹ cÅ© tá»« closure vÃ  khÃ´ng update khi state thay Ä‘á»•i. Fix báº±ng cÃ¡ch: (1) Add to deps, (2) Functional updates, (3) useRef.

**Mid Level:**

4. **Q:** Táº¡i sao object trong deps gÃ¢y re-run liÃªn tá»¥c?
   **A:** React so sÃ¡nh deps báº±ng Object.is() (===). Objects/arrays luÃ´n cÃ³ reference má»›i má»—i render, nÃªn luÃ´n "khÃ¡c" â†’ Effect re-runs.

5. **Q:** Khi nÃ o dÃ¹ng derived state vs useEffect?
   **A:**
   - Derived state: Khi value cÃ³ thá»ƒ tÃ­nh trá»±c tiáº¿p tá»« state/props
   - useEffect: Khi cáº§n side effect (DOM, API, timers, etc.)
   - Rule: Náº¿u khÃ´ng cÃ³ side effect â†’ Äá»«ng dÃ¹ng effect!

**Senior Level:**

6. **Q:** LÃ m sao optimize effect vá»›i object dependencies?
   **A:**
   - Extract primitive values: `[user.id]` thay vÃ¬ `[user]`
   - useMemo Ä‘á»ƒ stabilize objects (NgÃ y 28)
   - Custom comparison vá»›i useRef (advanced)
   - Restructure state Ä‘á»ƒ avoid objects

7. **Q:** Debug strategy cho effect dependency issues?
   **A:**
   - Log deps trong effect Ä‘á»ƒ track changes
   - React DevTools Profiler Ä‘á»ƒ see re-renders
   - Check ESLint warnings carefully
   - Use strict mode Ä‘á»ƒ catch issues
   - Implement useWhyDidYouUpdate custom hook

---

### War Stories

**Story #1: The Infinite Loop Production Bug ğŸ”¥**

> "Launch ngÃ y Ä‘áº§u, user complain app freeze. Debug tháº¥y effect vá»›i `[filteredData]` deps, mÃ  trong effect láº¡i setFilteredData. Filter táº¡o array má»›i â†’ Infinite loop. Fix báº±ng cÃ¡ch remove filteredData khá»i deps vÃ  dÃ¹ng derived state. BÃ i há»c: Output cá»§a effect KHÃ”NG BAO GIá»œ náº±m trong deps!"

**Story #2: Stale Closure in Chat App ğŸ’¬**

> "Chat app cÃ³ interval send 'typing...' indicator. DÃ¹ng `useEffect(() => setInterval(...), [])` vá»›i empty deps. Bug: Indicator luÃ´n hiá»ƒn thá»‹ user cÅ©, khÃ´ng update khi switch chat. Stale closure! Username Ä‘Æ°á»£c capture lÃºc mount. Fix: DÃ¹ng `[chatId]` deps Ä‘á»ƒ recreate interval, hoáº·c useRef. Trade-off: Performance vs correctness."

**Story #3: ESLint Disabled = Technical Debt ğŸ“‰**

> "Inherited codebase vá»›i 50+ `eslint-disable` cho exhaustive-deps. Má»—i effect Ä‘á»u cÃ³ subtle bugs. Spend 2 weeks refactor, fix táº¥t cáº£ deps properly. Discover 10+ bugs chÆ°a report. Lesson: ESLint rule exists for a reason - respect it!"

---

## ğŸ¯ NGÃ€Y MAI: Cleanup & Memory Leaks

Preview nhá»¯ng gÃ¬ báº¡n sáº½ há»c:

### Cleanup Function

- Return function trong effect
- Khi nÃ o cleanup cháº¡y
- Cleanup timers, listeners, subscriptions

### Memory Leaks Prevention

- Identify memory leaks
- Cleanup patterns
- Async operations cleanup
- AbortController preview

### Advanced Cleanup

- Multiple effects cleanup
- Cleanup dependencies
- Race conditions

**ğŸ”¥ Chuáº©n bá»‹:**

- Ã”n láº¡i event listeners (addEventListener, removeEventListener)
- Hiá»ƒu setInterval/setTimeout cleanup
- LÃ m xong bÃ i táº­p hÃ´m nay (especially window resize)

---

**ğŸ‰ ChÃºc má»«ng! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 17!**

Báº¡n Ä‘Ã£:

- âœ… Master Ä‘Æ°á»£c Dependencies Array
- âœ… Hiá»ƒu 3 patterns: no deps, empty [], specific deps
- âœ… Fix Ä‘Æ°á»£c Stale Closure bugs
- âœ… Biáº¿t optimize dependencies
- âœ… Ãp dá»¥ng Ä‘Æ°á»£c vÃ o real-world scenarios (debounce, auto-save, validation)

**Dependencies lÃ  chÃ¬a khÃ³a Ä‘á»ƒ lÃ m chá»§ useEffect. Báº¡n Ä‘Ã£ má»Ÿ khÃ³a thÃ nh cÃ´ng! ğŸš€**

**NgÃ y 18 sáº½ complete bá»©c tranh vá»›i Cleanup - missing piece cuá»‘i cÃ¹ng!**
