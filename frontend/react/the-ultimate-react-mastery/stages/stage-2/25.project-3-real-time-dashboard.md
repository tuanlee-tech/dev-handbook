# ğŸ“… NGÃ€Y 25: âš¡ Project 3 - Real-time Dashboard

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] TÃ­ch há»£p táº¥t cáº£ hooks Ä‘Ã£ há»c vÃ o má»™t project hoÃ n chá»‰nh
- [ ] Build production-ready dashboard vá»›i real-time data
- [ ] Implement custom hooks Ä‘á»ƒ organize code logic
- [ ] Handle complex state interactions vÃ  data flow
- [ ] Apply best practices vá» performance vÃ  UX
- [ ] Debug vÃ  optimize React applications
- [ ] Hiá»ƒu cÃ¡ch structure má»™t medium-sized React app

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, review nhanh nhá»¯ng gÃ¬ Ä‘Ã£ há»c:

1. **useState**: Manage component state âœ…
2. **useEffect**: Side effects, data fetching, subscriptions âœ…
3. **useRef**: Mutable values, DOM access, previous values âœ…
4. **useLayoutEffect**: Synchronous DOM measurements âœ…
5. **Custom Hooks**: Extract vÃ  reuse logic âœ…

**HÃ´m nay:** ChÃºng ta sáº½ **combine Táº¤T Cáº¢** Ä‘á»ƒ build real-world dashboard! ğŸš€

---

## ğŸ“– PHáº¦N 1: PROJECT OVERVIEW (15 phÃºt)

### 1.1 Project Specification

**ğŸ“Š Crypto Dashboard - Real-time Cryptocurrency Tracker**

Má»™t dashboard theo dÃµi giÃ¡ cryptocurrency real-time vá»›i cÃ¡c features:

#### Core Features:

1. **Real-time Data Fetching**
   - Fetch crypto prices tá»« API
   - Auto-refresh every 30 seconds
   - Manual refresh button

2. **Search & Filtering**
   - Search cryptocurrencies by name
   - Debounced search (500ms)
   - Filter by price change (gainers/losers)

3. **Data Comparison**
   - Compare current vs previous prices
   - Show price change percentage
   - Visual indicators (up/down arrows)

4. **Advanced UX**
   - Loading states with skeleton screens
   - Error handling with retry
   - Empty states
   - Responsive design

5. **Performance**
   - Optimized re-renders
   - Efficient data updates
   - Smooth animations

### 1.2 Tech Stack

```
React Hooks:
â”œâ”€â”€ useState - UI state management
â”œâ”€â”€ useEffect - Data fetching & auto-refresh
â”œâ”€â”€ useRef - Previous values, timers, abort controllers
â”œâ”€â”€ useLayoutEffect - Smooth animations (optional)
â””â”€â”€ Custom Hooks - Reusable logic

APIs:
â””â”€â”€ CoinGecko API (free, no auth required)

Styling:
â””â”€â”€ Inline styles (focus on logic, not CSS)
```

### 1.3 Architecture Overview

```
CryptoDashboard (Main Component)
â”‚
â”œâ”€â”€ Custom Hooks
â”‚   â”œâ”€â”€ useFetch - Generic data fetching
â”‚   â”œâ”€â”€ useDebounce - Search debouncing
â”‚   â”œâ”€â”€ usePrevious - Previous value tracking
â”‚   â””â”€â”€ useAutoRefresh - Auto-refresh logic
â”‚
â”œâ”€â”€ Components
â”‚   â”œâ”€â”€ Header - Title, manual refresh, stats
â”‚   â”œâ”€â”€ SearchBar - Search input vá»›i debounce
â”‚   â”œâ”€â”€ FilterControls - Filter buttons
â”‚   â”œâ”€â”€ CryptoList - List of crypto cards
â”‚   â”œâ”€â”€ CryptoCard - Individual crypto item
â”‚   â”œâ”€â”€ LoadingSkeleton - Loading state
â”‚   â””â”€â”€ ErrorMessage - Error state
â”‚
â””â”€â”€ Utils
    â”œâ”€â”€ api.js - API calls
    â””â”€â”€ helpers.js - Formatting functions
```

### 1.4 File Structure

```
src/
â”œâ”€â”€ App.jsx (Main Dashboard)
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useFetch.js
â”‚   â”œâ”€â”€ useDebounce.js
â”‚   â”œâ”€â”€ usePrevious.js
â”‚   â””â”€â”€ useAutoRefresh.js
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Header.jsx
â”‚   â”œâ”€â”€ SearchBar.jsx
â”‚   â”œâ”€â”€ FilterControls.jsx
â”‚   â”œâ”€â”€ CryptoList.jsx
â”‚   â”œâ”€â”€ CryptoCard.jsx
â”‚   â”œâ”€â”€ LoadingSkeleton.jsx
â”‚   â””â”€â”€ ErrorMessage.jsx
â””â”€â”€ utils/
    â”œâ”€â”€ api.js
    â””â”€â”€ helpers.js
```

---

## ğŸ’» PHáº¦N 2: IMPLEMENTATION (90 phÃºt)

### Step 1: Custom Hooks (30 phÃºt)

#### useFetch.js - Generic Data Fetching Hook

```jsx
// hooks/useFetch.js
import { useState, useEffect, useRef, useCallback } from 'react';

/**
 * Generic data fetching hook vá»›i advanced features
 *
 * @param {Function} fetchFn - Async function to fetch data
 * @param {Object} options - Configuration options
 * @returns {Object} { data, loading, error, refetch }
 */
export function useFetch(fetchFn, options = {}) {
  const { immediate = true, onSuccess, onError, dependencies = [] } = options;

  const [state, setState] = useState({
    data: null,
    loading: immediate,
    error: null,
  });

  const abortControllerRef = useRef(null);
  const isMountedRef = useRef(true);

  // Execute fetch function
  const execute = useCallback(async () => {
    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }

    // Create new abort controller
    abortControllerRef.current = new AbortController();

    setState((prev) => ({ ...prev, loading: true, error: null }));

    try {
      const data = await fetchFn(abortControllerRef.current.signal);

      if (isMountedRef.current) {
        setState({ data, loading: false, error: null });
        onSuccess?.(data);
      }
    } catch (error) {
      if (error.name === 'AbortError') {
        // Request was cancelled - this is ok
        return;
      }

      if (isMountedRef.current) {
        setState({ data: null, loading: false, error });
        onError?.(error);
      }
    }
  }, [fetchFn, onSuccess, onError]);

  // Auto-execute on mount if immediate
  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [immediate, execute, ...dependencies]);

  // Cleanup
  useEffect(() => {
    return () => {
      isMountedRef.current = false;
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  return {
    ...state,
    refetch: execute,
  };
}
```

#### useDebounce.js - Debounce Hook

```jsx
// hooks/useDebounce.js
import { useState, useEffect } from 'react';

/**
 * Debounce a value
 *
 * @param {any} value - Value to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {any} Debounced value
 */
export function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
```

#### usePrevious.js - Previous Value Hook

```jsx
// hooks/usePrevious.js
import { useRef, useEffect } from 'react';

/**
 * Track previous value of state/prop
 *
 * @param {any} value - Current value
 * @returns {any} Previous value
 */
export function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}
```

#### useAutoRefresh.js - Auto Refresh Hook

```jsx
// hooks/useAutoRefresh.js
import { useEffect, useRef } from 'react';

/**
 * Auto-refresh data at specified interval
 *
 * @param {Function} callback - Function to call on refresh
 * @param {number} interval - Interval in milliseconds
 * @param {boolean} enabled - Whether auto-refresh is enabled
 */
export function useAutoRefresh(callback, interval, enabled = true) {
  const callbackRef = useRef(callback);
  const intervalRef = useRef(null);

  // Keep callback ref updated
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  useEffect(() => {
    if (!enabled) return;

    // Start interval
    intervalRef.current = setInterval(() => {
      callbackRef.current();
    }, interval);

    // Cleanup
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [interval, enabled]);

  // Manual cleanup on unmount
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);
}
```

### Step 2: Utility Functions (15 phÃºt)

#### api.js - API Integration

```jsx
// utils/api.js

const API_BASE = 'https://api.coingecko.com/api/v3';

/**
 * Fetch top cryptocurrencies
 *
 * @param {AbortSignal} signal - Abort signal for cancellation
 * @returns {Promise<Array>} Array of crypto data
 */
export async function fetchCryptos(signal) {
  const response = await fetch(
    `${API_BASE}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false&price_change_percentage=24h`,
    { signal },
  );

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data = await response.json();

  // Transform API data to our format
  return data.map((coin) => ({
    id: coin.id,
    name: coin.name,
    symbol: coin.symbol.toUpperCase(),
    price: coin.current_price,
    priceChange24h: coin.price_change_percentage_24h,
    marketCap: coin.market_cap,
    volume24h: coin.total_volume,
    image: coin.image,
    rank: coin.market_cap_rank,
  }));
}
```

#### helpers.js - Helper Functions

```jsx
// utils/helpers.js

/**
 * Format price to USD
 */
export function formatPrice(price) {
  if (price >= 1) {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(price);
  } else {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 6,
    }).format(price);
  }
}

/**
 * Format large numbers (market cap, volume)
 */
export function formatLargeNumber(num) {
  if (num >= 1e12) {
    return `$${(num / 1e12).toFixed(2)}T`;
  }
  if (num >= 1e9) {
    return `$${(num / 1e9).toFixed(2)}B`;
  }
  if (num >= 1e6) {
    return `$${(num / 1e6).toFixed(2)}M`;
  }
  return `$${num.toFixed(2)}`;
}

/**
 * Format percentage change
 */
export function formatPercentage(percentage) {
  const sign = percentage >= 0 ? '+' : '';
  return `${sign}${percentage.toFixed(2)}%`;
}

/**
 * Get color for price change
 */
export function getPriceChangeColor(change) {
  if (change > 0) return '#00C853'; // Green
  if (change < 0) return '#FF1744'; // Red
  return '#666'; // Gray
}

/**
 * Calculate percentage difference
 */
export function calculatePercentDiff(current, previous) {
  if (!previous) return 0;
  return ((current - previous) / previous) * 100;
}
```

### Step 3: Components (45 phÃºt)

#### LoadingSkeleton.jsx

```jsx
// components/LoadingSkeleton.jsx
import React from 'react';

export function LoadingSkeleton() {
  return (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
        gap: '20px',
        padding: '20px',
      }}
    >
      {Array.from({ length: 6 }).map((_, index) => (
        <div
          key={index}
          style={{
            backgroundColor: '#f5f5f5',
            borderRadius: '12px',
            padding: '20px',
            animation: 'pulse 1.5s ease-in-out infinite',
          }}
        >
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '12px',
              marginBottom: '15px',
            }}
          >
            <div
              style={{
                width: '40px',
                height: '40px',
                backgroundColor: '#e0e0e0',
                borderRadius: '50%',
              }}
            />
            <div style={{ flex: 1 }}>
              <div
                style={{
                  height: '16px',
                  backgroundColor: '#e0e0e0',
                  borderRadius: '4px',
                  marginBottom: '8px',
                  width: '60%',
                }}
              />
              <div
                style={{
                  height: '12px',
                  backgroundColor: '#e0e0e0',
                  borderRadius: '4px',
                  width: '40%',
                }}
              />
            </div>
          </div>

          <div
            style={{
              height: '24px',
              backgroundColor: '#e0e0e0',
              borderRadius: '4px',
              marginBottom: '10px',
              width: '80%',
            }}
          />

          <div
            style={{
              height: '16px',
              backgroundColor: '#e0e0e0',
              borderRadius: '4px',
              width: '50%',
            }}
          />
        </div>
      ))}

      <style>{`
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.5; }
        }
      `}</style>
    </div>
  );
}
```

#### ErrorMessage.jsx

```jsx
// components/ErrorMessage.jsx
import React from 'react';

export function ErrorMessage({ error, onRetry }) {
  return (
    <div
      style={{
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '60px 20px',
        textAlign: 'center',
      }}
    >
      <div
        style={{
          fontSize: '64px',
          marginBottom: '20px',
        }}
      >
        âš ï¸
      </div>

      <h2
        style={{
          margin: '0 0 10px 0',
          color: '#FF1744',
          fontSize: '24px',
        }}
      >
        Oops! Something went wrong
      </h2>

      <p
        style={{
          margin: '0 0 20px 0',
          color: '#666',
          maxWidth: '400px',
        }}
      >
        {error?.message ||
          'Failed to fetch cryptocurrency data. Please try again.'}
      </p>

      <button
        onClick={onRetry}
        style={{
          padding: '12px 24px',
          backgroundColor: '#2196F3',
          color: 'white',
          border: 'none',
          borderRadius: '8px',
          fontSize: '16px',
          cursor: 'pointer',
          fontWeight: '600',
          transition: 'background-color 0.2s',
        }}
        onMouseEnter={(e) => (e.target.style.backgroundColor = '#1976D2')}
        onMouseLeave={(e) => (e.target.style.backgroundColor = '#2196F3')}
      >
        ğŸ”„ Try Again
      </button>
    </div>
  );
}
```

#### SearchBar.jsx

```jsx
// components/SearchBar.jsx
import React from 'react';

export function SearchBar({ value, onChange, resultsCount }) {
  return (
    <div
      style={{
        position: 'relative',
        maxWidth: '400px',
        width: '100%',
      }}
    >
      <div style={{ position: 'relative' }}>
        <span
          style={{
            position: 'absolute',
            left: '15px',
            top: '50%',
            transform: 'translateY(-50%)',
            fontSize: '20px',
          }}
        >
          ğŸ”
        </span>

        <input
          type='text'
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder='Search cryptocurrencies...'
          style={{
            width: '100%',
            padding: '12px 15px 12px 50px',
            fontSize: '16px',
            border: '2px solid #e0e0e0',
            borderRadius: '12px',
            outline: 'none',
            transition: 'border-color 0.2s',
            fontFamily: 'inherit',
          }}
          onFocus={(e) => (e.target.style.borderColor = '#2196F3')}
          onBlur={(e) => (e.target.style.borderColor = '#e0e0e0')}
        />
      </div>

      {value && (
        <div
          style={{
            marginTop: '8px',
            fontSize: '14px',
            color: '#666',
          }}
        >
          Found {resultsCount} {resultsCount === 1 ? 'result' : 'results'}
        </div>
      )}
    </div>
  );
}
```

#### FilterControls.jsx

```jsx
// components/FilterControls.jsx
import React from 'react';

export function FilterControls({ activeFilter, onFilterChange }) {
  const filters = [
    { id: 'all', label: 'All', icon: 'ğŸ“Š' },
    { id: 'gainers', label: 'Gainers', icon: 'ğŸ“ˆ' },
    { id: 'losers', label: 'Losers', icon: 'ğŸ“‰' },
  ];

  return (
    <div
      style={{
        display: 'flex',
        gap: '10px',
        flexWrap: 'wrap',
      }}
    >
      {filters.map((filter) => (
        <button
          key={filter.id}
          onClick={() => onFilterChange(filter.id)}
          style={{
            padding: '10px 20px',
            backgroundColor: activeFilter === filter.id ? '#2196F3' : 'white',
            color: activeFilter === filter.id ? 'white' : '#333',
            border: activeFilter === filter.id ? 'none' : '2px solid #e0e0e0',
            borderRadius: '8px',
            fontSize: '14px',
            fontWeight: '600',
            cursor: 'pointer',
            transition: 'all 0.2s',
            display: 'flex',
            alignItems: 'center',
            gap: '6px',
          }}
          onMouseEnter={(e) => {
            if (activeFilter !== filter.id) {
              e.target.style.borderColor = '#2196F3';
            }
          }}
          onMouseLeave={(e) => {
            if (activeFilter !== filter.id) {
              e.target.style.borderColor = '#e0e0e0';
            }
          }}
        >
          <span>{filter.icon}</span>
          {filter.label}
        </button>
      ))}
    </div>
  );
}
```

#### CryptoCard.jsx

```jsx
// components/CryptoCard.jsx
import React from 'react';
import { usePrevious } from '../hooks/usePrevious';
import {
  formatPrice,
  formatLargeNumber,
  formatPercentage,
  getPriceChangeColor,
  calculatePercentDiff,
} from '../utils/helpers';

export function CryptoCard({ crypto }) {
  const previousPrice = usePrevious(crypto.price);
  const isPriceUp = previousPrice && crypto.price > previousPrice;
  const isPriceDown = previousPrice && crypto.price < previousPrice;
  const priceChangeColor = getPriceChangeColor(crypto.priceChange24h);

  return (
    <div
      style={{
        backgroundColor: 'white',
        borderRadius: '12px',
        padding: '20px',
        boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        transition: 'all 0.3s ease',
        position: 'relative',
        overflow: 'hidden',
      }}
      onMouseEnter={(e) => {
        e.currentTarget.style.boxShadow = '0 4px 16px rgba(0,0,0,0.15)';
        e.currentTarget.style.transform = 'translateY(-2px)';
      }}
      onMouseLeave={(e) => {
        e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
        e.currentTarget.style.transform = 'translateY(0)';
      }}
    >
      {/* Price change flash animation */}
      {(isPriceUp || isPriceDown) && (
        <div
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: isPriceUp
              ? 'rgba(0, 200, 83, 0.1)'
              : 'rgba(255, 23, 68, 0.1)',
            animation: 'flash 0.5s ease-out',
            pointerEvents: 'none',
          }}
        />
      )}

      {/* Header */}
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '12px',
          marginBottom: '15px',
        }}
      >
        <img
          src={crypto.image}
          alt={crypto.name}
          style={{
            width: '40px',
            height: '40px',
            borderRadius: '50%',
          }}
        />
        <div style={{ flex: 1 }}>
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
            }}
          >
            <h3
              style={{
                margin: 0,
                fontSize: '18px',
                fontWeight: '700',
              }}
            >
              {crypto.name}
            </h3>
            <span
              style={{
                fontSize: '12px',
                color: '#999',
                fontWeight: '600',
              }}
            >
              #{crypto.rank}
            </span>
          </div>
          <div
            style={{
              fontSize: '14px',
              color: '#666',
              fontWeight: '600',
            }}
          >
            {crypto.symbol}
          </div>
        </div>
      </div>

      {/* Price */}
      <div
        style={{
          fontSize: '28px',
          fontWeight: '700',
          marginBottom: '10px',
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
        }}
      >
        {formatPrice(crypto.price)}
        {isPriceUp && <span style={{ fontSize: '20px' }}>ğŸ“ˆ</span>}
        {isPriceDown && <span style={{ fontSize: '20px' }}>ğŸ“‰</span>}
      </div>

      {/* 24h Change */}
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          gap: '6px',
          marginBottom: '15px',
        }}
      >
        <span
          style={{
            fontSize: '16px',
            fontWeight: '600',
            color: priceChangeColor,
          }}
        >
          {crypto.priceChange24h >= 0 ? 'â–²' : 'â–¼'}
        </span>
        <span
          style={{
            fontSize: '16px',
            fontWeight: '600',
            color: priceChangeColor,
          }}
        >
          {formatPercentage(crypto.priceChange24h)}
        </span>
        <span
          style={{
            fontSize: '14px',
            color: '#999',
          }}
        >
          24h
        </span>
      </div>

      {/* Previous Price Comparison */}
      {previousPrice && previousPrice !== crypto.price && (
        <div
          style={{
            fontSize: '12px',
            color: '#666',
            marginBottom: '15px',
            padding: '8px',
            backgroundColor: '#f5f5f5',
            borderRadius: '6px',
          }}
        >
          Previous: {formatPrice(previousPrice)}
          <span
            style={{
              marginLeft: '8px',
              color: isPriceUp ? '#00C853' : '#FF1744',
              fontWeight: '600',
            }}
          >
            (
            {formatPercentage(
              calculatePercentDiff(crypto.price, previousPrice),
            )}
            )
          </span>
        </div>
      )}

      {/* Stats */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: '1fr 1fr',
          gap: '12px',
          paddingTop: '15px',
          borderTop: '1px solid #f0f0f0',
        }}
      >
        <div>
          <div
            style={{
              fontSize: '12px',
              color: '#999',
              marginBottom: '4px',
            }}
          >
            Market Cap
          </div>
          <div
            style={{
              fontSize: '14px',
              fontWeight: '600',
            }}
          >
            {formatLargeNumber(crypto.marketCap)}
          </div>
        </div>

        <div>
          <div
            style={{
              fontSize: '12px',
              color: '#999',
              marginBottom: '4px',
            }}
          >
            24h Volume
          </div>
          <div
            style={{
              fontSize: '14px',
              fontWeight: '600',
            }}
          >
            {formatLargeNumber(crypto.volume24h)}
          </div>
        </div>
      </div>

      <style>{`
        @keyframes flash {
          0% { opacity: 1; }
          50% { opacity: 0.5; }
          100% { opacity: 0; }
        }
      `}</style>
    </div>
  );
}
```

#### CryptoList.jsx

```jsx
// components/CryptoList.jsx
import React from 'react';
import { CryptoCard } from './CryptoCard';

export function CryptoList({ cryptos }) {
  if (cryptos.length === 0) {
    return (
      <div
        style={{
          textAlign: 'center',
          padding: '60px 20px',
          color: '#666',
        }}
      >
        <div style={{ fontSize: '64px', marginBottom: '20px' }}>ğŸ”</div>
        <h3 style={{ margin: '0 0 10px 0', fontSize: '20px' }}>
          No cryptocurrencies found
        </h3>
        <p style={{ margin: 0 }}>Try adjusting your search or filters</p>
      </div>
    );
  }

  return (
    <div
      style={{
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(320px, 1fr))',
        gap: '20px',
        padding: '20px',
      }}
    >
      {cryptos.map((crypto) => (
        <CryptoCard
          key={crypto.id}
          crypto={crypto}
        />
      ))}
    </div>
  );
}
```

#### Header.jsx

```jsx
// components/Header.jsx
import React from 'react';

export function Header({
  onRefresh,
  isRefreshing,
  lastUpdate,
  totalCryptos,
  autoRefreshEnabled,
  onToggleAutoRefresh,
}) {
  return (
    <div
      style={{
        backgroundColor: 'white',
        borderBottom: '2px solid #f0f0f0',
        padding: '20px',
        position: 'sticky',
        top: 0,
        zIndex: 100,
        boxShadow: '0 2px 8px rgba(0,0,0,0.05)',
      }}
    >
      <div
        style={{
          maxWidth: '1400px',
          margin: '0 auto',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          flexWrap: 'wrap',
          gap: '20px',
        }}
      >
        {/* Logo & Title */}
        <div>
          <h1
            style={{
              margin: '0 0 5px 0',
              fontSize: '28px',
              fontWeight: '700',
              display: 'flex',
              alignItems: 'center',
              gap: '10px',
            }}
          >
            <span style={{ fontSize: '32px' }}>â‚¿</span>
            Crypto Dashboard
          </h1>
          <div
            style={{
              fontSize: '14px',
              color: '#666',
            }}
          >
            Real-time cryptocurrency tracker
          </div>
        </div>

        {/* Stats & Controls */}
        <div
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: '20px',
            flexWrap: 'wrap',
          }}
        >
          {/* Total Cryptos */}
          <div
            style={{
              padding: '8px 16px',
              backgroundColor: '#f5f5f5',
              borderRadius: '8px',
              fontSize: '14px',
              fontWeight: '600',
            }}
          >
            ğŸ“Š {totalCryptos} Cryptos
          </div>

          {/* Last Update */}
          {lastUpdate && (
            <div
              style={{
                fontSize: '14px',
                color: '#666',
              }}
            >
              ğŸ• Updated {lastUpdate}
            </div>
          )}

          {/* Auto-refresh Toggle */}
          <button
            onClick={onToggleAutoRefresh}
            style={{
              padding: '8px 16px',
              backgroundColor: autoRefreshEnabled ? '#00C853' : '#e0e0e0',
              color: autoRefreshEnabled ? 'white' : '#666',
              border: 'none',
              borderRadius: '8px',
              fontSize: '14px',
              fontWeight: '600',
              cursor: 'pointer',
              transition: 'all 0.2s',
              display: 'flex',
              alignItems: 'center',
              gap: '6px',
            }}
          >
            <span>{autoRefreshEnabled ? 'â¸' : 'â–¶'}</span>
            Auto-refresh {autoRefreshEnabled ? 'ON' : 'OFF'}
          </button>

          {/* Manual Refresh */}
          <button
            onClick={onRefresh}
            disabled={isRefreshing}
            style={{
              padding: '10px 20px',
              backgroundColor: '#2196F3',
              color: 'white',
              border: 'none',
              borderRadius: '8px',
              fontSize: '16px',
              fontWeight: '600',
              cursor: isRefreshing ? 'not-allowed' : 'pointer',
              opacity: isRefreshing ? 0.6 : 1,
              transition: 'all 0.2s',
              display: 'flex',
              alignItems: 'center',
              gap: '8px',
            }}
            onMouseEnter={(e) => {
              if (!isRefreshing) {
                e.target.style.backgroundColor = '#1976D2';
              }
            }}
            onMouseLeave={(e) => {
              e.target.style.backgroundColor = '#2196F3';
            }}
          >
            <span
              style={{
                display: 'inline-block',
                animation: isRefreshing ? 'spin 1s linear infinite' : 'none',
              }}
            >
              ğŸ”„
            </span>
            {isRefreshing ? 'Refreshing...' : 'Refresh'}
          </button>
        </div>
      </div>

      <style>{`
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
      `}</style>
    </div>
  );
}
```

### Step 4: Main Dashboard Component (30 phÃºt)

#### App.jsx - Main Component

```jsx
// App.jsx
import React, { useState, useMemo } from 'react';
import { useFetch } from './hooks/useFetch';
import { useDebounce } from './hooks/useDebounce';
import { useAutoRefresh } from './hooks/useAutoRefresh';
import { fetchCryptos } from './utils/api';
import { Header } from './components/Header';
import { SearchBar } from './components/SearchBar';
import { FilterControls } from './components/FilterControls';
import { CryptoList } from './components/CryptoList';
import { LoadingSkeleton } from './components/LoadingSkeleton';
import { ErrorMessage } from './components/ErrorMessage';

function App() {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // STATE MANAGEMENT
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const [searchQuery, setSearchQuery] = useState('');
  const [activeFilter, setActiveFilter] = useState('all');
  const [autoRefreshEnabled, setAutoRefreshEnabled] = useState(true);
  const [lastUpdateTime, setLastUpdateTime] = useState(null);

  // Debounce search query
  const debouncedSearch = useDebounce(searchQuery, 500);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DATA FETCHING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const {
    data: cryptos,
    loading,
    error,
    refetch,
  } = useFetch(fetchCryptos, {
    immediate: true,
    onSuccess: () => {
      setLastUpdateTime(getRelativeTime(new Date()));
    },
  });

  // Auto-refresh every 30 seconds
  useAutoRefresh(
    () => {
      refetch();
    },
    30000, // 30 seconds
    autoRefreshEnabled,
  );

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DATA FILTERING & PROCESSING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const filteredCryptos = useMemo(() => {
    if (!cryptos) return [];

    let filtered = cryptos;

    // Apply search filter
    if (debouncedSearch) {
      const query = debouncedSearch.toLowerCase();
      filtered = filtered.filter(
        (crypto) =>
          crypto.name.toLowerCase().includes(query) ||
          crypto.symbol.toLowerCase().includes(query),
      );
    }

    // Apply price change filter
    if (activeFilter === 'gainers') {
      filtered = filtered.filter((crypto) => crypto.priceChange24h > 0);
    } else if (activeFilter === 'losers') {
      filtered = filtered.filter((crypto) => crypto.priceChange24h < 0);
    }

    return filtered;
  }, [cryptos, debouncedSearch, activeFilter]);

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // EVENT HANDLERS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  const handleManualRefresh = () => {
    refetch();
  };

  const handleToggleAutoRefresh = () => {
    setAutoRefreshEnabled((prev) => !prev);
  };

  const handleSearchChange = (value) => {
    setSearchQuery(value);
  };

  const handleFilterChange = (filter) => {
    setActiveFilter(filter);
  };

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RENDER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  return (
    <div
      style={{
        minHeight: '100vh',
        backgroundColor: '#f5f7fa',
        fontFamily:
          '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
      }}
    >
      {/* Header */}
      <Header
        onRefresh={handleManualRefresh}
        isRefreshing={loading}
        lastUpdate={lastUpdateTime}
        totalCryptos={cryptos?.length || 0}
        autoRefreshEnabled={autoRefreshEnabled}
        onToggleAutoRefresh={handleToggleAutoRefresh}
      />

      {/* Controls */}
      <div
        style={{
          maxWidth: '1400px',
          margin: '0 auto',
          padding: '20px',
        }}
      >
        <div
          style={{
            display: 'flex',
            gap: '20px',
            flexWrap: 'wrap',
            marginBottom: '20px',
            alignItems: 'center',
            justifyContent: 'space-between',
          }}
        >
          <SearchBar
            value={searchQuery}
            onChange={handleSearchChange}
            resultsCount={filteredCryptos.length}
          />

          <FilterControls
            activeFilter={activeFilter}
            onFilterChange={handleFilterChange}
          />
        </div>
      </div>

      {/* Content */}
      <div
        style={{
          maxWidth: '1400px',
          margin: '0 auto',
        }}
      >
        {loading && !cryptos && <LoadingSkeleton />}

        {error && (
          <ErrorMessage
            error={error}
            onRetry={handleManualRefresh}
          />
        )}

        {!loading && !error && cryptos && (
          <CryptoList cryptos={filteredCryptos} />
        )}
      </div>
    </div>
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function getRelativeTime(date) {
  const now = new Date();
  const diffInSeconds = Math.floor((now - date) / 1000);

  if (diffInSeconds < 60) {
    return 'just now';
  }

  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes} min ago`;
  }

  const diffInHours = Math.floor(diffInMinutes / 60);
  return `${diffInHours} hour${diffInHours > 1 ? 's' : ''} ago`;
}

export default App;
```

---

## ğŸ”¨ PHáº¦N 3: ENHANCEMENTS & OPTIMIZATIONS (30 phÃºt)

### Enhancement 1: Add Sorting

```jsx
// Add to App.jsx

const [sortBy, setSortBy] = useState('rank'); // 'rank' | 'price' | 'change'
const [sortOrder, setSortOrder] = useState('asc'); // 'asc' | 'desc'

// Update filteredCryptos to include sorting
const filteredAndSortedCryptos = useMemo(() => {
  let result = [...filteredCryptos];

  result.sort((a, b) => {
    let aValue, bValue;

    switch (sortBy) {
      case 'price':
        aValue = a.price;
        bValue = b.price;
        break;
      case 'change':
        aValue = a.priceChange24h;
        bValue = b.priceChange24h;
        break;
      case 'rank':
      default:
        aValue = a.rank;
        bValue = b.rank;
    }

    if (sortOrder === 'asc') {
      return aValue - bValue;
    } else {
      return bValue - aValue;
    }
  });

  return result;
}, [filteredCryptos, sortBy, sortOrder]);

// Add SortControls component
function SortControls({ sortBy, sortOrder, onSortChange }) {
  const options = [
    { value: 'rank', label: 'Rank' },
    { value: 'price', label: 'Price' },
    { value: 'change', label: '24h Change' },
  ];

  return (
    <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
      <span style={{ fontSize: '14px', color: '#666', fontWeight: '600' }}>
        Sort by:
      </span>
      {options.map((option) => (
        <button
          key={option.value}
          onClick={() => onSortChange(option.value)}
          style={{
            padding: '8px 16px',
            backgroundColor: sortBy === option.value ? '#2196F3' : 'white',
            color: sortBy === option.value ? 'white' : '#333',
            border: sortBy === option.value ? 'none' : '2px solid #e0e0e0',
            borderRadius: '8px',
            fontSize: '14px',
            fontWeight: '600',
            cursor: 'pointer',
          }}
        >
          {option.label}
          {sortBy === option.value && (
            <span style={{ marginLeft: '4px' }}>
              {sortOrder === 'asc' ? 'â†‘' : 'â†“'}
            </span>
          )}
        </button>
      ))}
    </div>
  );
}
```

### Enhancement 2: Add Price Alerts

```jsx
// hooks/usePriceAlert.js
import { useEffect, useRef } from 'react';

export function usePriceAlert(cryptos, previousCryptos) {
  const hasAlerted = useRef(new Set());

  useEffect(() => {
    if (!cryptos || !previousCryptos) return;

    cryptos.forEach((crypto) => {
      const previous = previousCryptos.find((p) => p.id === crypto.id);
      if (!previous) return;

      const percentChange = Math.abs(
        ((crypto.price - previous.price) / previous.price) * 100,
      );

      // Alert if price changed more than 5%
      if (percentChange > 5 && !hasAlerted.current.has(crypto.id)) {
        const direction =
          crypto.price > previous.price ? 'increased' : 'decreased';

        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification(`${crypto.symbol} Price Alert`, {
            body: `${crypto.name} has ${direction} by ${percentChange.toFixed(2)}%`,
            icon: crypto.image,
          });
        }

        hasAlerted.current.add(crypto.id);

        // Reset after 5 minutes
        setTimeout(
          () => {
            hasAlerted.current.delete(crypto.id);
          },
          5 * 60 * 1000,
        );
      }
    });
  }, [cryptos, previousCryptos]);
}

// Request notification permission
useEffect(() => {
  if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
  }
}, []);
```

### Enhancement 3: Add Chart Preview

```jsx
// components/MiniChart.jsx
import React from 'react';

export function MiniChart({ data, color }) {
  if (!data || data.length === 0) return null;

  const max = Math.max(...data);
  const min = Math.min(...data);
  const range = max - min;

  const points = data
    .map((value, index) => {
      const x = (index / (data.length - 1)) * 100;
      const y = 100 - ((value - min) / range) * 100;
      return `${x},${y}`;
    })
    .join(' ');

  return (
    <svg
      width='100'
      height='30'
      viewBox='0 0 100 100'
      preserveAspectRatio='none'
      style={{ display: 'block' }}
    >
      <polyline
        points={points}
        fill='none'
        stroke={color}
        strokeWidth='3'
        strokeLinecap='round'
        strokeLinejoin='round'
      />
    </svg>
  );
}
```

---

## ğŸ“Š PHáº¦N 4: TESTING & DEBUGGING (15 phÃºt)

### Testing Checklist

```jsx
// Manual Testing Checklist:

âœ… Data Fetching:
- [ ] Initial load shows loading skeleton
- [ ] Data loads successfully
- [ ] Error shows error message with retry
- [ ] Retry button works

âœ… Auto-refresh:
- [ ] Data refreshes every 30 seconds
- [ ] Toggle button works
- [ ] Manual refresh works
- [ ] No duplicate requests

âœ… Search:
- [ ] Search updates results
- [ ] Debounce works (no lag)
- [ ] Result count accurate
- [ ] Clear search resets

âœ… Filtering:
- [ ] All filter shows everything
- [ ] Gainers shows only positive changes
- [ ] Losers shows only negative changes
- [ ] Filters combine with search

âœ… Price Comparison:
- [ ] Previous price shows after update
- [ ] Percentage change calculates correctly
- [ ] Flash animation works
- [ ] Arrows show correctly

âœ… UI/UX:
- [ ] Loading states smooth
- [ ] Hover effects work
- [ ] Responsive layout
- [ ] No console errors
```

### Common Bugs & Fixes

```jsx
// Bug 1: Memory leak from interval
// âŒ Problem: Interval not cleared on unmount
useEffect(() => {
  const interval = setInterval(refetch, 30000);
  // Missing cleanup!
}, []);

// âœ… Solution:
useEffect(() => {
  const interval = setInterval(refetch, 30000);
  return () => clearInterval(interval);
}, [refetch]);

// Bug 2: Stale search results
// âŒ Problem: Search doesn't update when data changes
const filtered = cryptos.filter((c) => c.name.includes(search));

// âœ… Solution: Use useMemo
const filtered = useMemo(() => {
  return cryptos.filter((c) => c.name.includes(debouncedSearch));
}, [cryptos, debouncedSearch]);

// Bug 3: Race condition
// âŒ Problem: Old requests complete after new ones
useEffect(() => {
  fetch(url).then(setData);
}, [url]);

// âœ… Solution: AbortController
useEffect(() => {
  const controller = new AbortController();
  fetch(url, { signal: controller.signal }).then(setData);
  return () => controller.abort();
}, [url]);
```

---

## âœ… PHáº¦N 5: DEPLOYMENT & PRODUCTION (10 phÃºt)

### Production Checklist

```jsx
// âœ… Performance:
- [ ] Memoize expensive calculations
- [ ] Debounce user inputs
- [ ] Cancel in-flight requests
- [ ] Lazy load images
- [ ] Minimize re-renders

// âœ… Error Handling:
- [ ] Network errors caught
- [ ] API errors handled
- [ ] User-friendly messages
- [ ] Retry mechanisms

// âœ… Accessibility:
- [ ] Keyboard navigation
- [ ] Screen reader support
- [ ] Focus management
- [ ] ARIA labels

// âœ… SEO:
- [ ] Meta tags
- [ ] Semantic HTML
- [ ] Page title
- [ ] Structured data

// âœ… Security:
- [ ] No API keys exposed
- [ ] HTTPS only
- [ ] Input validation
- [ ] XSS prevention
```

### Environment Variables

```jsx
// .env
REACT_APP_API_BASE_URL=https://api.coingecko.com/api/v3
REACT_APP_REFRESH_INTERVAL=30000
REACT_APP_ENABLE_NOTIFICATIONS=true

// Use in code:
const API_BASE = process.env.REACT_APP_API_BASE_URL;
const REFRESH_INTERVAL = parseInt(process.env.REACT_APP_REFRESH_INTERVAL);
```

---

## ğŸ¯ BÃ€I Táº¬P Má» Rá»˜NG (Optional)

### Exercise 1: Add Favorites

```jsx
// Requirements:
// - Star/unstar cryptocurrencies
// - Save to localStorage
// - Filter to show only favorites
// - Persist across sessions

// Hints:
// - useLocalStorage hook
// - Toggle favorite state
// - Filter favorites in useMemo
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook Ä‘á»ƒ quáº£n lÃ½ danh sÃ¡ch favorites lÆ°u trong localStorage
 * @returns {{
 *   favorites: string[],
 *   toggleFavorite: (coinId: string) => void,
 *   isFavorite: (coinId: string) => boolean
 * }}
 */
export function useFavorites() {
  const [favorites, setFavorites] = React.useState(() => {
    try {
      const saved = localStorage.getItem('crypto_favorites');
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  });

  React.useEffect(() => {
    try {
      localStorage.setItem('crypto_favorites', JSON.stringify(favorites));
    } catch (err) {
      console.warn('KhÃ´ng thá»ƒ lÆ°u favorites vÃ o localStorage', err);
    }
  }, [favorites]);

  const toggleFavorite = React.useCallback((coinId) => {
    setFavorites((prev) =>
      prev.includes(coinId)
        ? prev.filter((id) => id !== coinId)
        : [...prev, coinId],
    );
  }, []);

  const isFavorite = React.useCallback(
    (coinId) => {
      return favorites.includes(coinId);
    },
    [favorites],
  );

  return {
    favorites,
    toggleFavorite,
    isFavorite,
  };
}
```

```jsx
// components/FavoriteButton.jsx
/**
 * NÃºt toggle favorite cho má»—i coin
 * @param {{
 *   coinId: string,
 *   isFavorite: boolean,
 *   onToggle: (coinId: string) => void
 * }} props
 */
export function FavoriteButton({ coinId, isFavorite, onToggle }) {
  return (
    <button
      onClick={(e) => {
        e.stopPropagation();
        onToggle(coinId);
      }}
      title={isFavorite ? 'Remove from favorites' : 'Add to favorites'}
      style={{
        background: 'none',
        border: 'none',
        fontSize: '20px',
        cursor: 'pointer',
        padding: '4px',
        transition: 'transform 0.2s',
      }}
    >
      {isFavorite ? 'â­' : 'â˜†'}
    </button>
  );
}
```

```jsx
// Trong CryptoCard.jsx - thÃªm pháº§n favorite
// (thÃªm vÃ o Ä‘áº§u card, vÃ­ dá»¥ ngay sau áº£nh coin)

<div
  style={{
    display: 'flex',
    alignItems: 'center',
    gap: '12px',
    marginBottom: '15px',
  }}
>
  <img
    src={crypto.image}
    alt={crypto.name}
    style={{ width: '40px', height: '40px', borderRadius: '50%' }}
  />

  <div style={{ flex: 1 }}>{/* ... tÃªn + symbol + rank ... */}</div>

  {/* ThÃªm nÃºt favorite */}
  <FavoriteButton
    coinId={crypto.id}
    isFavorite={isFavorite(crypto.id)}
    onToggle={toggleFavorite}
  />
</div>
```

```jsx
// Trong App.jsx - thÃªm state vÃ  filter favorites

function App() {
  const [showOnlyFavorites, setShowOnlyFavorites] = useState(false);

  const {
    favorites,
    toggleFavorite,
    isFavorite
  } = useFavorites();

  // ... cÃ¡c state khÃ¡c ...

  const filteredCryptos = useMemo(() => {
    if (!cryptos) return [];

    let result = cryptos;

    // Favorites filter
    if (showOnlyFavorites) {
      result = result.filter(crypto => favorites.includes(crypto.id));
    }

    // Search
    if (debouncedSearch) {
      const query = debouncedSearch.toLowerCase();
      result = result.filter(
        crypto =>
          crypto.name.toLowerCase().includes(query) ||
          crypto.symbol.toLowerCase().includes(query)
      );
    }

    // Gainers/Losers filter
    if (activeFilter === 'gainers') {
      result = result.filter(c => c.priceChange24h > 0);
    } else if (activeFilter === 'losers') {
      result = result.filter(c => c.priceChange24h < 0);
    }

    return result;
  }, [
    cryptos,
    debouncedSearch,
    activeFilter,
    showOnlyFavorites,
    favorites
  ]);

  // ThÃªm nÃºt toggle favorites vÃ o pháº§n controls (cÃ¹ng vá»›i SearchBar & FilterControls)
  // VÃ­ dá»¥:
  <div style={{ display: 'flex', gap: '16px', alignItems: 'center', flexWrap: 'wrap' }}>
    <SearchBar ... />

    <FilterControls ... />

    <button
      onClick={() => setShowOnlyFavorites(prev => !prev)}
      style={{
        padding: '10px 16px',
        backgroundColor: showOnlyFavorites ? '#FFD700' : '#f0f0f0',
        border: 'none',
        borderRadius: '8px',
        fontWeight: '600',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        gap: '6px',
      }}
    >
      â­ Favorites {showOnlyFavorites ? 'ON' : 'OFF'}
    </button>
  </div>

  // Truyá»n props xuá»‘ng CryptoCard
  <CryptoList
    cryptos={filteredCryptos}
    // Náº¿u báº¡n muá»‘n truyá»n isFavorite & toggleFavorite cho tá»«ng card
    // CÃ¡ch 1: truyá»n hÃ m xuá»‘ng CryptoList rá»“i xuá»‘ng CryptoCard
    // CÃ¡ch 2 (khuyáº¿n nghá»‹ Ä‘Æ¡n giáº£n): dÃ¹ng context hoáº·c Ä‘á»ƒ CryptoCard dÃ¹ng hook trá»±c tiáº¿p
  />
}
```

**CÃ¡ch triá»ƒn khai phá»• biáº¿n nháº¥t (khuyáº¿n nghá»‹ cho bÃ i nÃ y):**

DÃ¹ng `useFavorites()` trá»±c tiáº¿p trong `CryptoCard` thay vÃ¬ truyá»n props xuá»‘ng nhiá»u táº§ng.

```jsx
// Trong CryptoCard.jsx
export function CryptoCard({ crypto }) {
  const { isFavorite, toggleFavorite } = useFavorites();

  // ... render nhÆ° cÅ© ...

  // ThÃªm nÃºt favorite vÃ o layout
  <div style={{ position: 'absolute', top: '16px', right: '16px' }}>
    <FavoriteButton
      coinId={crypto.id}
      isFavorite={isFavorite(crypto.id)}
      onToggle={toggleFavorite}
    />
  </div>;

  // ... pháº§n cÃ²n láº¡i ...
}
```

**Káº¿t quáº£ vÃ­ dá»¥:**

- Ban Ä‘áº§u: táº¥t cáº£ coin cÃ³ biá»ƒu tÆ°á»£ng ngÃ´i sao rá»—ng â˜†
- Nháº¥n vÃ o ngÃ´i sao cá»§a Bitcoin â†’ chuyá»ƒn thÃ nh â­ + lÆ°u id "bitcoin" vÃ o localStorage
- Báº­t nÃºt "Favorites ON" â†’ chá»‰ cÃ²n cÃ¡c coin Ä‘Ã£ Ä‘Æ°á»£c Ä‘Ã¡nh dáº¥u ngÃ´i sao
- Refresh trang â†’ favorites váº«n Ä‘Æ°á»£c giá»¯ nguyÃªn
- Nháº¥n láº¡i ngÃ´i sao â†’ bá» khá»i danh sÃ¡ch favorites

</details>

### Exercise 2: Add Price History Chart

```jsx
// Requirements:
// - Fetch historical data
// - Display line chart
// - Multiple timeframes (24h, 7d, 30d)
// - Interactive tooltip

// Hints:
// - Use Chart.js or Recharts
// - Separate API endpoint
// - Cache historical data
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Hook Ä‘á»ƒ láº¥y dá»¯ liá»‡u lá»‹ch sá»­ giÃ¡ cá»§a má»™t coin tá»« CoinGecko
 * @param {string} coinId - ID cá»§a coin (vÃ­ dá»¥: "bitcoin", "ethereum")
 * @param {string} days - Sá»‘ ngÃ y lá»‹ch sá»­ ("1", "7", "14", "30", "90", "180", "365", "max")
 * @returns {{
 *   history: Array<{time: number, price: number}>,
 *   loading: boolean,
 *   error: Error|null,
 *   refetch: () => void
 * }}
 */
export function usePriceHistory(coinId, days = '7') {
  const fetchHistory = useCallback(
    async (signal) => {
      if (!coinId) return [];

      const url = `https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=${days}&interval=daily&precision=2`;

      const response = await fetch(url, { signal });

      if (!response.ok) {
        throw new Error(`CoinGecko history error: ${response.status}`);
      }

      const data = await response.json();

      // prices: [[timestamp_ms, price], ...]
      return data.prices.map(([timestamp, price]) => ({
        time: timestamp / 1000, // chuyá»ƒn sang unix seconds cho biá»ƒu Ä‘á»“
        price: Number(price.toFixed(4)), // giá»¯ 4 chá»¯ sá»‘ tháº­p phÃ¢n
      }));
    },
    [coinId, days],
  );

  const { data, loading, error, refetch } = useFetch(fetchHistory, {
    immediate: !!coinId,
    dependencies: [coinId, days],
  });

  return {
    history: data || [],
    loading,
    error,
    refetch,
  };
}
```

```jsx
// components/MiniPriceChart.jsx
/**
 * Biá»ƒu Ä‘á»“ Ä‘Æ°á»ng Ä‘Æ¡n giáº£n hiá»ƒn thá»‹ lá»‹ch sá»­ giÃ¡ (khÃ´ng cáº§n thÆ° viá»‡n bÃªn ngoÃ i)
 * @param {{
 *   data: Array<{time: number, price: number}>,
 *   color?: string,
 *   height?: number,
 *   width?: number
 * }} props
 */
export function MiniPriceChart({
  data,
  color = '#2196F3',
  height = 80,
  width = '100%',
}) {
  if (!data || data.length < 2) {
    return (
      <div
        style={{
          height,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: '#999',
          fontSize: '14px',
        }}
      >
        Not enough data
      </div>
    );
  }

  const prices = data.map((d) => d.price);
  const minPrice = Math.min(...prices);
  const maxPrice = Math.max(...prices);
  const range = maxPrice - minPrice || 1;

  // Chuáº©n hÃ³a thÃ nh % tá»« 0-100
  const points = data
    .map((point, i) => {
      const x = (i / (data.length - 1)) * 100;
      const normalized = ((point.price - minPrice) / range) * 90 + 5; // margin 5%
      return `${x},${100 - normalized}`;
    })
    .join(' ');

  const latestPrice = data[data.length - 1]?.price;
  const firstPrice = data[0]?.price;
  const changePercent = firstPrice
    ? ((latestPrice - firstPrice) / firstPrice) * 100
    : 0;

  const isPositive = changePercent >= 0;

  return (
    <div style={{ position: 'relative', width, height }}>
      <svg
        width='100%'
        height='100%'
        viewBox='0 0 100 100'
        preserveAspectRatio='none'
        style={{ overflow: 'visible' }}
      >
        {/* Gradient ná»n dÆ°á»›i Ä‘Æ°á»ng */}
        <defs>
          <linearGradient
            id='gradient'
            x1='0%'
            y1='0%'
            x2='0%'
            y2='100%'
          >
            <stop
              offset='0%'
              stopColor={color}
              stopOpacity='0.25'
            />
            <stop
              offset='100%'
              stopColor={color}
              stopOpacity='0'
            />
          </linearGradient>
        </defs>

        {/* ÄÆ°á»ng ná»n gradient */}
        <polyline
          points={`0,100 ${points} 100,100`}
          fill='url(#gradient)'
          stroke='none'
        />

        {/* ÄÆ°á»ng chÃ­nh */}
        <polyline
          points={points}
          fill='none'
          stroke={color}
          strokeWidth='2.5'
          strokeLinecap='round'
          strokeLinejoin='round'
        />
      </svg>

      {/* Thay Ä‘á»•i % á»Ÿ gÃ³c */}
      <div
        style={{
          position: 'absolute',
          top: 4,
          right: 8,
          fontSize: '12px',
          fontWeight: 'bold',
          color: isPositive ? '#00C853' : '#FF1744',
          background: 'rgba(255,255,255,0.85)',
          padding: '2px 6px',
          borderRadius: '4px',
        }}
      >
        {changePercent >= 0 ? '+' : ''}
        {changePercent.toFixed(1)}%
      </div>
    </div>
  );
}
```

```jsx
// Trong CryptoCard.jsx - thÃªm biá»ƒu Ä‘á»“ nhá»
export function CryptoCard({ crypto }) {
  const { history, loading: chartLoading } = usePriceHistory(crypto.id, '7');

  // ... pháº§n render hiá»‡n táº¡i ...

  // ThÃªm vÃ o pháº§n dÆ°á»›i stats hoáº·c thay tháº¿ má»™t pháº§n
  <div
    style={{
      marginTop: '16px',
      borderTop: '1px solid #f0f0f0',
      paddingTop: '12px',
    }}
  >
    <div
      style={{
        fontSize: '13px',
        color: '#666',
        marginBottom: '6px',
        display: 'flex',
        justifyContent: 'space-between',
      }}
    >
      <span>7-day price history</span>
      {chartLoading && <span style={{ color: '#999' }}>Loading...</span>}
    </div>

    <MiniPriceChart
      data={history}
      color={crypto.priceChange24h >= 0 ? '#00C853' : '#FF1744'}
      height={70}
    />
  </div>;

  // ... pháº§n cÃ²n láº¡i cá»§a card ...
}
```

```jsx
// Bonus: CÃ¡ch thÃªm nÃºt chá»n timeframe (trong CryptoCard hoáº·c component riÃªng)
function TimeframeSelector({ value, onChange }) {
  const options = [
    { label: '24h', value: '1' },
    { label: '7d', value: '7' },
    { label: '14d', value: '14' },
    { label: '30d', value: '30' },
    { label: '90d', value: '90' },
  ];

  return (
    <div
      style={{
        display: 'flex',
        gap: '6px',
        marginBottom: '8px',
        flexWrap: 'wrap',
      }}
    >
      {options.map((opt) => (
        <button
          key={opt.value}
          onClick={() => onChange(opt.value)}
          style={{
            padding: '4px 10px',
            fontSize: '12px',
            background: value === opt.value ? '#2196F3' : '#f0f0f0',
            color: value === opt.value ? 'white' : '#333',
            border: 'none',
            borderRadius: '6px',
            cursor: 'pointer',
          }}
        >
          {opt.label}
        </button>
      ))}
    </div>
  );
}

// Sá»­ dá»¥ng trong CryptoCard:
const [timeframe, setTimeframe] = React.useState('7');
const { history } = usePriceHistory(crypto.id, timeframe);

// <TimeframeSelector value={timeframe} onChange={setTimeframe} />
```

**Káº¿t quáº£ vÃ­ dá»¥:**

- Má»—i CryptoCard hiá»ƒn thá»‹ biá»ƒu Ä‘á»“ Ä‘Æ°á»ng nhá» gá»n thá»ƒ hiá»‡n 7 ngÃ y giÃ¡ gáº§n nháº¥t
- MÃ u Ä‘Æ°á»ng biá»ƒu Ä‘á»“ khá»›p vá»›i xu hÆ°á»›ng 24h (xanh náº¿u tÄƒng, Ä‘á» náº¿u giáº£m)
- CÃ³ hiá»ƒn thá»‹ % thay Ä‘á»•i trong khoáº£ng thá»i gian Ä‘Æ°á»£c chá»n
- KhÃ´ng phá»¥ thuá»™c thÆ° viá»‡n chart bÃªn ngoÃ i â†’ nháº¹, nhanh
- Khi hover card â†’ cÃ³ thá»ƒ tháº¥y animation nháº¹ (náº¿u thÃªm CSS transition)
- Khi thay Ä‘á»•i timeframe (náº¿u thÃªm selector) â†’ biá»ƒu Ä‘á»“ tá»± Ä‘á»™ng cáº­p nháº­t

</details>

### Exercise 3: Add Portfolio Tracker

```jsx
// Requirements:
// - Add holdings (coin + amount)
// - Calculate total value
// - Show profit/loss
// - Persist in localStorage

// Hints:
// - Array of holdings
// - Calculate value based on current prices
// - Update on price changes
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook Ä‘á»ƒ quáº£n lÃ½ portfolio (danh sÃ¡ch coin Ä‘ang sá»Ÿ há»¯u)
 * LÆ°u trá»¯ trong localStorage
 * @returns {{
 *   holdings: Array<{coinId: string, amount: number, note?: string}>,
 *   addHolding: (coinId: string, amount: number, note?: string) => void,
 *   updateHolding: (coinId: string, amount: number) => void,
 *   removeHolding: (coinId: string) => void,
 *   hasHolding: (coinId: string) => boolean,
 *   getHoldingAmount: (coinId: string) => number
 * }}
 */
export function usePortfolio() {
  const [holdings, setHoldings] = React.useState(() => {
    try {
      const saved = localStorage.getItem('crypto_portfolio');
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  });

  React.useEffect(() => {
    try {
      localStorage.setItem('crypto_portfolio', JSON.stringify(holdings));
    } catch (err) {
      console.warn('Failed to save portfolio', err);
    }
  }, [holdings]);

  const addHolding = React.useCallback((coinId, amount, note = '') => {
    if (amount <= 0) return;

    setHoldings((prev) => {
      const exists = prev.find((h) => h.coinId === coinId);
      if (exists) {
        return prev.map((h) =>
          h.coinId === coinId
            ? { ...h, amount: h.amount + amount, note: note || h.note }
            : h,
        );
      }
      return [...prev, { coinId, amount, note }];
    });
  }, []);

  const updateHolding = React.useCallback((coinId, amount) => {
    if (amount <= 0) {
      setHoldings((prev) => prev.filter((h) => h.coinId !== coinId));
      return;
    }

    setHoldings((prev) =>
      prev.map((h) => (h.coinId === coinId ? { ...h, amount } : h)),
    );
  }, []);

  const removeHolding = React.useCallback((coinId) => {
    setHoldings((prev) => prev.filter((h) => h.coinId !== coinId));
  }, []);

  const hasHolding = React.useCallback(
    (coinId) => {
      return holdings.some((h) => h.coinId === coinId);
    },
    [holdings],
  );

  const getHoldingAmount = React.useCallback(
    (coinId) => {
      const holding = holdings.find((h) => h.coinId === coinId);
      return holding ? holding.amount : 0;
    },
    [holdings],
  );

  return {
    holdings,
    addHolding,
    updateHolding,
    removeHolding,
    hasHolding,
    getHoldingAmount,
  };
}
```

```jsx
/**
 * Component hiá»ƒn thá»‹ tá»•ng quan portfolio á»Ÿ Header hoáº·c pháº§n riÃªng
 */
export function PortfolioSummary({ cryptos, holdings }) {
  if (holdings.length === 0) {
    return (
      <div
        style={{
          padding: '12px 16px',
          background: '#f8f9fa',
          borderRadius: '8px',
          fontSize: '14px',
          color: '#666',
        }}
      >
        Portfolio: No holdings yet
      </div>
    );
  }

  const totalValue = holdings.reduce((sum, h) => {
    const coin = cryptos?.find((c) => c.id === h.coinId);
    return sum + (coin ? coin.price * h.amount : 0);
  }, 0);

  const formatValue = (val) =>
    new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(val);

  return (
    <div
      style={{
        padding: '12px 16px',
        background: '#e3f2fd',
        borderRadius: '8px',
        fontWeight: '600',
      }}
    >
      Portfolio Value: {formatValue(totalValue)}
      <span style={{ marginLeft: '12px', fontSize: '13px', color: '#555' }}>
        ({holdings.length} coin{holdings.length > 1 ? 's' : ''})
      </span>
    </div>
  );
}
```

```jsx
// Trong CryptoCard.jsx - thÃªm pháº§n portfolio control
export function CryptoCard({ crypto }) {
  const {
    hasHolding,
    getHoldingAmount,
    addHolding,
    updateHolding,
    removeHolding,
  } = usePortfolio();

  const currentAmount = getHoldingAmount(crypto.id);
  const [inputAmount, setInputAmount] = React.useState(currentAmount || '');

  const handleAddOrUpdate = () => {
    const amount = Number(inputAmount);
    if (isNaN(amount) || amount <= 0) return;

    if (currentAmount > 0) {
      updateHolding(crypto.id, amount);
    } else {
      addHolding(crypto.id, amount);
    }
    setInputAmount(amount);
  };

  const handleRemove = () => {
    removeHolding(crypto.id);
    setInputAmount('');
  };

  // ... render chÃ­nh cá»§a card ...

  // ThÃªm pháº§n Portfolio á»Ÿ dÆ°á»›i cÃ¹ng card
  <div
    style={{
      marginTop: '16px',
      paddingTop: '12px',
      borderTop: '1px solid #eee',
      fontSize: '14px',
    }}
  >
    <div
      style={{
        fontWeight: '600',
        marginBottom: '8px',
        color: currentAmount > 0 ? '#1976d2' : '#666',
      }}
    >
      {currentAmount > 0
        ? `You own: ${currentAmount} ${crypto.symbol}`
        : 'Add to your portfolio'}
    </div>

    <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
      <input
        type='number'
        min='0'
        step='any'
        value={inputAmount}
        onChange={(e) => setInputAmount(e.target.value)}
        placeholder='Amount'
        style={{
          width: '110px',
          padding: '6px 8px',
          border: '1px solid #ccc',
          borderRadius: '6px',
        }}
      />

      <button
        onClick={handleAddOrUpdate}
        disabled={!inputAmount || Number(inputAmount) <= 0}
        style={{
          padding: '6px 12px',
          background: currentAmount > 0 ? '#1976d2' : '#4caf50',
          color: 'white',
          border: 'none',
          borderRadius: '6px',
          cursor: 'pointer',
        }}
      >
        {currentAmount > 0 ? 'Update' : 'Add'}
      </button>

      {currentAmount > 0 && (
        <button
          onClick={handleRemove}
          style={{
            padding: '6px 10px',
            background: '#f44336',
            color: 'white',
            border: 'none',
            borderRadius: '6px',
            cursor: 'pointer',
          }}
        >
          Remove
        </button>
      )}
    </div>

    {currentAmount > 0 && crypto.price && (
      <div
        style={{
          marginTop: '8px',
          fontSize: '13px',
          color: '#555',
        }}
      >
        Current value: {formatPrice(currentAmount * crypto.price)}
      </div>
    )}
  </div>;
}
```

```jsx
// Trong App.jsx - thÃªm PortfolioSummary vÃ o Header hoáº·c pháº§n trÃªn cÃ¹ng
function App() {
  const { holdings } = usePortfolio();

  // ... cÃ¡c state vÃ  logic khÃ¡c ...

  return (
    <>
      <Header
        // ... props hiá»‡n cÃ³ ...
        extraContent={
          <PortfolioSummary
            cryptos={cryptos}
            holdings={holdings}
          />
        }
      />

      {/* ... pháº§n cÃ²n láº¡i ... */}
    </>
  );
}

// Trong Header.jsx - nháº­n prop extraContent
// VÃ­ dá»¥ Ä‘áº·t á»Ÿ bÃªn pháº£i hoáº·c dÆ°á»›i title
<div
  style={{
    display: 'flex',
    gap: '24px',
    alignItems: 'center',
    flexWrap: 'wrap',
  }}
>
  {/* cÃ¡c nÃºt hiá»‡n cÃ³ */}
  {extraContent}
</div>;
```

**Káº¿t quáº£ vÃ­ dá»¥:**

- Má»Ÿ app â†’ chÆ°a cÃ³ coin nÃ o trong portfolio
- VÃ o card Bitcoin â†’ nháº­p 0.5 â†’ nháº¥n Add â†’ tháº¥y "You own: 0.5 BTC" + giÃ¡ trá»‹ hiá»‡n táº¡i
- Refresh trang â†’ váº«n giá»¯ 0.5 BTC (localStorage)
- Cáº­p nháº­t giÃ¡ real-time â†’ giÃ¡ trá»‹ portfolio tá»± Ä‘á»™ng thay Ä‘á»•i
- Trong Header tháº¥y tá»•ng giÃ¡ trá»‹ portfolio (vÃ­ dá»¥: $42,150)
- Nháº¥n Remove â†’ xÃ³a coin khá»i portfolio
- Nháº­p sá»‘ lÆ°á»£ng má»›i â†’ update thay vÃ¬ add trÃ¹ng

</details>

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### API Documentation

- **CoinGecko API**: https://www.coingecko.com/en/api/documentation
- **Fetch API**: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API

### React Patterns

- **React Docs**: https://react.dev
- **Hooks Best Practices**: https://react.dev/reference/rules
- **Performance Optimization**: https://react.dev/learn/render-and-commit

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c Ä‘Ã£ sá»­ dá»¥ng:

- âœ… useState - UI state management
- âœ… useEffect - Data fetching, auto-refresh
- âœ… useRef - Previous values, timers
- âœ… useLayoutEffect - Animations (optional)
- âœ… Custom Hooks - Code organization

### HÆ°á»›ng tá»›i:

- **NgÃ y 26-28**: Performance optimization
- **NgÃ y 29-35**: Advanced patterns
- **Production apps**: Real-world projects

---

## ğŸ’¡ SENIOR INSIGHTS

### Best Practices Applied

```jsx
// 1. Separation of Concerns
// âœ… Custom hooks cho logic
// âœ… Components cho UI
// âœ… Utils cho helpers

// 2. Performance
// âœ… useMemo cho filtering
// âœ… Debouncing cho search
// âœ… Request cancellation

// 3. User Experience
// âœ… Loading states
// âœ… Error handling
// âœ… Smooth animations
// âœ… Responsive design

// 4. Maintainability
// âœ… Clear naming
// âœ… Comments
// âœ… Modular structure
// âœ… Reusable hooks
```

### Production Considerations

```jsx
// âœ… Rate Limiting
// API cÃ³ rate limits - implement caching

// âœ… Error Boundaries
// Wrap app trong ErrorBoundary

// âœ… Analytics
// Track user interactions

// âœ… Monitoring
// Log errors to service (Sentry)

// âœ… Testing
// Unit tests cho hooks
// Integration tests cho components
```

---

## âœ… CHECKLIST HOÃ€N THÃ€NH

- [ ] Project structure clear
- [ ] All custom hooks implemented
- [ ] All components working
- [ ] Data fetching successful
- [ ] Auto-refresh working
- [ ] Search & filter working
- [ ] Previous value comparison working
- [ ] Error handling complete
- [ ] UI polished
- [ ] Code organized

**ğŸ‰ Congratulations! Báº¡n Ä‘Ã£ hoÃ n thÃ nh Project 3!**

Báº¡n Ä‘Ã£ há»c Ä‘Æ°á»£c:
âœ… Build complete React application
âœ… Integrate multiple hooks
âœ… Handle real-time data
âœ… Advanced state management
âœ… Production-ready patterns
âœ… Performance optimization
âœ… Error handling strategies

**ğŸš€ Next Steps:**

- Review code
- Add more features
- Deploy to production
- Share with community!

Tomorrow: Performance Optimization Deep Dive! ğŸ’ª
