# ğŸ“… NGÃ€Y 18: Cleanup & Memory Leaks

## ğŸ“ Phase 2, Tuáº§n 5, NgÃ y 18 cá»§a 45

## â±ï¸ Thá»i lÆ°á»£ng: 3-4 giá»

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] Hiá»ƒu **Cleanup Function** lÃ  gÃ¬ vÃ  táº¡i sao cáº§n thiáº¿t
- [ ] Biáº¿t khi nÃ o cleanup function cháº¡y (timing critical!)
- [ ] NgÄƒn cháº·n **Memory Leaks** vá»›i timers, event listeners, subscriptions
- [ ] Xá»­ lÃ½ **Async Operations Cleanup** (cancel pending requests)
- [ ] Ãp dá»¥ng cleanup patterns cho production code

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i sau:

1. **CÃ¢u 1:** Náº¿u báº¡n dÃ¹ng `setInterval` trong useEffect, Ä‘iá»u gÃ¬ xáº£y ra khi component unmount?
   - _ÄÃ¡p Ã¡n: Interval váº«n cháº¡y â†’ Memory leak! (NgÃ y 18 sáº½ fix)_

2. **CÃ¢u 2:** Khi dependencies thay Ä‘á»•i, effect cháº¡y láº¡i. Váº­y effect CÅ¨ cÃ³ bá»‹ "dá»n dáº¹p" khÃ´ng?
   - _ÄÃ¡p Ã¡n: ChÆ°a biáº¿t cÃ¡ch! (HÃ´m nay há»c cleanup)_

3. **CÃ¢u 3:** API call Ä‘ang pending, nhÆ°ng user navigate away. CÃ³ váº¥n Ä‘á» gÃ¬?
   - _ÄÃ¡p Ã¡n: setState trÃªn unmounted component â†’ Warning! (Cleanup sáº½ giáº£i quyáº¿t)_

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

HÃ£y xem Ä‘oáº¡n code nÃ y:

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setSeconds((s) => s + 1);
    }, 1000);

    // âŒ PROBLEM: KhÃ´ng cleanup!
  }, []);

  return <div>Seconds: {seconds}</div>;
}

function App() {
  const [showTimer, setShowTimer] = useState(true);

  return (
    <div>
      <button onClick={() => setShowTimer(!showTimer)}>Toggle Timer</button>
      {showTimer && <Timer />}
    </div>
  );
}
```

**Váº¥n Ä‘á»:**

1. Click "Toggle Timer" â†’ Timer component unmount
2. NhÆ°ng `setInterval` VáºªN CHáº Y! (khÃ´ng ai dá»«ng nÃ³)
3. Interval cá»‘ gáº¯ng gá»i `setSeconds` trÃªn component Ä‘Ã£ unmount
4. **Memory leak** + Console warning: "Can't perform a React state update on an unmounted component"

**Káº¿t quáº£:**

- Memory leak (interval khÃ´ng bao giá» dá»«ng)
- Potential crashes
- Performance degradation
- Battery drain (mobile)

---

### 1.2 Giáº£i PhÃ¡p: Cleanup Function

**Cleanup Function** lÃ  function mÃ  effect **RETURN** Ä‘á»ƒ dá»n dáº¹p side effects.

**CÃº phÃ¡p:**

```jsx
useEffect(() => {
  // Setup code
  const id = setInterval(() => {
    // ...
  }, 1000);

  // Cleanup function
  return () => {
    clearInterval(id); // â† Dá»n dáº¹p
  };
}, []);
```

**Cleanup Function cháº¡y khi:**

1. **Component unmount** (component bá»‹ remove khá»i DOM)
2. **Dependencies thay Ä‘á»•i** (trÆ°á»›c khi effect cháº¡y láº¡i)

**GIáº¢I PHÃP cho Timer:**

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    console.log('âœ… Effect: Setup interval');

    const id = setInterval(() => {
      setSeconds((s) => s + 1);
    }, 1000);

    // âœ… Cleanup function
    return () => {
      console.log('ğŸ§¹ Cleanup: Clear interval');
      clearInterval(id);
    };
  }, []);

  return <div>Seconds: {seconds}</div>;
}

// BEHAVIOR:
// Mount â†’ Setup interval
// Unmount â†’ Cleanup (clear interval) âœ…
// No memory leak! âœ…
```

---

### 1.3 Mental Model: Setup & Cleanup Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           EFFECT LIFECYCLE WITH CLEANUP                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SCENARIO 1: Component Mount â†’ Unmount
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Component mounts
   â†“
2. Render
   â†“
3. Browser paints
   â†“
4. useEffect runs (SETUP)
   - Create interval, add listener, etc.
   â†“
5. ... Component exists ...
   â†“
6. Component unmounts
   â†“
7. Cleanup function runs (CLEANUP)
   - Clear interval, remove listener, etc.
   â†“
8. Component gone âœ…

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SCENARIO 2: Dependencies Change
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Effect runs vá»›i deps = [A]
   - Setup vá»›i A
   â†“
2. ... Time passes ...
   â†“
3. Deps thay Ä‘á»•i: A â†’ B
   â†“
4. Cleanup runs (cleanup OLD setup vá»›i A) ğŸ§¹
   â†“
5. Effect runs láº¡i (setup NEW vá»›i B) âœ…
   â†“
6. ... And so on ...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KEY INSIGHT:
Cleanup ALWAYS cháº¡y TRÆ¯á»šC khi effect cháº¡y láº¡i!
â†’ Old effect cleaned up BEFORE new effect sets up
â†’ Prevents resource leaks
```

**Analogy dá»… hiá»ƒu:**

> Effect nhÆ° thuÃª phÃ²ng khÃ¡ch sáº¡n:
>
> 1. Check-in (Setup): Nháº­n chÃ¬a khÃ³a, báº­t Ä‘Ã¨n, má»Ÿ Ä‘iá»u hÃ²a
> 2. á» trong phÃ²ng (Effect active)
> 3. Check-out (Cleanup): Tráº£ chÃ¬a khÃ³a, táº¯t Ä‘Ã¨n, táº¯t Ä‘iá»u hÃ²a
>
> Náº¿u khÃ´ng check-out (no cleanup):
>
> - ÄÃ¨n váº«n chÃ¡y (waste energy)
> - PhÃ²ng locked (resource not freed)
> - Hotel bill keeps going (memory leak!)

---

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

#### âŒ Hiá»ƒu láº§m #1: "Cleanup chá»‰ cháº¡y khi unmount"

```jsx
function Wrong() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('Effect with count:', count);

    return () => {
      console.log('Cleanup'); // Cháº¡y TRÆ¯á»šC má»—i effect re-run!
    };
  }, [count]); // â† Deps cÃ³ count

  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}

// Console output khi click 3 láº§n:
// Effect with count: 0
// (click)
// Cleanup           â† Cleanup OLD effect (count = 0)
// Effect with count: 1  â† New effect (count = 1)
// (click)
// Cleanup           â† Cleanup OLD (count = 1)
// Effect with count: 2  â† New effect (count = 2)
// (unmount)
// Cleanup           â† Final cleanup
```

**âœ… ÄÃºng:** Cleanup cháº¡y:

- TrÆ°á»›c má»—i effect re-run (khi deps thay Ä‘á»•i)
- Khi component unmount

---

#### âŒ Hiá»ƒu láº§m #2: "Cleanup lÃ  optional"

```jsx
// âŒ DANGEROUS: No cleanup
function Dangerous() {
  useEffect(() => {
    window.addEventListener('scroll', handleScroll);
    // KhÃ´ng remove listener â†’ Memory leak!
  }, []);
}

// âœ… SAFE: Always cleanup
function Safe() {
  useEffect(() => {
    window.addEventListener('scroll', handleScroll);

    return () => {
      window.removeEventListener('scroll', handleScroll); // âœ…
    };
  }, []);
}
```

**Rule:** Náº¿u effect táº¡o resource (timer, listener, subscription), Báº®T BUá»˜C pháº£i cleanup!

---

#### âŒ Hiá»ƒu láº§m #3: "Cleanup cháº¡y synchronously"

```jsx
function Wrong() {
  useEffect(() => {
    console.log('1. Effect runs');

    return () => {
      console.log('3. Cleanup runs'); // Cháº¡y SAU, khÃ´ng pháº£i ngay
    };
  }, []);

  console.log('2. Render completes');
}

// Output:
// 2. Render completes
// 1. Effect runs
// (later, on unmount)
// 3. Cleanup runs
```

**âœ… ÄÃºng:** Cleanup lÃ  async, cháº¡y SAU khi cáº§n (unmount hoáº·c deps change).

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Pattern CÆ¡ Báº£n - Timer Cleanup â­

```jsx
/**
 * Demo: setInterval vá»›i cleanup proper
 * Concepts: Cleanup timing, clearInterval
 */

import { useState, useEffect } from 'react';

function TimerWithCleanup() {
  const [seconds, setSeconds] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    if (!isRunning) return; // Don't setup náº¿u paused

    console.log('âœ… Setting up interval');

    const intervalId = setInterval(() => {
      setSeconds((s) => s + 1);
      console.log('â±ï¸ Tick');
    }, 1000);

    // Cleanup function
    return () => {
      console.log('ğŸ§¹ Cleaning up interval:', intervalId);
      clearInterval(intervalId);
    };
  }, [isRunning]); // Re-run khi isRunning thay Ä‘á»•i

  return (
    <div>
      <h2>Timer with Cleanup</h2>
      <p>Seconds: {seconds}</p>

      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? 'â¸ï¸ Pause' : 'â–¶ï¸ Start'}
      </button>

      <button onClick={() => setSeconds(0)}>ğŸ”„ Reset</button>

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>ğŸ“‹ Test Instructions:</h3>
        <ol>
          <li>Má»Ÿ Console</li>
          <li>Click Start â†’ Interval Ä‘Æ°á»£c táº¡o</li>
          <li>Click Pause â†’ Cleanup cháº¡y, interval cleared</li>
          <li>Click Start láº¡i â†’ Interval Má»šI Ä‘Æ°á»£c táº¡o</li>
        </ol>

        <h3>ğŸ” Observations:</h3>
        <ul>
          <li>âœ… Má»—i láº§n pause â†’ Cleanup removes old interval</li>
          <li>âœ… KhÃ´ng cÃ³ interval nÃ o "leak"</li>
          <li>âœ… Console.log clear patterns</li>
        </ul>
      </div>
    </div>
  );
}

export default TimerWithCleanup;
```

---

### Demo 2: Ká»‹ch Báº£n Thá»±c Táº¿ - Event Listener Cleanup â­â­

```jsx
/**
 * Demo: Event listeners cleanup
 * Use case: Window events, keyboard shortcuts
 */

import { useState, useEffect } from 'react';

function MouseTracker() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isTracking, setIsTracking] = useState(true);

  useEffect(() => {
    if (!isTracking) return;

    console.log('âœ… Adding mousemove listener');

    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMouseMove);

    // âœ… CLEANUP: Remove listener
    return () => {
      console.log('ğŸ§¹ Removing mousemove listener');
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, [isTracking]);

  return (
    <div>
      <h2>Mouse Tracker</h2>

      <p>
        Mouse Position: ({position.x}, {position.y})
      </p>

      <button onClick={() => setIsTracking(!isTracking)}>
        {isTracking ? 'â¸ï¸ Stop Tracking' : 'â–¶ï¸ Start Tracking'}
      </button>

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>âš ï¸ Without Cleanup:</h3>
        <ul>
          <li>âŒ Listener stays attached forever</li>
          <li>âŒ Multiple listeners accumulate</li>
          <li>âŒ Memory leak</li>
          <li>âŒ Performance degradation</li>
        </ul>

        <h3>âœ… With Cleanup:</h3>
        <ul>
          <li>âœ… Listener removed when not needed</li>
          <li>âœ… No accumulation</li>
          <li>âœ… Clean memory</li>
          <li>âœ… Optimal performance</li>
        </ul>
      </div>
    </div>
  );
}

// ğŸ”¥ ADVANCED: Multiple listeners
function KeyboardShortcuts() {
  const [keys, setKeys] = useState([]);

  useEffect(() => {
    console.log('âœ… Setting up keyboard listeners');

    const handleKeyDown = (e) => {
      setKeys((prev) => [...prev, `${e.key} (down)`].slice(-5));
    };

    const handleKeyUp = (e) => {
      setKeys((prev) => [...prev, `${e.key} (up)`].slice(-5));
    };

    // Add MULTIPLE listeners
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // Cleanup BOTH listeners
    return () => {
      console.log('ğŸ§¹ Removing keyboard listeners');
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []); // Empty deps â†’ Setup once

  return (
    <div>
      <h2>Keyboard Shortcuts</h2>
      <p>Press any key...</p>

      <div>
        <h3>Recent Keys:</h3>
        <ul>
          {keys.map((key, i) => (
            <li key={i}>{key}</li>
          ))}
        </ul>
      </div>

      <p>ğŸ’¡ Notice: Both keydown AND keyup listeners cleaned up together</p>
    </div>
  );
}

export default MouseTracker;
```

---

### Demo 3: Edge Cases - Async Cleanup & Race Conditions â­â­â­

```jsx
/**
 * Demo: Cleanup async operations
 * Edge case: Cancel pending API calls, avoid setState on unmounted component
 */

import { useState, useEffect } from 'react';

// Mock API vá»›i delay
const fetchUser = (userId) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        id: userId,
        name: `User ${userId}`,
        email: `user${userId}@example.com`,
      });
    }, 2000); // 2 second delay
  });
};

// âŒ VERSION 1: Without Cleanup (BUGGY!)
function UserProfileBuggy({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('Fetching user:', userId);
    setLoading(true);

    fetchUser(userId).then((data) => {
      // âš ï¸ PROBLEM: Náº¿u component unmount trÆ°á»›c khi promise resolve
      // â†’ setState trÃªn unmounted component â†’ Warning!
      setUser(data);
      setLoading(false);
      console.log('âœ… User loaded:', data.id);
    });

    // âŒ No cleanup!
  }, [userId]);

  if (loading) return <div>Loading user {userId}...</div>;
  return (
    <div>
      <h3>{user?.name}</h3>
      <p>{user?.email}</p>
    </div>
  );
}

// âœ… VERSION 2: With Cleanup (FIXED!)
function UserProfileFixed({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('âœ… Fetching user:', userId);
    setLoading(true);

    // Flag Ä‘á»ƒ track náº¿u component váº«n mounted
    let isCancelled = false;

    fetchUser(userId).then((data) => {
      // Chá»‰ update state náº¿u CHÆ¯A cleanup
      if (!isCancelled) {
        setUser(data);
        setLoading(false);
        console.log('âœ… User loaded:', data.id);
      } else {
        console.log('ğŸ§¹ Request cancelled for user:', data.id);
      }
    });

    // Cleanup: Set flag
    return () => {
      console.log('ğŸ§¹ Cleanup: Cancelling request for user:', userId);
      isCancelled = true;
    };
  }, [userId]);

  if (loading) return <div>Loading user {userId}...</div>;
  return (
    <div>
      <h3>{user?.name}</h3>
      <p>{user?.email}</p>
    </div>
  );
}

// ğŸ”¥ VERSION 3: With AbortController (MODERN!)
function UserProfileModern({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    console.log('âœ… Fetching user:', userId);
    setLoading(true);
    setError(null);

    // Create AbortController
    const controller = new AbortController();

    // Fetch vá»›i signal
    fetch(`/api/users/${userId}`, {
      signal: controller.signal,
    })
      .then((res) => res.json())
      .then((data) => {
        setUser(data);
        setLoading(false);
        console.log('âœ… User loaded:', data.id);
      })
      .catch((err) => {
        if (err.name === 'AbortError') {
          console.log('ğŸ§¹ Request aborted for user:', userId);
        } else {
          setError(err.message);
          setLoading(false);
        }
      });

    // Cleanup: Abort request
    return () => {
      console.log('ğŸ§¹ Aborting request for user:', userId);
      controller.abort();
    };
  }, [userId]);

  if (loading) return <div>Loading user {userId}...</div>;
  if (error) return <div>Error: {error}</div>;
  return (
    <div>
      <h3>{user?.name}</h3>
      <p>{user?.email}</p>
    </div>
  );
}

// Demo Component
function AsyncCleanupDemo() {
  const [userId, setUserId] = useState(1);
  const [showProfile, setShowProfile] = useState(true);

  return (
    <div>
      <h2>Async Cleanup Demo</h2>

      <div>
        <button onClick={() => setUserId(userId + 1)}>
          Next User ({userId + 1})
        </button>
        <button onClick={() => setShowProfile(!showProfile)}>
          {showProfile ? 'Hide' : 'Show'} Profile
        </button>
      </div>

      {showProfile && <UserProfileFixed userId={userId} />}

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>ğŸ§ª Test Race Condition:</h3>
        <ol>
          <li>Click "Next User" nhiá»u láº§n NHANH (má»—i 0.5s)</li>
          <li>Hoáº·c click "Hide Profile" trong khi loading</li>
        </ol>

        <h3>ğŸ“‹ Expected Behavior:</h3>
        <ul>
          <li>âœ… Old requests marked as cancelled</li>
          <li>âœ… No setState on unmounted component</li>
          <li>âœ… Only latest request updates state</li>
          <li>âœ… No console warnings</li>
        </ul>

        <h3>ğŸ¯ Cleanup Strategies:</h3>
        <ul>
          <li>
            <strong>v1 (Buggy):</strong> No cleanup â†’ Warnings
          </li>
          <li>
            <strong>v2 (Flag):</strong> isCancelled flag â†’ Works!
          </li>
          <li>
            <strong>v3 (AbortController):</strong> Actually cancel request â†’
            Best!
          </li>
        </ul>
      </div>
    </div>
  );
}

export default AsyncCleanupDemo;
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Level 1: Ãp Dá»¥ng Concept (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Practice cleanup vá»›i setTimeout
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useRef, custom hooks
 *
 * Requirements:
 * 1. Notification component tá»± Ä‘á»™ng áº©n sau 3 giÃ¢y
 * 2. DÃ¹ng setTimeout trong useEffect
 * 3. Cleanup timeout khi component unmount
 * 4. Cleanup timeout khi message thay Ä‘á»•i (show new notification)
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - setTimeout return timeoutId
 * - clearTimeout(timeoutId) Ä‘á»ƒ cleanup
 * - Dependencies: [message]
 */

// âŒ CÃ¡ch SAI (Anti-pattern):
function WrongNotification({ message }) {
  const [visible, setVisible] = useState(true);

  useEffect(() => {
    // âŒ No cleanup â†’ Timeout váº«n cháº¡y sau unmount!
    setTimeout(() => {
      setVisible(false);
    }, 3000);
  }, [message]);

  if (!visible) return null;
  return <div className='notification'>{message}</div>;
}

// Táº¡i sao sai?
// - Náº¿u message thay Ä‘á»•i trong 3 giÃ¢y â†’ Multiple timeouts!
// - Náº¿u component unmount â†’ Timeout váº«n cháº¡y â†’ setState warning
// - Memory leak

// âœ… CÃ¡ch ÄÃšNG (Best practice):
function CorrectNotification({ message }) {
  const [visible, setVisible] = useState(true);

  useEffect(() => {
    // Reset visible khi message thay Ä‘á»•i
    setVisible(true);

    const timeoutId = setTimeout(() => {
      setVisible(false);
    }, 3000);

    // âœ… Cleanup timeout
    return () => {
      clearTimeout(timeoutId);
    };
  }, [message]); // Re-run khi message thay Ä‘á»•i

  if (!visible) return null;
  return (
    <div
      style={{
        padding: '10px 20px',
        background: '#4CAF50',
        color: 'white',
        borderRadius: '4px',
        margin: '10px 0',
      }}
    >
      {message}
    </div>
  );
}

// Táº¡i sao tá»‘t hÆ¡n?
// âœ… Old timeout cleared khi message thay Ä‘á»•i
// âœ… Timeout cleared khi unmount
// âœ… No memory leaks
// âœ… No warnings

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
function Notification({ message, duration = 3000 }) {
  // TODO: State cho visible

  // TODO: useEffect vá»›i setTimeout
  // - Set visible = true khi message thay Ä‘á»•i
  // - setTimeout Ä‘á»ƒ set visible = false sau `duration`
  // - Return cleanup function Ä‘á»ƒ clearTimeout

  // TODO: Render notification náº¿u visible

  return null; // Replace this
}

// Test Component
function NotificationDemo() {
  const [message, setMessage] = useState('');
  const [count, setCount] = useState(0);

  const showNotification = () => {
    setMessage(`Notification #${count + 1}`);
    setCount(count + 1);
  };

  return (
    <div>
      <h2>Auto-Hide Notification</h2>

      <button onClick={showNotification}>Show Notification</button>

      <Notification
        message={message}
        duration={3000}
      />

      <div style={{ marginTop: '20px' }}>
        <h3>âœ… Test Checklist:</h3>
        <ul>
          <li>Click button â†’ Notification appears</li>
          <li>Wait 3s â†’ Notification hides</li>
          <li>Click again quickly (before 3s) â†’ Old notification replaced</li>
          <li>Console: No warnings</li>
        </ul>
      </div>
    </div>
  );
}
```

---

### â­â­ Level 2: Nháº­n Biáº¿t Pattern (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Cleanup multiple resources
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: Debounced search vá»›i multiple cleanups
 * YÃªu cáº§u:
 * - Debounce input (500ms)
 * - Cancel pending searches
 * - Cleanup event listeners
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 *
 * RESOURCES cáº§n cleanup:
 * 1. setTimeout (debounce timer)
 * 2. Fetch request (if using AbortController)
 * 3. Event listeners (náº¿u cÃ³)
 *
 * APPROACH: Single effect vá»›i multiple cleanups
 * - Return cleanup function
 * - Cleanup ALL resources trong Ä‘Ã³
 * - Order matters? KhÃ´ng, nhÆ°ng nÃªn cÃ³ comment
 *
 * ğŸ’­ IMPLEMENT STRATEGY
 */

// Mock search API
const searchProducts = (query) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      const products = [
        'iPhone 15',
        'iPhone 14',
        'iPad Pro',
        'iPad Air',
        'MacBook Pro',
        'MacBook Air',
        'AirPods Pro',
      ];
      const filtered = products.filter((p) =>
        p.toLowerCase().includes(query.toLowerCase()),
      );
      resolve(filtered);
    }, 1000);
  });
};

function DebouncedSearch() {
  const [query, setQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);

  // TODO: Effect 1 - Debounce query
  useEffect(() => {
    // TODO:
    // 1. Set isSearching = true
    // 2. setTimeout 500ms Ä‘á»ƒ setDebouncedQuery
    // 3. Return cleanup Ä‘á»ƒ clearTimeout
    // Dependencies: [query]
  }, [query]);

  // TODO: Effect 2 - Search khi debouncedQuery thay Ä‘á»•i
  useEffect(() => {
    // TODO:
    // 1. Náº¿u debouncedQuery empty â†’ Clear results
    // 2. Náº¿u cÃ³ query â†’ Call searchProducts
    // 3. DÃ¹ng isCancelled flag Ä‘á»ƒ prevent setState sau unmount
    // 4. Return cleanup Ä‘á»ƒ set isCancelled = true
    // Dependencies: [debouncedQuery]
  }, [debouncedQuery]);

  return (
    <div>
      <h2>Debounced Search</h2>

      <input
        type='text'
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search products...'
        style={{ padding: '10px', width: '300px', fontSize: '16px' }}
      />

      {isSearching && <p>ğŸ” Searching...</p>}

      <div>
        <h3>Results:</h3>
        {results.length > 0 ? (
          <ul>
            {results.map((product, i) => (
              <li key={i}>{product}</li>
            ))}
          </ul>
        ) : (
          debouncedQuery && <p>No results found.</p>
        )}
      </div>

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>ğŸ§ª Test Cleanup:</h3>
        <ol>
          <li>Type "iphone" NHANH (má»—i 100ms má»™t chá»¯)</li>
          <li>Console: Chá»‰ 1 search SAU KHI ngá»«ng typing 500ms</li>
          <li>Type "ip" â†’ Wait â†’ "ad" â†’ 2 searches (debounced)</li>
          <li>Clear input nhanh â†’ Search cancelled</li>
        </ol>

        <h3>ğŸ“‹ Cleanup Points:</h3>
        <ul>
          <li>âœ… Timeout cleared khi typing continues</li>
          <li>âœ… Search cancelled khi new query arrives</li>
          <li>âœ… No setState on unmounted component</li>
        </ul>
      </div>
    </div>
  );
}

export default DebouncedSearch;
```

---

### â­â­â­ Level 3: Ká»‹ch Báº£n Thá»±c Táº¿ (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Real-time Chat Subscription
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  user, tÃ´i muá»‘n nháº­n messages real-time
 * tá»« chat room, vÃ  unsubscribe khi rá»i khá»i room"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Subscribe to chat room khi component mount
 * - [ ] Receive vÃ  display messages real-time
 * - [ ] Unsubscribe khi switch rooms
 * - [ ] Unsubscribe khi component unmount
 * - [ ] No memory leaks
 * - [ ] Handle connection errors
 *
 * ğŸ¨ Technical Constraints:
 * - Simulate WebSocket vá»›i setInterval
 * - Cleanup subscription properly
 * - Handle multiple room switches
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Switch room nhanh (< 1s) â†’ Cancel old subscription
 * - Component unmount while receiving â†’ No setState
 * - Reconnection logic (optional)
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] State cho messages array
 * - [ ] State cho current room
 * - [ ] Effect Ä‘á»ƒ subscribe/unsubscribe
 * - [ ] Cleanup function comprehensive
 * - [ ] UI cho room selection
 */

// Mock Chat Service
class ChatService {
  constructor() {
    this.subscriptions = new Map();
  }

  subscribe(roomId, callback) {
    console.log(`ğŸ“¡ Subscribing to room: ${roomId}`);

    // Simulate receiving messages every 2 seconds
    const intervalId = setInterval(() => {
      const message = {
        id: Date.now(),
        roomId,
        text: `Message from ${roomId} at ${new Date().toLocaleTimeString()}`,
        sender: `User${Math.floor(Math.random() * 10)}`,
      };
      callback(message);
    }, 2000);

    this.subscriptions.set(roomId, intervalId);

    // Return unsubscribe function
    return () => {
      console.log(`ğŸ“´ Unsubscribing from room: ${roomId}`);
      clearInterval(intervalId);
      this.subscriptions.delete(roomId);
    };
  }
}

const chatService = new ChatService();

// ğŸ¯ STARTER CODE:
function ChatRoom() {
  const [currentRoom, setCurrentRoom] = useState('general');
  const [messages, setMessages] = useState([]);
  const [isConnected, setIsConnected] = useState(false);

  // TODO: Effect - Subscribe to chat room
  useEffect(() => {
    console.log(`âœ… Setting up subscription for room: ${currentRoom}`);
    setIsConnected(true);
    setMessages([]); // Clear old messages

    // Subscribe to room
    const unsubscribe = chatService.subscribe(currentRoom, (message) => {
      // TODO: Add message to state
      // Hint: setMessages(prev => [...prev, message])
    });

    // TODO: Cleanup function
    return () => {
      console.log(`ğŸ§¹ Cleaning up subscription for room: ${currentRoom}`);
      unsubscribe(); // Call unsubscribe function
      setIsConnected(false);
    };
  }, [currentRoom]); // Re-subscribe khi room thay Ä‘á»•i

  const rooms = ['general', 'random', 'tech', 'sports'];

  return (
    <div style={{ maxWidth: '600px', margin: '0 auto', padding: '20px' }}>
      <h2>Real-time Chat Room</h2>

      {/* Room Selection */}
      <div style={{ marginBottom: '20px' }}>
        <strong>Select Room:</strong>
        <div style={{ display: 'flex', gap: '10px', marginTop: '10px' }}>
          {rooms.map((room) => (
            <button
              key={room}
              onClick={() => setCurrentRoom(room)}
              style={{
                padding: '10px 20px',
                background: currentRoom === room ? '#4CAF50' : '#ddd',
                color: currentRoom === room ? 'white' : 'black',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
              }}
            >
              #{room}
            </button>
          ))}
        </div>
      </div>

      {/* Connection Status */}
      <div
        style={{
          padding: '10px',
          background: isConnected ? '#4CAF50' : '#f44336',
          color: 'white',
          borderRadius: '4px',
          marginBottom: '20px',
        }}
      >
        {isConnected ? 'ğŸŸ¢ Connected' : 'ğŸ”´ Disconnected'} to #{currentRoom}
      </div>

      {/* Messages */}
      <div
        style={{
          border: '1px solid #ddd',
          borderRadius: '4px',
          padding: '10px',
          minHeight: '300px',
          maxHeight: '400px',
          overflowY: 'auto',
          background: '#f9f9f9',
        }}
      >
        {messages.length === 0 ? (
          <p style={{ textAlign: 'center', color: '#999' }}>
            Waiting for messages...
          </p>
        ) : (
          messages.map((msg) => (
            <div
              key={msg.id}
              style={{
                padding: '10px',
                margin: '5px 0',
                background: 'white',
                borderRadius: '4px',
                border: '1px solid #eee',
              }}
            >
              <strong>{msg.sender}:</strong> {msg.text}
            </div>
          ))
        )}
      </div>

      {/* Instructions */}
      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>ğŸ§ª Test Cleanup:</h3>
        <ol>
          <li>Má»Ÿ Console</li>
          <li>Äá»£i messages xuáº¥t hiá»‡n trong "general"</li>
          <li>Switch sang "tech" â†’ Quan sÃ¡t cleanup log</li>
          <li>Switch nhanh giá»¯a rooms â†’ Má»—i switch trigger cleanup</li>
        </ol>

        <h3>âœ… Expected Behavior:</h3>
        <ul>
          <li>âœ… Old subscription cancelled khi switch room</li>
          <li>âœ… Messages cleared khi switch</li>
          <li>âœ… Only current room receives messages</li>
          <li>âœ… No console warnings</li>
        </ul>
      </div>
    </div>
  );
}

export default ChatRoom;
```

---

### â­â­â­â­ Level 4: Quyáº¿t Äá»‹nh Kiáº¿n TrÃºc (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Analytics Tracker vá»›i Multiple Cleanup Strategies
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Context:
 * XÃ¢y dá»±ng Analytics tracker theo dÃµi:
 * - Page views
 * - Time on page
 * - Click events
 * - Scroll depth
 * - User activity (active/idle)
 *
 * Má»—i metric cáº§n cleanup strategy khÃ¡c nhau:
 * 1. Timer-based (time on page) â†’ clearInterval
 * 2. Event-based (clicks, scroll) â†’ removeEventListener
 * 3. Batching (gá»­i batch sau N seconds) â†’ clearTimeout + send remaining
 * 4. Visibility (track tab active) â†’ removeEventListener
 *
 * APPROACH OPTIONS:
 *
 * APPROACH 1: Multiple effects, má»—i effect 1 cleanup
 * Pros:
 * - Separation of concerns rÃµ rÃ ng
 * - Dá»… debug tá»«ng metric
 * - Dá»… enable/disable individual trackers
 * Cons:
 * - Nhiá»u effects (4-5 effects)
 * - CÃ³ thá»ƒ conflicts giá»¯a effects
 *
 * APPROACH 2: Single effect, táº¥t cáº£ trong 1, return combined cleanup
 * Pros:
 * - Gá»n hÆ¡n, 1 effect duy nháº¥t
 * - Centralized logic
 * Cons:
 * - KhÃ³ Ä‘á»c, logic phá»©c táº¡p
 * - KhÃ³ maintain
 * - All-or-nothing (khÃ³ disable 1 tracker)
 *
 * APPROACH 3: Hybrid - Group related metrics
 * Pros:
 * - Balance clarity vs compactness
 * - Effect 1: Timers (time on page, batching)
 * - Effect 2: Events (clicks, scroll, visibility)
 * - CÃ³ thá»ƒ deps khÃ¡c nhau
 * Cons:
 * - Váº«n cáº§n cáº©n tháº­n vá»›i interactions
 *
 * ğŸ’­ RECOMMENDATION: Approach 1 (Multiple Effects)
 * LÃ½ do: Clarity > Brevity, easier to maintain
 *
 * ADR:
 * ---
 * # ADR: Analytics Cleanup Strategy
 *
 * ## Context
 * Track multiple metrics, má»—i metric cáº§n cleanup khÃ¡c nhau
 *
 * ## Decision
 * Multiple effects, má»—i effect responsible cho 1 concern
 *
 * ## Rationale
 * - Clarity: Má»—i effect rÃµ rÃ ng purpose
 * - Maintainability: Dá»… update/remove individual trackers
 * - Debuggability: Console.log tá»«ng effect
 * - Flexibility: Enable/disable vá»›i flags
 *
 * ## Consequences
 * - More effects (4-5)
 * - Potential slight performance overhead (negligible)
 * - Easier to reason about
 * ---
 */

// ğŸ’» PHASE 2: Implementation (30 phÃºt)

import { useState, useEffect } from 'react';

function AnalyticsTracker({ enableTracking = true }) {
  // Analytics data
  const [analytics, setAnalytics] = useState({
    pageViews: 0,
    timeOnPage: 0,
    clicks: 0,
    maxScrollDepth: 0,
    isActive: true,
    events: [],
  });

  // Effect 1: Page View Tracking
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ“Š Tracking page view');

    setAnalytics((prev) => ({
      ...prev,
      pageViews: prev.pageViews + 1,
    }));

    // Send to analytics server (simulated)
    const sendPageView = () => {
      console.log('ğŸ“¤ Sending page view event');
      // analytics.track('page_view', { ... });
    };
    sendPageView();

    // No cleanup needed (one-time event)
  }, [enableTracking]); // Re-track náº¿u enable thay Ä‘á»•i

  // Effect 2: Time on Page
  useEffect(() => {
    if (!enableTracking) return;

    console.log('â±ï¸ Starting time tracker');

    const intervalId = setInterval(() => {
      setAnalytics((prev) => ({
        ...prev,
        timeOnPage: prev.timeOnPage + 1,
      }));
    }, 1000);

    return () => {
      console.log('ğŸ§¹ Stopping time tracker');
      clearInterval(intervalId);
    };
  }, [enableTracking]);

  // Effect 3: Click Tracking
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ–±ï¸ Adding click listener');

    const handleClick = (e) => {
      setAnalytics((prev) => ({
        ...prev,
        clicks: prev.clicks + 1,
        events: [
          ...prev.events,
          {
            type: 'click',
            target: e.target.tagName,
            time: Date.now(),
          },
        ].slice(-10), // Keep last 10
      }));
    };

    document.addEventListener('click', handleClick);

    return () => {
      console.log('ğŸ§¹ Removing click listener');
      document.removeEventListener('click', handleClick);
    };
  }, [enableTracking]);

  // Effect 4: Scroll Depth Tracking
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ“œ Adding scroll listener');

    const handleScroll = () => {
      const scrollPercent = Math.round(
        (window.scrollY /
          (document.documentElement.scrollHeight - window.innerHeight)) *
          100,
      );

      setAnalytics((prev) => ({
        ...prev,
        maxScrollDepth: Math.max(prev.maxScrollDepth, scrollPercent || 0),
      }));
    };

    window.addEventListener('scroll', handleScroll);

    return () => {
      console.log('ğŸ§¹ Removing scroll listener');
      window.removeEventListener('scroll', handleScroll);
    };
  }, [enableTracking]);

  // Effect 5: Visibility / Activity Tracking
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ‘ï¸ Adding visibility listener');

    const handleVisibilityChange = () => {
      setAnalytics((prev) => ({
        ...prev,
        isActive: !document.hidden,
      }));
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      console.log('ğŸ§¹ Removing visibility listener');
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [enableTracking]);

  // Effect 6: Batch Send (every 10 seconds)
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ“¦ Starting batch sender');

    const batchInterval = setInterval(() => {
      console.log('ğŸ“¤ Sending analytics batch:', analytics);
      // Send to server: analytics.batch(analytics);
    }, 10000);

    // Cleanup: Send remaining data immediately
    return () => {
      console.log('ğŸ§¹ Sending final batch before cleanup');
      console.log('ğŸ“¤ Final analytics:', analytics);
      clearInterval(batchInterval);
      // analytics.batch(analytics);
    };
  }, [enableTracking, analytics]); // Note: analytics in deps Ä‘á»ƒ send latest

  return (
    <div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}>
      <h2>Analytics Tracker</h2>

      {/* Stats Dashboard */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
          gap: '10px',
          marginBottom: '20px',
        }}
      >
        <StatCard
          title='Page Views'
          value={analytics.pageViews}
          icon='ğŸ“Š'
        />
        <StatCard
          title='Time on Page'
          value={`${analytics.timeOnPage}s`}
          icon='â±ï¸'
        />
        <StatCard
          title='Clicks'
          value={analytics.clicks}
          icon='ğŸ–±ï¸'
        />
        <StatCard
          title='Scroll Depth'
          value={`${analytics.maxScrollDepth}%`}
          icon='ğŸ“œ'
        />
        <StatCard
          title='Status'
          value={analytics.isActive ? 'Active' : 'Idle'}
          icon={analytics.isActive ? 'ğŸŸ¢' : 'âšª'}
        />
      </div>

      {/* Recent Events */}
      <div style={{ marginBottom: '20px' }}>
        <h3>Recent Events (Last 10):</h3>
        <div
          style={{
            maxHeight: '200px',
            overflowY: 'auto',
            border: '1px solid #ddd',
            borderRadius: '4px',
            padding: '10px',
          }}
        >
          {analytics.events.length === 0 ? (
            <p>No events yet. Click around!</p>
          ) : (
            analytics.events.map((event, i) => (
              <div
                key={i}
                style={{ padding: '5px', borderBottom: '1px solid #eee' }}
              >
                {event.type} on {event.target} at{' '}
                {new Date(event.time).toLocaleTimeString()}
              </div>
            ))
          )}
        </div>
      </div>

      {/* Test Content */}
      <div style={{ marginTop: '40px' }}>
        <h3>Test Content (Scroll, Click, etc.)</h3>
        {[...Array(20)].map((_, i) => (
          <p
            key={i}
            style={{ marginBottom: '20px' }}
          >
            Paragraph {i + 1}: Lorem ipsum dolor sit amet, consectetur
            adipiscing elit. Click me! Scroll past me! Switch tabs!
          </p>
        ))}
      </div>

      {/* Instructions */}
      <div
        style={{
          position: 'fixed',
          bottom: '20px',
          right: '20px',
          background: 'white',
          border: '2px solid #4CAF50',
          borderRadius: '8px',
          padding: '15px',
          maxWidth: '300px',
          boxShadow: '0 2px 10px rgba(0,0,0,0.1)',
        }}
      >
        <h4>ğŸ§ª Test Cleanup:</h4>
        <ol style={{ fontSize: '14px', paddingLeft: '20px' }}>
          <li>Má»Ÿ Console</li>
          <li>Scroll page</li>
          <li>Click vÃ i láº§n</li>
          <li>Switch tab (visibility)</li>
          <li>Navigate away â†’ Observe cleanup logs</li>
        </ol>
      </div>
    </div>
  );
}

function StatCard({ title, value, icon }) {
  return (
    <div
      style={{
        padding: '15px',
        background: '#f5f5f5',
        borderRadius: '8px',
        textAlign: 'center',
      }}
    >
      <div style={{ fontSize: '24px', marginBottom: '5px' }}>{icon}</div>
      <div style={{ fontSize: '12px', color: '#666', marginBottom: '5px' }}>
        {title}
      </div>
      <div style={{ fontSize: '20px', fontWeight: 'bold' }}>{value}</div>
    </div>
  );
}

export default AnalyticsTracker;

// ğŸ§ª PHASE 3: Testing (10 phÃºt)
// Manual testing checklist:
// - [ ] All 6 effects set up on mount (check Console)
// - [ ] Time tracker increments every second
// - [ ] Clicks tracked and displayed
// - [ ] Scroll depth updates
// - [ ] Tab visibility changes detected
// - [ ] Batch sends every 10s
// - [ ] Navigate away â†’ All 6 cleanups execute
// - [ ] No console warnings
// - [ ] Final batch sent with latest data

// ğŸ“‹ PRODUCTION CONSIDERATIONS:
// - Error handling trong effects (try/catch)
// - Throttle scroll/click handlers
// - localStorage persistence
// - Server API integration
// - Privacy compliance (GDPR)
// - Opt-out mechanism
```

---

### â­â­â­â­â­ Level 5: Production Challenge (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Video Player vá»›i Comprehensive Cleanup
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * XÃ¢y dá»±ng custom video player vá»›i:
 * 1. Play/Pause controls
 * 2. Progress bar (updates má»—i giÃ¢y)
 * 3. Volume control
 * 4. Fullscreen toggle
 * 5. Keyboard shortcuts
 * 6. Auto-save playback position
 * 7. Picture-in-Picture mode
 * 8. Playback speed control
 *
 * ğŸ—ï¸ Technical Design Doc:
 *
 * 1. Component Architecture:
 *    - VideoPlayer (parent)
 *    - VideoControls (UI controls)
 *    - ProgressBar (seekable)
 *    - VolumeSlider
 *
 * 2. State Management:
 *    - isPlaying, currentTime, duration, volume
 *    - isFullscreen, isPiP, playbackRate
 *
 * 3. Cleanup Requirements (CRITICAL!):
 *    - Effect 1: Progress interval â†’ clearInterval
 *    - Effect 2: Keyboard listeners â†’ removeEventListener (multiple keys)
 *    - Effect 3: Fullscreen listeners â†’ removeEventListener
 *    - Effect 4: Auto-save timer â†’ clearTimeout + save final position
 *    - Effect 5: Video element listeners â†’ removeEventListener (ended, error, etc.)
 *    - Effect 6: PiP listeners â†’ removeEventListener
 *
 * 4. Performance Considerations:
 *    - Throttle progress updates
 *    - Debounce auto-save
 *    - Cancel pending saves on unmount
 *
 * 5. Error Handling:
 *    - Video load errors
 *    - Fullscreen API errors
 *    - PiP not supported
 *    - localStorage errors
 *
 * âœ… Production Checklist:
 * - [ ] All intervals/timeouts cleaned up
 * - [ ] All event listeners removed
 * - [ ] Video playback stopped on unmount
 * - [ ] Auto-save executed before unmount
 * - [ ] No memory leaks
 * - [ ] Keyboard shortcuts disabled on unmount
 * - [ ] Fullscreen exited on unmount
 * - [ ] PiP closed on unmount
 * - [ ] Error boundaries (basic)
 * - [ ] Accessibility (ARIA labels)
 *
 * ğŸ“ Documentation:
 * - Comment each cleanup
 * - Explain WHY cleanup needed
 * - Document keyboard shortcuts
 */

import { useState, useEffect, useRef } from 'react';

function VideoPlayer({ src, autoplay = false }) {
  const videoRef = useRef(null);

  // Playback state
  const [isPlaying, setIsPlaying] = useState(autoplay);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [playbackRate, setPlaybackRate] = useState(1);

  // UI state
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isPiP, setIsPiP] = useState(false);
  const [showControls, setShowControls] = useState(true);

  // Auto-save state
  const [lastSaved, setLastSaved] = useState(null);

  // TODO: Effect 1 - Video Element Event Listeners
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    console.log('ğŸ¬ Setting up video listeners');

    const handleLoadedMetadata = () => {
      setDuration(video.duration);
      console.log('âœ… Video metadata loaded');
    };

    const handleEnded = () => {
      setIsPlaying(false);
      console.log('ğŸ Video ended');
    };

    const handleError = (e) => {
      console.error('âŒ Video error:', e);
      // TODO: Show error UI
    };

    // Add listeners
    video.addEventListener('loadedmetadata', handleLoadedMetadata);
    video.addEventListener('ended', handleEnded);
    video.addEventListener('error', handleError);

    // Cleanup
    return () => {
      console.log('ğŸ§¹ Cleaning up video listeners');
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
      video.removeEventListener('ended', handleEnded);
      video.removeEventListener('error', handleError);
    };
  }, [src]); // Re-setup khi video source thay Ä‘á»•i

  // TODO: Effect 2 - Play/Pause Control
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    if (isPlaying) {
      video.play().catch((err) => {
        console.error('Play error:', err);
        setIsPlaying(false);
      });
    } else {
      video.pause();
    }
  }, [isPlaying]);

  // TODO: Effect 3 - Progress Tracker
  useEffect(() => {
    if (!isPlaying) return;

    console.log('â±ï¸ Starting progress tracker');

    const intervalId = setInterval(() => {
      const video = videoRef.current;
      if (video) {
        setCurrentTime(video.currentTime);
      }
    }, 1000);

    return () => {
      console.log('ğŸ§¹ Stopping progress tracker');
      clearInterval(intervalId);
    };
  }, [isPlaying]);

  // TODO: Effect 4 - Keyboard Shortcuts
  useEffect(() => {
    console.log('âŒ¨ï¸ Setting up keyboard shortcuts');

    const handleKeyPress = (e) => {
      // Space: Play/Pause
      if (e.code === 'Space') {
        e.preventDefault();
        setIsPlaying((prev) => !prev);
      }
      // F: Fullscreen
      else if (e.code === 'KeyF') {
        e.preventDefault();
        toggleFullscreen();
      }
      // M: Mute
      else if (e.code === 'KeyM') {
        e.preventDefault();
        setVolume((prev) => (prev === 0 ? 1 : 0));
      }
      // Arrow Left: -5s
      else if (e.code === 'ArrowLeft') {
        e.preventDefault();
        const video = videoRef.current;
        if (video) video.currentTime = Math.max(0, video.currentTime - 5);
      }
      // Arrow Right: +5s
      else if (e.code === 'ArrowRight') {
        e.preventDefault();
        const video = videoRef.current;
        if (video)
          video.currentTime = Math.min(duration, video.currentTime + 5);
      }
    };

    document.addEventListener('keydown', handleKeyPress);

    return () => {
      console.log('ğŸ§¹ Removing keyboard shortcuts');
      document.removeEventListener('keydown', handleKeyPress);
    };
  }, [duration]); // duration needed for arrow keys

  // TODO: Effect 5 - Auto-save Playback Position
  useEffect(() => {
    console.log('ğŸ’¾ Setting up auto-save');

    const timeoutId = setTimeout(() => {
      // Save to localStorage
      try {
        localStorage.setItem('videoPlaybackPosition', currentTime.toString());
        setLastSaved(new Date());
        console.log('ğŸ’¾ Auto-saved position:', currentTime);
      } catch (err) {
        console.error('Save error:', err);
      }
    }, 3000); // Debounce 3s

    // Cleanup: Save immediately before unmount
    return () => {
      console.log('ğŸ§¹ Saving final position before cleanup');
      clearTimeout(timeoutId);

      try {
        localStorage.setItem('videoPlaybackPosition', currentTime.toString());
        console.log('ğŸ’¾ Final save:', currentTime);
      } catch (err) {
        console.error('Save error:', err);
      }
    };
  }, [currentTime]);

  // TODO: Effect 6 - Load Saved Position (mount only)
  useEffect(() => {
    console.log('ğŸ“‚ Loading saved position');

    try {
      const savedPosition = localStorage.getItem('videoPlaybackPosition');
      if (savedPosition && videoRef.current) {
        const position = parseFloat(savedPosition);
        videoRef.current.currentTime = position;
        setCurrentTime(position);
        console.log('âœ… Loaded position:', position);
      }
    } catch (err) {
      console.error('Load error:', err);
    }
  }, []); // Empty deps â†’ Only on mount

  // TODO: Effect 7 - Volume Sync
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      video.volume = volume;
    }
  }, [volume]);

  // TODO: Effect 8 - Playback Rate Sync
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      video.playbackRate = playbackRate;
    }
  }, [playbackRate]);

  // TODO: Effect 9 - Fullscreen Listeners
  useEffect(() => {
    console.log('ğŸ–¥ï¸ Setting up fullscreen listeners');

    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);

    // Cleanup: Exit fullscreen
    return () => {
      console.log('ğŸ§¹ Exiting fullscreen');
      document.removeEventListener('fullscreenchange', handleFullscreenChange);

      if (document.fullscreenElement) {
        document.exitFullscreen().catch((err) => {
          console.error('Exit fullscreen error:', err);
        });
      }
    };
  }, []);

  // TODO: Effect 10 - Picture-in-Picture Listeners
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    console.log('ğŸ“º Setting up PiP listeners');

    const handlePiPEnter = () => {
      setIsPiP(true);
      console.log('ğŸ“º Entered PiP');
    };

    const handlePiPLeave = () => {
      setIsPiP(false);
      console.log('ğŸ“º Left PiP');
    };

    video.addEventListener('enterpictureinpicture', handlePiPEnter);
    video.addEventListener('leavepictureinpicture', handlePiPLeave);

    // Cleanup: Exit PiP
    return () => {
      console.log('ğŸ§¹ Exiting PiP');
      video.removeEventListener('enterpictureinpicture', handlePiPEnter);
      video.removeEventListener('leavepictureinpicture', handlePiPLeave);

      if (document.pictureInPictureElement) {
        document.exitPictureInPicture().catch((err) => {
          console.error('Exit PiP error:', err);
        });
      }
    };
  }, []);

  // Helper functions
  const togglePlay = () => {
    setIsPlaying(!isPlaying);
  };

  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      videoRef.current?.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  };

  const togglePiP = async () => {
    try {
      if (document.pictureInPictureElement) {
        await document.exitPictureInPicture();
      } else {
        await videoRef.current?.requestPictureInPicture();
      }
    } catch (err) {
      console.error('PiP error:', err);
    }
  };

  const handleSeek = (e) => {
    const video = videoRef.current;
    if (video) {
      const rect = e.currentTarget.getBoundingClientRect();
      const pos = (e.clientX - rect.left) / rect.width;
      video.currentTime = pos * duration;
      setCurrentTime(pos * duration);
    }
  };

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div
      style={{
        maxWidth: '800px',
        margin: '0 auto',
        padding: '20px',
        background: '#000',
        borderRadius: '8px',
      }}
    >
      {/* Video Element */}
      <video
        ref={videoRef}
        src={src}
        style={{
          width: '100%',
          borderRadius: '4px',
          display: 'block',
        }}
        onClick={togglePlay}
      />

      {/* Controls */}
      <div
        style={{
          padding: '15px',
          background: '#1a1a1a',
          borderRadius: '0 0 8px 8px',
        }}
      >
        {/* Progress Bar */}
        <div
          onClick={handleSeek}
          style={{
            height: '8px',
            background: '#333',
            borderRadius: '4px',
            cursor: 'pointer',
            marginBottom: '15px',
            position: 'relative',
          }}
        >
          <div
            style={{
              width: `${(currentTime / duration) * 100}%`,
              height: '100%',
              background: '#4CAF50',
              borderRadius: '4px',
            }}
          />
        </div>

        {/* Time Display */}
        <div
          style={{
            color: 'white',
            fontSize: '14px',
            marginBottom: '15px',
            display: 'flex',
            justifyContent: 'space-between',
          }}
        >
          <span>{formatTime(currentTime)}</span>
          <span>{formatTime(duration)}</span>
        </div>

        {/* Control Buttons */}
        <div
          style={{
            display: 'flex',
            gap: '10px',
            alignItems: 'center',
            flexWrap: 'wrap',
          }}
        >
          <button
            onClick={togglePlay}
            style={buttonStyle}
          >
            {isPlaying ? 'â¸ï¸ Pause' : 'â–¶ï¸ Play'}
          </button>

          <button
            onClick={toggleFullscreen}
            style={buttonStyle}
          >
            {isFullscreen ? 'â¬…ï¸ Exit FS' : 'â¬†ï¸ Fullscreen'}
          </button>

          <button
            onClick={togglePiP}
            style={buttonStyle}
          >
            {isPiP ? 'ğŸ“º Exit PiP' : 'ğŸ“º PiP'}
          </button>

          {/* Volume */}
          <div style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
            <span style={{ color: 'white', fontSize: '14px' }}>ğŸ”Š</span>
            <input
              type='range'
              min='0'
              max='1'
              step='0.1'
              value={volume}
              onChange={(e) => setVolume(parseFloat(e.target.value))}
              style={{ width: '80px' }}
            />
          </div>

          {/* Playback Speed */}
          <select
            value={playbackRate}
            onChange={(e) => setPlaybackRate(parseFloat(e.target.value))}
            style={{
              padding: '5px',
              borderRadius: '4px',
              border: 'none',
            }}
          >
            <option value='0.5'>0.5x</option>
            <option value='1'>1x</option>
            <option value='1.5'>1.5x</option>
            <option value='2'>2x</option>
          </select>
        </div>

        {/* Keyboard Shortcuts Help */}
        <div
          style={{
            color: '#999',
            fontSize: '12px',
            marginTop: '15px',
            borderTop: '1px solid #333',
            paddingTop: '10px',
          }}
        >
          <strong>Shortcuts:</strong> Space=Play/Pause | F=Fullscreen | M=Mute |
          â†/â†’=Seek
        </div>

        {/* Auto-save Status */}
        {lastSaved && (
          <div
            style={{
              color: '#4CAF50',
              fontSize: '12px',
              marginTop: '5px',
            }}
          >
            âœ… Last saved: {lastSaved.toLocaleTimeString()}
          </div>
        )}
      </div>
    </div>
  );
}

const buttonStyle = {
  padding: '8px 15px',
  background: '#4CAF50',
  color: 'white',
  border: 'none',
  borderRadius: '4px',
  cursor: 'pointer',
  fontSize: '14px',
};

// Demo Wrapper
function VideoPlayerDemo() {
  const [showPlayer, setShowPlayer] = useState(true);

  return (
    <div>
      <div style={{ textAlign: 'center', marginBottom: '20px' }}>
        <button onClick={() => setShowPlayer(!showPlayer)}>
          {showPlayer ? 'Unmount Player' : 'Mount Player'}
        </button>
        <p style={{ fontSize: '14px', color: '#666', marginTop: '10px' }}>
          Click "Unmount" and watch Console for cleanup logs
        </p>
      </div>

      {showPlayer && (
        <VideoPlayer
          src='https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4'
          autoplay={false}
        />
      )}
    </div>
  );
}

export default VideoPlayerDemo;

// ğŸ“‹ TESTING CHECKLIST:
// - [ ] Play video â†’ Progress updates
// - [ ] Pause â†’ Progress stops
// - [ ] Seek â†’ Position changes
// - [ ] Volume slider works
// - [ ] Playback speed changes
// - [ ] Keyboard shortcuts functional
// - [ ] Fullscreen enter/exit
// - [ ] PiP enter/exit
// - [ ] Auto-save every 3s (check localStorage)
// - [ ] Unmount â†’ All cleanups execute (Console)
// - [ ] Unmount â†’ Final position saved
// - [ ] Remount â†’ Resumes from saved position
// - [ ] Switch video src â†’ Old listeners removed, new ones added
// - [ ] No memory leaks (check Chrome DevTools Memory)
// - [ ] No console warnings/errors

// ğŸ’¡ PRODUCTION ENHANCEMENTS:
// - Error boundaries
// - Loading states
// - Buffering indicator
// - Quality selector
// - Captions/subtitles
// - Playlist support
// - Analytics integration
// - Adaptive bitrate
```

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Common Cleanup Patterns

| Resource Type      | Setup Code                         | Cleanup Code                          | Common Mistakes                          |
| ------------------ | ---------------------------------- | ------------------------------------- | ---------------------------------------- |
| **setInterval**    | `setInterval(fn, ms)`              | `clearInterval(id)`                   | âŒ KhÃ´ng cleanup â†’ Multiple intervals    |
| **setTimeout**     | `setTimeout(fn, ms)`               | `clearTimeout(id)`                    | âŒ KhÃ´ng cleanup khi deps thay Ä‘á»•i       |
| **Event Listener** | `addEventListener(event, handler)` | `removeEventListener(event, handler)` | âŒ Handler reference khÃ¡c â†’ KhÃ´ng remove |
| **Fetch/API**      | `fetch(url)`                       | `controller.abort()`                  | âŒ setState sau unmount â†’ Warning        |
| **WebSocket**      | `new WebSocket(url)`               | `ws.close()`                          | âŒ Connection leak                       |
| **Subscription**   | `observable.subscribe(fn)`         | `subscription.unsubscribe()`          | âŒ Memory leak                           |
| **Animation**      | `requestAnimationFrame(fn)`        | `cancelAnimationFrame(id)`            | âŒ Animation continues                   |

### Báº£ng So SÃ¡nh: Cleanup Timing

| Scenario                | When Cleanup Runs                              | Example                   |
| ----------------------- | ---------------------------------------------- | ------------------------- |
| **Component Unmount**   | Before component removed from DOM              | User navigates away       |
| **Dependencies Change** | Before effect re-runs with new deps            | `[count]` â†’ count changes |
| **Effect Disabled**     | When effect condition becomes false            | `if (!enabled) return;`   |
| **Strict Mode (Dev)**   | After mount, then immediately cleanup + re-run | React 18 double-invoke    |

### Decision Tree: Khi nÃ o cáº§n Cleanup?

```
Effect táº¡o ra resource nÃ o?
â”‚
â”œâ”€ Timer (setInterval, setTimeout)?
â”‚  â†’ âœ… Báº®T BUá»˜C cleanup vá»›i clearInterval/clearTimeout
â”‚
â”œâ”€ Event listener (window, document, element)?
â”‚  â†’ âœ… Báº®T BUá»˜C removeEventListener
â”‚
â”œâ”€ Subscription (WebSocket, Observable, etc.)?
â”‚  â†’ âœ… Báº®T BUá»˜C unsubscribe/close
â”‚
â”œâ”€ Async operation (fetch, promise)?
â”‚  â”‚
â”‚  â”œâ”€ setState trong promise callback?
â”‚  â”‚  â†’ âœ… Cáº¦N cancel flag hoáº·c AbortController
â”‚  â”‚
â”‚  â””â”€ KhÃ´ng setState?
â”‚     â†’ âš ï¸ Consider cleanup náº¿u operation expensive
â”‚
â”œâ”€ DOM manipulation trá»±c tiáº¿p?
â”‚  â†’ âœ… Restore original state
â”‚
â”œâ”€ Third-party library instance?
â”‚  â†’ âœ… Call cleanup/destroy method
â”‚
â””â”€ Chá»‰ Ä‘á»c data, khÃ´ng táº¡o resource?
   â†’ âŒ KhÃ´ng cáº§n cleanup
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug #1: Handler Reference Mismatch ğŸ›

```jsx
/**
 * ğŸ› BUG: Event listener khÃ´ng Ä‘Æ°á»£c remove
 * ğŸ¯ Nhiá»‡m vá»¥: Fix handler reference
 */

function BuggyClickCounter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('âœ… Adding click listener');

    // âŒ BUG: Inline function â†’ New reference má»—i láº§n!
    window.addEventListener('click', () => {
      setCount((c) => c + 1);
    });

    return () => {
      console.log('ğŸ§¹ Removing click listener');
      // âŒ This is a DIFFERENT function â†’ KhÃ´ng remove Ä‘Æ°á»£c!
      window.removeEventListener('click', () => {
        setCount((c) => c + 1);
      });
    };
  }, []);

  return <div>Clicks: {count}</div>;
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. Unmount component â†’ Listener cÃ³ Ä‘Æ°á»£c remove khÃ´ng?
// 2. Mount láº¡i â†’ Bao nhiÃªu listeners Ä‘ang active?
// 3. Sau 5 láº§n mount/unmount â†’ Bao nhiÃªu listeners?

// ğŸ’¡ GIáº¢I THÃCH:
// - addEventListener vÃ  removeEventListener pháº£i dÃ¹ng SAME function reference
// - Inline arrow functions táº¡o new reference má»—i láº§n
// - removeEventListener vá»›i different function â†’ No effect!
// - Káº¿t quáº£: Listeners accumulate â†’ Memory leak

// âœ… FIX: Define handler outside
function Fixed() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('âœ… Adding click listener');

    // âœ… Named function vá»›i stable reference
    const handleClick = () => {
      setCount((c) => c + 1);
    };

    window.addEventListener('click', handleClick);

    return () => {
      console.log('ğŸ§¹ Removing click listener');
      window.removeEventListener('click', handleClick); // âœ… Same reference!
    };
  }, []);

  return <div>Clicks: {count}</div>;
}

// ğŸ“ BÃ€I Há»ŒC:
// - Event handlers pháº£i cÃ³ stable reference Ä‘á»ƒ remove Ä‘Æ°á»£c
// - Define handler BÃŠN TRONG effect (cÃ³ access to closure)
// - SAME handler reference trong add vÃ  remove
```

---

### Bug #2: Missing Cleanup with Dependencies ğŸ”„

```jsx
/**
 * ğŸ› BUG: Interval khÃ´ng Ä‘Æ°á»£c clear khi deps thay Ä‘á»•i
 * ğŸ¯ Nhiá»‡m vá»¥: Add proper cleanup
 */

function BuggyIntervalCounter({ interval = 1000 }) {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`âœ… Starting interval with ${interval}ms`);

    const id = setInterval(() => {
      setCount((c) => c + 1);
    }, interval);

    // âŒ BUG: KhÃ´ng cleanup khi interval prop thay Ä‘á»•i!
    // Náº¿u interval thay Ä‘á»•i tá»« 1000 â†’ 500:
    // - Effect re-runs, táº¡o interval Má»šI vá»›i 500ms
    // - NhÆ°ng interval CÅ¨ (1000ms) váº«n cháº¡y!
    // - BÃ¢y giá» cÃ³ 2 intervals cháº¡y cÃ¹ng lÃºc!
  }, [interval]); // Deps cÃ³ interval â†’ Re-run khi thay Ä‘á»•i

  return (
    <div>
      <p>Count: {count}</p>
      <p>Interval: {interval}ms</p>
    </div>
  );
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. interval thay Ä‘á»•i tá»« 1000 â†’ 500 â†’ 250 â†’ Bao nhiÃªu intervals Ä‘ang cháº¡y?
// 2. Count tÄƒng vá»›i tá»‘c Ä‘á»™ nÃ o?
// 3. Memory cÃ³ leak khÃ´ng?

// ğŸ’¡ GIáº¢I THÃCH:
// Má»—i láº§n interval thay Ä‘á»•i:
// 1. Effect re-runs
// 2. Táº¡o interval Má»šI
// 3. Interval CÅ¨ KHÃ”NG Ä‘Æ°á»£c clear â†’ Still running!
// 4. Accumulation: 1000ms + 500ms + 250ms = 3 intervals!
// 5. Count tÄƒng nhanh hÆ¡n expected

// âœ… FIX: Add cleanup
function Fixed({ interval = 1000 }) {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`âœ… Starting interval with ${interval}ms`);

    const id = setInterval(() => {
      setCount((c) => c + 1);
    }, interval);

    // âœ… Cleanup clears old interval
    return () => {
      console.log(`ğŸ§¹ Clearing interval with ${interval}ms`);
      clearInterval(id);
    };
  }, [interval]);

  return (
    <div>
      <p>Count: {count}</p>
      <p>Interval: {interval}ms</p>
    </div>
  );
}

// Console output khi interval thay Ä‘á»•i:
// âœ… Starting interval with 1000ms
// (interval changes)
// ğŸ§¹ Clearing interval with 1000ms  â† Old cleared!
// âœ… Starting interval with 500ms  â† New created!

// ğŸ“ BÃ€I Há»ŒC:
// - Dependencies thay Ä‘á»•i â†’ Effect re-runs
// - LUÃ”N cleanup old resources trÆ°á»›c khi setup new
// - Cleanup cháº¡y Tá»° Äá»˜NG trÆ°á»›c effect re-run
```

---

### Bug #3: Async setState After Unmount âš ï¸

```jsx
/**
 * ğŸ› BUG: setState trÃªn unmounted component
 * ğŸ¯ Nhiá»‡m vá»¥: Prevent vá»›i cleanup flag
 */

function BuggyDataFetcher({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('Fetching user:', userId);
    setLoading(true);

    // Simulate API call (2 seconds)
    setTimeout(() => {
      const userData = { id: userId, name: `User ${userId}` };

      // âŒ BUG: Náº¿u component unmount trong 2 giÃ¢y nÃ y
      // â†’ setState trÃªn unmounted component â†’ Warning!
      setUser(userData);
      setLoading(false);
      console.log('âœ… User loaded');
    }, 2000);

    // âŒ No cleanup!
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>User: {user?.name}</div>;
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. Mount component â†’ Unmount sau 1 giÃ¢y â†’ GÃ¬ xáº£y ra sau 2 giÃ¢y?
// 2. Console cÃ³ warning khÃ´ng?
// 3. Memory cÃ³ leak khÃ´ng?

// ğŸ’¡ GIáº¢I THÃCH:
// Timeline:
// 0s: Mount â†’ Start setTimeout (2s)
// 1s: Unmount â†’ Component gone
// 2s: setTimeout callback runs â†’ setUser() + setLoading()
// â†’ React warning: "Can't perform a React state update on an unmounted component"
// â†’ Potential memory leak (references to unmounted component)

// âœ… FIX #1: Cleanup Flag
function FixedV1({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('Fetching user:', userId);
    setLoading(true);

    let isCancelled = false; // â† Cleanup flag

    setTimeout(() => {
      const userData = { id: userId, name: `User ${userId}` };

      // âœ… Chá»‰ setState náº¿u chÆ°a cancelled
      if (!isCancelled) {
        setUser(userData);
        setLoading(false);
        console.log('âœ… User loaded');
      } else {
        console.log('ğŸ§¹ Request cancelled, skipping setState');
      }
    }, 2000);

    // Cleanup: Set flag
    return () => {
      console.log('ğŸ§¹ Cancelling request');
      isCancelled = true;
    };
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>User: {user?.name}</div>;
}

// âœ… FIX #2: AbortController (Modern, for real fetch)
function FixedV2({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('Fetching user:', userId);
    setLoading(true);

    const controller = new AbortController();

    fetch(`/api/users/${userId}`, { signal: controller.signal })
      .then((res) => res.json())
      .then((data) => {
        setUser(data);
        setLoading(false);
        console.log('âœ… User loaded');
      })
      .catch((err) => {
        if (err.name === 'AbortError') {
          console.log('ğŸ§¹ Fetch aborted');
        } else {
          console.error('Error:', err);
        }
      });

    return () => {
      console.log('ğŸ§¹ Aborting fetch');
      controller.abort();
    };
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>User: {user?.name}</div>;
}

// ğŸ“ BÃ€I Há»ŒC:
// - Async operations cáº§n cleanup Ä‘á»ƒ prevent setState sau unmount
// - Flag approach: Simple, works vá»›i má»i async code
// - AbortController: Modern, actually cancels network request
// - LUÃ”N cleanup async operations!
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u âœ… nhá»¯ng Ä‘iá»u báº¡n Ä‘Ã£ hiá»ƒu:

#### Concepts:

- [ ] TÃ´i hiá»ƒu cleanup function lÃ  gÃ¬
- [ ] TÃ´i biáº¿t khi nÃ o cleanup function cháº¡y (unmount + deps change)
- [ ] TÃ´i hiá»ƒu táº¡i sao cáº§n cleanup
- [ ] TÃ´i biáº¿t memory leak lÃ  gÃ¬ vÃ  háº­u quáº£
- [ ] TÃ´i hiá»ƒu cleanup timing (before re-run, on unmount)

#### Practices:

- [ ] TÃ´i cÃ³ thá»ƒ cleanup setInterval/setTimeout
- [ ] TÃ´i cÃ³ thá»ƒ cleanup event listeners properly
- [ ] TÃ´i biáº¿t prevent setState sau unmount
- [ ] TÃ´i sá»­ dá»¥ng AbortController cho fetch
- [ ] TÃ´i biáº¿t cleanup multiple resources

#### Debugging:

- [ ] TÃ´i nháº­n biáº¿t Ä‘Æ°á»£c memory leaks
- [ ] TÃ´i biáº¿t debug listener khÃ´ng Ä‘Æ°á»£c remove
- [ ] TÃ´i hiá»ƒu handler reference issues
- [ ] TÃ´i cÃ³ thá»ƒ trace cleanup execution
- [ ] TÃ´i biáº¿t test cleanup vá»›i unmount

---

### Code Review Checklist

Khi review code cÃ³ useEffect, kiá»ƒm tra cleanup:

#### Timers:

- [ ] setInterval â†’ clearInterval trong cleanup
- [ ] setTimeout â†’ clearTimeout trong cleanup
- [ ] requestAnimationFrame â†’ cancelAnimationFrame

#### Event Listeners:

- [ ] addEventListener â†’ removeEventListener vá»›i SAME handler
- [ ] Handler defined trong effect (stable reference)
- [ ] No inline functions trong add/remove

#### Async Operations:

- [ ] fetch â†’ AbortController cleanup
- [ ] Promises â†’ isCancelled flag
- [ ] No setState sau unmount

#### Subscriptions:

- [ ] WebSocket â†’ close() trong cleanup
- [ ] Observable â†’ unsubscribe() trong cleanup
- [ ] Third-party libs â†’ cleanup method called

#### Best Practices:

- [ ] Cleanup function ALWAYS returned náº¿u cÃ³ resources
- [ ] Console.log cleanup execution (dev)
- [ ] Comments giáº£i thÃ­ch WHY cleanup needed
- [ ] Test unmount behavior

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**BÃ i 1: Countdown Timer vá»›i Cleanup**

```jsx
/**
 * Táº¡o countdown timer:
 * - Input sá»‘ giÃ¢y countdown
 * - Button Start/Pause/Reset
 * - Auto stop khi vá» 0
 * - Cleanup interval properly
 *
 * Requirements:
 * - setInterval Ä‘á»ƒ countdown
 * - clearInterval trong cleanup
 * - Test unmount during countdown
 *
 * Hints:
 * - useEffect vá»›i [isRunning] deps
 * - Return cleanup function
 * - Functional update: setTime(t => t - 1)
 */
```

**BÃ i 2: Window Resize Handler vá»›i Debounce**

```jsx
/**
 * Táº¡o component hiá»ƒn thá»‹ window size:
 * - Track window.innerWidth vÃ  innerHeight
 * - Debounce resize events (300ms)
 * - Cleanup listener vÃ  timeout
 *
 * Requirements:
 * - addEventListener('resize', ...)
 * - removeEventListener trong cleanup
 * - setTimeout Ä‘á»ƒ debounce
 * - clearTimeout trong cleanup
 *
 * Hints:
 * - Effect vá»›i [] deps (setup once)
 * - Cleanup function removes listener
 * - Nested cleanup: clear timeout before removing listener
 */
```

---

### NÃ¢ng cao (60 phÃºt)

**BÃ i 3: Auto-save Form vá»›i Multiple Cleanups**

```jsx
/**
 * Táº¡o form tá»± Ä‘á»™ng save:
 * - Fields: name, email, message
 * - Auto-save sau 3s khÃ´ng cÃ³ thay Ä‘á»•i (debounce)
 * - Show "Saving..." indicator
 * - Cleanup: Save immediately on unmount
 *
 * Requirements:
 * - setTimeout Ä‘á»ƒ debounce save
 * - clearTimeout khi fields thay Ä‘á»•i
 * - Final save trong cleanup
 * - localStorage persistence
 *
 * Challenges:
 * - Multiple fields â†’ Single debounce
 * - Unsaved changes warning
 * - Load saved data on mount
 * - Handle localStorage errors
 */
```

**BÃ i 4: Live Search vá»›i Cancel**

```jsx
/**
 * Táº¡o live search vá»›i API:
 * - Input field
 * - Debounce 500ms
 * - Cancel pending requests khi query thay Ä‘á»•i
 * - Cleanup táº¥t cáº£
 *
 * Requirements:
 * - setTimeout debounce
 * - AbortController Ä‘á»ƒ cancel fetch
 * - Cleanup: clear timeout + abort fetch
 * - No setState sau unmount
 *
 * Challenges:
 * - Race conditions
 * - Loading states
 * - Error handling
 * - Empty results
 */
```

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - useEffect Cleanup**
   - https://react.dev/reference/react/useEffect#cleanup-function
   - Äá»c ká»¹ pháº§n Cleanup
   - Examples vá»›i timers, listeners

2. **Synchronizing with Effects**
   - https://react.dev/learn/synchronizing-with-effects
   - Effect lifecycle
   - When cleanup runs

### Äá»c thÃªm

3. **AbortController MDN**
   - https://developer.mozilla.org/en-US/docs/Web/API/AbortController
   - How to cancel fetch requests
   - Browser support

4. **Memory Leaks in React**
   - Common patterns that leak
   - Detection vá»›i Chrome DevTools
   - Prevention strategies

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (Ä‘Ã£ há»c):

- **NgÃ y 16:** useEffect Introduction
  - ÄÃ£ há»c: Effect basic syntax
  - Káº¿t ná»‘i: HÃ´m nay complete vá»›i cleanup

- **NgÃ y 17:** Dependencies Deep Dive
  - ÄÃ£ há»c: When effects re-run
  - Káº¿t ná»‘i: Cleanup cháº¡y trÆ°á»›c re-run

### HÆ°á»›ng tá»›i (sáº½ há»c):

- **NgÃ y 19-20:** Data Fetching
  - Sáº½ há»c: API calls trong effects
  - Sáº½ dÃ¹ng: Cleanup Ä‘á»ƒ cancel requests

- **NgÃ y 21:** useRef
  - Sáº½ há»c: Persist values without re-render
  - Sáº½ dÃ¹ng: Alternative to isCancelled flag

- **NgÃ y 24:** Custom Hooks
  - Sáº½ há»c: Extract cleanup logic
  - Sáº½ dÃ¹ng: useDebounce, useInterval custom hooks

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. Cleanup Checklist Template:**

```jsx
useEffect(() => {
  // âœ… Setup
  const resource = setupResource();

  // âœ… Cleanup checklist:
  return () => {
    // 1. Clear timers
    clearInterval(intervalId);
    clearTimeout(timeoutId);

    // 2. Remove listeners
    element.removeEventListener('event', handler);

    // 3. Close connections
    websocket.close();

    // 4. Cancel async
    controller.abort();

    // 5. Cleanup third-party
    library.destroy();

    // 6. Final sync (save data, send analytics)
    finalSave();
  };
}, [deps]);
```

**2. Debugging Cleanup:**

```jsx
useEffect(() => {
  const DEBUG = process.env.NODE_ENV === 'development';

  if (DEBUG) console.log('[Effect] Setup:', { deps });

  // Setup code

  return () => {
    if (DEBUG) console.log('[Cleanup] Running:', { deps });
    // Cleanup code
  };
}, [deps]);
```

**3. Testing Cleanup:**

```jsx
// Test cleanup manually
function TestCleanup() {
  const [show, setShow] = useState(true);

  return (
    <>
      <button onClick={() => setShow(!show)}>Toggle (triggers cleanup)</button>
      {show && <ComponentWithCleanup />}
    </>
  );
}
```

---

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

1. **Q:** Cleanup function lÃ  gÃ¬?
   **A:** Function Ä‘Æ°á»£c return tá»« useEffect Ä‘á»ƒ dá»n dáº¹p side effects (timers, listeners, etc.). Cháº¡y trÆ°á»›c khi effect re-run vÃ  khi component unmount.

2. **Q:** Khi nÃ o cáº§n cleanup?
   **A:** Khi effect táº¡o resources cáº§n Ä‘Æ°á»£c dá»n dáº¹p: timers (setInterval/setTimeout), event listeners, subscriptions, async operations cÃ³ setState.

3. **Q:** LÃ m sao cleanup event listener?
   **A:**
   ```jsx
   useEffect(() => {
     const handler = () => {
       /* ... */
     };
     window.addEventListener('event', handler);
     return () => window.removeEventListener('event', handler);
   }, []);
   ```

**Mid Level:**

4. **Q:** Táº¡i sao cleanup cháº¡y trÆ°á»›c effect re-run?
   **A:** Äá»ƒ dá»n dáº¹p old setup trÆ°á»›c khi táº¡o new setup. Prevents resource leaks vÃ  conflicts giá»¯a old vÃ  new effects.

5. **Q:** LÃ m sao prevent setState sau unmount?
   **A:** DÃ¹ng cleanup flag:
   ```jsx
   useEffect(() => {
     let isCancelled = false;
     fetchData().then((data) => {
       if (!isCancelled) setState(data);
     });
     return () => {
       isCancelled = true;
     };
   }, []);
   ```

**Senior Level:**

6. **Q:** Handle cleanup cho complex async workflows?
   **A:**
