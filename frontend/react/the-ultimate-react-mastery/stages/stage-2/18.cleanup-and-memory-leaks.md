# ğŸ“… NGÃ€Y 18: Cleanup & Memory Leaks

## ğŸ“ Phase 2, Tuáº§n 5, NgÃ y 18 cá»§a 45

## â±ï¸ Thá»i lÆ°á»£ng: 3-4 giá»

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] Hiá»ƒu **Cleanup Function** lÃ  gÃ¬ vÃ  táº¡i sao cáº§n thiáº¿t
- [ ] Biáº¿t khi nÃ o cleanup function cháº¡y (timing critical!)
- [ ] NgÄƒn cháº·n **Memory Leaks** vá»›i timers, event listeners, subscriptions
- [ ] Xá»­ lÃ½ **Async Operations Cleanup** (cancel pending requests)
- [ ] Ãp dá»¥ng cleanup patterns cho production code

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i sau:

1. **CÃ¢u 1:** Náº¿u báº¡n dÃ¹ng `setInterval` trong useEffect, Ä‘iá»u gÃ¬ xáº£y ra khi component unmount?
   - _ÄÃ¡p Ã¡n: Interval váº«n cháº¡y â†’ Memory leak! (NgÃ y 18 sáº½ fix)_

2. **CÃ¢u 2:** Khi dependencies thay Ä‘á»•i, effect cháº¡y láº¡i. Váº­y effect CÅ¨ cÃ³ bá»‹ "dá»n dáº¹p" khÃ´ng?
   - _ÄÃ¡p Ã¡n: ChÆ°a biáº¿t cÃ¡ch! (HÃ´m nay há»c cleanup)_

3. **CÃ¢u 3:** API call Ä‘ang pending, nhÆ°ng user navigate away. CÃ³ váº¥n Ä‘á» gÃ¬?
   - _ÄÃ¡p Ã¡n: setState trÃªn unmounted component â†’ Warning! (Cleanup sáº½ giáº£i quyáº¿t)_

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

HÃ£y xem Ä‘oáº¡n code nÃ y:

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setSeconds((s) => s + 1);
    }, 1000);

    // âŒ PROBLEM: KhÃ´ng cleanup!
  }, []);

  return <div>Seconds: {seconds}</div>;
}

function App() {
  const [showTimer, setShowTimer] = useState(true);

  return (
    <div>
      <button onClick={() => setShowTimer(!showTimer)}>Toggle Timer</button>
      {showTimer && <Timer />}
    </div>
  );
}
```

**Váº¥n Ä‘á»:**

1. Click "Toggle Timer" â†’ Timer component unmount
2. NhÆ°ng `setInterval` VáºªN CHáº Y! (khÃ´ng ai dá»«ng nÃ³)
3. Interval cá»‘ gáº¯ng gá»i `setSeconds` trÃªn component Ä‘Ã£ unmount
4. **Memory leak** + Console warning: "Can't perform a React state update on an unmounted component"

**Káº¿t quáº£:**

- Memory leak (interval khÃ´ng bao giá» dá»«ng)
- Potential crashes
- Performance degradation
- Battery drain (mobile)

---

### 1.2 Giáº£i PhÃ¡p: Cleanup Function

**Cleanup Function** lÃ  function mÃ  effect **RETURN** Ä‘á»ƒ dá»n dáº¹p side effects.

**CÃº phÃ¡p:**

```jsx
useEffect(() => {
  // Setup code
  const id = setInterval(() => {
    // ...
  }, 1000);

  // Cleanup function
  return () => {
    clearInterval(id); // â† Dá»n dáº¹p
  };
}, []);
```

**Cleanup Function cháº¡y khi:**

1. **Component unmount** (component bá»‹ remove khá»i DOM)
2. **Dependencies thay Ä‘á»•i** (trÆ°á»›c khi effect cháº¡y láº¡i)

**GIáº¢I PHÃP cho Timer:**

```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    console.log('âœ… Effect: Setup interval');

    const id = setInterval(() => {
      setSeconds((s) => s + 1);
    }, 1000);

    // âœ… Cleanup function
    return () => {
      console.log('ğŸ§¹ Cleanup: Clear interval');
      clearInterval(id);
    };
  }, []);

  return <div>Seconds: {seconds}</div>;
}

// BEHAVIOR:
// Mount â†’ Setup interval
// Unmount â†’ Cleanup (clear interval) âœ…
// No memory leak! âœ…
```

---

### 1.3 Mental Model: Setup & Cleanup Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           EFFECT LIFECYCLE WITH CLEANUP                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SCENARIO 1: Component Mount â†’ Unmount
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Component mounts
   â†“
2. Render
   â†“
3. Browser paints
   â†“
4. useEffect runs (SETUP)
   - Create interval, add listener, etc.
   â†“
5. ... Component exists ...
   â†“
6. Component unmounts
   â†“
7. Cleanup function runs (CLEANUP)
   - Clear interval, remove listener, etc.
   â†“
8. Component gone âœ…

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SCENARIO 2: Dependencies Change
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Effect runs vá»›i deps = [A]
   - Setup vá»›i A
   â†“
2. ... Time passes ...
   â†“
3. Deps thay Ä‘á»•i: A â†’ B
   â†“
4. Cleanup runs (cleanup OLD setup vá»›i A) ğŸ§¹
   â†“
5. Effect runs láº¡i (setup NEW vá»›i B) âœ…
   â†“
6. ... And so on ...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KEY INSIGHT:
Cleanup ALWAYS cháº¡y TRÆ¯á»šC khi effect cháº¡y láº¡i!
â†’ Old effect cleaned up BEFORE new effect sets up
â†’ Prevents resource leaks
```

**Analogy dá»… hiá»ƒu:**

> Effect nhÆ° thuÃª phÃ²ng khÃ¡ch sáº¡n:
>
> 1. Check-in (Setup): Nháº­n chÃ¬a khÃ³a, báº­t Ä‘Ã¨n, má»Ÿ Ä‘iá»u hÃ²a
> 2. á» trong phÃ²ng (Effect active)
> 3. Check-out (Cleanup): Tráº£ chÃ¬a khÃ³a, táº¯t Ä‘Ã¨n, táº¯t Ä‘iá»u hÃ²a
>
> Náº¿u khÃ´ng check-out (no cleanup):
>
> - ÄÃ¨n váº«n chÃ¡y (waste energy)
> - PhÃ²ng locked (resource not freed)
> - Hotel bill keeps going (memory leak!)

---

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

#### âŒ Hiá»ƒu láº§m #1: "Cleanup chá»‰ cháº¡y khi unmount"

```jsx
function Wrong() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('Effect with count:', count);

    return () => {
      console.log('Cleanup'); // Cháº¡y TRÆ¯á»šC má»—i effect re-run!
    };
  }, [count]); // â† Deps cÃ³ count

  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}

// Console output khi click 3 láº§n:
// Effect with count: 0
// (click)
// Cleanup           â† Cleanup OLD effect (count = 0)
// Effect with count: 1  â† New effect (count = 1)
// (click)
// Cleanup           â† Cleanup OLD (count = 1)
// Effect with count: 2  â† New effect (count = 2)
// (unmount)
// Cleanup           â† Final cleanup
```

**âœ… ÄÃºng:** Cleanup cháº¡y:

- TrÆ°á»›c má»—i effect re-run (khi deps thay Ä‘á»•i)
- Khi component unmount

---

#### âŒ Hiá»ƒu láº§m #2: "Cleanup lÃ  optional"

```jsx
// âŒ DANGEROUS: No cleanup
function Dangerous() {
  useEffect(() => {
    window.addEventListener('scroll', handleScroll);
    // KhÃ´ng remove listener â†’ Memory leak!
  }, []);
}

// âœ… SAFE: Always cleanup
function Safe() {
  useEffect(() => {
    window.addEventListener('scroll', handleScroll);

    return () => {
      window.removeEventListener('scroll', handleScroll); // âœ…
    };
  }, []);
}
```

**Rule:** Náº¿u effect táº¡o resource (timer, listener, subscription), Báº®T BUá»˜C pháº£i cleanup!

---

#### âŒ Hiá»ƒu láº§m #3: "Cleanup cháº¡y synchronously"

```jsx
function Wrong() {
  useEffect(() => {
    console.log('1. Effect runs');

    return () => {
      console.log('3. Cleanup runs'); // Cháº¡y SAU, khÃ´ng pháº£i ngay
    };
  }, []);

  console.log('2. Render completes');
}

// Output:
// 2. Render completes
// 1. Effect runs
// (later, on unmount)
// 3. Cleanup runs
```

**âœ… ÄÃºng:** Cleanup lÃ  async, cháº¡y SAU khi cáº§n (unmount hoáº·c deps change).

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Pattern CÆ¡ Báº£n - Timer Cleanup â­

```jsx
/**
 * Demo: setInterval vá»›i cleanup proper
 * Concepts: Cleanup timing, clearInterval
 */

import { useState, useEffect } from 'react';

function TimerWithCleanup() {
  const [seconds, setSeconds] = useState(0);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    if (!isRunning) return; // Don't setup náº¿u paused

    console.log('âœ… Setting up interval');

    const intervalId = setInterval(() => {
      setSeconds((s) => s + 1);
      console.log('â±ï¸ Tick');
    }, 1000);

    // Cleanup function
    return () => {
      console.log('ğŸ§¹ Cleaning up interval:', intervalId);
      clearInterval(intervalId);
    };
  }, [isRunning]); // Re-run khi isRunning thay Ä‘á»•i

  return (
    <div>
      <h2>Timer with Cleanup</h2>
      <p>Seconds: {seconds}</p>

      <button onClick={() => setIsRunning(!isRunning)}>
        {isRunning ? 'â¸ï¸ Pause' : 'â–¶ï¸ Start'}
      </button>

      <button onClick={() => setSeconds(0)}>ğŸ”„ Reset</button>

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>ğŸ“‹ Test Instructions:</h3>
        <ol>
          <li>Má»Ÿ Console</li>
          <li>Click Start â†’ Interval Ä‘Æ°á»£c táº¡o</li>
          <li>Click Pause â†’ Cleanup cháº¡y, interval cleared</li>
          <li>Click Start láº¡i â†’ Interval Má»šI Ä‘Æ°á»£c táº¡o</li>
        </ol>

        <h3>ğŸ” Observations:</h3>
        <ul>
          <li>âœ… Má»—i láº§n pause â†’ Cleanup removes old interval</li>
          <li>âœ… KhÃ´ng cÃ³ interval nÃ o "leak"</li>
          <li>âœ… Console.log clear patterns</li>
        </ul>
      </div>
    </div>
  );
}

export default TimerWithCleanup;
```

---

### Demo 2: Ká»‹ch Báº£n Thá»±c Táº¿ - Event Listener Cleanup â­â­

```jsx
/**
 * Demo: Event listeners cleanup
 * Use case: Window events, keyboard shortcuts
 */

import { useState, useEffect } from 'react';

function MouseTracker() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isTracking, setIsTracking] = useState(true);

  useEffect(() => {
    if (!isTracking) return;

    console.log('âœ… Adding mousemove listener');

    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };

    window.addEventListener('mousemove', handleMouseMove);

    // âœ… CLEANUP: Remove listener
    return () => {
      console.log('ğŸ§¹ Removing mousemove listener');
      window.removeEventListener('mousemove', handleMouseMove);
    };
  }, [isTracking]);

  return (
    <div>
      <h2>Mouse Tracker</h2>

      <p>
        Mouse Position: ({position.x}, {position.y})
      </p>

      <button onClick={() => setIsTracking(!isTracking)}>
        {isTracking ? 'â¸ï¸ Stop Tracking' : 'â–¶ï¸ Start Tracking'}
      </button>

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>âš ï¸ Without Cleanup:</h3>
        <ul>
          <li>âŒ Listener stays attached forever</li>
          <li>âŒ Multiple listeners accumulate</li>
          <li>âŒ Memory leak</li>
          <li>âŒ Performance degradation</li>
        </ul>

        <h3>âœ… With Cleanup:</h3>
        <ul>
          <li>âœ… Listener removed when not needed</li>
          <li>âœ… No accumulation</li>
          <li>âœ… Clean memory</li>
          <li>âœ… Optimal performance</li>
        </ul>
      </div>
    </div>
  );
}

// ğŸ”¥ ADVANCED: Multiple listeners
function KeyboardShortcuts() {
  const [keys, setKeys] = useState([]);

  useEffect(() => {
    console.log('âœ… Setting up keyboard listeners');

    const handleKeyDown = (e) => {
      setKeys((prev) => [...prev, `${e.key} (down)`].slice(-5));
    };

    const handleKeyUp = (e) => {
      setKeys((prev) => [...prev, `${e.key} (up)`].slice(-5));
    };

    // Add MULTIPLE listeners
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    // Cleanup BOTH listeners
    return () => {
      console.log('ğŸ§¹ Removing keyboard listeners');
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []); // Empty deps â†’ Setup once

  return (
    <div>
      <h2>Keyboard Shortcuts</h2>
      <p>Press any key...</p>

      <div>
        <h3>Recent Keys:</h3>
        <ul>
          {keys.map((key, i) => (
            <li key={i}>{key}</li>
          ))}
        </ul>
      </div>

      <p>ğŸ’¡ Notice: Both keydown AND keyup listeners cleaned up together</p>
    </div>
  );
}

export default MouseTracker;
```

---

### Demo 3: Edge Cases - Async Cleanup & Race Conditions â­â­â­

```jsx
/**
 * Demo: Cleanup async operations
 * Edge case: Cancel pending API calls, avoid setState on unmounted component
 */

import { useState, useEffect } from 'react';

// Mock API vá»›i delay
const fetchUser = (userId) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({
        id: userId,
        name: `User ${userId}`,
        email: `user${userId}@example.com`,
      });
    }, 2000); // 2 second delay
  });
};

// âŒ VERSION 1: Without Cleanup (BUGGY!)
function UserProfileBuggy({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('Fetching user:', userId);
    setLoading(true);

    fetchUser(userId).then((data) => {
      // âš ï¸ PROBLEM: Náº¿u component unmount trÆ°á»›c khi promise resolve
      // â†’ setState trÃªn unmounted component â†’ Warning!
      setUser(data);
      setLoading(false);
      console.log('âœ… User loaded:', data.id);
    });

    // âŒ No cleanup!
  }, [userId]);

  if (loading) return <div>Loading user {userId}...</div>;
  return (
    <div>
      <h3>{user?.name}</h3>
      <p>{user?.email}</p>
    </div>
  );
}

// âœ… VERSION 2: With Cleanup (FIXED!)
function UserProfileFixed({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('âœ… Fetching user:', userId);
    setLoading(true);

    // Flag Ä‘á»ƒ track náº¿u component váº«n mounted
    let isCancelled = false;

    fetchUser(userId).then((data) => {
      // Chá»‰ update state náº¿u CHÆ¯A cleanup
      if (!isCancelled) {
        setUser(data);
        setLoading(false);
        console.log('âœ… User loaded:', data.id);
      } else {
        console.log('ğŸ§¹ Request cancelled for user:', data.id);
      }
    });

    // Cleanup: Set flag
    return () => {
      console.log('ğŸ§¹ Cleanup: Cancelling request for user:', userId);
      isCancelled = true;
    };
  }, [userId]);

  if (loading) return <div>Loading user {userId}...</div>;
  return (
    <div>
      <h3>{user?.name}</h3>
      <p>{user?.email}</p>
    </div>
  );
}

// ğŸ”¥ VERSION 3: With AbortController (MODERN!)
function UserProfileModern({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    console.log('âœ… Fetching user:', userId);
    setLoading(true);
    setError(null);

    // Create AbortController
    const controller = new AbortController();

    // Fetch vá»›i signal
    fetch(`/api/users/${userId}`, {
      signal: controller.signal,
    })
      .then((res) => res.json())
      .then((data) => {
        setUser(data);
        setLoading(false);
        console.log('âœ… User loaded:', data.id);
      })
      .catch((err) => {
        if (err.name === 'AbortError') {
          console.log('ğŸ§¹ Request aborted for user:', userId);
        } else {
          setError(err.message);
          setLoading(false);
        }
      });

    // Cleanup: Abort request
    return () => {
      console.log('ğŸ§¹ Aborting request for user:', userId);
      controller.abort();
    };
  }, [userId]);

  if (loading) return <div>Loading user {userId}...</div>;
  if (error) return <div>Error: {error}</div>;
  return (
    <div>
      <h3>{user?.name}</h3>
      <p>{user?.email}</p>
    </div>
  );
}

// Demo Component
function AsyncCleanupDemo() {
  const [userId, setUserId] = useState(1);
  const [showProfile, setShowProfile] = useState(true);

  return (
    <div>
      <h2>Async Cleanup Demo</h2>

      <div>
        <button onClick={() => setUserId(userId + 1)}>
          Next User ({userId + 1})
        </button>
        <button onClick={() => setShowProfile(!showProfile)}>
          {showProfile ? 'Hide' : 'Show'} Profile
        </button>
      </div>

      {showProfile && <UserProfileFixed userId={userId} />}

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>ğŸ§ª Test Race Condition:</h3>
        <ol>
          <li>Click "Next User" nhiá»u láº§n NHANH (má»—i 0.5s)</li>
          <li>Hoáº·c click "Hide Profile" trong khi loading</li>
        </ol>

        <h3>ğŸ“‹ Expected Behavior:</h3>
        <ul>
          <li>âœ… Old requests marked as cancelled</li>
          <li>âœ… No setState on unmounted component</li>
          <li>âœ… Only latest request updates state</li>
          <li>âœ… No console warnings</li>
        </ul>

        <h3>ğŸ¯ Cleanup Strategies:</h3>
        <ul>
          <li>
            <strong>v1 (Buggy):</strong> No cleanup â†’ Warnings
          </li>
          <li>
            <strong>v2 (Flag):</strong> isCancelled flag â†’ Works!
          </li>
          <li>
            <strong>v3 (AbortController):</strong> Actually cancel request â†’
            Best!
          </li>
        </ul>
      </div>
    </div>
  );
}

export default AsyncCleanupDemo;
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Level 1: Ãp Dá»¥ng Concept (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Practice cleanup vá»›i setTimeout
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useRef, custom hooks
 *
 * Requirements:
 * 1. Notification component tá»± Ä‘á»™ng áº©n sau 3 giÃ¢y
 * 2. DÃ¹ng setTimeout trong useEffect
 * 3. Cleanup timeout khi component unmount
 * 4. Cleanup timeout khi message thay Ä‘á»•i (show new notification)
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - setTimeout return timeoutId
 * - clearTimeout(timeoutId) Ä‘á»ƒ cleanup
 * - Dependencies: [message]
 */

// âŒ CÃ¡ch SAI (Anti-pattern):
function WrongNotification({ message }) {
  const [visible, setVisible] = useState(true);

  useEffect(() => {
    // âŒ No cleanup â†’ Timeout váº«n cháº¡y sau unmount!
    setTimeout(() => {
      setVisible(false);
    }, 3000);
  }, [message]);

  if (!visible) return null;
  return <div className='notification'>{message}</div>;
}

// Táº¡i sao sai?
// - Náº¿u message thay Ä‘á»•i trong 3 giÃ¢y â†’ Multiple timeouts!
// - Náº¿u component unmount â†’ Timeout váº«n cháº¡y â†’ setState warning
// - Memory leak

// âœ… CÃ¡ch ÄÃšNG (Best practice):
function CorrectNotification({ message }) {
  const [visible, setVisible] = useState(true);

  useEffect(() => {
    // Reset visible khi message thay Ä‘á»•i
    setVisible(true);

    const timeoutId = setTimeout(() => {
      setVisible(false);
    }, 3000);

    // âœ… Cleanup timeout
    return () => {
      clearTimeout(timeoutId);
    };
  }, [message]); // Re-run khi message thay Ä‘á»•i

  if (!visible) return null;
  return (
    <div
      style={{
        padding: '10px 20px',
        background: '#4CAF50',
        color: 'white',
        borderRadius: '4px',
        margin: '10px 0',
      }}
    >
      {message}
    </div>
  );
}

// Táº¡i sao tá»‘t hÆ¡n?
// âœ… Old timeout cleared khi message thay Ä‘á»•i
// âœ… Timeout cleared khi unmount
// âœ… No memory leaks
// âœ… No warnings

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
function Notification({ message, duration = 3000 }) {
  // TODO: State cho visible

  // TODO: useEffect vá»›i setTimeout
  // - Set visible = true khi message thay Ä‘á»•i
  // - setTimeout Ä‘á»ƒ set visible = false sau `duration`
  // - Return cleanup function Ä‘á»ƒ clearTimeout

  // TODO: Render notification náº¿u visible

  return null; // Replace this
}

// Test Component
function NotificationDemo() {
  const [message, setMessage] = useState('');
  const [count, setCount] = useState(0);

  const showNotification = () => {
    setMessage(`Notification #${count + 1}`);
    setCount(count + 1);
  };

  return (
    <div>
      <h2>Auto-Hide Notification</h2>

      <button onClick={showNotification}>Show Notification</button>

      <Notification
        message={message}
        duration={3000}
      />

      <div style={{ marginTop: '20px' }}>
        <h3>âœ… Test Checklist:</h3>
        <ul>
          <li>Click button â†’ Notification appears</li>
          <li>Wait 3s â†’ Notification hides</li>
          <li>Click again quickly (before 3s) â†’ Old notification replaced</li>
          <li>Console: No warnings</li>
        </ul>
      </div>
    </div>
  );
}
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Notification component with auto-hide after duration
 * - Shows message when received
 * - Automatically hides after duration ms
 * - Cleans up timeout when message changes or component unmounts
 * - Prevents memory leaks and setState on unmounted component
 */
function Notification({ message, duration = 3000 }) {
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    // Khi message thay Ä‘á»•i â†’ hiá»ƒn thá»‹ láº¡i vÃ  báº¯t Ä‘áº§u Ä‘áº¿m ngÆ°á»£c
    if (message) {
      setVisible(true);

      const timeoutId = setTimeout(() => {
        setVisible(false);
      }, duration);

      // Cleanup: há»§y timeout cÅ© khi message thay Ä‘á»•i hoáº·c unmount
      return () => {
        clearTimeout(timeoutId);
      };
    }
  }, [message, duration]);

  if (!visible || !message) return null;

  return (
    <div
      style={{
        padding: '12px 20px',
        background: '#4CAF50',
        color: 'white',
        borderRadius: '6px',
        margin: '12px 0',
        boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
      }}
    >
      {message}
    </div>
  );
}
```

</details>

---

### â­â­ Level 2: Nháº­n Biáº¿t Pattern (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Cleanup multiple resources
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: Debounced search vá»›i multiple cleanups
 * YÃªu cáº§u:
 * - Debounce input (500ms)
 * - Cancel pending searches
 * - Cleanup event listeners
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 *
 * RESOURCES cáº§n cleanup:
 * 1. setTimeout (debounce timer)
 * 2. Fetch request (if using AbortController)
 * 3. Event listeners (náº¿u cÃ³)
 *
 * APPROACH: Single effect vá»›i multiple cleanups
 * - Return cleanup function
 * - Cleanup ALL resources trong Ä‘Ã³
 * - Order matters? KhÃ´ng, nhÆ°ng nÃªn cÃ³ comment
 *
 * ğŸ’­ IMPLEMENT STRATEGY
 */

// Mock search API
const searchProducts = (query) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      const products = [
        'iPhone 15',
        'iPhone 14',
        'iPad Pro',
        'iPad Air',
        'MacBook Pro',
        'MacBook Air',
        'AirPods Pro',
      ];
      const filtered = products.filter((p) =>
        p.toLowerCase().includes(query.toLowerCase()),
      );
      resolve(filtered);
    }, 1000);
  });
};

function DebouncedSearch() {
  const [query, setQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);

  // TODO: Effect 1 - Debounce query
  useEffect(() => {
    // TODO:
    // 1. Set isSearching = true
    // 2. setTimeout 500ms Ä‘á»ƒ setDebouncedQuery
    // 3. Return cleanup Ä‘á»ƒ clearTimeout
    // Dependencies: [query]
  }, [query]);

  // TODO: Effect 2 - Search khi debouncedQuery thay Ä‘á»•i
  useEffect(() => {
    // TODO:
    // 1. Náº¿u debouncedQuery empty â†’ Clear results
    // 2. Náº¿u cÃ³ query â†’ Call searchProducts
    // 3. DÃ¹ng isCancelled flag Ä‘á»ƒ prevent setState sau unmount
    // 4. Return cleanup Ä‘á»ƒ set isCancelled = true
    // Dependencies: [debouncedQuery]
  }, [debouncedQuery]);

  return (
    <div>
      <h2>Debounced Search</h2>

      <input
        type='text'
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search products...'
        style={{ padding: '10px', width: '300px', fontSize: '16px' }}
      />

      {isSearching && <p>ğŸ” Searching...</p>}

      <div>
        <h3>Results:</h3>
        {results.length > 0 ? (
          <ul>
            {results.map((product, i) => (
              <li key={i}>{product}</li>
            ))}
          </ul>
        ) : (
          debouncedQuery && <p>No results found.</p>
        )}
      </div>

      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>ğŸ§ª Test Cleanup:</h3>
        <ol>
          <li>Type "iphone" NHANH (má»—i 100ms má»™t chá»¯)</li>
          <li>Console: Chá»‰ 1 search SAU KHI ngá»«ng typing 500ms</li>
          <li>Type "ip" â†’ Wait â†’ "ad" â†’ 2 searches (debounced)</li>
          <li>Clear input nhanh â†’ Search cancelled</li>
        </ol>

        <h3>ğŸ“‹ Cleanup Points:</h3>
        <ul>
          <li>âœ… Timeout cleared khi typing continues</li>
          <li>âœ… Search cancelled khi new query arrives</li>
          <li>âœ… No setState on unmounted component</li>
        </ul>
      </div>
    </div>
  );
}

export default DebouncedSearch;
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Debounced Search component
 * - Debounces input changes (500ms)
 * - Cancels pending searches when new query arrives
 * - Cleans up debounce timeout and fetch cancellation
 * - Prevents setState on unmounted component
 */
function DebouncedSearch() {
  const [query, setQuery] = useState('');
  const [debouncedQuery, setDebouncedQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);

  // Effect 1: Debounce input
  useEffect(() => {
    setIsSearching(true);

    const timeoutId = setTimeout(() => {
      setDebouncedQuery(query);
    }, 500);

    return () => {
      clearTimeout(timeoutId);
      setIsSearching(false);
    };
  }, [query]);

  // Effect 2: Perform search when debounced query changes
  useEffect(() => {
    if (!debouncedQuery.trim()) {
      setResults([]);
      setIsSearching(false);
      return;
    }

    let isCancelled = false;
    setIsSearching(true);

    searchProducts(debouncedQuery)
      .then((data) => {
        if (!isCancelled) {
          setResults(data);
          setIsSearching(false);
        }
      })
      .catch((err) => {
        if (!isCancelled) {
          console.error('Search error:', err);
          setIsSearching(false);
        }
      });

    return () => {
      isCancelled = true;
      setIsSearching(false);
    };
  }, [debouncedQuery]);

  return (
    <div>
      <h2>Debounced Search</h2>
      <input
        type='text'
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder='Search products...'
      />
      {isSearching && <p>ğŸ” Searching...</p>}
      <div>
        <h3>Results:</h3>
        {results.length > 0 ? (
          <ul>
            {results.map((product, i) => (
              <li key={i}>{product}</li>
            ))}
          </ul>
        ) : (
          debouncedQuery && <p>No results found.</p>
        )}
      </div>
    </div>
  );
}
```

</details>

---

### â­â­â­ Level 3: Ká»‹ch Báº£n Thá»±c Táº¿ (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Real-time Chat Subscription
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  user, tÃ´i muá»‘n nháº­n messages real-time
 * tá»« chat room, vÃ  unsubscribe khi rá»i khá»i room"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Subscribe to chat room khi component mount
 * - [ ] Receive vÃ  display messages real-time
 * - [ ] Unsubscribe khi switch rooms
 * - [ ] Unsubscribe khi component unmount
 * - [ ] No memory leaks
 * - [ ] Handle connection errors
 *
 * ğŸ¨ Technical Constraints:
 * - Simulate WebSocket vá»›i setInterval
 * - Cleanup subscription properly
 * - Handle multiple room switches
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Switch room nhanh (< 1s) â†’ Cancel old subscription
 * - Component unmount while receiving â†’ No setState
 * - Reconnection logic (optional)
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] State cho messages array
 * - [ ] State cho current room
 * - [ ] Effect Ä‘á»ƒ subscribe/unsubscribe
 * - [ ] Cleanup function comprehensive
 * - [ ] UI cho room selection
 */

// Mock Chat Service
class ChatService {
  constructor() {
    this.subscriptions = new Map();
  }

  subscribe(roomId, callback) {
    console.log(`ğŸ“¡ Subscribing to room: ${roomId}`);

    // Simulate receiving messages every 2 seconds
    const intervalId = setInterval(() => {
      const message = {
        id: Date.now(),
        roomId,
        text: `Message from ${roomId} at ${new Date().toLocaleTimeString()}`,
        sender: `User${Math.floor(Math.random() * 10)}`,
      };
      callback(message);
    }, 2000);

    this.subscriptions.set(roomId, intervalId);

    // Return unsubscribe function
    return () => {
      console.log(`ğŸ“´ Unsubscribing from room: ${roomId}`);
      clearInterval(intervalId);
      this.subscriptions.delete(roomId);
    };
  }
}

const chatService = new ChatService();

// ğŸ¯ STARTER CODE:
function ChatRoom() {
  const [currentRoom, setCurrentRoom] = useState('general');
  const [messages, setMessages] = useState([]);
  const [isConnected, setIsConnected] = useState(false);

  // TODO: Effect - Subscribe to chat room
  useEffect(() => {
    console.log(`âœ… Setting up subscription for room: ${currentRoom}`);
    setIsConnected(true);
    setMessages([]); // Clear old messages

    // Subscribe to room
    const unsubscribe = chatService.subscribe(currentRoom, (message) => {
      // TODO: Add message to state
      // Hint: setMessages(prev => [...prev, message])
    });

    // TODO: Cleanup function
    return () => {
      console.log(`ğŸ§¹ Cleaning up subscription for room: ${currentRoom}`);
      unsubscribe(); // Call unsubscribe function
      setIsConnected(false);
    };
  }, [currentRoom]); // Re-subscribe khi room thay Ä‘á»•i

  const rooms = ['general', 'random', 'tech', 'sports'];

  return (
    <div style={{ maxWidth: '600px', margin: '0 auto', padding: '20px' }}>
      <h2>Real-time Chat Room</h2>

      {/* Room Selection */}
      <div style={{ marginBottom: '20px' }}>
        <strong>Select Room:</strong>
        <div style={{ display: 'flex', gap: '10px', marginTop: '10px' }}>
          {rooms.map((room) => (
            <button
              key={room}
              onClick={() => setCurrentRoom(room)}
              style={{
                padding: '10px 20px',
                background: currentRoom === room ? '#4CAF50' : '#ddd',
                color: currentRoom === room ? 'white' : 'black',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
              }}
            >
              #{room}
            </button>
          ))}
        </div>
      </div>

      {/* Connection Status */}
      <div
        style={{
          padding: '10px',
          background: isConnected ? '#4CAF50' : '#f44336',
          color: 'white',
          borderRadius: '4px',
          marginBottom: '20px',
        }}
      >
        {isConnected ? 'ğŸŸ¢ Connected' : 'ğŸ”´ Disconnected'} to #{currentRoom}
      </div>

      {/* Messages */}
      <div
        style={{
          border: '1px solid #ddd',
          borderRadius: '4px',
          padding: '10px',
          minHeight: '300px',
          maxHeight: '400px',
          overflowY: 'auto',
          background: '#f9f9f9',
        }}
      >
        {messages.length === 0 ? (
          <p style={{ textAlign: 'center', color: '#999' }}>
            Waiting for messages...
          </p>
        ) : (
          messages.map((msg) => (
            <div
              key={msg.id}
              style={{
                padding: '10px',
                margin: '5px 0',
                background: 'white',
                borderRadius: '4px',
                border: '1px solid #eee',
              }}
            >
              <strong>{msg.sender}:</strong> {msg.text}
            </div>
          ))
        )}
      </div>

      {/* Instructions */}
      <div
        style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
      >
        <h3>ğŸ§ª Test Cleanup:</h3>
        <ol>
          <li>Má»Ÿ Console</li>
          <li>Äá»£i messages xuáº¥t hiá»‡n trong "general"</li>
          <li>Switch sang "tech" â†’ Quan sÃ¡t cleanup log</li>
          <li>Switch nhanh giá»¯a rooms â†’ Má»—i switch trigger cleanup</li>
        </ol>

        <h3>âœ… Expected Behavior:</h3>
        <ul>
          <li>âœ… Old subscription cancelled khi switch room</li>
          <li>âœ… Messages cleared khi switch</li>
          <li>âœ… Only current room receives messages</li>
          <li>âœ… No console warnings</li>
        </ul>
      </div>
    </div>
  );
}

export default ChatRoom;
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Real-time Chat Room component using simulated subscription
 * - Subscribes to selected chat room
 * - Receives messages in real-time (simulated every 2s)
 * - Properly unsubscribes when switching rooms or unmounting
 * - Clears messages when changing rooms
 * - Prevents memory leaks from leftover intervals
 */
function ChatRoom() {
  const [currentRoom, setCurrentRoom] = useState('general');
  const [messages, setMessages] = useState([]);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    console.log(`âœ… Setting up subscription for room: ${currentRoom}`);

    // Reset state khi Ä‘á»•i room
    setMessages([]);
    setIsConnected(true);

    // Subscribe vÃ  nháº­n unsubscribe function
    const unsubscribe = chatService.subscribe(currentRoom, (message) => {
      setMessages((prev) => [...prev, message]);
    });

    // Cleanup: unsubscribe khi room thay Ä‘á»•i hoáº·c component unmount
    return () => {
      console.log(`ğŸ§¹ Cleaning up subscription for room: ${currentRoom}`);
      unsubscribe();
      setIsConnected(false);
    };
  }, [currentRoom]);

  const rooms = ['general', 'random', 'tech', 'sports'];

  return (
    <div>
      <h2>Real-time Chat Room</h2>

      <div>
        <strong>Select Room:</strong>
        <div style={{ margin: '10px 0' }}>
          {rooms.map((room) => (
            <button
              key={room}
              onClick={() => setCurrentRoom(room)}
              style={{
                margin: '0 8px 8px 0',
                padding: '8px 16px',
                background: currentRoom === room ? '#4CAF50' : '#e0e0e0',
                color: currentRoom === room ? 'white' : 'black',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
              }}
            >
              #{room}
            </button>
          ))}
        </div>
      </div>

      <div
        style={{
          padding: '10px',
          background: isConnected ? '#4CAF50' : '#f44336',
          color: 'white',
          borderRadius: '4px',
          marginBottom: '16px',
          display: 'inline-block',
        }}
      >
        {isConnected ? 'ğŸŸ¢ Connected' : 'ğŸ”´ Disconnected'} to #{currentRoom}
      </div>

      <div
        style={{
          border: '1px solid #ddd',
          borderRadius: '6px',
          padding: '16px',
          minHeight: '300px',
          maxHeight: '400px',
          overflowY: 'auto',
          background: '#fafafa',
        }}
      >
        {messages.length === 0 ? (
          <p style={{ textAlign: 'center', color: '#888', marginTop: '100px' }}>
            Waiting for messages in #{currentRoom}...
          </p>
        ) : (
          messages.map((msg) => (
            <div
              key={msg.id}
              style={{
                marginBottom: '12px',
                padding: '10px',
                background: 'white',
                borderRadius: '6px',
                border: '1px solid #eee',
              }}
            >
              <strong>{msg.sender}</strong>: {msg.text}
              <div
                style={{ fontSize: '11px', color: '#888', marginTop: '4px' }}
              >
                {msg.roomId} â€¢ {new Date(msg.id).toLocaleTimeString()}
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i khi test:
- Mount â†’ tháº¥y "Setting up subscription for room: general" vÃ  báº¯t Ä‘áº§u nháº­n message má»—i ~2s
- Chuyá»ƒn sang "tech" â†’ tháº¥y "Cleaning up subscription for room: general" â†’ "Setting up subscription for room: tech"
- Messages cÅ© bá»‹ xÃ³a, chá»‰ nháº­n message tá»« room má»›i
- Chuyá»ƒn room nhanh liÃªn tá»¥c â†’ má»—i láº§n cÅ© Ä‘á»u Ä‘Æ°á»£c cleanup trÆ°á»›c khi táº¡o má»›i
- Unmount component (áº©n ChatRoom) â†’ tháº¥y log cleanup cuá»‘i cÃ¹ng, interval dá»«ng hoÃ n toÃ n
- KhÃ´ng cÃ²n interval cháº¡y ngáº§m, khÃ´ng warning setState trÃªn unmounted component
*/
```

</details>

---

### â­â­â­â­ Level 4: Quyáº¿t Äá»‹nh Kiáº¿n TrÃºc (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Analytics Tracker vá»›i Multiple Cleanup Strategies
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Context:
 * XÃ¢y dá»±ng Analytics tracker theo dÃµi:
 * - Page views
 * - Time on page
 * - Click events
 * - Scroll depth
 * - User activity (active/idle)
 *
 * Má»—i metric cáº§n cleanup strategy khÃ¡c nhau:
 * 1. Timer-based (time on page) â†’ clearInterval
 * 2. Event-based (clicks, scroll) â†’ removeEventListener
 * 3. Batching (gá»­i batch sau N seconds) â†’ clearTimeout + send remaining
 * 4. Visibility (track tab active) â†’ removeEventListener
 *
 * APPROACH OPTIONS:
 *
 * APPROACH 1: Multiple effects, má»—i effect 1 cleanup
 * Pros:
 * - Separation of concerns rÃµ rÃ ng
 * - Dá»… debug tá»«ng metric
 * - Dá»… enable/disable individual trackers
 * Cons:
 * - Nhiá»u effects (4-5 effects)
 * - CÃ³ thá»ƒ conflicts giá»¯a effects
 *
 * APPROACH 2: Single effect, táº¥t cáº£ trong 1, return combined cleanup
 * Pros:
 * - Gá»n hÆ¡n, 1 effect duy nháº¥t
 * - Centralized logic
 * Cons:
 * - KhÃ³ Ä‘á»c, logic phá»©c táº¡p
 * - KhÃ³ maintain
 * - All-or-nothing (khÃ³ disable 1 tracker)
 *
 * APPROACH 3: Hybrid - Group related metrics
 * Pros:
 * - Balance clarity vs compactness
 * - Effect 1: Timers (time on page, batching)
 * - Effect 2: Events (clicks, scroll, visibility)
 * - CÃ³ thá»ƒ deps khÃ¡c nhau
 * Cons:
 * - Váº«n cáº§n cáº©n tháº­n vá»›i interactions
 *
 * ğŸ’­ RECOMMENDATION: Approach 1 (Multiple Effects)
 * LÃ½ do: Clarity > Brevity, easier to maintain
 *
 * ADR:
 * ---
 * # ADR: Analytics Cleanup Strategy
 *
 * ## Context
 * Track multiple metrics, má»—i metric cáº§n cleanup khÃ¡c nhau
 *
 * ## Decision
 * Multiple effects, má»—i effect responsible cho 1 concern
 *
 * ## Rationale
 * - Clarity: Má»—i effect rÃµ rÃ ng purpose
 * - Maintainability: Dá»… update/remove individual trackers
 * - Debuggability: Console.log tá»«ng effect
 * - Flexibility: Enable/disable vá»›i flags
 *
 * ## Consequences
 * - More effects (4-5)
 * - Potential slight performance overhead (negligible)
 * - Easier to reason about
 * ---
 */

// ğŸ’» PHASE 2: Implementation (30 phÃºt)

import { useState, useEffect } from 'react';

function AnalyticsTracker({ enableTracking = true }) {
  // Analytics data
  const [analytics, setAnalytics] = useState({
    pageViews: 0,
    timeOnPage: 0,
    clicks: 0,
    maxScrollDepth: 0,
    isActive: true,
    events: [],
  });

  // Effect 1: Page View Tracking
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ“Š Tracking page view');

    setAnalytics((prev) => ({
      ...prev,
      pageViews: prev.pageViews + 1,
    }));

    // Send to analytics server (simulated)
    const sendPageView = () => {
      console.log('ğŸ“¤ Sending page view event');
      // analytics.track('page_view', { ... });
    };
    sendPageView();

    // No cleanup needed (one-time event)
  }, [enableTracking]); // Re-track náº¿u enable thay Ä‘á»•i

  // Effect 2: Time on Page
  useEffect(() => {
    if (!enableTracking) return;

    console.log('â±ï¸ Starting time tracker');

    const intervalId = setInterval(() => {
      setAnalytics((prev) => ({
        ...prev,
        timeOnPage: prev.timeOnPage + 1,
      }));
    }, 1000);

    return () => {
      console.log('ğŸ§¹ Stopping time tracker');
      clearInterval(intervalId);
    };
  }, [enableTracking]);

  // Effect 3: Click Tracking
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ–±ï¸ Adding click listener');

    const handleClick = (e) => {
      setAnalytics((prev) => ({
        ...prev,
        clicks: prev.clicks + 1,
        events: [
          ...prev.events,
          {
            type: 'click',
            target: e.target.tagName,
            time: Date.now(),
          },
        ].slice(-10), // Keep last 10
      }));
    };

    document.addEventListener('click', handleClick);

    return () => {
      console.log('ğŸ§¹ Removing click listener');
      document.removeEventListener('click', handleClick);
    };
  }, [enableTracking]);

  // Effect 4: Scroll Depth Tracking
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ“œ Adding scroll listener');

    const handleScroll = () => {
      const scrollPercent = Math.round(
        (window.scrollY /
          (document.documentElement.scrollHeight - window.innerHeight)) *
          100,
      );

      setAnalytics((prev) => ({
        ...prev,
        maxScrollDepth: Math.max(prev.maxScrollDepth, scrollPercent || 0),
      }));
    };

    window.addEventListener('scroll', handleScroll);

    return () => {
      console.log('ğŸ§¹ Removing scroll listener');
      window.removeEventListener('scroll', handleScroll);
    };
  }, [enableTracking]);

  // Effect 5: Visibility / Activity Tracking
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ‘ï¸ Adding visibility listener');

    const handleVisibilityChange = () => {
      setAnalytics((prev) => ({
        ...prev,
        isActive: !document.hidden,
      }));
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);

    return () => {
      console.log('ğŸ§¹ Removing visibility listener');
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [enableTracking]);

  // Effect 6: Batch Send (every 10 seconds)
  useEffect(() => {
    if (!enableTracking) return;

    console.log('ğŸ“¦ Starting batch sender');

    const batchInterval = setInterval(() => {
      console.log('ğŸ“¤ Sending analytics batch:', analytics);
      // Send to server: analytics.batch(analytics);
    }, 10000);

    // Cleanup: Send remaining data immediately
    return () => {
      console.log('ğŸ§¹ Sending final batch before cleanup');
      console.log('ğŸ“¤ Final analytics:', analytics);
      clearInterval(batchInterval);
      // analytics.batch(analytics);
    };
  }, [enableTracking, analytics]); // Note: analytics in deps Ä‘á»ƒ send latest

  return (
    <div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}>
      <h2>Analytics Tracker</h2>

      {/* Stats Dashboard */}
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
          gap: '10px',
          marginBottom: '20px',
        }}
      >
        <StatCard
          title='Page Views'
          value={analytics.pageViews}
          icon='ğŸ“Š'
        />
        <StatCard
          title='Time on Page'
          value={`${analytics.timeOnPage}s`}
          icon='â±ï¸'
        />
        <StatCard
          title='Clicks'
          value={analytics.clicks}
          icon='ğŸ–±ï¸'
        />
        <StatCard
          title='Scroll Depth'
          value={`${analytics.maxScrollDepth}%`}
          icon='ğŸ“œ'
        />
        <StatCard
          title='Status'
          value={analytics.isActive ? 'Active' : 'Idle'}
          icon={analytics.isActive ? 'ğŸŸ¢' : 'âšª'}
        />
      </div>

      {/* Recent Events */}
      <div style={{ marginBottom: '20px' }}>
        <h3>Recent Events (Last 10):</h3>
        <div
          style={{
            maxHeight: '200px',
            overflowY: 'auto',
            border: '1px solid #ddd',
            borderRadius: '4px',
            padding: '10px',
          }}
        >
          {analytics.events.length === 0 ? (
            <p>No events yet. Click around!</p>
          ) : (
            analytics.events.map((event, i) => (
              <div
                key={i}
                style={{ padding: '5px', borderBottom: '1px solid #eee' }}
              >
                {event.type} on {event.target} at{' '}
                {new Date(event.time).toLocaleTimeString()}
              </div>
            ))
          )}
        </div>
      </div>

      {/* Test Content */}
      <div style={{ marginTop: '40px' }}>
        <h3>Test Content (Scroll, Click, etc.)</h3>
        {[...Array(20)].map((_, i) => (
          <p
            key={i}
            style={{ marginBottom: '20px' }}
          >
            Paragraph {i + 1}: Lorem ipsum dolor sit amet, consectetur
            adipiscing elit. Click me! Scroll past me! Switch tabs!
          </p>
        ))}
      </div>

      {/* Instructions */}
      <div
        style={{
          position: 'fixed',
          bottom: '20px',
          right: '20px',
          background: 'white',
          border: '2px solid #4CAF50',
          borderRadius: '8px',
          padding: '15px',
          maxWidth: '300px',
          boxShadow: '0 2px 10px rgba(0,0,0,0.1)',
        }}
      >
        <h4>ğŸ§ª Test Cleanup:</h4>
        <ol style={{ fontSize: '14px', paddingLeft: '20px' }}>
          <li>Má»Ÿ Console</li>
          <li>Scroll page</li>
          <li>Click vÃ i láº§n</li>
          <li>Switch tab (visibility)</li>
          <li>Navigate away â†’ Observe cleanup logs</li>
        </ol>
      </div>
    </div>
  );
}

function StatCard({ title, value, icon }) {
  return (
    <div
      style={{
        padding: '15px',
        background: '#f5f5f5',
        borderRadius: '8px',
        textAlign: 'center',
      }}
    >
      <div style={{ fontSize: '24px', marginBottom: '5px' }}>{icon}</div>
      <div style={{ fontSize: '12px', color: '#666', marginBottom: '5px' }}>
        {title}
      </div>
      <div style={{ fontSize: '20px', fontWeight: 'bold' }}>{value}</div>
    </div>
  );
}

export default AnalyticsTracker;

// ğŸ§ª PHASE 3: Testing (10 phÃºt)
// Manual testing checklist:
// - [ ] All 6 effects set up on mount (check Console)
// - [ ] Time tracker increments every second
// - [ ] Clicks tracked and displayed
// - [ ] Scroll depth updates
// - [ ] Tab visibility changes detected
// - [ ] Batch sends every 10s
// - [ ] Navigate away â†’ All 6 cleanups execute
// - [ ] No console warnings
// - [ ] Final batch sent with latest data

// ğŸ“‹ PRODUCTION CONSIDERATIONS:
// - Error handling trong effects (try/catch)
// - Throttle scroll/click handlers
// - localStorage persistence
// - Server API integration
// - Privacy compliance (GDPR)
// - Opt-out mechanism
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Analytics Tracker component with multiple cleanup effects
 * - Tracks page views, time on page, clicks, scroll depth, visibility
 * - Uses separate useEffect for each concern â†’ clear separation
 * - All resources properly cleaned up on unmount or when tracking disabled
 * - Sends final batch on cleanup
 */
function AnalyticsTracker({ enableTracking = true }) {
  const [analytics, setAnalytics] = useState({
    pageViews: 0,
    timeOnPage: 0,
    clicks: 0,
    maxScrollDepth: 0,
    isActive: true,
    events: [],
  });

  // Effect 1: Page View (one-time on mount/enable)
  useEffect(() => {
    if (!enableTracking) return;

    setAnalytics((prev) => ({ ...prev, pageViews: prev.pageViews + 1 }));

    console.log('ğŸ“¤ Page view tracked');

    // No cleanup needed for one-time event
  }, [enableTracking]);

  // Effect 2: Time on Page
  useEffect(() => {
    if (!enableTracking) return;

    const intervalId = setInterval(() => {
      setAnalytics((prev) => ({
        ...prev,
        timeOnPage: prev.timeOnPage + 1,
      }));
    }, 1000);

    return () => {
      console.log('ğŸ§¹ Clearing time tracker interval');
      clearInterval(intervalId);
    };
  }, [enableTracking]);

  // Effect 3: Click Tracking
  useEffect(() => {
    if (!enableTracking) return;

    const handleClick = (e) => {
      setAnalytics((prev) => ({
        ...prev,
        clicks: prev.clicks + 1,
        events: [
          ...prev.events,
          { type: 'click', target: e.target.tagName, time: Date.now() },
        ].slice(-10),
      }));
    };

    document.addEventListener('click', handleClick);

    return () => {
      console.log('ğŸ§¹ Removing click listener');
      document.removeEventListener('click', handleClick);
    };
  }, [enableTracking]);

  // Effect 4: Scroll Depth
  useEffect(() => {
    if (!enableTracking) return;

    const handleScroll = () => {
      const scrollPercent =
        Math.round(
          (window.scrollY /
            (document.documentElement.scrollHeight - window.innerHeight)) *
            100,
        ) || 0;

      setAnalytics((prev) => ({
        ...prev,
        maxScrollDepth: Math.max(prev.maxScrollDepth, scrollPercent),
      }));
    };

    window.addEventListener('scroll', handleScroll, { passive: true });

    return () => {
      console.log('ğŸ§¹ Removing scroll listener');
      window.removeEventListener('scroll', handleScroll);
    };
  }, [enableTracking]);

  // Effect 5: Visibility Change
  useEffect(() => {
    if (!enableTracking) return;

    const handleVisibility = () => {
      setAnalytics((prev) => ({
        ...prev,
        isActive: !document.hidden,
      }));
    };

    document.addEventListener('visibilitychange', handleVisibility);

    return () => {
      console.log('ğŸ§¹ Removing visibility listener');
      document.removeEventListener('visibilitychange', handleVisibility);
    };
  }, [enableTracking]);

  // Effect 6: Batch sending (every 10s) + final send on cleanup
  useEffect(() => {
    if (!enableTracking) return;

    const batchInterval = setInterval(() => {
      console.log('ğŸ“¤ Sending batch:', analytics);
      // In production: send to server
    }, 10000);

    return () => {
      console.log('ğŸ§¹ Final batch before unmount / disable');
      console.log('ğŸ“¤ Final analytics data:', analytics);
      // In production: send remaining data immediately
      clearInterval(batchInterval);
    };
  }, [enableTracking, analytics]);

  return (
    <div>
      <h2>Analytics Tracker</h2>
      <div
        style={{
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))',
          gap: '12px',
        }}
      >
        <div>Page Views: {analytics.pageViews}</div>
        <div>Time on Page: {analytics.timeOnPage}s</div>
        <div>Clicks: {analytics.clicks}</div>
        <div>Max Scroll: {analytics.maxScrollDepth}%</div>
        <div>Status: {analytics.isActive ? 'Active ğŸŸ¢' : 'Idle âšª'}</div>
      </div>

      <h3>Recent Events (last 10)</h3>
      {analytics.events.length === 0 ? (
        <p>No events yet</p>
      ) : (
        <ul>
          {analytics.events.map((ev, i) => (
            <li key={i}>
              {ev.type} on {ev.target} at{' '}
              {new Date(ev.time).toLocaleTimeString()}
            </li>
          ))}
        </ul>
      )}

      {/* Test content to scroll & click */}
      <div style={{ marginTop: '40px', height: '1200px' }}>
        <p>Scroll down and click around to generate events...</p>
        {[...Array(30)].map((_, i) => (
          <p key={i}>Paragraph {i + 1} - Click me!</p>
        ))}
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i khi test:
- Mount â†’ táº¥t cáº£ 6 effects setup (xem console)
- Time on page tÄƒng má»—i giÃ¢y
- Click â†’ clicks +1, event ghi láº¡i
- Scroll â†’ maxScrollDepth cáº­p nháº­t
- Chuyá»ƒn tab â†’ isActive thay Ä‘á»•i
- Má»—i 10s â†’ batch log
- Disable tracking (enableTracking=false) hoáº·c unmount â†’ táº¥t cáº£ cleanups cháº¡y
  â†’ intervals cleared, listeners removed, final batch sent
- KhÃ´ng warning, khÃ´ng leak (kiá»ƒm tra Memory tab trong DevTools)
*/
```

</details>

---

### â­â­â­â­â­ Level 5: Production Challenge (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Video Player vá»›i Comprehensive Cleanup
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * XÃ¢y dá»±ng custom video player vá»›i:
 * 1. Play/Pause controls
 * 2. Progress bar (updates má»—i giÃ¢y)
 * 3. Volume control
 * 4. Fullscreen toggle
 * 5. Keyboard shortcuts
 * 6. Auto-save playback position
 * 7. Picture-in-Picture mode
 * 8. Playback speed control
 *
 * ğŸ—ï¸ Technical Design Doc:
 *
 * 1. Component Architecture:
 *    - VideoPlayer (parent)
 *    - VideoControls (UI controls)
 *    - ProgressBar (seekable)
 *    - VolumeSlider
 *
 * 2. State Management:
 *    - isPlaying, currentTime, duration, volume
 *    - isFullscreen, isPiP, playbackRate
 *
 * 3. Cleanup Requirements (CRITICAL!):
 *    - Effect 1: Progress interval â†’ clearInterval
 *    - Effect 2: Keyboard listeners â†’ removeEventListener (multiple keys)
 *    - Effect 3: Fullscreen listeners â†’ removeEventListener
 *    - Effect 4: Auto-save timer â†’ clearTimeout + save final position
 *    - Effect 5: Video element listeners â†’ removeEventListener (ended, error, etc.)
 *    - Effect 6: PiP listeners â†’ removeEventListener
 *
 * 4. Performance Considerations:
 *    - Throttle progress updates
 *    - Debounce auto-save
 *    - Cancel pending saves on unmount
 *
 * 5. Error Handling:
 *    - Video load errors
 *    - Fullscreen API errors
 *    - PiP not supported
 *    - localStorage errors
 *
 * âœ… Production Checklist:
 * - [ ] All intervals/timeouts cleaned up
 * - [ ] All event listeners removed
 * - [ ] Video playback stopped on unmount
 * - [ ] Auto-save executed before unmount
 * - [ ] No memory leaks
 * - [ ] Keyboard shortcuts disabled on unmount
 * - [ ] Fullscreen exited on unmount
 * - [ ] PiP closed on unmount
 * - [ ] Error boundaries (basic)
 * - [ ] Accessibility (ARIA labels)
 *
 * ğŸ“ Documentation:
 * - Comment each cleanup
 * - Explain WHY cleanup needed
 * - Document keyboard shortcuts
 */

import { useState, useEffect, useRef } from 'react';

function VideoPlayer({ src, autoplay = false }) {
  const videoRef = useRef(null);

  // Playback state
  const [isPlaying, setIsPlaying] = useState(autoplay);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [playbackRate, setPlaybackRate] = useState(1);

  // UI state
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isPiP, setIsPiP] = useState(false);
  const [showControls, setShowControls] = useState(true);

  // Auto-save state
  const [lastSaved, setLastSaved] = useState(null);

  // TODO: Effect 1 - Video Element Event Listeners
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    console.log('ğŸ¬ Setting up video listeners');

    const handleLoadedMetadata = () => {
      setDuration(video.duration);
      console.log('âœ… Video metadata loaded');
    };

    const handleEnded = () => {
      setIsPlaying(false);
      console.log('ğŸ Video ended');
    };

    const handleError = (e) => {
      console.error('âŒ Video error:', e);
      // TODO: Show error UI
    };

    // Add listeners
    video.addEventListener('loadedmetadata', handleLoadedMetadata);
    video.addEventListener('ended', handleEnded);
    video.addEventListener('error', handleError);

    // Cleanup
    return () => {
      console.log('ğŸ§¹ Cleaning up video listeners');
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
      video.removeEventListener('ended', handleEnded);
      video.removeEventListener('error', handleError);
    };
  }, [src]); // Re-setup khi video source thay Ä‘á»•i

  // TODO: Effect 2 - Play/Pause Control
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    if (isPlaying) {
      video.play().catch((err) => {
        console.error('Play error:', err);
        setIsPlaying(false);
      });
    } else {
      video.pause();
    }
  }, [isPlaying]);

  // TODO: Effect 3 - Progress Tracker
  useEffect(() => {
    if (!isPlaying) return;

    console.log('â±ï¸ Starting progress tracker');

    const intervalId = setInterval(() => {
      const video = videoRef.current;
      if (video) {
        setCurrentTime(video.currentTime);
      }
    }, 1000);

    return () => {
      console.log('ğŸ§¹ Stopping progress tracker');
      clearInterval(intervalId);
    };
  }, [isPlaying]);

  // TODO: Effect 4 - Keyboard Shortcuts
  useEffect(() => {
    console.log('âŒ¨ï¸ Setting up keyboard shortcuts');

    const handleKeyPress = (e) => {
      // Space: Play/Pause
      if (e.code === 'Space') {
        e.preventDefault();
        setIsPlaying((prev) => !prev);
      }
      // F: Fullscreen
      else if (e.code === 'KeyF') {
        e.preventDefault();
        toggleFullscreen();
      }
      // M: Mute
      else if (e.code === 'KeyM') {
        e.preventDefault();
        setVolume((prev) => (prev === 0 ? 1 : 0));
      }
      // Arrow Left: -5s
      else if (e.code === 'ArrowLeft') {
        e.preventDefault();
        const video = videoRef.current;
        if (video) video.currentTime = Math.max(0, video.currentTime - 5);
      }
      // Arrow Right: +5s
      else if (e.code === 'ArrowRight') {
        e.preventDefault();
        const video = videoRef.current;
        if (video)
          video.currentTime = Math.min(duration, video.currentTime + 5);
      }
    };

    document.addEventListener('keydown', handleKeyPress);

    return () => {
      console.log('ğŸ§¹ Removing keyboard shortcuts');
      document.removeEventListener('keydown', handleKeyPress);
    };
  }, [duration]); // duration needed for arrow keys

  // TODO: Effect 5 - Auto-save Playback Position
  useEffect(() => {
    console.log('ğŸ’¾ Setting up auto-save');

    const timeoutId = setTimeout(() => {
      // Save to localStorage
      try {
        localStorage.setItem('videoPlaybackPosition', currentTime.toString());
        setLastSaved(new Date());
        console.log('ğŸ’¾ Auto-saved position:', currentTime);
      } catch (err) {
        console.error('Save error:', err);
      }
    }, 3000); // Debounce 3s

    // Cleanup: Save immediately before unmount
    return () => {
      console.log('ğŸ§¹ Saving final position before cleanup');
      clearTimeout(timeoutId);

      try {
        localStorage.setItem('videoPlaybackPosition', currentTime.toString());
        console.log('ğŸ’¾ Final save:', currentTime);
      } catch (err) {
        console.error('Save error:', err);
      }
    };
  }, [currentTime]);

  // TODO: Effect 6 - Load Saved Position (mount only)
  useEffect(() => {
    console.log('ğŸ“‚ Loading saved position');

    try {
      const savedPosition = localStorage.getItem('videoPlaybackPosition');
      if (savedPosition && videoRef.current) {
        const position = parseFloat(savedPosition);
        videoRef.current.currentTime = position;
        setCurrentTime(position);
        console.log('âœ… Loaded position:', position);
      }
    } catch (err) {
      console.error('Load error:', err);
    }
  }, []); // Empty deps â†’ Only on mount

  // TODO: Effect 7 - Volume Sync
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      video.volume = volume;
    }
  }, [volume]);

  // TODO: Effect 8 - Playback Rate Sync
  useEffect(() => {
    const video = videoRef.current;
    if (video) {
      video.playbackRate = playbackRate;
    }
  }, [playbackRate]);

  // TODO: Effect 9 - Fullscreen Listeners
  useEffect(() => {
    console.log('ğŸ–¥ï¸ Setting up fullscreen listeners');

    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);

    // Cleanup: Exit fullscreen
    return () => {
      console.log('ğŸ§¹ Exiting fullscreen');
      document.removeEventListener('fullscreenchange', handleFullscreenChange);

      if (document.fullscreenElement) {
        document.exitFullscreen().catch((err) => {
          console.error('Exit fullscreen error:', err);
        });
      }
    };
  }, []);

  // TODO: Effect 10 - Picture-in-Picture Listeners
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    console.log('ğŸ“º Setting up PiP listeners');

    const handlePiPEnter = () => {
      setIsPiP(true);
      console.log('ğŸ“º Entered PiP');
    };

    const handlePiPLeave = () => {
      setIsPiP(false);
      console.log('ğŸ“º Left PiP');
    };

    video.addEventListener('enterpictureinpicture', handlePiPEnter);
    video.addEventListener('leavepictureinpicture', handlePiPLeave);

    // Cleanup: Exit PiP
    return () => {
      console.log('ğŸ§¹ Exiting PiP');
      video.removeEventListener('enterpictureinpicture', handlePiPEnter);
      video.removeEventListener('leavepictureinpicture', handlePiPLeave);

      if (document.pictureInPictureElement) {
        document.exitPictureInPicture().catch((err) => {
          console.error('Exit PiP error:', err);
        });
      }
    };
  }, []);

  // Helper functions
  const togglePlay = () => {
    setIsPlaying(!isPlaying);
  };

  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      videoRef.current?.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  };

  const togglePiP = async () => {
    try {
      if (document.pictureInPictureElement) {
        await document.exitPictureInPicture();
      } else {
        await videoRef.current?.requestPictureInPicture();
      }
    } catch (err) {
      console.error('PiP error:', err);
    }
  };

  const handleSeek = (e) => {
    const video = videoRef.current;
    if (video) {
      const rect = e.currentTarget.getBoundingClientRect();
      const pos = (e.clientX - rect.left) / rect.width;
      video.currentTime = pos * duration;
      setCurrentTime(pos * duration);
    }
  };

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div
      style={{
        maxWidth: '800px',
        margin: '0 auto',
        padding: '20px',
        background: '#000',
        borderRadius: '8px',
      }}
    >
      {/* Video Element */}
      <video
        ref={videoRef}
        src={src}
        style={{
          width: '100%',
          borderRadius: '4px',
          display: 'block',
        }}
        onClick={togglePlay}
      />

      {/* Controls */}
      <div
        style={{
          padding: '15px',
          background: '#1a1a1a',
          borderRadius: '0 0 8px 8px',
        }}
      >
        {/* Progress Bar */}
        <div
          onClick={handleSeek}
          style={{
            height: '8px',
            background: '#333',
            borderRadius: '4px',
            cursor: 'pointer',
            marginBottom: '15px',
            position: 'relative',
          }}
        >
          <div
            style={{
              width: `${(currentTime / duration) * 100}%`,
              height: '100%',
              background: '#4CAF50',
              borderRadius: '4px',
            }}
          />
        </div>

        {/* Time Display */}
        <div
          style={{
            color: 'white',
            fontSize: '14px',
            marginBottom: '15px',
            display: 'flex',
            justifyContent: 'space-between',
          }}
        >
          <span>{formatTime(currentTime)}</span>
          <span>{formatTime(duration)}</span>
        </div>

        {/* Control Buttons */}
        <div
          style={{
            display: 'flex',
            gap: '10px',
            alignItems: 'center',
            flexWrap: 'wrap',
          }}
        >
          <button
            onClick={togglePlay}
            style={buttonStyle}
          >
            {isPlaying ? 'â¸ï¸ Pause' : 'â–¶ï¸ Play'}
          </button>

          <button
            onClick={toggleFullscreen}
            style={buttonStyle}
          >
            {isFullscreen ? 'â¬…ï¸ Exit FS' : 'â¬†ï¸ Fullscreen'}
          </button>

          <button
            onClick={togglePiP}
            style={buttonStyle}
          >
            {isPiP ? 'ğŸ“º Exit PiP' : 'ğŸ“º PiP'}
          </button>

          {/* Volume */}
          <div style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
            <span style={{ color: 'white', fontSize: '14px' }}>ğŸ”Š</span>
            <input
              type='range'
              min='0'
              max='1'
              step='0.1'
              value={volume}
              onChange={(e) => setVolume(parseFloat(e.target.value))}
              style={{ width: '80px' }}
            />
          </div>

          {/* Playback Speed */}
          <select
            value={playbackRate}
            onChange={(e) => setPlaybackRate(parseFloat(e.target.value))}
            style={{
              padding: '5px',
              borderRadius: '4px',
              border: 'none',
            }}
          >
            <option value='0.5'>0.5x</option>
            <option value='1'>1x</option>
            <option value='1.5'>1.5x</option>
            <option value='2'>2x</option>
          </select>
        </div>

        {/* Keyboard Shortcuts Help */}
        <div
          style={{
            color: '#999',
            fontSize: '12px',
            marginTop: '15px',
            borderTop: '1px solid #333',
            paddingTop: '10px',
          }}
        >
          <strong>Shortcuts:</strong> Space=Play/Pause | F=Fullscreen | M=Mute |
          â†/â†’=Seek
        </div>

        {/* Auto-save Status */}
        {lastSaved && (
          <div
            style={{
              color: '#4CAF50',
              fontSize: '12px',
              marginTop: '5px',
            }}
          >
            âœ… Last saved: {lastSaved.toLocaleTimeString()}
          </div>
        )}
      </div>
    </div>
  );
}

const buttonStyle = {
  padding: '8px 15px',
  background: '#4CAF50',
  color: 'white',
  border: 'none',
  borderRadius: '4px',
  cursor: 'pointer',
  fontSize: '14px',
};

// Demo Wrapper
function VideoPlayerDemo() {
  const [showPlayer, setShowPlayer] = useState(true);

  return (
    <div>
      <div style={{ textAlign: 'center', marginBottom: '20px' }}>
        <button onClick={() => setShowPlayer(!showPlayer)}>
          {showPlayer ? 'Unmount Player' : 'Mount Player'}
        </button>
        <p style={{ fontSize: '14px', color: '#666', marginTop: '10px' }}>
          Click "Unmount" and watch Console for cleanup logs
        </p>
      </div>

      {showPlayer && (
        <VideoPlayer
          src='https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4'
          autoplay={false}
        />
      )}
    </div>
  );
}

export default VideoPlayerDemo;

// ğŸ“‹ TESTING CHECKLIST:
// - [ ] Play video â†’ Progress updates
// - [ ] Pause â†’ Progress stops
// - [ ] Seek â†’ Position changes
// - [ ] Volume slider works
// - [ ] Playback speed changes
// - [ ] Keyboard shortcuts functional
// - [ ] Fullscreen enter/exit
// - [ ] PiP enter/exit
// - [ ] Auto-save every 3s (check localStorage)
// - [ ] Unmount â†’ All cleanups execute (Console)
// - [ ] Unmount â†’ Final position saved
// - [ ] Remount â†’ Resumes from saved position
// - [ ] Switch video src â†’ Old listeners removed, new ones added
// - [ ] No memory leaks (check Chrome DevTools Memory)
// - [ ] No console warnings/errors

// ğŸ’¡ PRODUCTION ENHANCEMENTS:
// - Error boundaries
// - Loading states
// - Buffering indicator
// - Quality selector
// - Captions/subtitles
// - Playlist support
// - Analytics integration
// - Adaptive bitrate
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Advanced Video Player with comprehensive cleanup
 * - Handles play/pause, progress, volume, fullscreen, PiP, keyboard shortcuts
 * - Auto-saves playback position with debounce
 * - Cleans up ALL timers, listeners, and API states on unmount / src change
 * - Prevents memory leaks and setState warnings
 */
function VideoPlayer({ src, autoplay = false }) {
  const videoRef = useRef(null);

  const [isPlaying, setIsPlaying] = useState(autoplay);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [playbackRate, setPlaybackRate] = useState(1);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isPiP, setIsPiP] = useState(false);

  // Progress tracking
  useEffect(() => {
    if (!isPlaying) return;

    const intervalId = setInterval(() => {
      if (videoRef.current) {
        setCurrentTime(videoRef.current.currentTime);
      }
    }, 800);

    return () => {
      console.log('ğŸ§¹ Clearing progress interval');
      clearInterval(intervalId);
    };
  }, [isPlaying]);

  // Video event listeners (loadedmetadata, ended, error)
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleLoaded = () => {
      setDuration(video.duration);
      const saved = localStorage.getItem(`video-pos-${src}`);
      if (saved) {
        video.currentTime = parseFloat(saved);
        setCurrentTime(parseFloat(saved));
      }
    };

    const handleEnded = () => setIsPlaying(false);

    video.addEventListener('loadedmetadata', handleLoaded);
    video.addEventListener('ended', handleEnded);

    return () => {
      console.log('ğŸ§¹ Removing video event listeners');
      video.removeEventListener('loadedmetadata', handleLoaded);
      video.removeEventListener('ended', handleEnded);
    };
  }, [src]);

  // Play / Pause sync
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    if (isPlaying) {
      video.play().catch(() => setIsPlaying(false));
    } else {
      video.pause();
    }
  }, [isPlaying]);

  // Volume & Playback Rate sync
  useEffect(() => {
    if (videoRef.current) {
      videoRef.current.volume = volume;
    }
  }, [volume]);

  useEffect(() => {
    if (videoRef.current) {
      videoRef.current.playbackRate = playbackRate;
    }
  }, [playbackRate]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKey = (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')
        return;

      switch (e.code) {
        case 'Space':
          e.preventDefault();
          setIsPlaying((p) => !p);
          break;
        case 'KeyF':
          e.preventDefault();
          toggleFullscreen();
          break;
        case 'KeyM':
          e.preventDefault();
          setVolume((v) => (v === 0 ? 1 : 0));
          break;
        case 'ArrowLeft':
          e.preventDefault();
          if (videoRef.current) videoRef.current.currentTime -= 5;
          break;
        case 'ArrowRight':
          e.preventDefault();
          if (videoRef.current) videoRef.current.currentTime += 5;
          break;
        default:
          break;
      }
    };

    document.addEventListener('keydown', handleKey);

    return () => {
      console.log('ğŸ§¹ Removing keyboard listeners');
      document.removeEventListener('keydown', handleKey);
    };
  }, [duration]);

  // Fullscreen listener & cleanup
  useEffect(() => {
    const handleFSChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener('fullscreenchange', handleFSChange);

    return () => {
      console.log('ğŸ§¹ Cleaning up fullscreen');
      document.removeEventListener('fullscreenchange', handleFSChange);
      if (document.fullscreenElement) {
        document.exitFullscreen().catch(() => {});
      }
    };
  }, []);

  // Picture-in-Picture listeners
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const onEnterPiP = () => setIsPiP(true);
    const onLeavePiP = () => setIsPiP(false);

    video.addEventListener('enterpictureinpicture', onEnterPiP);
    video.addEventListener('leavepictureinpicture', onLeavePiP);

    return () => {
      console.log('ğŸ§¹ Cleaning up PiP');
      video.removeEventListener('enterpictureinpicture', onEnterPiP);
      video.removeEventListener('leavepictureinpicture', onLeavePiP);
      if (document.pictureInPictureElement) {
        document.exitPictureInPicture().catch(() => {});
      }
    };
  }, []);

  // Auto-save position (debounced)
  useEffect(() => {
    if (!currentTime || currentTime < 1) return;

    const timeoutId = setTimeout(() => {
      try {
        localStorage.setItem(`video-pos-${src}`, currentTime.toString());
        console.log('ğŸ’¾ Auto-saved position:', currentTime);
      } catch (err) {}
    }, 2500);

    return () => {
      console.log('ğŸ§¹ Final save before cleanup');
      clearTimeout(timeoutId);
      try {
        localStorage.setItem(`video-pos-${src}`, currentTime.toString());
      } catch (err) {}
    };
  }, [currentTime, src]);

  const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
      videoRef.current?.requestFullscreen().catch(() => {});
    } else {
      document.exitFullscreen().catch(() => {});
    }
  };

  const togglePiP = () => {
    if (document.pictureInPictureElement) {
      document.exitPictureInPicture().catch(() => {});
    } else {
      videoRef.current?.requestPictureInPicture().catch(() => {});
    }
  };

  const handleSeek = (e) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const pos = (e.clientX - rect.left) / rect.width;
    if (videoRef.current) {
      videoRef.current.currentTime = pos * duration;
      setCurrentTime(pos * duration);
    }
  };

  const formatTime = (s) => {
    const m = Math.floor(s / 60);
    const sec = Math.floor(s % 60);
    return `${m}:${sec.toString().padStart(2, '0')}`;
  };

  return (
    <div
      style={{
        maxWidth: '900px',
        margin: '0 auto',
        background: '#111',
        borderRadius: '12px',
        overflow: 'hidden',
      }}
    >
      <video
        ref={videoRef}
        src={src}
        style={{ width: '100%', display: 'block' }}
        onClick={() => setIsPlaying((p) => !p)}
      />

      <div style={{ padding: '16px', background: '#1a1a1a', color: 'white' }}>
        {/* Progress */}
        <div
          onClick={handleSeek}
          style={{
            height: '8px',
            background: '#444',
            borderRadius: '4px',
            cursor: 'pointer',
            marginBottom: '12px',
            position: 'relative',
          }}
        >
          <div
            style={{
              width: `${duration ? (currentTime / duration) * 100 : 0}%`,
              height: '100%',
              background: '#e91e63',
              borderRadius: '4px',
            }}
          />
        </div>

        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            marginBottom: '12px',
            fontSize: '14px',
          }}
        >
          <span>{formatTime(currentTime)}</span>
          <span>{formatTime(duration)}</span>
        </div>

        {/* Controls */}
        <div
          style={{
            display: 'flex',
            gap: '16px',
            alignItems: 'center',
            flexWrap: 'wrap',
          }}
        >
          <button onClick={() => setIsPlaying((p) => !p)}>
            {isPlaying ? 'Pause' : 'Play'}
          </button>

          <button onClick={toggleFullscreen}>
            {isFullscreen ? 'Exit Fullscreen' : 'Fullscreen'}
          </button>

          <button onClick={togglePiP}>{isPiP ? 'Exit PiP' : 'PiP'}</button>

          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <span>Vol:</span>
            <input
              type='range'
              min='0'
              max='1'
              step='0.05'
              value={volume}
              onChange={(e) => setVolume(Number(e.target.value))}
              style={{ width: '100px' }}
            />
          </div>

          <select
            value={playbackRate}
            onChange={(e) => setPlaybackRate(Number(e.target.value))}
            style={{ padding: '6px', borderRadius: '4px' }}
          >
            <option value='0.5'>0.5Ã—</option>
            <option value='0.75'>0.75Ã—</option>
            <option value='1'>1Ã—</option>
            <option value='1.25'>1.25Ã—</option>
            <option value='1.5'>1.5Ã—</option>
            <option value='2'>2Ã—</option>
          </select>
        </div>

        <div style={{ marginTop: '12px', fontSize: '13px', color: '#aaa' }}>
          Shortcuts: Space = Play/Pause â€¢ F = Fullscreen â€¢ M = Mute â€¢ â†/â†’ = Seek
          5s
        </div>
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i khi test:
- Play â†’ progress cáº­p nháº­t mÆ°á»£t, time tÄƒng
- Pause â†’ progress dá»«ng
- Seek báº±ng click hoáº·c phÃ­m mÅ©i tÃªn â†’ vá»‹ trÃ­ thay Ä‘á»•i
- Volume & tá»‘c Ä‘á»™ thay Ä‘á»•i â†’ Ã¡p dá»¥ng ngay
- Fullscreen / PiP â†’ vÃ o/ra Ä‘Ãºng, cleanup khi unmount
- GÃµ Space, F, M, â†â†’ â†’ hoáº¡t Ä‘á»™ng
- Chuyá»ƒn tab hoáº·c unmount â†’ táº¥t cáº£ interval dá»«ng, listeners gá»¡, vá»‹ trÃ­ cuá»‘i cÃ¹ng Ä‘Æ°á»£c lÆ°u
- Mount láº¡i â†’ resume tá»« vá»‹ trÃ­ Ä‘Ã£ lÆ°u (per src)
- Console sáº¡ch, khÃ´ng warning "setState on unmounted", khÃ´ng leak interval/listener
*/
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Common Cleanup Patterns

| Resource Type      | Setup Code                         | Cleanup Code                          | Common Mistakes                          |
| ------------------ | ---------------------------------- | ------------------------------------- | ---------------------------------------- |
| **setInterval**    | `setInterval(fn, ms)`              | `clearInterval(id)`                   | âŒ KhÃ´ng cleanup â†’ Multiple intervals    |
| **setTimeout**     | `setTimeout(fn, ms)`               | `clearTimeout(id)`                    | âŒ KhÃ´ng cleanup khi deps thay Ä‘á»•i       |
| **Event Listener** | `addEventListener(event, handler)` | `removeEventListener(event, handler)` | âŒ Handler reference khÃ¡c â†’ KhÃ´ng remove |
| **Fetch/API**      | `fetch(url)`                       | `controller.abort()`                  | âŒ setState sau unmount â†’ Warning        |
| **WebSocket**      | `new WebSocket(url)`               | `ws.close()`                          | âŒ Connection leak                       |
| **Subscription**   | `observable.subscribe(fn)`         | `subscription.unsubscribe()`          | âŒ Memory leak                           |
| **Animation**      | `requestAnimationFrame(fn)`        | `cancelAnimationFrame(id)`            | âŒ Animation continues                   |

### Báº£ng So SÃ¡nh: Cleanup Timing

| Ká»‹ch báº£n                  | Khi Cleanup Cháº¡y                            | VÃ­ dá»¥                      |
| ------------------------- | ------------------------------------------- | -------------------------- |
| **Component Unmount**     | TrÆ°á»›c khi component bá»‹ gá»¡ khá»i DOM          | NgÆ°á»i dÃ¹ng chuyá»ƒn trang    |
| **Dependencies Thay Äá»•i** | TrÆ°á»›c khi effect cháº¡y láº¡i vá»›i deps má»›i      | `[count]` â†’ count thay Ä‘á»•i |
| **Effect Bá»‹ VÃ´ Hiá»‡u**     | Khi Ä‘iá»u kiá»‡n effect trá»Ÿ thÃ nh false        | `if (!enabled) return;`    |
| **Strict Mode (Dev)**     | Sau khi mount, rá»“i cleanup ngay vÃ  cháº¡y láº¡i | React 18 gá»i hai láº§n       |

### Decision Tree: Khi nÃ o cáº§n Cleanup?

```
Effect táº¡o ra resource nÃ o?
â”‚
â”œâ”€ Timer (setInterval, setTimeout)?
â”‚  â†’ âœ… Báº®T BUá»˜C cleanup vá»›i clearInterval/clearTimeout
â”‚
â”œâ”€ Event listener (window, document, element)?
â”‚  â†’ âœ… Báº®T BUá»˜C removeEventListener
â”‚
â”œâ”€ Subscription (WebSocket, Observable, etc.)?
â”‚  â†’ âœ… Báº®T BUá»˜C unsubscribe/close
â”‚
â”œâ”€ Async operation (fetch, promise)?
â”‚  â”‚
â”‚  â”œâ”€ setState trong promise callback?
â”‚  â”‚  â†’ âœ… Cáº¦N cancel flag hoáº·c AbortController
â”‚  â”‚
â”‚  â””â”€ KhÃ´ng setState?
â”‚     â†’ âš ï¸ Consider cleanup náº¿u operation expensive
â”‚
â”œâ”€ DOM manipulation trá»±c tiáº¿p?
â”‚  â†’ âœ… Restore original state
â”‚
â”œâ”€ Third-party library instance?
â”‚  â†’ âœ… Call cleanup/destroy method
â”‚
â””â”€ Chá»‰ Ä‘á»c data, khÃ´ng táº¡o resource?
   â†’ âŒ KhÃ´ng cáº§n cleanup
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug #1: Handler Reference Mismatch ğŸ›

```jsx
/**
 * ğŸ› BUG: Event listener khÃ´ng Ä‘Æ°á»£c remove
 * ğŸ¯ Nhiá»‡m vá»¥: Fix handler reference
 */

function BuggyClickCounter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('âœ… Adding click listener');

    // âŒ BUG: Inline function â†’ New reference má»—i láº§n!
    window.addEventListener('click', () => {
      setCount((c) => c + 1);
    });

    return () => {
      console.log('ğŸ§¹ Removing click listener');
      // âŒ This is a DIFFERENT function â†’ KhÃ´ng remove Ä‘Æ°á»£c!
      window.removeEventListener('click', () => {
        setCount((c) => c + 1);
      });
    };
  }, []);

  return <div>Clicks: {count}</div>;
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. Unmount component â†’ Listener cÃ³ Ä‘Æ°á»£c remove khÃ´ng?
// 2. Mount láº¡i â†’ Bao nhiÃªu listeners Ä‘ang active?
// 3. Sau 5 láº§n mount/unmount â†’ Bao nhiÃªu listeners?

// ğŸ’¡ GIáº¢I THÃCH:
// - addEventListener vÃ  removeEventListener pháº£i dÃ¹ng SAME function reference
// - Inline arrow functions táº¡o new reference má»—i láº§n
// - removeEventListener vá»›i different function â†’ No effect!
// - Káº¿t quáº£: Listeners accumulate â†’ Memory leak

// âœ… FIX: Define handler outside
function Fixed() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('âœ… Adding click listener');

    // âœ… Named function vá»›i stable reference
    const handleClick = () => {
      setCount((c) => c + 1);
    };

    window.addEventListener('click', handleClick);

    return () => {
      console.log('ğŸ§¹ Removing click listener');
      window.removeEventListener('click', handleClick); // âœ… Same reference!
    };
  }, []);

  return <div>Clicks: {count}</div>;
}

// ğŸ“ BÃ€I Há»ŒC:
// - Event handlers pháº£i cÃ³ stable reference Ä‘á»ƒ remove Ä‘Æ°á»£c
// - Define handler BÃŠN TRONG effect (cÃ³ access to closure)
// - SAME handler reference trong add vÃ  remove
```

---

### Bug #2: Missing Cleanup with Dependencies ğŸ”„

```jsx
/**
 * ğŸ› BUG: Interval khÃ´ng Ä‘Æ°á»£c clear khi deps thay Ä‘á»•i
 * ğŸ¯ Nhiá»‡m vá»¥: Add proper cleanup
 */

function BuggyIntervalCounter({ interval = 1000 }) {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`âœ… Starting interval with ${interval}ms`);

    const id = setInterval(() => {
      setCount((c) => c + 1);
    }, interval);

    // âŒ BUG: KhÃ´ng cleanup khi interval prop thay Ä‘á»•i!
    // Náº¿u interval thay Ä‘á»•i tá»« 1000 â†’ 500:
    // - Effect re-runs, táº¡o interval Má»šI vá»›i 500ms
    // - NhÆ°ng interval CÅ¨ (1000ms) váº«n cháº¡y!
    // - BÃ¢y giá» cÃ³ 2 intervals cháº¡y cÃ¹ng lÃºc!
  }, [interval]); // Deps cÃ³ interval â†’ Re-run khi thay Ä‘á»•i

  return (
    <div>
      <p>Count: {count}</p>
      <p>Interval: {interval}ms</p>
    </div>
  );
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. interval thay Ä‘á»•i tá»« 1000 â†’ 500 â†’ 250 â†’ Bao nhiÃªu intervals Ä‘ang cháº¡y?
// 2. Count tÄƒng vá»›i tá»‘c Ä‘á»™ nÃ o?
// 3. Memory cÃ³ leak khÃ´ng?

// ğŸ’¡ GIáº¢I THÃCH:
// Má»—i láº§n interval thay Ä‘á»•i:
// 1. Effect re-runs
// 2. Táº¡o interval Má»šI
// 3. Interval CÅ¨ KHÃ”NG Ä‘Æ°á»£c clear â†’ Still running!
// 4. Accumulation: 1000ms + 500ms + 250ms = 3 intervals!
// 5. Count tÄƒng nhanh hÆ¡n expected

// âœ… FIX: Add cleanup
function Fixed({ interval = 1000 }) {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`âœ… Starting interval with ${interval}ms`);

    const id = setInterval(() => {
      setCount((c) => c + 1);
    }, interval);

    // âœ… Cleanup clears old interval
    return () => {
      console.log(`ğŸ§¹ Clearing interval with ${interval}ms`);
      clearInterval(id);
    };
  }, [interval]);

  return (
    <div>
      <p>Count: {count}</p>
      <p>Interval: {interval}ms</p>
    </div>
  );
}

// Console output khi interval thay Ä‘á»•i:
// âœ… Starting interval with 1000ms
// (interval changes)
// ğŸ§¹ Clearing interval with 1000ms  â† Old cleared!
// âœ… Starting interval with 500ms  â† New created!

// ğŸ“ BÃ€I Há»ŒC:
// - Dependencies thay Ä‘á»•i â†’ Effect re-runs
// - LUÃ”N cleanup old resources trÆ°á»›c khi setup new
// - Cleanup cháº¡y Tá»° Äá»˜NG trÆ°á»›c effect re-run
```

---

### Bug #3: Async setState After Unmount âš ï¸

```jsx
/**
 * ğŸ› BUG: setState trÃªn unmounted component
 * ğŸ¯ Nhiá»‡m vá»¥: Prevent vá»›i cleanup flag
 */

function BuggyDataFetcher({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('Fetching user:', userId);
    setLoading(true);

    // Simulate API call (2 seconds)
    setTimeout(() => {
      const userData = { id: userId, name: `User ${userId}` };

      // âŒ BUG: Náº¿u component unmount trong 2 giÃ¢y nÃ y
      // â†’ setState trÃªn unmounted component â†’ Warning!
      setUser(userData);
      setLoading(false);
      console.log('âœ… User loaded');
    }, 2000);

    // âŒ No cleanup!
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>User: {user?.name}</div>;
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. Mount component â†’ Unmount sau 1 giÃ¢y â†’ GÃ¬ xáº£y ra sau 2 giÃ¢y?
// 2. Console cÃ³ warning khÃ´ng?
// 3. Memory cÃ³ leak khÃ´ng?

// ğŸ’¡ GIáº¢I THÃCH:
// Timeline:
// 0s: Mount â†’ Start setTimeout (2s)
// 1s: Unmount â†’ Component gone
// 2s: setTimeout callback runs â†’ setUser() + setLoading()
// â†’ React warning: "Can't perform a React state update on an unmounted component"
// â†’ Potential memory leak (references to unmounted component)

// âœ… FIX #1: Cleanup Flag
function FixedV1({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('Fetching user:', userId);
    setLoading(true);

    let isCancelled = false; // â† Cleanup flag

    setTimeout(() => {
      const userData = { id: userId, name: `User ${userId}` };

      // âœ… Chá»‰ setState náº¿u chÆ°a cancelled
      if (!isCancelled) {
        setUser(userData);
        setLoading(false);
        console.log('âœ… User loaded');
      } else {
        console.log('ğŸ§¹ Request cancelled, skipping setState');
      }
    }, 2000);

    // Cleanup: Set flag
    return () => {
      console.log('ğŸ§¹ Cancelling request');
      isCancelled = true;
    };
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>User: {user?.name}</div>;
}

// âœ… FIX #2: AbortController (Modern, for real fetch)
function FixedV2({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    console.log('Fetching user:', userId);
    setLoading(true);

    const controller = new AbortController();

    fetch(`/api/users/${userId}`, { signal: controller.signal })
      .then((res) => res.json())
      .then((data) => {
        setUser(data);
        setLoading(false);
        console.log('âœ… User loaded');
      })
      .catch((err) => {
        if (err.name === 'AbortError') {
          console.log('ğŸ§¹ Fetch aborted');
        } else {
          console.error('Error:', err);
        }
      });

    return () => {
      console.log('ğŸ§¹ Aborting fetch');
      controller.abort();
    };
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  return <div>User: {user?.name}</div>;
}

// ğŸ“ BÃ€I Há»ŒC:
// - Async operations cáº§n cleanup Ä‘á»ƒ prevent setState sau unmount
// - Flag approach: Simple, works vá»›i má»i async code
// - AbortController: Modern, actually cancels network request
// - LUÃ”N cleanup async operations!
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u âœ… nhá»¯ng Ä‘iá»u báº¡n Ä‘Ã£ hiá»ƒu:

#### Concepts:

- [ ] TÃ´i hiá»ƒu cleanup function lÃ  gÃ¬
- [ ] TÃ´i biáº¿t khi nÃ o cleanup function cháº¡y (unmount + deps change)
- [ ] TÃ´i hiá»ƒu táº¡i sao cáº§n cleanup
- [ ] TÃ´i biáº¿t memory leak lÃ  gÃ¬ vÃ  háº­u quáº£
- [ ] TÃ´i hiá»ƒu cleanup timing (before re-run, on unmount)

#### Practices:

- [ ] TÃ´i cÃ³ thá»ƒ cleanup setInterval/setTimeout
- [ ] TÃ´i cÃ³ thá»ƒ cleanup event listeners properly
- [ ] TÃ´i biáº¿t prevent setState sau unmount
- [ ] TÃ´i sá»­ dá»¥ng AbortController cho fetch
- [ ] TÃ´i biáº¿t cleanup multiple resources

#### Debugging:

- [ ] TÃ´i nháº­n biáº¿t Ä‘Æ°á»£c memory leaks
- [ ] TÃ´i biáº¿t debug listener khÃ´ng Ä‘Æ°á»£c remove
- [ ] TÃ´i hiá»ƒu handler reference issues
- [ ] TÃ´i cÃ³ thá»ƒ trace cleanup execution
- [ ] TÃ´i biáº¿t test cleanup vá»›i unmount

---

### Code Review Checklist

Khi review code cÃ³ useEffect, kiá»ƒm tra cleanup:

#### Timers:

- [ ] setInterval â†’ clearInterval trong cleanup
- [ ] setTimeout â†’ clearTimeout trong cleanup
- [ ] requestAnimationFrame â†’ cancelAnimationFrame

#### Event Listeners:

- [ ] addEventListener â†’ removeEventListener vá»›i SAME handler
- [ ] Handler defined trong effect (stable reference)
- [ ] No inline functions trong add/remove

#### Async Operations:

- [ ] fetch â†’ AbortController cleanup
- [ ] Promises â†’ isCancelled flag
- [ ] No setState sau unmount

#### Subscriptions:

- [ ] WebSocket â†’ close() trong cleanup
- [ ] Observable â†’ unsubscribe() trong cleanup
- [ ] Third-party libs â†’ cleanup method called

#### Best Practices:

- [ ] Cleanup function ALWAYS returned náº¿u cÃ³ resources
- [ ] Console.log cleanup execution (dev)
- [ ] Comments giáº£i thÃ­ch WHY cleanup needed
- [ ] Test unmount behavior

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**BÃ i 1: Countdown Timer vá»›i Cleanup**

```jsx
/**
 * Táº¡o countdown timer:
 * - Input sá»‘ giÃ¢y countdown
 * - Button Start/Pause/Reset
 * - Auto stop khi vá» 0
 * - Cleanup interval properly
 *
 * Requirements:
 * - setInterval Ä‘á»ƒ countdown
 * - clearInterval trong cleanup
 * - Test unmount during countdown
 *
 * Hints:
 * - useEffect vá»›i [isRunning] deps
 * - Return cleanup function
 * - Functional update: setTime(t => t - 1)
 */
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Countdown Timer component
 * - Nháº­p sá»‘ giÃ¢y ban Ä‘áº§u
 * - NÃºt Start / Pause / Reset
 * - Tá»± Ä‘á»™ng dá»«ng khi vá» 0
 * - Cleanup interval Ä‘Ãºng cÃ¡ch khi pause, reset, unmount
 * - NgÄƒn memory leak vÃ  warning setState trÃªn unmounted component
 */
function CountdownTimer() {
  const [initialSeconds, setInitialSeconds] = useState(60);
  const [seconds, setSeconds] = useState(60);
  const [isRunning, setIsRunning] = useState(false);

  useEffect(() => {
    if (!isRunning) return;

    const intervalId = setInterval(() => {
      setSeconds((prev) => {
        if (prev <= 1) {
          setIsRunning(false);
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => {
      console.log('ğŸ§¹ Clearing countdown interval');
      clearInterval(intervalId);
    };
  }, [isRunning]);

  const handleStartPause = () => {
    setIsRunning((prev) => !prev);
  };

  const handleReset = () => {
    setIsRunning(false);
    setSeconds(initialSeconds);
  };

  const handleInputChange = (e) => {
    const value = Number(e.target.value);
    if (!isNaN(value) && value >= 0) {
      setInitialSeconds(value);
      if (!isRunning) {
        setSeconds(value);
      }
    }
  };

  return (
    <div style={{ padding: '20px', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Countdown Timer</h2>

      <div style={{ marginBottom: '16px' }}>
        <label>
          Sá»‘ giÃ¢y ban Ä‘áº§u:{' '}
          <input
            type='number'
            value={initialSeconds}
            onChange={handleInputChange}
            min='0'
            style={{ width: '80px', padding: '6px' }}
            disabled={isRunning}
          />
        </label>
      </div>

      <div style={{ fontSize: '48px', fontWeight: 'bold', margin: '20px 0' }}>
        {seconds}
      </div>

      <div style={{ display: 'flex', gap: '12px' }}>
        <button
          onClick={handleStartPause}
          disabled={seconds === 0 && !isRunning}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            background: isRunning ? '#f44336' : '#4CAF50',
            color: 'white',
            border: 'none',
            borderRadius: '6px',
            cursor: 'pointer',
          }}
        >
          {isRunning ? 'Pause' : 'Start'}
        </button>

        <button
          onClick={handleReset}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            background: '#2196F3',
            color: 'white',
            border: 'none',
            borderRadius: '6px',
            cursor: 'pointer',
          }}
        >
          Reset
        </button>
      </div>

      <p style={{ marginTop: '20px', color: '#666', fontSize: '14px' }}>
        Thá»­ unmount component (áº©n nÃ³) trong lÃºc Ä‘ang cháº¡y â†’ kiá»ƒm tra console
        khÃ´ng cÃ²n interval leak
      </p>
    </div>
  );
}
/*
Káº¿t quáº£ mong Ä‘á»£i khi test:
- Nháº­p 30 â†’ Start â†’ Ä‘áº¿m ngÆ°á»£c tá»« 30 â†’ 29 â†’ ... â†’ 0 thÃ¬ tá»± dá»«ng
- Pause giá»¯a chá»«ng â†’ Ä‘áº¿m dá»«ng, tiáº¿p tá»¥c Start thÃ¬ cháº¡y tiáº¿p
- Reset â†’ vá» giÃ¡ trá»‹ ban Ä‘áº§u, dá»«ng náº¿u Ä‘ang cháº¡y
- Thay Ä‘á»•i input khi Ä‘ang cháº¡y â†’ khÃ´ng áº£nh hÆ°á»Ÿng (disabled)
- Unmount trong lÃºc Ä‘áº¿m â†’ console log "Clearing countdown interval", khÃ´ng warning setState
- KhÃ´ng cÃ²n interval cháº¡y ngáº§m sau khi pause/unmount/reset
*/
```

</details>

**BÃ i 2: Window Resize Handler vá»›i Debounce**

```jsx
/**
 * Táº¡o component hiá»ƒn thá»‹ window size:
 * - Track window.innerWidth vÃ  innerHeight
 * - Debounce resize events (300ms)
 * - Cleanup listener vÃ  timeout
 *
 * Requirements:
 * - addEventListener('resize', ...)
 * - removeEventListener trong cleanup
 * - setTimeout Ä‘á»ƒ debounce
 * - clearTimeout trong cleanup
 *
 * Hints:
 * - Effect vá»›i [] deps (setup once)
 * - Cleanup function removes listener
 * - Nested cleanup: clear timeout before removing listener
 */
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Window Resize Handler with Debounce
 * - Hiá»ƒn thá»‹ kÃ­ch thÆ°á»›c cá»­a sá»• hiá»‡n táº¡i (width Ã— height)
 * - Debounce sá»± kiá»‡n resize 300ms Ä‘á»ƒ trÃ¡nh cáº­p nháº­t quÃ¡ thÆ°á»ng xuyÃªn
 * - Cleanup cáº£ event listener vÃ  timeout khi component unmount
 * - Setup chá»‰ má»™t láº§n (empty deps)
 */
function WindowSizeTracker() {
  const [dimensions, setDimensions] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    let timeoutId = null;

    const handleResize = () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }

      timeoutId = setTimeout(() => {
        setDimensions({
          width: window.innerWidth,
          height: window.innerHeight,
        });
      }, 300);
    };

    window.addEventListener('resize', handleResize);

    return () => {
      console.log('ğŸ§¹ Cleaning up resize handler');
      window.removeEventListener('resize', handleResize);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, []);

  return (
    <div style={{ padding: '24px', fontFamily: 'system-ui' }}>
      <h2>Window Size Tracker (Debounced)</h2>
      <div
        style={{
          fontSize: '32px',
          fontWeight: 'bold',
          margin: '20px 0',
          padding: '20px',
          background: '#f0f4f8',
          borderRadius: '12px',
          textAlign: 'center',
        }}
      >
        {dimensions.width} Ã— {dimensions.height}
      </div>
      <p style={{ color: '#555', fontSize: '15px' }}>
        Thá»­ thay Ä‘á»•i kÃ­ch thÆ°á»›c cá»­a sá»• â†’ giÃ¡ trá»‹ chá»‰ cáº­p nháº­t sau khi ngá»«ng
        resize ~300ms
      </p>
      <p style={{ color: '#777', fontSize: '13px', marginTop: '24px' }}>
        Unmount component (áº©n nÃ³) â†’ kiá»ƒm tra console cÃ³ log cleanup vÃ  khÃ´ng cÃ²n
        listener/timeout leak
      </p>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i khi test:
- Mount â†’ hiá»ƒn thá»‹ kÃ­ch thÆ°á»›c ban Ä‘áº§u ngay láº­p tá»©c
- Resize cá»­a sá»• nhanh liÃªn tá»¥c â†’ state chá»‰ cáº­p nháº­t 1 láº§n sau khi ngá»«ng ~300ms
- Resize cháº­m (ngá»«ng >300ms giá»¯a cÃ¡c láº§n) â†’ cáº­p nháº­t má»—i láº§n sau 300ms
- Unmount component trong lÃºc Ä‘ang debounce â†’ timeout bá»‹ clear, khÃ´ng update state thá»«a
- Console log "Cleaning up resize handler" khi unmount
- KhÃ´ng warning "Can't perform a React state update on an unmounted component"
- KhÃ´ng cÃ²n resize listener hoáº¡t Ä‘á»™ng sau khi component bá»‹ gá»¡
*/
```

</details>

---

### NÃ¢ng cao (60 phÃºt)

**BÃ i 3: Auto-save Form vá»›i Multiple Cleanups**

```jsx
/**
 * Táº¡o form tá»± Ä‘á»™ng save:
 * - Fields: name, email, message
 * - Auto-save sau 3s khÃ´ng cÃ³ thay Ä‘á»•i (debounce)
 * - Show "Saving..." indicator
 * - Cleanup: Save immediately on unmount
 *
 * Requirements:
 * - setTimeout Ä‘á»ƒ debounce save
 * - clearTimeout khi fields thay Ä‘á»•i
 * - Final save trong cleanup
 * - localStorage persistence
 *
 * Challenges:
 * - Multiple fields â†’ Single debounce
 * - Unsaved changes warning
 * - Load saved data on mount
 * - Handle localStorage errors
 */
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Auto-save Form vá»›i debounce vÃ  cleanup toÃ n diá»‡n
 * - Fields: name, email, message
 * - Tá»± Ä‘á»™ng lÆ°u vÃ o localStorage sau 3 giÃ¢y khÃ´ng thay Ä‘á»•i (debounce)
 * - Hiá»ƒn thá»‹ tráº¡ng thÃ¡i "Saving..." khi Ä‘ang lÆ°u
 * - LÆ°u ngay láº­p tá»©c khi component unmount (final save)
 * - Load dá»¯ liá»‡u Ä‘Ã£ lÆ°u khi mount
 * - Xá»­ lÃ½ lá»—i localStorage cÆ¡ báº£n
 * - Cleanup timeout khi fields thay Ä‘á»•i hoáº·c unmount
 */
function AutoSaveForm() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: '',
  });
  const [isSaving, setIsSaving] = useState(false);
  const [lastSaved, setLastSaved] = useState(null);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  // Load dá»¯ liá»‡u tá»« localStorage khi mount
  useEffect(() => {
    try {
      const saved = localStorage.getItem('autoSaveForm');
      if (saved) {
        const parsed = JSON.parse(saved);
        setFormData(parsed);
        setLastSaved(new Date());
        console.log('ğŸ“‚ Loaded saved form data');
      }
    } catch (err) {
      console.error('âŒ Error loading form data:', err);
    }
  }, []);

  // Debounce auto-save
  useEffect(() => {
    if (!hasUnsavedChanges) return;

    setIsSaving(true);

    const timeoutId = setTimeout(() => {
      try {
        localStorage.setItem('autoSaveForm', JSON.stringify(formData));
        setLastSaved(new Date());
        setIsSaving(false);
        setHasUnsavedChanges(false);
        console.log('ğŸ’¾ Auto-saved form data');
      } catch (err) {
        console.error('âŒ Error saving form data:', err);
        setIsSaving(false);
      }
    }, 3000);

    return () => {
      console.log('ğŸ§¹ Clearing auto-save timeout');
      clearTimeout(timeoutId);
      setIsSaving(false);
    };
  }, [formData, hasUnsavedChanges]);

  // Final save khi unmount (náº¿u cÃ³ thay Ä‘á»•i chÆ°a lÆ°u)
  useEffect(() => {
    return () => {
      if (hasUnsavedChanges) {
        try {
          localStorage.setItem('autoSaveForm', JSON.stringify(formData));
          console.log('ğŸ’¾ Final save on unmount');
        } catch (err) {
          console.error('âŒ Final save failed:', err);
        }
      }
    };
  }, [formData, hasUnsavedChanges]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
    setHasUnsavedChanges(true);
  };

  const handleReset = () => {
    if (window.confirm('Báº¡n cÃ³ cháº¯c muá»‘n xÃ³a dá»¯ liá»‡u Ä‘Ã£ nháº­p?')) {
      setFormData({ name: '', email: '', message: '' });
      setHasUnsavedChanges(false);
      setLastSaved(null);
      try {
        localStorage.removeItem('autoSaveForm');
      } catch (err) {}
    }
  };

  return (
    <div style={{ maxWidth: '600px', margin: '0 auto', padding: '24px' }}>
      <h2>Auto-save Form (Debounce 3s)</h2>

      <form style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
        <div>
          <label
            style={{ display: 'block', marginBottom: '6px', fontWeight: '500' }}
          >
            Há» tÃªn
          </label>
          <input
            type='text'
            name='name'
            value={formData.name}
            onChange={handleChange}
            placeholder='Nháº­p tÃªn cá»§a báº¡n'
            style={{
              width: '100%',
              padding: '10px',
              borderRadius: '6px',
              border: '1px solid #ccc',
            }}
          />
        </div>

        <div>
          <label
            style={{ display: 'block', marginBottom: '6px', fontWeight: '500' }}
          >
            Email
          </label>
          <input
            type='email'
            name='email'
            value={formData.email}
            onChange={handleChange}
            placeholder='example@email.com'
            style={{
              width: '100%',
              padding: '10px',
              borderRadius: '6px',
              border: '1px solid #ccc',
            }}
          />
        </div>

        <div>
          <label
            style={{ display: 'block', marginBottom: '6px', fontWeight: '500' }}
          >
            Tin nháº¯n / Ghi chÃº
          </label>
          <textarea
            name='message'
            value={formData.message}
            onChange={handleChange}
            placeholder='Viáº¿t gÃ¬ Ä‘Ã³...'
            rows={5}
            style={{
              width: '100%',
              padding: '10px',
              borderRadius: '6px',
              border: '1px solid #ccc',
              resize: 'vertical',
            }}
          />
        </div>

        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginTop: '12px',
          }}
        >
          <div
            style={{
              fontSize: '14px',
              color: isSaving ? '#e91e63' : '#4CAF50',
            }}
          >
            {isSaving
              ? 'Äang lÆ°u...'
              : lastSaved
                ? `ÄÃ£ lÆ°u láº§n cuá»‘i: ${lastSaved.toLocaleTimeString()}`
                : 'ChÆ°a cÃ³ thay Ä‘á»•i'}
          </div>

          <button
            type='button'
            onClick={handleReset}
            style={{
              padding: '10px 20px',
              background: '#f44336',
              color: 'white',
              border: 'none',
              borderRadius: '6px',
              cursor: 'pointer',
            }}
          >
            XÃ³a dá»¯ liá»‡u
          </button>
        </div>
      </form>

      {hasUnsavedChanges && (
        <p style={{ color: '#f57c00', fontSize: '14px', marginTop: '16px' }}>
          âš ï¸ Báº¡n cÃ³ thay Ä‘á»•i chÆ°a lÆ°u. Dá»¯ liá»‡u sáº½ tá»± Ä‘á»™ng lÆ°u sau 3 giÃ¢y khÃ´ng
          gÃµ.
        </p>
      )}

      <p style={{ marginTop: '32px', color: '#666', fontSize: '13px' }}>
        Thá»­ gÃµ gÃ¬ Ä‘Ã³ â†’ chá» 3s â†’ tháº¥y "ÄÃ£ lÆ°u" <br />
        Thay Ä‘á»•i rá»“i unmount ngay (áº©n component) â†’ kiá»ƒm tra console cÃ³ "Final
        save on unmount" vÃ  dá»¯ liá»‡u váº«n Ä‘Æ°á»£c lÆ°u
      </p>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i khi test:
- Mount â†’ load dá»¯ liá»‡u cÅ© tá»« localStorage (náº¿u cÃ³)
- GÃµ báº¥t ká»³ field nÃ o â†’ "Äang lÆ°u..." sau 3s â†’ "ÄÃ£ lÆ°u láº§n cuá»‘i: ..."
- GÃµ liÃªn tá»¥c nhanh â†’ timeout cÅ© bá»‹ clear, chá»‰ lÆ°u 1 láº§n sau 3s ngá»«ng gÃµ
- Unmount khi Ä‘ang cÃ³ thay Ä‘á»•i chÆ°a lÆ°u â†’ console "Final save on unmount", dá»¯ liá»‡u Ä‘Æ°á»£c lÆ°u ngay
- Mount láº¡i â†’ dá»¯ liá»‡u vá»«a lÆ°u Ä‘Æ°á»£c load láº¡i
- Nháº¥n "XÃ³a dá»¯ liá»‡u" â†’ xÃ³a form vÃ  localStorage
- KhÃ´ng warning setState trÃªn unmounted component
- KhÃ´ng timeout leak khi gÃµ nhanh hoáº·c unmount
*/
```

</details>

**BÃ i 4: Live Search vá»›i Cancel**

```jsx
/**
 * Táº¡o live search vá»›i API:
 * - Input field
 * - Debounce 500ms
 * - Cancel pending requests khi query thay Ä‘á»•i
 * - Cleanup táº¥t cáº£
 *
 * Requirements:
 * - setTimeout debounce
 * - AbortController Ä‘á»ƒ cancel fetch
 * - Cleanup: clear timeout + abort fetch
 * - No setState sau unmount
 *
 * Challenges:
 * - Race conditions
 * - Loading states
 * - Error handling
 * - Empty results
 */
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Live Search vá»›i debounce + cancel pending requests
 * - Input field tÃ¬m kiáº¿m sáº£n pháº©m
 * - Debounce 500ms trÆ°á»›c khi gá»i API
 * - Sá»­ dá»¥ng AbortController Ä‘á»ƒ há»§y fetch khi query thay Ä‘á»•i
 * - Cleanup: clear timeout + abort controller khi deps thay Ä‘á»•i hoáº·c unmount
 * - Xá»­ lÃ½ loading, error, empty results
 * - NgÄƒn race condition vÃ  setState trÃªn unmounted component
 */
function LiveSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!query.trim()) {
      setResults([]);
      setError(null);
      setIsLoading(false);
      return;
    }

    let timeoutId = null;
    const controller = new AbortController();

    const performSearch = async () => {
      setIsLoading(true);
      setError(null);

      try {
        const response = await fetch(
          `https://dummyjson.com/products/search?q=${encodeURIComponent(query)}`,
          { signal: controller.signal },
        );

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        setResults(data.products || []);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message || 'CÃ³ lá»—i khi tÃ¬m kiáº¿m');
          setResults([]);
        }
      } finally {
        setIsLoading(false);
      }
    };

    timeoutId = setTimeout(() => {
      performSearch();
    }, 500);

    return () => {
      console.log('ğŸ§¹ Cleaning up live search');
      if (timeoutId) clearTimeout(timeoutId);
      controller.abort();
    };
  }, [query]);

  const handleChange = (e) => {
    setQuery(e.target.value);
  };

  return (
    <div style={{ maxWidth: '600px', margin: '0 auto', padding: '24px' }}>
      <h2>Live Search (Debounce + Cancel)</h2>

      <input
        type='text'
        value={query}
        onChange={handleChange}
        placeholder='TÃ¬m kiáº¿m sáº£n pháº©m (vÃ­ dá»¥: phone, laptop...)'
        style={{
          width: '100%',
          padding: '12px',
          fontSize: '16px',
          borderRadius: '8px',
          border: '1px solid #ccc',
          marginBottom: '16px',
        }}
      />

      {isLoading && (
        <p style={{ color: '#1976d2', fontWeight: '500' }}>Äang tÃ¬m kiáº¿m...</p>
      )}

      {error && (
        <p style={{ color: '#d32f2f', fontWeight: '500' }}>Lá»—i: {error}</p>
      )}

      {!isLoading && !error && results.length === 0 && query.trim() && (
        <p style={{ color: '#757575' }}>
          KhÃ´ng tÃ¬m tháº¥y sáº£n pháº©m nÃ o cho "{query}"
        </p>
      )}

      {results.length > 0 && (
        <div>
          <h3>Káº¿t quáº£ ({results.length} sáº£n pháº©m)</h3>
          <ul style={{ listStyle: 'none', padding: 0 }}>
            {results.map((product) => (
              <li
                key={product.id}
                style={{
                  padding: '12px',
                  borderBottom: '1px solid #eee',
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                }}
              >
                <div>
                  <strong>{product.title}</strong>
                  <div style={{ color: '#555', fontSize: '14px' }}>
                    {product.description.substring(0, 80)}...
                  </div>
                </div>
                <span style={{ color: '#2e7d32', fontWeight: 'bold' }}>
                  ${product.price}
                </span>
              </li>
            ))}
          </ul>
        </div>
      )}

      <p style={{ marginTop: '32px', color: '#666', fontSize: '14px' }}>
        Thá»­ gÃµ nhanh "phone" rá»“i sá»­a thÃ nh "laptop" ngay â†’ request cÅ© bá»‹ há»§y
        <br />
        Unmount component khi Ä‘ang loading â†’ khÃ´ng cÃ³ warning setState, fetch bá»‹
        abort
      </p>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i khi test:
- GÃµ "phone" â†’ sau 500ms gá»i API â†’ hiá»ƒn thá»‹ sáº£n pháº©m
- GÃµ nhanh "phone" â†’ xÃ³a â†’ gÃµ "laptop" â†’ request "phone" bá»‹ abort, chá»‰ hiá»ƒn thá»‹ káº¿t quáº£ "laptop"
- GÃµ rá»“i unmount ngay (áº©n component) â†’ fetch bá»‹ há»§y, khÃ´ng warning "Can't perform a React state update on an unmounted component"
- Query rá»—ng â†’ káº¿t quáº£ clear ngay
- Lá»—i máº¡ng â†’ hiá»ƒn thá»‹ thÃ´ng bÃ¡o lá»—i
- Console log "Cleaning up live search" khi query thay Ä‘á»•i hoáº·c unmount
- KhÃ´ng timeout hay fetch nÃ o leak
*/
```

</details>

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - useEffect Cleanup**
   - https://react.dev/reference/react/useEffect#cleanup-function
   - Äá»c ká»¹ pháº§n Cleanup
   - Examples vá»›i timers, listeners

2. **Synchronizing with Effects**
   - https://react.dev/learn/synchronizing-with-effects
   - Effect lifecycle
   - When cleanup runs

### Äá»c thÃªm

3. **AbortController MDN**
   - https://developer.mozilla.org/en-US/docs/Web/API/AbortController
   - How to cancel fetch requests
   - Browser support

4. **Memory Leaks in React**
   - Common patterns that leak
   - Detection vá»›i Chrome DevTools
   - Prevention strategies

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (Ä‘Ã£ há»c):

- **NgÃ y 16:** useEffect Introduction
  - ÄÃ£ há»c: Effect basic syntax
  - Káº¿t ná»‘i: HÃ´m nay complete vá»›i cleanup

- **NgÃ y 17:** Dependencies Deep Dive
  - ÄÃ£ há»c: When effects re-run
  - Káº¿t ná»‘i: Cleanup cháº¡y trÆ°á»›c re-run

### HÆ°á»›ng tá»›i (sáº½ há»c):

- **NgÃ y 19-20:** Data Fetching
  - Sáº½ há»c: API calls trong effects
  - Sáº½ dÃ¹ng: Cleanup Ä‘á»ƒ cancel requests

- **NgÃ y 21:** useRef
  - Sáº½ há»c: Persist values without re-render
  - Sáº½ dÃ¹ng: Alternative to isCancelled flag

- **NgÃ y 24:** Custom Hooks
  - Sáº½ há»c: Extract cleanup logic
  - Sáº½ dÃ¹ng: useDebounce, useInterval custom hooks

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**1. Cleanup Checklist Template:**

```jsx
useEffect(() => {
  // âœ… Setup
  const resource = setupResource();

  // âœ… Cleanup checklist:
  return () => {
    // 1. Clear timers
    clearInterval(intervalId);
    clearTimeout(timeoutId);

    // 2. Remove listeners
    element.removeEventListener('event', handler);

    // 3. Close connections
    websocket.close();

    // 4. Cancel async
    controller.abort();

    // 5. Cleanup third-party
    library.destroy();

    // 6. Final sync (save data, send analytics)
    finalSave();
  };
}, [deps]);
```

**2. Debugging Cleanup:**

```jsx
useEffect(() => {
  const DEBUG = process.env.NODE_ENV === 'development';

  if (DEBUG) console.log('[Effect] Setup:', { deps });

  // Setup code

  return () => {
    if (DEBUG) console.log('[Cleanup] Running:', { deps });
    // Cleanup code
  };
}, [deps]);
```

**3. Testing Cleanup:**

```jsx
// Test cleanup manually
function TestCleanup() {
  const [show, setShow] = useState(true);

  return (
    <>
      <button onClick={() => setShow(!show)}>Toggle (triggers cleanup)</button>
      {show && <ComponentWithCleanup />}
    </>
  );
}
```

---

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior Level:**

1. **Q:** Cleanup function lÃ  gÃ¬?

   **A:** Function Ä‘Æ°á»£c return tá»« useEffect Ä‘á»ƒ dá»n dáº¹p side effects (timers, listeners, etc.). Cháº¡y trÆ°á»›c khi effect re-run vÃ  khi component unmount.

2. **Q:** Khi nÃ o cáº§n cleanup?

   **A:** Khi effect táº¡o resources cáº§n Ä‘Æ°á»£c dá»n dáº¹p: timers (setInterval/setTimeout), event listeners, subscriptions, async operations cÃ³ setState.

3. **Q:** LÃ m sao cleanup event listener?

   **A:**

   ```jsx
   useEffect(() => {
     const handler = () => {
       /* ... */
     };
     window.addEventListener('event', handler);
     return () => window.removeEventListener('event', handler);
   }, []);
   ```

**Mid Level:**

4. **Q:** Táº¡i sao cleanup cháº¡y trÆ°á»›c effect re-run?

   **A:** Äá»ƒ dá»n dáº¹p old setup trÆ°á»›c khi táº¡o new setup. Prevents resource leaks vÃ  conflicts giá»¯a old vÃ  new effects.

5. **Q:** LÃ m sao prevent setState sau unmount?

   **A:** DÃ¹ng cleanup flag:

   ```jsx
   useEffect(() => {
     let isCancelled = false;
     fetchData().then((data) => {
       if (!isCancelled) setState(data);
     });
     return () => {
       isCancelled = true;
     };
   }, []);
   ```

**Senior Level:**

6. **Q:** Handle cleanup cho complex async workflows? (
   Xá»­ lÃ½ viá»‡c dá»n dáº¹p cho cÃ¡c quy trÃ¬nh cÃ´ng viá»‡c báº¥t Ä‘á»“ng bá»™ phá»©c táº¡p.)

   **A:**
   - AbortController cho fetch: há»§y request khi component unmount

     ```ts
     const controller = new AbortController();

     fetch(url, { signal: controller.signal });

     return () => controller.abort();
     ```

   - Cleanup flags cho promises: cháº·n xá»­ lÃ½ khi async hoÃ n thÃ nh muá»™n

     ```ts
     let isCancelled = false;

     asyncTask().then(() => {
       if (!isCancelled) setState(data);
     });

     return () => {
       isCancelled = true;
     };
     ```

   - Queue management cho batched operations: clear queue khi workflow bá»‹ cancel

     ```ts
     const queue: Job[] = [];

     function cancelAll() {
       queue.length = 0;
     }
     ```

   - Timeout Ä‘á»ƒ force cleanup náº¿u chÆ°a hoÃ n thÃ nh (bá»‹ hung / treo): watchdog tá»± Ä‘á»™ng há»§y task

     ```ts
     const timeoutId = setTimeout(() => cancelTask(), 30000);

     task.finally(() => clearTimeout(timeoutId));
     ```

   - Transaction pattern (commit hoáº·c rollback): chá»‰ commit khi táº¥t cáº£ step thÃ nh cÃ´ng

     ```ts
     try {
       await step1();
       await step2();
       commit();
     } catch {
       rollback();
     }
     ```

7. **Q:** Memory leak detection strategy?

   **A:**
   - Chrome DevTools Memory profiler: so sÃ¡nh heap snapshot

     ```js
     // Take snapshot before & after navigation
     ```

   - Track component instances count: Ä‘áº¿m instance cÃ²n sá»‘ng

     ```ts
     let instanceCount = 0;
     useEffect(() => {
       instanceCount++;
       return () => instanceCount--;
     }, []);
     ```

   - Monitor event listeners (`getEventListeners()`): check listener chÆ°a remove

     ```js
     getEventListeners(window).resize;
     ```

   - Automated tests vá»›i mount/unmount cycles: stress test lifecycle

     ```ts
     for (let i = 0; i < 100; i++) {
       mount();
       unmount();
     }
     ```

   - Production monitoring (Sentry, etc.): log memory theo session

     ```ts
     Sentry.captureMessage(`Heap: ${performance.memory.usedJSHeapSize}`);
     ```

---

### War Stories

**Story #1: The Invisible Memory Leak ğŸ’€**

> "Production app cháº¡y smooth ban Ä‘áº§u, nhÆ°ng sau 2-3 giá» â†’ lag, eventual crash. Profiling discover: 1000+ mousemove listeners! Root cause: useEffect thÃªm listener má»—i re-render, khÃ´ng cÃ³ cleanup. Fix: Add return () => removeEventListener. Lesson: LUÃ”N cleanup listeners, test vá»›i unmount/remount cycles."

**Story #2: Race Condition Hell ğŸï¸**

> "Search feature: Type 'react' â†’ 5 letters = 5 API calls. Old requests return sau new request â†’ Wrong results displayed. Issue: No cleanup Ä‘á»ƒ cancel pending requests. Fix: AbortController trong cleanup. Bonus: Added debounce. Lesson: Async + No cleanup = Race conditions."

**Story #3: The Cleanup That Saved Production ğŸš‘**

> "Video player app: Users report 'ghost audio' - video stopped nhÆ°ng váº«n nghe audio. Debug: Multiple `<audio>` elements created, khÃ´ng cleanup khi video thay Ä‘á»•i. Fix: Return () => audio.pause() + audio.remove() trong cleanup. Lesson: DOM elements cáº§n explicit cleanup, especially media!"

---

## ğŸ¯ NGÃ€Y MAI: Data Fetching - Basics

Preview nhá»¯ng gÃ¬ báº¡n sáº½ há»c:

### fetch API trong useEffect

- Async/await syntax trong effects
- Loading/Error/Success states
- Dependencies cho data fetching

### Practical Patterns

- Initial data fetch (empty deps)
- Refetch on param change
- Cancel vá»›i AbortController

### Error Handling

- Try/catch trong async effects
- Error boundaries preview
- Retry logic

**ğŸ”¥ Chuáº©n bá»‹:**

- Ã”n láº¡i Promises & async/await
- Hiá»ƒu fetch API basics
- Practice cleanup (bÃ i táº­p hÃ´m nay!)

---

**ğŸ‰ ChÃºc má»«ng! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 18!**

Báº¡n Ä‘Ã£:

- âœ… Master Ä‘Æ°á»£c Cleanup Functions
- âœ… Prevent Memory Leaks effectively
- âœ… Handle Async Cleanup (AbortController, flags)
- âœ… Clean up Timers, Listeners, Subscriptions
- âœ… Apply cleanup cho production scenarios

**Cleanup lÃ  foundation cho stable, leak-free React apps. Báº¡n Ä‘Ã£ lÃ m chá»§ nÃ³! ğŸŠ**

**NgÃ y 19 sáº½ káº¿t há»£p táº¥t cáº£ (effects + deps + cleanup) cho Data Fetching thá»±c chiáº¿n! ğŸš€**
