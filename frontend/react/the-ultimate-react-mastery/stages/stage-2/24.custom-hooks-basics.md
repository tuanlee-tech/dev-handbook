# üìÖ NG√ÄY 24: Custom Hooks - Basics & Reusable Logic

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:

- [ ] Hi·ªÉu custom hooks l√† g√¨ v√† t·∫°i sao c·∫ßn thi·∫øt
- [ ] N·∫Øm v·ªØng naming convention v√† rules of hooks
- [ ] T·∫°o ƒë∆∞·ª£c custom hooks ƒë·ªÉ extract v√† reuse logic
- [ ] Compose multiple hooks together
- [ ] Bi·∫øt khi n√†o n√™n t·∫°o custom hook vs khi n√†o kh√¥ng
- [ ] Test custom hooks properly
- [ ] Tr√°nh ƒë∆∞·ª£c common pitfalls v√† anti-patterns

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu, h√£y tr·∫£ l·ªùi 3 c√¢u h·ªèi n√†y:

1. **useState, useEffect, useRef l√† g√¨?**
   - Built-in React hooks ƒë·ªÉ manage state, side effects, v√† refs

2. **L√†m sao reuse logic gi·ªØa nhi·ªÅu components?**
   - Tr∆∞·ªõc ƒë√¢y: HOCs, render props. B√¢y gi·ªù: Custom hooks! üéØ

3. **useLayoutEffect d√πng khi n√†o?**
   - DOM measurements tr∆∞·ªõc paint, preventing visual flash

**H√¥m nay:** Ch√∫ng ta s·∫Ω h·ªçc c√°ch **extract hook logic** th√†nh reusable custom hooks! üé£

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

H√£y xem t√¨nh hu·ªëng n√†y - nhi·ªÅu components c·∫ßn same logic:

```jsx
// ‚ùå V·∫§N ƒê·ªÄ: Duplicate logic across components

function UserProfile() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch('/api/user')
      .then((res) => res.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>{data.name}</div>;
}

function ProductList() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch('/api/products')
      .then((res) => res.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return (
    <div>
      {data.map((p) => (
        <div key={p.id}>{p.name}</div>
      ))}
    </div>
  );
}

// ‚ö†Ô∏è Same logic repeated!
// ‚ö†Ô∏è Hard to maintain
// ‚ö†Ô∏è Bug fixes need to be applied everywhere
```

**V·∫•n ƒë·ªÅ:**

- Logic duplicate across nhi·ªÅu components
- Kh√≥ maintain - s·ª≠a 1 ch·ªó ph·∫£i s·ª≠a nhi·ªÅu n∆°i
- Bugs c√≥ th·ªÉ inconsistent
- Code bloat

### 1.2 Gi·∫£i Ph√°p: Custom Hooks

```jsx
// ‚úÖ GI·∫¢I PH√ÅP: Extract logic into custom hook

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        setData(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, [url]);

  return { data, loading, error };
}

// Usage - DRY and clean!
function UserProfile() {
  const { data, loading, error } = useFetch('/api/user');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return <div>{data.name}</div>;
}

function ProductList() {
  const { data, loading, error } = useFetch('/api/products');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  return (
    <div>
      {data.map((p) => (
        <div key={p.id}>{p.name}</div>
      ))}
    </div>
  );
}
```

**Benefits:**

- ‚úÖ Logic reused across components
- ‚úÖ Single source of truth
- ‚úÖ Easy to maintain
- ‚úÖ Easy to test
- ‚úÖ Composable

### 1.3 Mental Model

Custom hooks l√† **functions that use hooks**:

```
Regular Function          Custom Hook
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function add(a, b) {     function useCounter(initial) {
  return a + b;            const [count, setCount] = useState(initial);
}
                           const increment = () => setCount(c => c + 1);

                           return { count, increment };
                         }

Call anywhere            Call only in React components/hooks
Pure computation         Can use React hooks
No side effects          Can have side effects
```

**Visualization:**

```
Component
    ‚îÇ
    ‚îú‚îÄ Built-in Hooks
    ‚îÇ    ‚îú‚îÄ useState
    ‚îÇ    ‚îú‚îÄ useEffect
    ‚îÇ    ‚îî‚îÄ useRef
    ‚îÇ
    ‚îî‚îÄ Custom Hooks
         ‚îú‚îÄ useFetch (uses useState + useEffect)
         ‚îú‚îÄ useLocalStorage (uses useState + useEffect)
         ‚îî‚îÄ useDebounce (uses useState + useEffect)
              ‚îÇ
              ‚îî‚îÄ Can use other custom hooks!
                   ‚îî‚îÄ useTimeout
```

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

#### ‚ùå Hi·ªÉu l·∫ßm 1: "Custom hooks l√† special syntax"

```jsx
// ‚ùå SAI: Nghƒ© custom hook c·∫ßn special declaration
// Kh√¥ng c√≥ g√¨ ƒë·∫∑c bi·ªát! Ch·ªâ l√† function th√¥i.

// ‚úÖ Custom hook ch·ªâ l√† function theo naming convention
function useMyHook() {
  // Must start with "use"
  const [state, setState] = useState(0);
  return state;
}

// That's it! Kh√¥ng c√≥ magic n√†o c·∫£.
```

#### ‚ùå Hi·ªÉu l·∫ßm 2: "Custom hooks share state gi·ªØa components"

```jsx
// ‚ùå SAI: Nghƒ© 2 components d√πng c√πng hook share state
function useCounter() {
  const [count, setCount] = useState(0);
  return { count, setCount };
}

function ComponentA() {
  const { count } = useCounter();
  return <div>A: {count}</div>;
}

function ComponentB() {
  const { count } = useCounter();
  return <div>B: {count}</div>; // ‚ö†Ô∏è KH√îNG share v·ªõi ComponentA!
}
```

**Th·ª±c t·∫ø:**

- M·ªói component call hook ‚Üí ƒë·ªôc l·∫≠p instance c·ªßa hook logic
- State KH√îNG share gi·ªØa components
- Gi·ªëng nh∆∞ g·ªçi useState nhi·ªÅu l·∫ßn ‚Üí separate states

```jsx
// M·ªói component c√≥ ri√™ng state:
ComponentA: count = 0 (instance 1)
ComponentB: count = 0 (instance 2)

// Increment trong A ‚Üí ch·ªâ A update
ComponentA: count = 1
ComponentB: count = 0 (unchanged)
```

#### ‚ùå Hi·ªÉu l·∫ßm 3: "Custom hooks ph·∫£i return object"

```jsx
// Custom hook c√≥ th·ªÉ return b·∫•t c·ª© g√¨:

// ‚úÖ Return array (nh∆∞ useState)
function useToggle(initial) {
  const [value, setValue] = useState(initial);
  const toggle = () => setValue((v) => !v);
  return [value, toggle]; // Array
}

// ‚úÖ Return object
function useCounter(initial) {
  const [count, setCount] = useState(initial);
  return { count, setCount }; // Object
}

// ‚úÖ Return primitive
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline; // Just boolean
}

// ‚úÖ Return function
function useDebounce(callback, delay) {
  const timeoutRef = useRef(null);

  return (...args) => {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(() => callback(...args), delay);
  }; // Function
}
```

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Pattern C∆° B·∫£n - useToggle ‚≠ê

```jsx
/**
 * üéØ M·ª•c ti√™u: Simple custom hook ƒë·ªÉ toggle boolean state
 * üí° Pattern: Extract common toggle logic
 */

import { useState } from 'react';

// ‚úÖ Custom Hook
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = () => setValue((v) => !v);
  const setTrue = () => setValue(true);
  const setFalse = () => setValue(false);

  return [value, { toggle, setTrue, setFalse }];
}

// Usage Examples
function ToggleDemo() {
  const [isOn, { toggle, setTrue, setFalse }] = useToggle(false);
  const [isVisible, toggleVisible] = useToggle(true);

  return (
    <div style={{ padding: '20px' }}>
      <h2>useToggle Demo</h2>

      {/* Example 1: Light switch */}
      <div style={{ marginBottom: '20px' }}>
        <h3>Light Switch</h3>
        <div
          style={{
            width: '100px',
            height: '100px',
            backgroundColor: isOn ? 'yellow' : 'gray',
            borderRadius: '50%',
            margin: '10px 0',
          }}
        />
        <button onClick={toggle}>Toggle</button>
        <button onClick={setTrue}>Turn On</button>
        <button onClick={setFalse}>Turn Off</button>
      </div>

      {/* Example 2: Show/Hide content */}
      <div>
        <h3>Show/Hide Content</h3>
        <button onClick={toggleVisible.toggle}>
          {isVisible ? 'Hide' : 'Show'} Content
        </button>
        {isVisible && (
          <div
            style={{
              marginTop: '10px',
              padding: '15px',
              backgroundColor: '#e3f2fd',
              borderRadius: '4px',
            }}
          >
            This content can be toggled!
          </div>
        )}
      </div>
    </div>
  );
}
```

**Breakdown:**

```jsx
// 1. Hook definition - just a function
function useToggle(initialValue = false) {
  // 2. Use built-in hooks inside
  const [value, setValue] = useState(initialValue);

  // 3. Define helper functions
  const toggle = () => setValue((v) => !v);
  const setTrue = () => setValue(true);
  const setFalse = () => setValue(false);

  // 4. Return API for consumers
  return [value, { toggle, setTrue, setFalse }];
}

// Why this pattern?
// ‚úÖ Reusable across components
// ‚úÖ Encapsulates toggle logic
// ‚úÖ Cleaner than inline setState everywhere
// ‚úÖ Consistent behavior
```

### Demo 2: K·ªãch B·∫£n Th·ª±c T·∫ø - useLocalStorage ‚≠ê‚≠ê

```jsx
/**
 * üéØ Use case: Sync state v·ªõi localStorage
 * üíº Real-world: Theme preferences, form drafts, settings
 * ‚ö†Ô∏è Edge cases: JSON parse errors, storage quota, SSR
 */

import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  // State ƒë·ªÉ store gi√° tr·ªã
  const [storedValue, setStoredValue] = useState(() => {
    // ‚ö†Ô∏è SSR: localStorage kh√¥ng t·ªìn t·∫°i
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      // Get from localStorage by key
      const item = window.localStorage.getItem(key);
      // Parse stored json or return initialValue
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      // ‚ö†Ô∏è Parse error ‚Üí return initialValue
      console.error('Error reading from localStorage:', error);
      return initialValue;
    }
  });

  // Return wrapped version of useState's setter function
  const setValue = (value) => {
    try {
      // Allow value to be a function (same API as useState)
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;

      // Save state
      setStoredValue(valueToStore);

      // Save to localStorage
      if (typeof window !== 'undefined') {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      // ‚ö†Ô∏è Storage quota exceeded
      console.error('Error saving to localStorage:', error);
    }
  };

  return [storedValue, setValue];
}

// Demo App
function LocalStorageDemo() {
  const [name, setName] = useLocalStorage('user-name', '');
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const [todos, setTodos] = useLocalStorage('todos', []);
  const [newTodo, setNewTodo] = useState('');

  const addTodo = () => {
    if (newTodo.trim()) {
      setTodos([...todos, { id: Date.now(), text: newTodo }]);
      setNewTodo('');
    }
  };

  return (
    <div
      style={{
        padding: '20px',
        backgroundColor: theme === 'dark' ? '#222' : '#fff',
        color: theme === 'dark' ? '#fff' : '#000',
        minHeight: '100vh',
      }}
    >
      <h2>useLocalStorage Demo</h2>
      <p>Refresh page to see persistence! üîÑ</p>

      {/* Theme Toggle */}
      <div style={{ marginBottom: '20px' }}>
        <label>
          Theme:
          <select
            value={theme}
            onChange={(e) => setTheme(e.target.value)}
            style={{ marginLeft: '10px', padding: '5px' }}
          >
            <option value='light'>Light</option>
            <option value='dark'>Dark</option>
          </select>
        </label>
      </div>

      {/* Name Input */}
      <div style={{ marginBottom: '20px' }}>
        <label>
          Name:
          <input
            type='text'
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder='Enter your name...'
            style={{
              marginLeft: '10px',
              padding: '5px',
              backgroundColor: theme === 'dark' ? '#333' : '#fff',
              color: theme === 'dark' ? '#fff' : '#000',
              border: '1px solid #ccc',
            }}
          />
        </label>
        {name && <p>Hello, {name}! üëã</p>}
      </div>

      {/* Todo List */}
      <div>
        <h3>Persistent Todo List</h3>
        <div style={{ display: 'flex', gap: '10px', marginBottom: '10px' }}>
          <input
            type='text'
            value={newTodo}
            onChange={(e) => setNewTodo(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && addTodo()}
            placeholder='Add todo...'
            style={{
              flex: 1,
              padding: '8px',
              backgroundColor: theme === 'dark' ? '#333' : '#fff',
              color: theme === 'dark' ? '#fff' : '#000',
              border: '1px solid #ccc',
            }}
          />
          <button
            onClick={addTodo}
            style={{ padding: '8px 15px' }}
          >
            Add
          </button>
        </div>

        <ul style={{ listStyle: 'none', padding: 0 }}>
          {todos.map((todo) => (
            <li
              key={todo.id}
              style={{
                padding: '10px',
                marginBottom: '5px',
                backgroundColor: theme === 'dark' ? '#333' : '#f0f0f0',
                borderRadius: '4px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
              }}
            >
              <span>{todo.text}</span>
              <button
                onClick={() => setTodos(todos.filter((t) => t.id !== todo.id))}
                style={{
                  backgroundColor: '#dc3545',
                  color: 'white',
                  border: 'none',
                  padding: '5px 10px',
                  borderRadius: '4px',
                  cursor: 'pointer',
                }}
              >
                Delete
              </button>
            </li>
          ))}
        </ul>
      </div>

      {/* Debug Info */}
      <details style={{ marginTop: '20px' }}>
        <summary style={{ cursor: 'pointer', fontWeight: 'bold' }}>
          Debug Info
        </summary>
        <pre
          style={{
            marginTop: '10px',
            padding: '10px',
            backgroundColor: theme === 'dark' ? '#333' : '#f5f5f5',
            borderRadius: '4px',
            fontSize: '12px',
          }}
        >
          {JSON.stringify({ name, theme, todos }, null, 2)}
        </pre>
      </details>
    </div>
  );
}
```

**Key Patterns:**

```jsx
// Pattern 1: Lazy initialization
const [storedValue, setStoredValue] = useState(() => {
  // ‚úÖ Function runs once on mount
  // Expensive operation (localStorage read) happens once
  return expensiveRead();
});

// Pattern 2: Functional setter support
const setValue = (value) => {
  const valueToStore = value instanceof Function ? value(storedValue) : value;
  // ‚úÖ Supports both: setValue(5) v√† setValue(prev => prev + 1)
};

// Pattern 3: Error handling
try {
  // Risky operation
} catch (error) {
  // ‚úÖ Graceful fallback
  console.error('Error:', error);
  return initialValue;
}

// Pattern 4: SSR safety
if (typeof window === 'undefined') {
  return initialValue; // ‚úÖ Server-side safe
}
```

### Demo 3: Edge Cases - useDebounce ‚≠ê‚≠ê‚≠ê

```jsx
/**
 * üéØ Use case: Debounce value changes (search input, API calls)
 * ‚ö†Ô∏è Edge cases:
 *    - Value changes rapidly
 *    - Component unmounts during delay
 *    - Delay changes mid-execution
 *    - Initial value handling
 */

import { useState, useEffect } from 'react';

function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    // Set timeout to update debounced value
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cleanup: clear timeout on value/delay change or unmount
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]); // Re-run when value or delay changes

  return debouncedValue;
}

// Search Demo
function SearchDemo() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  const [results, setResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);

  // Effect ƒë·ªÉ search khi debounced value changes
  useEffect(() => {
    if (debouncedSearchTerm) {
      setIsSearching(true);

      // Mock API call
      setTimeout(() => {
        const mockResults = [
          `Result 1 for "${debouncedSearchTerm}"`,
          `Result 2 for "${debouncedSearchTerm}"`,
          `Result 3 for "${debouncedSearchTerm}"`,
        ];
        setResults(mockResults);
        setIsSearching(false);
      }, 300);
    } else {
      setResults([]);
    }
  }, [debouncedSearchTerm]); // ‚úÖ Only search when debounced value changes

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h2>useDebounce Demo - Search</h2>

      <input
        type='text'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder='Type to search...'
        style={{
          width: '100%',
          padding: '12px',
          fontSize: '16px',
          border: '2px solid #007bff',
          borderRadius: '4px',
        }}
      />

      <div style={{ marginTop: '10px', fontSize: '14px', color: '#666' }}>
        <p>Typing: "{searchTerm}"</p>
        <p>Searching for: "{debouncedSearchTerm}"</p>
        <p>Delay: 500ms after you stop typing</p>
      </div>

      {isSearching && (
        <div
          style={{ marginTop: '20px', textAlign: 'center', color: '#007bff' }}
        >
          Searching...
        </div>
      )}

      {!isSearching && results.length > 0 && (
        <ul style={{ marginTop: '20px' }}>
          {results.map((result, index) => (
            <li
              key={index}
              style={{
                padding: '10px',
                marginBottom: '5px',
                backgroundColor: '#f0f0f0',
                borderRadius: '4px',
              }}
            >
              {result}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

**Timeline visualization:**

```
User types "react"
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Time:    0ms   100ms  200ms  300ms  400ms  500ms  600ms
Input:   r     re     rea    reac   react  (stop)
Timeout: [set] [clear+set] [clear+set] [clear+set] [clear+set] [wait] [FIRE!]
Search:                                                         [API call]

Without debounce:
API:     call  call   call   call   call
         ‚ùå 5 unnecessary API calls!

With debounce:
API:                                                            call
         ‚úÖ Only 1 API call after user stops typing!
```

**Advanced useDebounce with callback:**

```jsx
// Alternative: Debounce callback instead of value
function useDebouncedCallback(callback, delay) {
  const timeoutRef = useRef(null);
  const callbackRef = useRef(callback);

  // Keep callback ref updated
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);

  return (...args) => {
    // Clear previous timeout
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // Set new timeout
    timeoutRef.current = setTimeout(() => {
      callbackRef.current(...args);
    }, delay);
  };
}

// Usage:
function SearchWithCallback() {
  const [results, setResults] = useState([]);

  const debouncedSearch = useDebouncedCallback((term) => {
    fetch(`/api/search?q=${term}`)
      .then((res) => res.json())
      .then(setResults);
  }, 500);

  return <input onChange={(e) => debouncedSearch(e.target.value)} />;
}
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Exercise 1: useCounter Hook (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: T·∫°o reusable counter hook
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: useReducer (ch∆∞a h·ªçc)
 *
 * Requirements:
 * 1. Initial value support
 * 2. Increment, decrement, reset functions
 * 3. Set to specific value
 * 4. Min/max bounds (optional)
 * 5. Step size configurable
 *
 * üí° G·ª£i √Ω:
 * - useState cho counter value
 * - Return object v·ªõi value v√† methods
 * - Clamp gi√° tr·ªã trong bounds n·∫øu c√≥
 */

import { useState } from 'react';

// TODO: Implement useCounter
function useCounter(initialValue = 0, { min, max, step = 1 } = {}) {
  // Step 1: State cho counter value
  // const [count, setCount] = useState(initialValue);
  // Step 2: Increment function
  // const increment = () => {
  //   setCount(current => {
  //     const newValue = current + step;
  //     if (max !== undefined) return Math.min(newValue, max);
  //     return newValue;
  //   });
  // };
  // Step 3: Decrement function
  // const decrement = () => { ... };
  // Step 4: Reset function
  // const reset = () => setCount(initialValue);
  // Step 5: Set function
  // const set = (value) => { ... with bounds checking };
  // Step 6: Return API
  // return { count, increment, decrement, reset, set };
}

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N: Implement hook and test with this component
function CounterDemo() {
  const counter = useCounter(0, { min: 0, max: 10, step: 1 });
  const bigCounter = useCounter(0, { step: 5 });

  return (
    <div style={{ padding: '20px' }}>
      <h2>useCounter Demo</h2>

      {/* Basic Counter */}
      <div style={{ marginBottom: '30px' }}>
        <h3>Basic Counter (0-10)</h3>
        <div style={{ fontSize: '32px', fontWeight: 'bold', margin: '10px 0' }}>
          {counter.count}
        </div>
        <div style={{ display: 'flex', gap: '10px' }}>
          <button onClick={counter.decrement}>-1</button>
          <button onClick={counter.increment}>+1</button>
          <button onClick={counter.reset}>Reset</button>
          <button onClick={() => counter.set(5)}>Set to 5</button>
        </div>
      </div>

      {/* Big Step Counter */}
      <div>
        <h3>Big Step Counter (step: 5)</h3>
        <div style={{ fontSize: '32px', fontWeight: 'bold', margin: '10px 0' }}>
          {bigCounter.count}
        </div>
        <div style={{ display: 'flex', gap: '10px' }}>
          <button onClick={bigCounter.decrement}>-5</button>
          <button onClick={bigCounter.increment}>+5</button>
          <button onClick={bigCounter.reset}>Reset</button>
        </div>
      </div>
    </div>
  );
}

// ‚úÖ Expected behavior:
// - Counter stays within bounds (0-10)
// - Step size applied correctly
// - Reset returns to initial value
// - Set clamps to bounds
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Custom hook t·∫°o b·ªô ƒë·∫øm c√≥ th·ªÉ t√πy ch·ªânh gi·ªõi h·∫°n, b∆∞·ªõc nh·∫£y
 * @param {number} initialValue - Gi√° tr·ªã ban ƒë·∫ßu c·ªßa b·ªô ƒë·∫øm
 * @param {Object} options - T√πy ch·ªçn c·∫•u h√¨nh
 * @param {number} [options.min] - Gi√° tr·ªã t·ªëi thi·ªÉu (optional)
 * @param {number} [options.max] - Gi√° tr·ªã t·ªëi ƒëa (optional)
 * @param {number} [options.step=1] - B∆∞·ªõc nh·∫£y m·ªói l·∫ßn tƒÉng/gi·∫£m
 * @returns {Object} API c·ªßa counter
 */
function useCounter(initialValue = 0, { min, max, step = 1 } = {}) {
  const [count, setCount] = useState(initialValue);

  const clamp = (value) => {
    if (min !== undefined) value = Math.max(value, min);
    if (max !== undefined) value = Math.min(value, max);
    return value;
  };

  const increment = () => {
    setCount((current) => clamp(current + step));
  };

  const decrement = () => {
    setCount((current) => clamp(current - step));
  };

  const reset = () => {
    setCount(initialValue);
  };

  const set = (value) => {
    setCount(clamp(value));
  };

  return {
    count,
    increment,
    decrement,
    reset,
    set,
  };
}

// V√≠ d·ª• k·∫øt qu·∫£ khi s·ª≠ d·ª•ng:
// const counter = useCounter(0, { min: 0, max: 10, step: 1 });
// counter.count     ‚Üí 0
// counter.increment() ‚Üí count = 1
// counter.increment() ‚Üí count = 2
// ... ti·∫øp t·ª•c ƒë·∫øn 10 th√¨ kh√¥ng tƒÉng n·ªØa
// counter.decrement() ‚Üí count = 9
// counter.set(15)     ‚Üí count = 10 (b·ªã clamp)
// counter.reset()     ‚Üí count = 0

// const bigCounter = useCounter(0, { step: 5 });
// bigCounter.increment() ‚Üí count = 5
// bigCounter.decrement() ‚Üí count = 0
```

</details>

### ‚≠ê‚≠ê Exercise 2: useClickOutside Hook (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Reusable click-outside detection hook
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario:
 * Nhi·ªÅu components c·∫ßn close khi click outside (dropdown, modal, tooltip).
 * Extract logic n√†y th√†nh hook ƒë·ªÉ reuse.
 *
 * Requirements:
 * 1. Accept ref v√† callback
 * 2. Detect clicks outside element
 * 3. Cleanup listeners properly
 * 4. Support multiple refs (bonus)
 * 5. Keyboard escape support (bonus)
 *
 * API Design:
 * useClickOutside(ref, callback, options)
 */

import { useEffect, useRef } from 'react';

function useClickOutside(ref, handler, options = {}) {
  const { enabled = true, keys = ['Escape'] } = options;

  useEffect(() => {
    if (!enabled) return;

    // TODO: Implement
    // 1. Handle mouse clicks
    // const handleClick = (event) => {
    //   if (ref.current && !ref.current.contains(event.target)) {
    //     handler(event);
    //   }
    // };

    // 2. Handle keyboard (Escape)
    // const handleKeyDown = (event) => {
    //   if (keys.includes(event.key)) {
    //     handler(event);
    //   }
    // };

    // 3. Add listeners
    // document.addEventListener('mousedown', handleClick);
    // document.addEventListener('keydown', handleKeyDown);

    // 4. Cleanup
    // return () => {
    //   document.removeEventListener('mousedown', handleClick);
    //   document.removeEventListener('keydown', handleKeyDown);
    // };
  }, [ref, handler, enabled, keys]);
}

// Demo Components
function DropdownMenu() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  useClickOutside(dropdownRef, () => setIsOpen(false), {
    enabled: isOpen,
  });

  return (
    <div style={{ position: 'relative', display: 'inline-block' }}>
      <button onClick={() => setIsOpen(!isOpen)}>
        Menu {isOpen ? '‚ñ≤' : '‚ñº'}
      </button>

      {isOpen && (
        <div
          ref={dropdownRef}
          style={{
            position: 'absolute',
            top: '100%',
            left: 0,
            marginTop: '5px',
            backgroundColor: 'white',
            border: '1px solid #ccc',
            borderRadius: '4px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
            minWidth: '150px',
            zIndex: 1000,
          }}
        >
          <div style={{ padding: '10px', cursor: 'pointer' }}>Option 1</div>
          <div style={{ padding: '10px', cursor: 'pointer' }}>Option 2</div>
          <div style={{ padding: '10px', cursor: 'pointer' }}>Option 3</div>
        </div>
      )}
    </div>
  );
}

function Modal({ isOpen, onClose, children }) {
  const modalRef = useRef(null);

  useClickOutside(modalRef, onClose, {
    enabled: isOpen,
  });

  if (!isOpen) return null;

  return (
    <div
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0,0,0,0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
      }}
    >
      <div
        ref={modalRef}
        style={{
          backgroundColor: 'white',
          padding: '20px',
          borderRadius: '8px',
          maxWidth: '400px',
        }}
      >
        {children}
      </div>
    </div>
  );
}

// Test Component
function ClickOutsideDemo() {
  const [showModal, setShowModal] = useState(false);

  return (
    <div style={{ padding: '20px' }}>
      <h2>useClickOutside Demo</h2>

      <div style={{ marginBottom: '20px' }}>
        <DropdownMenu />
      </div>

      <button onClick={() => setShowModal(true)}>Open Modal</button>

      <Modal
        isOpen={showModal}
        onClose={() => setShowModal(false)}
      >
        <h3>Modal Title</h3>
        <p>Click outside or press Escape to close</p>
        <button onClick={() => setShowModal(false)}>Close</button>
      </Modal>
    </div>
  );
}

// üéØ Expected behavior:
// - Dropdown closes on outside click
// - Modal closes on outside click or Escape
// - No crashes, proper cleanup
// - Works with multiple instances
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Custom hook ph√°t hi·ªán click b√™n ngo√†i m·ªôt element (ho·∫∑c nh·∫•n Escape)
 * @param {React.RefObject} ref - ref c·ªßa element c·∫ßn theo d√µi
 * @param {Function} handler - h√†m ƒë∆∞·ª£c g·ªçi khi click outside ho·∫∑c nh·∫•n ph√≠m tho√°t
 * @param {Object} [options={}] - t√πy ch·ªçn
 * @param {boolean} [options.enabled=true] - b·∫≠t/t·∫Øt hook
 * @param {string[]} [options.keys=['Escape']] - danh s√°ch ph√≠m tho√°t (th∆∞·ªùng l√† Escape)
 */
function useClickOutside(ref, handler, options = {}) {
  const { enabled = true, keys = ['Escape'] } = options;

  useEffect(() => {
    if (!enabled) return;

    const handleClick = (event) => {
      // B·ªè qua n·∫øu click v√†o ch√≠nh element ho·∫∑c con c·ªßa n√≥
      if (ref.current && !ref.current.contains(event.target)) {
        handler(event);
      }
    };

    const handleKeyDown = (event) => {
      if (keys.includes(event.key)) {
        handler(event);
      }
    };

    // S·ª≠ d·ª•ng mousedown thay v√¨ click ƒë·ªÉ b·∫Øt ƒë∆∞·ª£c s·ªõm h∆°n (tr∆∞·ªõc focus change)
    document.addEventListener('mousedown', handleClick);
    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('mousedown', handleClick);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [ref, handler, enabled, ...keys]); // keys l√† array ‚Üí spread ƒë·ªÉ theo d√µi thay ƒë·ªïi
}

// V√≠ d·ª• k·∫øt qu·∫£ khi s·ª≠ d·ª•ng:
// ‚Üí Dropdown / Modal s·∫Ω ƒë√≥ng khi:
//   ‚Ä¢ Click chu·ªôt ra ngo√†i v√πng ref
//   ‚Ä¢ Nh·∫•n ph√≠m Escape (m·∫∑c ƒë·ªãnh)
// ‚Üí Kh√¥ng ƒë√≥ng khi click b√™n trong v√πng ref
// ‚Üí Kh√¥ng l·∫Øng nghe s·ª± ki·ªán khi enabled = false
// ‚Üí Cleanup ƒë√∫ng c√°ch khi component unmount ho·∫∑c enabled thay ƒë·ªïi
```

</details>

### ‚≠ê‚≠ê‚≠ê Exercise 3: useAsync Hook (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Generic async operation hook
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† developer, t√¥i mu·ªën reusable hook cho async operations"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Execute async function
 * - [ ] Track loading, data, error states
 * - [ ] Support manual trigger (lazy execution)
 * - [ ] Support immediate execution
 * - [ ] Cancellation support
 * - [ ] Retry functionality
 *
 * üé® Technical Constraints:
 * - AbortController cho cancellation
 * - Cleanup on unmount
 * - No memory leaks
 *
 * üö® Edge Cases:
 * - Component unmounts during request
 * - Rapid sequential calls
 * - Error handling
 */

import { useState, useEffect, useRef, useCallback } from 'react';

function useAsync(asyncFunction, options = {}) {
  const { immediate = false, onSuccess, onError } = options;

  const [state, setState] = useState({
    loading: false,
    data: null,
    error: null,
  });

  const abortControllerRef = useRef(null);
  const isMountedRef = useRef(true);

  // Execute async function
  const execute = useCallback(
    async (...args) => {
      // TODO: Implement
      // 1. Cancel previous request
      // 2. Create new AbortController
      // 3. Set loading state
      // 4. Try execute asyncFunction
      // 5. Update data on success
      // 6. Update error on failure
      // 7. Call callbacks
      // 8. Only update state if still mounted
    },
    [asyncFunction],
  );

  // Reset state
  const reset = useCallback(() => {
    setState({ loading: false, data: null, error: null });
  }, []);

  // Retry
  const retry = useCallback(
    (...args) => {
      reset();
      return execute(...args);
    },
    [execute, reset],
  );

  // Immediate execution
  useEffect(() => {
    if (immediate) {
      execute();
    }
  }, [immediate, execute]);

  // Cleanup
  useEffect(() => {
    return () => {
      isMountedRef.current = false;
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  return {
    ...state,
    execute,
    reset,
    retry,
  };
}

// Demo: User Profile Fetcher
function UserProfileDemo() {
  const [userId, setUserId] = useState(1);

  const {
    loading,
    data: user,
    error,
    execute: fetchUser,
    retry,
  } = useAsync(
    async (id) => {
      const response = await fetch(
        `https://jsonplaceholder.typicode.com/users/${id}`,
      );
      if (!response.ok) throw new Error('Failed to fetch');
      return response.json();
    },
    {
      immediate: true,
      onSuccess: (data) => console.log('User loaded:', data.name),
      onError: (error) => console.error('Error:', error),
    },
  );

  useEffect(() => {
    fetchUser(userId);
  }, [userId, fetchUser]);

  return (
    <div style={{ padding: '20px' }}>
      <h2>useAsync Demo - User Profile</h2>

      <div style={{ marginBottom: '20px' }}>
        <label>
          User ID:
          <input
            type='number'
            min='1'
            max='10'
            value={userId}
            onChange={(e) => setUserId(Number(e.target.value))}
            style={{ marginLeft: '10px', padding: '5px' }}
          />
        </label>
      </div>

      {loading && <div>Loading user #{userId}...</div>}

      {error && (
        <div
          style={{
            padding: '15px',
            backgroundColor: '#fee',
            border: '1px solid #fcc',
            borderRadius: '4px',
            marginBottom: '10px',
          }}
        >
          Error: {error.message}
          <button
            onClick={retry}
            style={{ marginLeft: '10px' }}
          >
            Retry
          </button>
        </div>
      )}

      {user && !loading && (
        <div
          style={{
            padding: '15px',
            backgroundColor: '#f0f0f0',
            borderRadius: '4px',
          }}
        >
          <h3>{user.name}</h3>
          <p>Email: {user.email}</p>
          <p>Phone: {user.phone}</p>
          <p>Website: {user.website}</p>
        </div>
      )}
    </div>
  );
}

// üéØ Expected behavior:
// - Fetches user on mount
// - Fetches new user when ID changes
// - Shows loading state
// - Handles errors with retry
// - Cancels previous request when new one starts
// - No updates after unmount
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Custom hook x·ª≠ l√Ω c√°c t√°c v·ª• async m·ªôt c√°ch t·ªïng qu√°t
 * H·ªó tr·ª£: loading state, error handling, cancellation, retry, manual/lazy execution
 * @param {Function} asyncFunction - h√†m async c·∫ßn th·ª±c thi (c√≥ th·ªÉ nh·∫≠n tham s·ªë)
 * @param {Object} [options={}] - t√πy ch·ªçn c·∫•u h√¨nh
 * @param {boolean} [options.immediate=true] - t·ª± ƒë·ªông ch·∫°y ngay khi mount
 * @param {Function} [options.onSuccess] - callback khi th√†nh c√¥ng
 * @param {Function} [options.onError] - callback khi l·ªói
 * @returns {{
 *   loading: boolean,
 *   data: any,
 *   error: Error | null,
 *   execute: (...args: any[]) => Promise<void>,
 *   reset: () => void,
 *   retry: (...args: any[]) => Promise<void>
 * }}
 */
function useAsync(asyncFunction, options = {}) {
  const { immediate = true, onSuccess, onError } = options;

  const [state, setState] = useState({
    loading: false,
    data: null,
    error: null,
  });

  const abortControllerRef = useRef(null);
  const isMountedRef = useRef(true);

  const execute = useCallback(
    async (...args) => {
      // H·ªßy request tr∆∞·ªõc ƒë√≥ n·∫øu ƒëang ch·∫°y
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }

      // T·∫°o AbortController m·ªõi
      abortControllerRef.current = new AbortController();

      setState({ loading: true, data: null, error: null });

      try {
        const result = await asyncFunction(...args, {
          signal: abortControllerRef.current.signal,
        });

        // Ch·ªâ update state n·∫øu component v·∫´n mounted
        if (isMountedRef.current) {
          setState({ loading: false, data: result, error: null });
          onSuccess?.(result);
        }
      } catch (err) {
        // B·ªè qua l·ªói AbortError (do h·ªßy ch·ªß ƒë·ªông)
        if (err.name !== 'AbortError' && isMountedRef.current) {
          setState({ loading: false, data: null, error: err });
          onError?.(err);
        }
      }
    },
    [asyncFunction, onSuccess, onError],
  );

  const reset = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
    setState({ loading: false, data: null, error: null });
  }, []);

  const retry = useCallback(
    (...args) => {
      reset();
      return execute(...args);
    },
    [execute, reset],
  );

  // T·ª± ƒë·ªông ch·∫°y l·∫ßn ƒë·∫ßu n·∫øu immediate = true
  useEffect(() => {
    if (immediate) {
      execute();
    }
    // Cleanup khi unmount
    return () => {
      isMountedRef.current = false;
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [immediate, execute]);

  return {
    ...state,
    execute,
    reset,
    retry,
  };
}

// V√≠ d·ª• k·∫øt qu·∫£ khi s·ª≠ d·ª•ng:
// const { loading, data: user, error, execute: fetchUser, retry } = useAsync(
//   async (id) => {
//     const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`);
//     if (!res.ok) throw new Error('Fetch failed');
//     return res.json();
//   },
//   { immediate: true }
// );

// ‚Üí loading = true ‚Üí false
// ‚Üí user = {id: 1, name: "Leanne Graham", ...}
// ‚Üí error = null ho·∫∑c Error object
// ‚Üí fetchUser(5)      ‚Üí t·∫£i user id 5
// ‚Üí retry()           ‚Üí th·ª≠ l·∫°i l·∫ßn cu·ªëi c√πng
// ‚Üí Khi ƒë·ªïi userId ‚Üí request c≈© b·ªã abort, request m·ªõi ch·∫°y
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê Exercise 4: useForm Hook (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Form management hook v·ªõi validation
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * Requirements:
 * - Manage form values
 * - Handle changes
 * - Validation (sync and async)
 * - Touched fields tracking
 * - Submit handling
 * - Reset functionality
 * - Error messages
 *
 * API Design:
 * const {
 *   values,
 *   errors,
 *   touched,
 *   handleChange,
 *   handleBlur,
 *   handleSubmit,
 *   reset,
 *   isValid,
 *   isSubmitting
 * } = useForm(initialValues, validate, onSubmit);
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 * üß™ PHASE 3: Testing (10 ph√∫t)
 */

import { useState, useCallback } from 'react';

function useForm(initialValues, validate, onSubmit) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Handle field change
  const handleChange = useCallback(
    (event) => {
      const { name, value } = event.target;

      setValues((prev) => ({
        ...prev,
        [name]: value,
      }));

      // Clear error when user starts typing
      if (errors[name]) {
        setErrors((prev) => ({
          ...prev,
          [name]: undefined,
        }));
      }
    },
    [errors],
  );

  // Handle field blur
  const handleBlur = useCallback(
    (event) => {
      const { name } = event.target;

      setTouched((prev) => ({
        ...prev,
        [name]: true,
      }));

      // Validate field on blur
      if (validate) {
        const fieldErrors = validate(values);
        if (fieldErrors[name]) {
          setErrors((prev) => ({
            ...prev,
            [name]: fieldErrors[name],
          }));
        }
      }
    },
    [values, validate],
  );

  // Handle submit
  const handleSubmit = useCallback(
    async (event) => {
      event?.preventDefault();

      // Mark all fields as touched
      const allTouched = Object.keys(values).reduce((acc, key) => {
        acc[key] = true;
        return acc;
      }, {});
      setTouched(allTouched);

      // Validate all fields
      const validationErrors = validate ? validate(values) : {};
      setErrors(validationErrors);

      // If no errors, submit
      if (Object.keys(validationErrors).length === 0) {
        setIsSubmitting(true);
        try {
          await onSubmit(values);
        } catch (error) {
          console.error('Submit error:', error);
        } finally {
          setIsSubmitting(false);
        }
      }
    },
    [values, validate, onSubmit],
  );

  // Reset form
  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  // Check if form is valid
  const isValid = Object.keys(errors).length === 0;

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
    isValid,
    isSubmitting,
  };
}

// Demo: Registration Form
function RegistrationForm() {
  const validate = (values) => {
    const errors = {};

    if (!values.username) {
      errors.username = 'Username is required';
    } else if (values.username.length < 3) {
      errors.username = 'Username must be at least 3 characters';
    }

    if (!values.email) {
      errors.email = 'Email is required';
    } else if (!/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i.test(values.email)) {
      errors.email = 'Invalid email address';
    }

    if (!values.password) {
      errors.password = 'Password is required';
    } else if (values.password.length < 6) {
      errors.password = 'Password must be at least 6 characters';
    }

    if (values.password !== values.confirmPassword) {
      errors.confirmPassword = 'Passwords must match';
    }

    return errors;
  };

  const handleSubmit = async (values) => {
    // Simulate API call
    await new Promise((resolve) => setTimeout(resolve, 1000));
    console.log('Form submitted:', values);
    alert('Registration successful!');
  };

  const form = useForm(
    {
      username: '',
      email: '',
      password: '',
      confirmPassword: '',
    },
    validate,
    handleSubmit,
  );

  return (
    <div style={{ padding: '20px', maxWidth: '400px', margin: '0 auto' }}>
      <h2>useForm Demo - Registration</h2>

      <form onSubmit={form.handleSubmit}>
        {/* Username */}
        <div style={{ marginBottom: '15px' }}>
          <label
            style={{
              display: 'block',
              marginBottom: '5px',
              fontWeight: 'bold',
            }}
          >
            Username:
          </label>
          <input
            type='text'
            name='username'
            value={form.values.username}
            onChange={form.handleChange}
            onBlur={form.handleBlur}
            style={{
              width: '100%',
              padding: '8px',
              fontSize: '14px',
              border:
                form.errors.username && form.touched.username
                  ? '2px solid #dc3545'
                  : '1px solid #ccc',
              borderRadius: '4px',
            }}
          />
          {form.errors.username && form.touched.username && (
            <div
              style={{ color: '#dc3545', fontSize: '12px', marginTop: '5px' }}
            >
              {form.errors.username}
            </div>
          )}
        </div>

        {/* Email */}
        <div style={{ marginBottom: '15px' }}>
          <label
            style={{
              display: 'block',
              marginBottom: '5px',
              fontWeight: 'bold',
            }}
          >
            Email:
          </label>
          <input
            type='email'
            name='email'
            value={form.values.email}
            onChange={form.handleChange}
            onBlur={form.handleBlur}
            style={{
              width: '100%',
              padding: '8px',
              fontSize: '14px',
              border:
                form.errors.email && form.touched.email
                  ? '2px solid #dc3545'
                  : '1px solid #ccc',
              borderRadius: '4px',
            }}
          />
          {form.errors.email && form.touched.email && (
            <div
              style={{ color: '#dc3545', fontSize: '12px', marginTop: '5px' }}
            >
              {form.errors.email}
            </div>
          )}
        </div>

        {/* Password */}
        <div style={{ marginBottom: '15px' }}>
          <label
            style={{
              display: 'block',
              marginBottom: '5px',
              fontWeight: 'bold',
            }}
          >
            Password:
          </label>
          <input
            type='password'
            name='password'
            value={form.values.password}
            onChange={form.handleChange}
            onBlur={form.handleBlur}
            style={{
              width: '100%',
              padding: '8px',
              fontSize: '14px',
              border:
                form.errors.password && form.touched.password
                  ? '2px solid #dc3545'
                  : '1px solid #ccc',
              borderRadius: '4px',
            }}
          />
          {form.errors.password && form.touched.password && (
            <div
              style={{ color: '#dc3545', fontSize: '12px', marginTop: '5px' }}
            >
              {form.errors.password}
            </div>
          )}
        </div>

        {/* Confirm Password */}
        <div style={{ marginBottom: '20px' }}>
          <label
            style={{
              display: 'block',
              marginBottom: '5px',
              fontWeight: 'bold',
            }}
          >
            Confirm Password:
          </label>
          <input
            type='password'
            name='confirmPassword'
            value={form.values.confirmPassword}
            onChange={form.handleChange}
            onBlur={form.handleBlur}
            style={{
              width: '100%',
              padding: '8px',
              fontSize: '14px',
              border:
                form.errors.confirmPassword && form.touched.confirmPassword
                  ? '2px solid #dc3545'
                  : '1px solid #ccc',
              borderRadius: '4px',
            }}
          />
          {form.errors.confirmPassword && form.touched.confirmPassword && (
            <div
              style={{ color: '#dc3545', fontSize: '12px', marginTop: '5px' }}
            >
              {form.errors.confirmPassword}
            </div>
          )}
        </div>

        {/* Actions */}
        <div style={{ display: 'flex', gap: '10px' }}>
          <button
            type='submit'
            disabled={form.isSubmitting || !form.isValid}
            style={{
              flex: 1,
              padding: '10px',
              backgroundColor: form.isValid ? '#28a745' : '#6c757d',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor:
                form.isValid && !form.isSubmitting ? 'pointer' : 'not-allowed',
              fontSize: '16px',
            }}
          >
            {form.isSubmitting ? 'Submitting...' : 'Register'}
          </button>

          <button
            type='button'
            onClick={form.reset}
            style={{
              padding: '10px 20px',
              backgroundColor: '#6c757d',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Reset
          </button>
        </div>
      </form>

      {/* Debug */}
      <details style={{ marginTop: '20px' }}>
        <summary style={{ cursor: 'pointer', fontWeight: 'bold' }}>
          Debug Info
        </summary>
        <pre
          style={{
            marginTop: '10px',
            padding: '10px',
            backgroundColor: '#f5f5f5',
            borderRadius: '4px',
            fontSize: '12px',
            overflow: 'auto',
          }}
        >
          {JSON.stringify(
            {
              values: form.values,
              errors: form.errors,
              touched: form.touched,
              isValid: form.isValid,
              isSubmitting: form.isSubmitting,
            },
            null,
            2,
          )}
        </pre>
      </details>
    </div>
  );
}

// üß™ Testing Checklist:
// - [ ] Validation works on blur
// - [ ] Errors clear when typing
// - [ ] Submit validates all fields
// - [ ] Can't submit invalid form
// - [ ] Reset clears everything
// - [ ] Async submit works
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Custom hook qu·∫£n l√Ω form v·ªõi validation, touched state v√† submit handling
 * @param {Object} initialValues - Gi√° tr·ªã ban ƒë·∫ßu c·ªßa c√°c field
 * @param {Function} validate - h√†m validate to√†n b·ªô form, tr·∫£ v·ªÅ object l·ªói { field: message }
 * @param {Function} onSubmit - h√†m x·ª≠ l√Ω khi form h·ª£p l·ªá (nh·∫≠n values)
 * @returns {{
 *   values: Object,
 *   errors: Object,
 *   touched: Object,
 *   handleChange: (e: Event) => void,
 *   handleBlur: (e: Event) => void,
 *   handleSubmit: (e?: Event) => Promise<void>,
 *   reset: () => void,
 *   isValid: boolean,
 *   isSubmitting: boolean
 * }}
 */
function useForm(initialValues, validate, onSubmit) {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleChange = useCallback(
    (event) => {
      const { name, value } = event.target;
      setValues((prev) => ({ ...prev, [name]: value }));

      // X√≥a l·ªói ngay khi ng∆∞·ªùi d√πng b·∫Øt ƒë·∫ßu s·ª≠a
      if (errors[name]) {
        setErrors((prev) => ({ ...prev, [name]: undefined }));
      }
    },
    [errors],
  );

  const handleBlur = useCallback(
    (event) => {
      const { name } = event.target;

      setTouched((prev) => ({ ...prev, [name]: true }));

      // Validate field khi blur (n·∫øu c√≥ validate)
      if (validate) {
        const fieldErrors = validate(values);
        setErrors((prev) => ({
          ...prev,
          [name]: fieldErrors[name],
        }));
      }
    },
    [values, validate],
  );

  const handleSubmit = useCallback(
    async (event) => {
      if (event) event.preventDefault();

      // ƒê√°nh d·∫•u t·∫•t c·∫£ field l√† touched ƒë·ªÉ hi·ªÉn th·ªã l·ªói
      const allTouched = Object.keys(values).reduce((acc, key) => {
        acc[key] = true;
        return acc;
      }, {});
      setTouched(allTouched);

      // Validate to√†n b·ªô form
      const validationErrors = validate ? validate(values) : {};
      setErrors(validationErrors);

      // N·∫øu kh√¥ng c√≥ l·ªói ‚Üí submit
      if (Object.keys(validationErrors).length === 0) {
        setIsSubmitting(true);
        try {
          await onSubmit(values);
        } catch (error) {
          console.error('Submit error:', error);
          // C√≥ th·ªÉ set error chung n·∫øu mu·ªën
        } finally {
          setIsSubmitting(false);
        }
      }
    },
    [values, validate, onSubmit],
  );

  const reset = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  }, [initialValues]);

  const isValid = Object.keys(errors).length === 0;

  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
    isValid,
    isSubmitting,
  };
}

// V√≠ d·ª• k·∫øt qu·∫£ khi s·ª≠ d·ª•ng:
// const form = useForm(
//   { username: '', email: '', password: '' },
//   (values) => {
//     const errors = {};
//     if (!values.username) errors.username = 'Required';
//     if (!values.email) errors.email = 'Required';
//     if (!values.password) errors.password = 'Required';
//     return errors;
//   },
//   async (values) => { console.log('Submitted:', values); }
// );

// ‚Üí form.values.username thay ƒë·ªïi khi g√µ
// ‚Üí form.errors.username xu·∫•t hi·ªán khi blur n·∫øu r·ªóng
// ‚Üí form.handleSubmit() ‚Üí validate to√†n b·ªô ‚Üí ch·ªâ g·ªçi onSubmit n·∫øu h·ª£p l·ªá
// ‚Üí form.isValid = false khi c√≥ l·ªói
// ‚Üí form.isSubmitting = true trong l√∫c submit async
// ‚Üí form.reset() ‚Üí tr·ªü v·ªÅ initialValues, x√≥a l·ªói & touched
```

</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Exercise 5: useInfiniteScroll Hook (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Production-ready infinite scroll hook
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 *
 * Build hook cho infinite scroll lists:
 * 1. Intersection Observer based
 * 2. Loading states
 * 3. Error handling with retry
 * 4. Bidirectional scroll (load more top/bottom)
 * 5. Reset functionality
 * 6. Custom threshold
 *
 * üèóÔ∏è Technical Design Doc:
 *
 * 1. Hook Architecture:
 *    - useRef cho sentinel element
 *    - useState cho loading/error states
 *    - useCallback cho loadMore function
 *    - Intersection Observer setup
 *
 * 2. API Design:
 *    const {
 *      items,
 *      loading,
 *      error,
 *      hasMore,
 *      sentinelRef,
 *      loadMore,
 *      retry,
 *      reset
 *    } = useInfiniteScroll(fetchFunction, options);
 *
 * ‚úÖ Production Checklist:
 * - [ ] Intersection Observer setup
 * - [ ] Proper cleanup
 * - [ ] Error handling
 * - [ ] Loading states
 * - [ ] Has more detection
 * - [ ] Retry functionality
 * - [ ] Reset works
 * - [ ] No memory leaks
 */

import { useState, useRef, useEffect, useCallback } from 'react';

function useInfiniteScroll(fetchFunction, options = {}) {
  const {
    threshold = 0.5,
    rootMargin = '0px',
    initialPage = 1,
    enabled = true,
  } = options;

  const [items, setItems] = useState([]);
  const [page, setPage] = useState(initialPage);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [hasMore, setHasMore] = useState(true);

  const sentinelRef = useRef(null);
  const observerRef = useRef(null);

  // Load more items
  const loadMore = useCallback(async () => {
    if (loading || !hasMore || !enabled) return;

    setLoading(true);
    setError(null);

    try {
      const result = await fetchFunction(page);

      setItems((prev) => [...prev, ...result.items]);
      setHasMore(result.hasMore);
      setPage((prev) => prev + 1);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, [fetchFunction, page, loading, hasMore, enabled]);

  // Retry after error
  const retry = useCallback(() => {
    setError(null);
    loadMore();
  }, [loadMore]);

  // Reset to initial state
  const reset = useCallback(() => {
    setItems([]);
    setPage(initialPage);
    setLoading(false);
    setError(null);
    setHasMore(true);
  }, [initialPage]);

  // Setup Intersection Observer
  useEffect(() => {
    if (!enabled || !sentinelRef.current) return;

    const observer = new IntersectionObserver(
      (entries) => {
        const [entry] = entries;
        if (entry.isIntersecting && !loading && hasMore) {
          loadMore();
        }
      },
      {
        threshold,
        rootMargin,
      },
    );

    observer.observe(sentinelRef.current);
    observerRef.current = observer;

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [enabled, loading, hasMore, loadMore, threshold, rootMargin]);

  return {
    items,
    loading,
    error,
    hasMore,
    sentinelRef,
    loadMore,
    retry,
    reset,
  };
}

// Demo: Posts List
function InfiniteScrollDemo() {
  // Mock fetch function
  const fetchPosts = async (page) => {
    await new Promise((resolve) => setTimeout(resolve, 1000));

    const itemsPerPage = 10;
    const totalPages = 5;

    const items = Array.from({ length: itemsPerPage }, (_, i) => ({
      id: (page - 1) * itemsPerPage + i + 1,
      title: `Post #${(page - 1) * itemsPerPage + i + 1}`,
      content: `This is the content of post ${(page - 1) * itemsPerPage + i + 1}`,
    }));

    return {
      items,
      hasMore: page < totalPages,
    };
  };

  const { items, loading, error, hasMore, sentinelRef, retry, reset } =
    useInfiniteScroll(fetchPosts);

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '20px',
        }}
      >
        <h2>useInfiniteScroll Demo</h2>
        <button onClick={reset}>Reset</button>
      </div>

      {/* Items list */}
      <div>
        {items.map((item) => (
          <div
            key={item.id}
            style={{
              padding: '15px',
              marginBottom: '10px',
              backgroundColor: 'white',
              border: '1px solid #ddd',
              borderRadius: '4px',
            }}
          >
            <h3 style={{ margin: '0 0 5px 0' }}>{item.title}</h3>
            <p style={{ margin: 0, color: '#666' }}>{item.content}</p>
          </div>
        ))}
      </div>

      {/* Loading indicator */}
      {loading && (
        <div
          style={{
            padding: '20px',
            textAlign: 'center',
            color: '#007bff',
          }}
        >
          Loading more posts...
        </div>
      )}

      {/* Error */}
      {error && (
        <div
          style={{
            padding: '15px',
            backgroundColor: '#fee',
            border: '1px solid #fcc',
            borderRadius: '4px',
            textAlign: 'center',
          }}
        >
          <p style={{ margin: '0 0 10px 0', color: '#c00' }}>
            Error: {error.message}
          </p>
          <button onClick={retry}>Retry</button>
        </div>
      )}

      {/* Sentinel element */}
      {hasMore && !error && (
        <div
          ref={sentinelRef}
          style={{
            height: '20px',
            margin: '10px 0',
          }}
        />
      )}

      {/* End message */}
      {!hasMore && (
        <div
          style={{
            padding: '20px',
            textAlign: 'center',
            color: '#999',
            borderTop: '2px solid #eee',
          }}
        >
          üéâ You've reached the end!
        </div>
      )}

      {/* Stats */}
      <div
        style={{
          position: 'fixed',
          bottom: '20px',
          right: '20px',
          padding: '10px',
          backgroundColor: 'rgba(0,0,0,0.8)',
          color: 'white',
          borderRadius: '4px',
          fontSize: '12px',
        }}
      >
        <div>Items loaded: {items.length}</div>
        <div>Loading: {loading ? 'Yes' : 'No'}</div>
        <div>Has more: {hasMore ? 'Yes' : 'No'}</div>
      </div>
    </div>
  );
}

// üìù Implementation Notes:
//
// Hook can be extended with:
// 1. Prefetching (load next page in advance)
// 2. Caching (don't refetch same pages)
// 3. Bidirectional scroll (load top + bottom)
// 4. Virtual scrolling integration
// 5. Search/filter support
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Custom hook tri·ªÉn khai infinite scroll d·ª±a tr√™n Intersection Observer
 * T·ª± ƒë·ªông load th√™m data khi sentinel element xu·∫•t hi·ªán trong viewport
 * @param {Function} fetchFunction - async function nh·∫≠n page number, tr·∫£ v·ªÅ { items: [], hasMore: boolean }
 * @param {Object} [options={}] - t√πy ch·ªçn c·∫•u h√¨nh
 * @param {number} [options.threshold=0.1] - ng∆∞·ª°ng intersection (0-1)
 * @param {string} [options.rootMargin='0px'] - margin cho observer
 * @param {number} [options.initialPage=1] - trang b·∫Øt ƒë·∫ßu
 * @param {boolean} [options.enabled=true] - b·∫≠t/t·∫Øt infinite scroll
 * @returns {{
 *   items: any[],
 *   loading: boolean,
 *   error: Error | null,
 *   hasMore: boolean,
 *   sentinelRef: React.RefObject<HTMLDivElement>,
 *   loadMore: () => Promise<void>,
 *   retry: () => Promise<void>,
 *   reset: () => void
 * }}
 */
function useInfiniteScroll(fetchFunction, options = {}) {
  const {
    threshold = 0.1,
    rootMargin = '0px',
    initialPage = 1,
    enabled = true,
  } = options;

  const [items, setItems] = useState([]);
  const [page, setPage] = useState(initialPage);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [hasMore, setHasMore] = useState(true);

  const sentinelRef = useRef(null);
  const observerRef = useRef(null);

  const loadMore = useCallback(async () => {
    if (loading || !hasMore || !enabled) return;

    setLoading(true);
    setError(null);

    try {
      const result = await fetchFunction(page);
      setItems((prev) => [...prev, ...result.items]);
      setHasMore(result.hasMore);
      setPage((prev) => prev + 1);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, [fetchFunction, page, loading, hasMore, enabled]);

  const retry = useCallback(() => {
    setError(null);
    loadMore();
  }, [loadMore]);

  const reset = useCallback(() => {
    setItems([]);
    setPage(initialPage);
    setLoading(false);
    setError(null);
    setHasMore(true);
  }, [initialPage]);

  // Thi·∫øt l·∫≠p Intersection Observer
  useEffect(() => {
    if (!enabled || !sentinelRef.current) return;

    const observer = new IntersectionObserver(
      (entries) => {
        const [entry] = entries;
        if (entry.isIntersecting && !loading && hasMore) {
          loadMore();
        }
      },
      { threshold, rootMargin },
    );

    observer.observe(sentinelRef.current);
    observerRef.current = observer;

    // Cleanup
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [enabled, loading, hasMore, loadMore, threshold, rootMargin]);

  // Load trang ƒë·∫ßu ti√™n n·∫øu enabled
  useEffect(() => {
    if (enabled && page === initialPage && items.length === 0) {
      loadMore();
    }
  }, [enabled, initialPage, items.length, loadMore]);

  return {
    items,
    loading,
    error,
    hasMore,
    sentinelRef,
    loadMore,
    retry,
    reset,
  };
}

// V√≠ d·ª• k·∫øt qu·∫£ khi s·ª≠ d·ª•ng:
// const fetchPosts = async (page) => {
//   await new Promise(r => setTimeout(r, 800));
//   const newItems = Array.from({length: 5}, (_, i) => ({
//     id: (page-1)*5 + i + 1,
//     title: `Post ${(page-1)*5 + i + 1}`
//   }));
//   return {
//     items: newItems,
//     hasMore: page < 4
//   };
// };

// const { items, loading, hasMore, sentinelRef } = useInfiniteScroll(fetchPosts);

// ‚Üí Cu·ªôn xu·ªëng ‚Üí khi th·∫•y sentinel ‚Üí t·ª± ƒë·ªông g·ªçi loadMore
// ‚Üí items tƒÉng d·∫ßn: 5 ‚Üí 10 ‚Üí 15 ‚Üí 20 (hasMore = false)
// ‚Üí loading hi·ªÉn th·ªã khi ƒëang fetch
// ‚Üí error xu·∫•t hi·ªán n·∫øu fetch th·∫•t b·∫°i ‚Üí c√≥ th·ªÉ retry()
// ‚Üí reset() ‚Üí x√≥a items, quay v·ªÅ page 1, load l·∫°i t·ª´ ƒë·∫ßu
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### Rules of Hooks

```jsx
// ‚úÖ RULES - B·∫ÆT BU·ªòC tu√¢n th·ªß:

// Rule 1: Only call hooks at the TOP LEVEL
function MyComponent() {
  const [state, setState] = useState(0); // ‚úÖ Top level

  if (condition) {
    const [bad, setBad] = useState(0); // ‚ùå Inside condition
  }

  for (let i = 0; i < 10; i++) {
    const [bad, setBad] = useState(i); // ‚ùå Inside loop
  }

  function nested() {
    const [bad, setBad] = useState(0); // ‚ùå Inside nested function
  }

  return <div>{state}</div>;
}

// Rule 2: Only call hooks from REACT FUNCTIONS
function MyComponent() {
  const value = useMyHook(); // ‚úÖ React component
  return <div>{value}</div>;
}

function useMyHook() {
  const value = useOtherHook(); // ‚úÖ Custom hook
  return value;
}

function regularFunction() {
  const value = useMyHook(); // ‚ùå Regular JS function
  return value;
}

// Rule 3: Custom hooks must start with "use"
function useMyHook() {
  // ‚úÖ Starts with "use"
  const [state, setState] = useState(0);
  return state;
}

function myHook() {
  // ‚ùå Doesn't start with "use"
  const [state, setState] = useState(0); // ESLint error!
  return state;
}
```

### When to Create Custom Hook

```
Decision Tree:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Logic ƒë∆∞·ª£c d√πng ·ªü >1 component?
    ‚îÇ
    ‚îú‚îÄ No ‚Üí Keep inline
    ‚îÇ
    ‚îî‚îÄ Yes
        ‚îÇ
        Logic c√≥ d√πng hooks?
            ‚îÇ
            ‚îú‚îÄ No ‚Üí Regular function
            ‚îÇ
            ‚îî‚îÄ Yes ‚Üí Custom hook!
```

**Examples:**

```jsx
// ‚ùå Kh√¥ng c·∫ßn custom hook
function formatDate(date) {
  return date.toLocaleDateString();
}
// ‚Üí Regular function ƒë·ªß

// ‚úÖ C·∫ßn custom hook
function useFormattedDate(date) {
  const [formatted, setFormatted] = useState('');

  useEffect(() => {
    setFormatted(date.toLocaleDateString());
  }, [date]);

  return formatted;
}
// ‚Üí Uses hooks, needs to be custom hook
```

### Hook Composition Patterns

#### Pattern 1: Hook s·ª≠ d·ª•ng Hook kh√°c

```jsx
// useDebounce uses useState + useEffect
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

// useSearch uses useDebounce
function useSearch(query) {
  const [results, setResults] = useState([]);
  const debouncedQuery = useDebounce(query, 500); // ‚úÖ Compose!

  useEffect(() => {
    if (debouncedQuery) {
      fetch(`/api/search?q=${debouncedQuery}`)
        .then((res) => res.json())
        .then(setResults);
    }
  }, [debouncedQuery]);

  return results;
}
```

#### Pattern 2: Hook Aggregation

```jsx
// Combine multiple hooks into one API
function useAuth() {
  const user = useUser();
  const login = useLogin();
  const logout = useLogout();
  const permissions = usePermissions();

  return {
    user,
    login,
    logout,
    permissions,
    isAuthenticated: !!user,
    can: (action) => permissions.includes(action),
  };
}

// Clean usage
function ProtectedPage() {
  const { user, isAuthenticated, can } = useAuth();

  if (!isAuthenticated) return <Login />;
  if (!can('view-page')) return <Forbidden />;

  return <div>Welcome, {user.name}!</div>;
}
```

#### Pattern 3: Hook with Options Object

```jsx
// Flexible API with options
function useFetch(url, options = {}) {
  const {
    method = 'GET',
    headers = {},
    body,
    dependencies = [],
    lazy = false,
    onSuccess,
    onError,
  } = options;

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(!lazy);
  const [error, setError] = useState(null);

  const execute = useCallback(async () => {
    // ... fetch logic
  }, [url, method, JSON.stringify(headers), body]);

  useEffect(() => {
    if (!lazy) {
      execute();
    }
  }, [lazy, execute, ...dependencies]);

  return { data, loading, error, refetch: execute };
}

// Usage:
const { data, refetch } = useFetch('/api/users', {
  method: 'POST',
  body: JSON.stringify({ name: 'John' }),
  onSuccess: (data) => console.log('Success!', data),
  dependencies: [userId],
});
```

### Return Value Patterns

```jsx
// Pattern 1: Array (useState-like)
function useToggle(initial) {
  const [value, setValue] = useState(initial);
  const toggle = () => setValue((v) => !v);
  return [value, toggle]; // ‚úÖ Array destructuring
}
const [isOpen, toggleOpen] = useToggle(false);

// Pattern 2: Object (more descriptive)
function useCounter(initial) {
  const [count, setCount] = useState(initial);
  return {
    count,
    increment: () => setCount((c) => c + 1),
    decrement: () => setCount((c) => c - 1),
    reset: () => setCount(initial),
  };
}
const { count, increment } = useCounter(0);

// Pattern 3: Mixed (complex hooks)
function useForm(initialValues) {
  // ... implementation
  return {
    values,
    errors,
    handleChange,
    handleSubmit,
    // Also expose as tuple for convenience
    field: (name) => ({
      name,
      value: values[name],
      onChange: handleChange,
      error: errors[name],
    }),
  };
}
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Violating Rules of Hooks ‚≠ê

```jsx
// ‚ùå BUG: Conditional hook call
function BuggyConditionalHook({ shouldFetch }) {
  if (shouldFetch) {
    const [data, setData] = useState(null); // ‚ö†Ô∏è Conditional hook!

    useEffect(() => {
      fetch('/api/data')
        .then((res) => res.json())
        .then(setData);
    }, []);

    return <div>{data}</div>;
  }

  return <div>Not fetching</div>;
}
```

**üîç Debug Questions:**

1. T·∫°i sao ƒë√¢y l√† violation?
2. ƒêi·ªÅu g√¨ s·∫Ω x·∫£y ra?
3. C√°ch fix?

**üí° Gi·∫£i th√≠ch:**

```jsx
// ‚ùå V·∫§N ƒê·ªÄ:
// React relies on hook call order to maintain state
// Timeline:
// Render 1 (shouldFetch=true):  Hook #1 = useState, Hook #2 = useEffect
// Render 2 (shouldFetch=false): No hooks called!
// React confused: Where did hooks go? üí•

// ‚úÖ SOLUTION: Always call hooks, control behavior
function FixedConditionalHook({ shouldFetch }) {
  const [data, setData] = useState(null); // ‚úÖ Always called

  useEffect(() => {
    if (shouldFetch) {
      // ‚úÖ Condition inside effect
      fetch('/api/data')
        .then((res) => res.json())
        .then(setData);
    }
  }, [shouldFetch]);

  if (!shouldFetch) {
    return <div>Not fetching</div>;
  }

  return <div>{data}</div>;
}

// üìä RULE:
// Hooks must be called in the SAME ORDER every render
// ‚Üí Never put hooks inside conditions, loops, or nested functions
```

### Bug 2: Stale Closure in Custom Hook ‚≠ê‚≠ê

```jsx
// ‚ùå BUG: Callback has stale closure
function useInterval(callback, delay) {
  useEffect(() => {
    const id = setInterval(callback, delay); // ‚ö†Ô∏è Stale callback!
    return () => clearInterval(id);
  }, [delay]); // ‚ö†Ô∏è Missing callback dependency
}

// Usage:
function Counter() {
  const [count, setCount] = useState(0);

  useInterval(() => {
    console.log(count); // ‚ö†Ô∏è Always logs 0!
    setCount(count + 1); // ‚ö†Ô∏è Always sets to 1!
  }, 1000);

  return <div>{count}</div>;
}
```

**üîç Debug Questions:**

1. T·∫°i sao count lu√¥n l√† 0?
2. ESLint warning l√† g√¨?
3. Fix nh∆∞ th·∫ø n√†o?

**üí° Gi·∫£i th√≠ch:**

```jsx
// ‚ùå V·∫§N ƒê·ªÄ:
// - useEffect runs once (delay dependency only)
// - Callback captures count = 0 (initial value)
// - Interval keeps calling callback v·ªõi count = 0
// - setCount(0 + 1) ‚Üí always 1
// - State updates nh∆∞ng callback kh√¥ng re-created

// ‚úÖ SOLUTION 1: Add callback to dependencies (not ideal)
function useInterval(callback, delay) {
  useEffect(() => {
    const id = setInterval(callback, delay);
    return () => clearInterval(id);
  }, [callback, delay]); // ‚ö†Ô∏è Re-creates interval m·ªói l·∫ßn callback changes
}

// ‚úÖ SOLUTION 2: Ref pattern (recommended)
function useInterval(callback, delay) {
  const callbackRef = useRef(callback);

  // Keep ref updated
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  useEffect(() => {
    const id = setInterval(() => {
      callbackRef.current(); // ‚úÖ Always calls latest callback
    }, delay);

    return () => clearInterval(id);
  }, [delay]); // ‚úÖ Only depends on delay
}

// Usage now works:
function Counter() {
  const [count, setCount] = useState(0);

  useInterval(() => {
    console.log(count); // ‚úÖ Logs current count!
    setCount((c) => c + 1); // ‚úÖ Better: functional update
  }, 1000);

  return <div>{count}</div>;
}

// üìä LESSON:
// When hook accepts callbacks, use ref pattern to avoid stale closures
```

### Bug 3: Hook Dependency Missing ‚≠ê‚≠ê‚≠ê

```jsx
// ‚ùå BUG: Missing dependency causes bugs
function useSearch(query) {
  const [results, setResults] = useState([]);
  const apiKey = 'abc123';

  useEffect(() => {
    fetch(`/api/search?q=${query}&key=${apiKey}`)
      .then((res) => res.json())
      .then(setResults);
  }, [query]); // ‚ö†Ô∏è Missing apiKey dependency

  return results;
}

// Later, apiKey becomes dynamic:
function SearchComponent() {
  const [apiKey, setApiKey] = useState('abc123');
  const [query, setQuery] = useState('');
  const results = useSearch(query); // ‚ö†Ô∏è apiKey not passed!

  // ...
}
```

**üîç Debug Questions:**

1. T·∫°i sao ESLint warning?
2. ƒêi·ªÅu g√¨ x·∫£y ra khi apiKey changes?
3. Best practice?

**üí° Gi·∫£i th√≠ch:**

```jsx
// ‚ùå V·∫§N ƒê·ªÄ:
// - apiKey used trong effect
// - Kh√¥ng c√≥ trong dependencies
// - Effect kh√¥ng re-run khi apiKey changes
// - Stale apiKey used!

// ‚úÖ SOLUTION 1: Add all dependencies
function useSearch(query, apiKey) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    fetch(`/api/search?q=${query}&key=${apiKey}`)
      .then((res) => res.json())
      .then(setResults);
  }, [query, apiKey]); // ‚úÖ All dependencies

  return results;
}

// ‚úÖ SOLUTION 2: Move constant outside
const API_KEY = 'abc123'; // ‚úÖ Outside component

function useSearch(query) {
  const [results, setResults] = useState([]);

  useEffect(() => {
    fetch(`/api/search?q=${query}&key=${API_KEY}`)
      .then((res) => res.json())
      .then(setResults);
  }, [query]); // ‚úÖ API_KEY kh√¥ng c·∫ßn dependency (constant)

  return results;
}

// üìä RULE:
// ALWAYS include ALL values from component scope used inside effect
// ESLint plugin "exhaustive-deps" helps catch these
```

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

ƒê√°nh d·∫•u c√°c c√¢u b·∫°n c√≥ th·ªÉ tr·∫£ l·ªùi t·ª± tin:

- [ ] Custom hook l√† g√¨?
- [ ] Rules of Hooks l√† g√¨ v√† t·∫°i sao quan tr·ªçng?
- [ ] Khi n√†o n√™n t·∫°o custom hook?
- [ ] Custom hook c√≥ share state gi·ªØa components kh√¥ng?
- [ ] Naming convention cho custom hooks?
- [ ] Custom hook c√≥ th·ªÉ return g√¨?
- [ ] L√†m sao compose multiple hooks?
- [ ] Stale closure trong hooks l√† g√¨?
- [ ] Dependency array rules?
- [ ] Test custom hooks nh∆∞ th·∫ø n√†o?

### Code Review Checklist

Khi review custom hooks, check:

#### ‚úÖ Naming & Structure:

- [ ] Name starts with "use"
- [ ] Only called from React functions
- [ ] Called at top level (no conditions/loops)
- [ ] Clear, descriptive name

#### ‚úÖ Dependencies:

- [ ] All dependencies included
- [ ] No unnecessary dependencies
- [ ] ESLint exhaustive-deps satisfied
- [ ] Ref pattern cho callbacks if needed

#### ‚úÖ API Design:

- [ ] Return value intuitive
- [ ] Options object cho flexibility
- [ ] Reasonable defaults
- [ ] TypeScript types (if applicable)

#### ‚úÖ Edge Cases:

- [ ] Cleanup trong useEffect
- [ ] Handle unmount during async
- [ ] Error handling
- [ ] Loading states

#### ‚úÖ Reusability:

- [ ] Generic enough
- [ ] Kh√¥ng hardcode values
- [ ] Configurable via props/options
- [ ] Well documented

#### ‚ùå Red Flags:

- [ ] Violates Rules of Hooks
- [ ] Missing dependencies
- [ ] No cleanup
- [ ] Over-complicated
- [ ] Too specific (not reusable)

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

#### Exercise: useTimeout Hook

```jsx
/**
 * üéØ M·ª•c ti√™u: Declarative setTimeout hook
 *
 * Requirements:
 * 1. Execute callback after delay
 * 2. Auto-cleanup on unmount
 * 3. Reset functionality
 * 4. Cancel functionality
 *
 * API:
 * const { reset, cancel } = useTimeout(callback, delay);
 */

function useTimeout(callback, delay) {
  // TODO: Implement
  // Hints:
  // - useRef cho timeout ID
  // - useRef cho callback (avoid stale closure)
  // - useEffect cho setup/cleanup
  // - Return reset & cancel functions
}

// Usage:
function NotificationDemo() {
  const [show, setShow] = useState(true);

  const { reset, cancel } = useTimeout(() => {
    setShow(false);
  }, 3000);

  return (
    <div>
      {show && (
        <div>
          This will disappear in 3 seconds
          <button onClick={cancel}>Keep it</button>
          <button onClick={reset}>Reset timer</button>
        </div>
      )}
    </div>
  );
}
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Custom hook qu·∫£n l√Ω setTimeout m·ªôt c√°ch declarative
 * T·ª± ƒë·ªông cleanup khi unmount ho·∫∑c delay thay ƒë·ªïi
 * @param {Function} callback - h√†m s·∫Ω ch·∫°y sau delay
 * @param {number} delay - th·ªùi gian ch·ªù (ms), n·∫øu null th√¨ kh√¥ng ch·∫°y
 * @returns {{
 *   reset: () => void,
 *   cancel: () => void
 * }}
 */
function useTimeout(callback, delay) {
  const timeoutRef = useRef(null);
  const callbackRef = useRef(callback);

  // Lu√¥n gi·ªØ callback m·ªõi nh·∫•t ƒë·ªÉ tr√°nh stale closure
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);

  // Setup v√† cleanup timeout
  useEffect(() => {
    // N·∫øu delay l√† null/undefined ‚Üí kh√¥ng l√†m g√¨
    if (delay == null) {
      return;
    }

    // Clear timeout c≈© n·∫øu c√≥
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // Set timeout m·ªõi
    timeoutRef.current = setTimeout(() => {
      callbackRef.current();
    }, delay);

    // Cleanup khi unmount ho·∫∑c delay thay ƒë·ªïi
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, [delay]); // Ch·ªâ re-run khi delay thay ƒë·ªïi

  const reset = useCallback(() => {
    if (delay == null) return;

    // Clear v√† set l·∫°i timeout m·ªõi
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    timeoutRef.current = setTimeout(() => {
      callbackRef.current();
    }, delay);
  }, [delay]);

  const cancel = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  }, []);

  return { reset, cancel };
}

// V√≠ d·ª• k·∫øt qu·∫£ khi s·ª≠ d·ª•ng:
// const [show, setShow] = useState(true);
// const { reset, cancel } = useTimeout(() => setShow(false), 3000);

// ‚Üí Sau 3 gi√¢y ‚Üí show = false
// ‚Üí cancel() ‚Üí ngƒÉn th√¥ng b√°o bi·∫øn m·∫•t
// ‚Üí reset() ‚Üí ƒë·∫øm l·∫°i t·ª´ ƒë·∫ßu 3 gi√¢y
// ‚Üí N·∫øu component unmount ‚Üí timeout t·ª± ƒë·ªông clear, kh√¥ng g·ªçi callback
// ‚Üí N·∫øu delay thay ƒë·ªïi (v√≠ d·ª• setDelay(5000)) ‚Üí timeout c≈© clear, set m·ªõi
```

</details>

### N√¢ng cao (60 ph√∫t)

#### Exercise: usePrevious Hook

```jsx
/**
 * üéØ M·ª•c ti√™u: Track previous value c·ªßa state/prop
 *
 * Scenario:
 * Component c·∫ßn so s√°nh current value v·ªõi previous value.
 *
 * Requirements:
 * 1. Return previous value
 * 2. Update on value change
 * 3. Initial value handling
 *
 * Bonus:
 * - usePreviousDistinct (only update if different)
 * - usePreviousArray (track multiple previous values)
 */

function usePrevious(value) {
  // TODO: Implement
  // Pattern: useRef + useEffect
}

// Usage:
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  const diff = count - (prevCount ?? 0);

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <p>Change: {diff > 0 ? `+${diff}` : diff}</p>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
    </div>
  );
}
```

<details><summary>üí° Solution</summary>

```jsx
/**
 * Custom hook theo d√µi gi√° tr·ªã tr∆∞·ªõc ƒë√≥ c·ªßa m·ªôt state ho·∫∑c prop
 * @param {any} value - Gi√° tr·ªã hi·ªán t·∫°i c·∫ßn theo d√µi previous
 * @returns {any | undefined} Gi√° tr·ªã ·ªü render tr∆∞·ªõc ƒë√≥ (undefined ·ªü l·∫ßn render ƒë·∫ßu)
 */
function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  // Tr·∫£ v·ªÅ gi√° tr·ªã c≈© (tr∆∞·ªõc khi effect ch·∫°y)
  // ‚Üí ·ªü l·∫ßn render ƒë·∫ßu: undefined
  // ‚Üí t·ª´ l·∫ßn th·ª© 2 tr·ªü ƒëi: gi√° tr·ªã c·ªßa render tr∆∞·ªõc
  return ref.current;
}

// Bonus: Phi√™n b·∫£n ch·ªâ c·∫≠p nh·∫≠t khi gi√° tr·ªã th·ª±c s·ª± thay ƒë·ªïi (kh√°c v·ªõi previous)
function usePreviousDistinct(value, isEqual = Object.is) {
  const ref = useRef();

  useEffect(() => {
    if (!isEqual(value, ref.current)) {
      ref.current = value;
    }
  }, [value, isEqual]);

  return ref.current;
}

// V√≠ d·ª• k·∫øt qu·∫£ khi s·ª≠ d·ª•ng:
// function Counter() {
//   const [count, setCount] = useState(0);
//   const prevCount = usePrevious(count);
//
//   return (
//     <div>
//       <p>Current: {count}</p>
//       <p>Previous: {prevCount ?? '‚Äî'}</p>
//       <p>{prevCount !== undefined && count > prevCount ? '‚Üë tƒÉng' : '‚Üì gi·∫£m'}</p>
//       <button onClick={() => setCount(c => c + 1)}>TƒÉng</button>
//     </div>
//   );
// }
//
// Render 1: count = 0, prevCount = undefined
// Render 2: count = 1, prevCount = 0
// Render 3: count = 2, prevCount = 1
// ‚Üí D·ªÖ d√†ng so s√°nh current vs previous trong c√πng render
```

</details>

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - Reusing Logic with Custom Hooks:**
   https://react.dev/learn/reusing-logic-with-custom-hooks

2. **React Docs - Rules of Hooks:**
   https://react.dev/reference/rules/rules-of-hooks

### ƒê·ªçc th√™m

1. **useHooks - Collection of Custom Hooks:**
   https://usehooks.com/

2. **React Hook Form:**
   https://react-hook-form.com/

3. **SWR - Data Fetching Hook:**
   https://swr.vercel.app/

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (c·∫ßn bi·∫øt t·ª´ tr∆∞·ªõc)

- **Ng√†y 11-14:** useState patterns
- **Ng√†y 16-20:** useEffect v√† dependencies
- **Ng√†y 21-22:** useRef patterns
- **Ng√†y 23:** useLayoutEffect timing

### H∆∞·ªõng t·ªõi (s·∫Ω d√πng ·ªü)

- **Ng√†y 25:** Project - combine t·∫•t c·∫£ hooks
- **Ng√†y 29-34:** Advanced patterns
- **Real apps:** Reusable logic everywhere!

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

#### 1. TypeScript Support

```typescript
// ‚úÖ GOOD: Type-safe custom hook
function useLocalStorage<T>(
  key: string,
  initialValue: T,
): [T, (value: T | ((prev: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value: T | ((prev: T) => T)) => {
    try {
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}
```

#### 2. Testing Custom Hooks

```jsx
// Use @testing-library/react-hooks
import { renderHook, act } from '@testing-library/react-hooks';

test('useCounter increments', () => {
  const { result } = renderHook(() => useCounter(0));

  expect(result.current.count).toBe(0);

  act(() => {
    result.current.increment();
  });

  expect(result.current.count).toBe(1);
});
```

#### 3. Performance Optimization

```jsx
// ‚úÖ GOOD: Memoize expensive calculations
function useExpensiveHook(data) {
  const processedData = useMemo(() => {
    return expensiveComputation(data);
  }, [data]);

  const callback = useCallback(() => {
    doSomething(processedData);
  }, [processedData]);

  return { processedData, callback };
}
```

### C√¢u H·ªèi Ph·ªèng V·∫•n

#### Junior Level:

**Q1: "Custom hook l√† g√¨?"**

Expected answer:

- Function s·ª≠ d·ª•ng React hooks
- T√™n b·∫Øt ƒë·∫ßu b·∫±ng "use"
- Extract v√† reuse stateful logic
- Kh√¥ng share state gi·ªØa components

**Q2: "Rules of Hooks?"**

Expected answer:

- Only call at top level
- Only call from React functions
- Name must start with "use"

#### Mid Level:

**Q3: "L√†m sao avoid stale closure trong custom hook?"**

Expected answer:

```jsx
const callbackRef = useRef(callback);

useEffect(() => {
  callbackRef.current = callback;
}, [callback]);

useEffect(() => {
  // Use callbackRef.current
}, []);
```

**Q4: "Khi n√†o d√πng array vs object return?"**

Expected answer:

- Array: Simple hooks (useState-like), allow rename
- Object: Complex hooks, descriptive names
- Consider usage patterns

#### Senior Level:

**Q5: "Design generic data fetching hook."**

Expected answer:

- Generic over resource type
- Caching strategy
- Request cancellation
- Error retry logic
- TypeScript generics
- Configurable options

**Q6: "Handle race conditions trong async hook?"**

Expected answer:

- AbortController
- Ignore outdated responses
- Request ID tracking
- Cleanup on unmount

### War Stories

#### Story: The Infinite Loop Hook

Production bug: Custom hook caused infinite re-renders.

```jsx
// ‚ùå BUG:
function useData(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then(setData); // ‚ö†Ô∏è setData creates new function reference!
  }, [setData]); // ‚ö†Ô∏è Infinite loop!

  return data;
}

// ‚úÖ FIX:
function useData(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then(setData);
  }, [url]); // ‚úÖ Only depend on url

  return data;
}
```

**Lesson:** setState functions are stable, don't need dependencies!

---

## üéØ PREVIEW NG√ÄY MAI

**Ng√†y 25: Project - Real-time Dashboard** üìä

Ng√†y mai ch√∫ng ta s·∫Ω **build complete project** combining t·∫•t c·∫£ hooks ƒë√£ h·ªçc!

Project features:

- Real-time data updates
- Custom hooks for logic reuse
- Advanced patterns
- Production-ready code
- Complete dashboard app

Get ready to put everything together! üöÄ

---

## ‚úÖ CHECKLIST HO√ÄN TH√ÄNH

Tr∆∞·ªõc khi k·∫øt th√∫c ng√†y h·ªçc, check:

- [ ] Hi·ªÉu s√¢u custom hooks concept
- [ ] L√†m ƒë·ªß 5 exercises
- [ ] ƒê·ªçc React docs v·ªÅ custom hooks
- [ ] L√†m b√†i t·∫≠p v·ªÅ nh√†
- [ ] Review Rules of Hooks
- [ ] Chu·∫©n b·ªã cho project day

**üéâ Congratulations! B·∫°n ƒë√£ ho√†n th√†nh Ng√†y 24!**

B·∫°n ƒë√£ h·ªçc ƒë∆∞·ª£c:
‚úÖ Custom hooks fundamentals
‚úÖ Rules of Hooks
‚úÖ Hook composition
‚úÖ Common patterns (useToggle, useLocalStorage, useDebounce)
‚úÖ Testing strategies
‚úÖ Production considerations

Tomorrow: Build a complete real-world project! üí™
