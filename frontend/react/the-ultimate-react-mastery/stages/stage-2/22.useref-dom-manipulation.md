# ğŸ“… NGÃ€Y 22: useRef - DOM Manipulation & Focus Management

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] Hiá»ƒu cÃ¡ch useRef truy cáº­p vÃ  manipulate DOM nodes trá»±c tiáº¿p
- [ ] Náº¯m vá»¯ng ref forwarding pattern vÃ  khi nÃ o cáº§n dÃ¹ng
- [ ] Quáº£n lÃ½ focus, scroll, vÃ  animations vá»›i refs
- [ ] TÃ­ch há»£p third-party libraries cáº§n DOM access
- [ ] PhÃ¢n biá»‡t khi nÃ o dÃ¹ng refs vs state Ä‘á»ƒ control DOM
- [ ] Xá»­ lÃ½ edge cases nhÆ° conditional rendering vÃ  ref timing

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i nÃ y:

1. **useRef tráº£ vá» object cÃ³ structure nhÆ° tháº¿ nÃ o?**
   - `{ current: value }` - object vá»›i property `.current`

2. **Táº¡i sao update ref.current khÃ´ng trigger re-render?**
   - VÃ¬ React khÃ´ng track changes trong ref.current, chá»‰ track state changes

3. **NgÃ y hÃ´m qua chÃºng ta dÃ¹ng useRef cho gÃ¬?**
   - Mutable values: timer IDs, previous values, flags, render counts

**HÃ´m nay:** ChÃºng ta sáº½ há»c use case thá»© 2 - **DOM References** ğŸ¯

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

Trong React, báº¡n thÆ°á»ng **declarative** - nÃ³i React "cÃ¡i gÃ¬" cáº§n render, khÃ´ng pháº£i "lÃ m sao" render:

```jsx
// âœ… Declarative React way
function SearchBox() {
  const [query, setQuery] = useState('');

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder='Search...'
    />
  );
}
```

NhÆ°ng Ä‘Ã´i khi báº¡n cáº§n **imperative** - trá»±c tiáº¿p control DOM:

```jsx
// âŒ Váº¤N Äá»€: LÃ m sao auto-focus input khi component mount?

function SearchBox() {
  const [query, setQuery] = useState('');

  // ğŸ¤” LÃ m sao gá»i input.focus()?
  // KhÃ´ng cÃ³ cÃ¡ch nÃ o access DOM element!

  return (
    <input
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder='Search...'
    />
  );
}
```

**CÃ¡c tÃ¬nh huá»‘ng cáº§n DOM access:**

1. **Focus management** - Auto-focus input, focus next field
2. **Scroll control** - Scroll to element, smooth scroll
3. **Measurements** - Get element width/height/position
4. **Animations** - Trigger CSS animations, integrate animation libraries
5. **Third-party libs** - Chart libraries, text editors, video players
6. **Media control** - Play/pause video, seek audio

### 1.2 Giáº£i PhÃ¡p: DOM Refs

```jsx
// âœ… GIáº¢I PHÃP: useRef Ä‘á»ƒ access DOM
import { useRef, useEffect } from 'react';

function SearchBox() {
  const [query, setQuery] = useState('');
  const inputRef = useRef(null); // ğŸ¯ Create ref

  useEffect(() => {
    // ğŸ¯ Access DOM node
    inputRef.current.focus();
  }, []); // Run once on mount

  return (
    <input
      ref={inputRef} // ğŸ¯ Attach ref to element
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder='Search...'
    />
  );
}
```

**CÃ¡ch hoáº¡t Ä‘á»™ng:**

```
1. Create ref:     const inputRef = useRef(null)
                   â†“
                   { current: null }

2. Attach to JSX:  <input ref={inputRef} />
                   â†“
                   React fills: { current: <input> DOM node }

3. Use in effect:  inputRef.current.focus()
                   â†“
                   Direct DOM manipulation!
```

### 1.3 Mental Model

HÃ£y tÆ°á»Ÿng tÆ°á»£ng refs nhÆ° **"tay cáº§m" Ä‘á»ƒ náº¯m DOM elements**:

```
React Component (Declarative World)
â”‚
â”‚  const inputRef = useRef(null);
â”‚  â†“
â”‚  ref={inputRef}
â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€> "Tay cáº§m"
             â”‚
             â”‚ inputRef.current
             â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  DOM Element   â”‚  â† Real Browser DOM (Imperative World)
         â”‚  <input>       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Timeline:**

```
Mount phase:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. React creates virtual DOM:  <input ref={inputRef} />
2. inputRef.current = null      (initial)
3. React creates real DOM:      <input> element
4. React assigns ref:            inputRef.current = <input>
5. useEffect runs:               inputRef.current.focus() âœ…

Update phase:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Component re-renders
2. inputRef.current stays same  (ref object persists)
3. Still points to same DOM node

Unmount phase:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. React removes DOM element
2. inputRef.current = null      (cleanup)
```

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

#### âŒ Hiá»ƒu láº§m 1: "CÃ³ thá»ƒ access ref.current trong render"

```jsx
// âŒ SAI: Access ref trong render phase
function BadExample() {
  const divRef = useRef(null);

  // âš ï¸ Láº§n render Ä‘áº§u tiÃªn: divRef.current = null!
  console.log(divRef.current); // null â†’ error!
  const width = divRef.current.offsetWidth; // âŒ Cannot read property of null

  return <div ref={divRef}>Content</div>;
}

// âœ… ÄÃšNG: Access ref trong useEffect
function GoodExample() {
  const divRef = useRef(null);

  useEffect(() => {
    // âœ… BÃ¢y giá» divRef.current Ä‘Ã£ cÃ³ giÃ¡ trá»‹
    console.log(divRef.current); // <div> element
    const width = divRef.current.offsetWidth; // âœ… Works!
  }, []);

  return <div ref={divRef}>Content</div>;
}
```

**Táº¡i sao?**

```
Render phase:
  1. Function component cháº¡y
  2. JSX Ä‘Æ°á»£c táº¡o (virtual DOM)
  3. ref={divRef} Ä‘Æ°á»£c note láº¡i
  â†’ LÃºc nÃ y divRef.current váº«n lÃ  null!

Commit phase:
  1. React táº¡o/update real DOM
  2. React gÃ¡n ref: divRef.current = DOM node
  3. useEffect cháº¡y
  â†’ BÃ¢y giá» má»›i cÃ³ thá»ƒ dÃ¹ng!
```

#### âŒ Hiá»ƒu láº§m 2: "CÃ³ thá»ƒ dÃ¹ng ref cho conditional elements"

```jsx
// âŒ Váº¤N Äá»€: Element cÃ³ thá»ƒ khÃ´ng tá»“n táº¡i
function BadConditional() {
  const [show, setShow] = useState(false);
  const divRef = useRef(null);

  useEffect(() => {
    divRef.current.focus(); // âš ï¸ Náº¿u show=false â†’ crash!
  }, []);

  return (
    <div>
      {show && (
        <div
          ref={divRef}
          tabIndex={-1}
        >
          Content
        </div>
      )}
    </div>
  );
}

// âœ… ÄÃšNG: LuÃ´n check ref.current trÆ°á»›c khi dÃ¹ng
function GoodConditional() {
  const [show, setShow] = useState(false);
  const divRef = useRef(null);

  useEffect(() => {
    if (divRef.current) {
      // âœ… Null check!
      divRef.current.focus();
    }
  }, [show]); // âœ… Re-run when show changes

  return (
    <div>
      {show && (
        <div
          ref={divRef}
          tabIndex={-1}
        >
          Content
        </div>
      )}
    </div>
  );
}
```

#### âŒ Hiá»ƒu láº§m 3: "Refs thay tháº¿ state cho má»i DOM manipulation"

```jsx
// âŒ ANTI-PATTERN: DÃ¹ng ref thay vÃ¬ state
function BadToggle() {
  const divRef = useRef(null);

  const toggle = () => {
    // âš ï¸ Direct DOM manipulation - bad React pattern!
    if (divRef.current.style.display === 'none') {
      divRef.current.style.display = 'block';
    } else {
      divRef.current.style.display = 'none';
    }
  };

  return (
    <div>
      <button onClick={toggle}>Toggle</button>
      <div ref={divRef}>Content</div>
    </div>
  );
}

// âœ… ÄÃšNG: DÃ¹ng state, Ä‘á»ƒ React quáº£n lÃ½
function GoodToggle() {
  const [show, setShow] = useState(true);

  return (
    <div>
      <button onClick={() => setShow(!show)}>Toggle</button>
      {show && <div>Content</div>}
    </div>
  );
}
```

**Rule of thumb:**

```
DÃ¹ng STATE khi:
âœ… Control whether element renders
âœ… Control element's React props
âœ… Manage data that affects UI
âœ… Declarative approach works

DÃ¹ng REF khi:
âœ… Need imperative DOM API (focus, scroll, play)
âœ… Measure DOM properties
âœ… Integrate with non-React code
âœ… Must escape React's declarative model
```

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Pattern CÆ¡ Báº£n - Auto Focus Input â­

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Focus input khi component mount
 * ğŸ’¡ Pattern: useRef + useEffect for imperative DOM operations
 */

import { useState, useRef, useEffect } from 'react';

function AutoFocusInput() {
  const [value, setValue] = useState('');
  const inputRef = useRef(null);

  // âœ… Effect Ä‘á»ƒ focus khi mount
  useEffect(() => {
    // Focus input
    inputRef.current.focus();

    // Optional: Select all text
    inputRef.current.select();
  }, []); // Empty deps = chá»‰ cháº¡y khi mount

  return (
    <div style={{ padding: '20px' }}>
      <h2>Auto Focus Demo</h2>

      <input
        ref={inputRef} // ğŸ¯ Attach ref
        type='text'
        value={value}
        onChange={(e) => setValue(e.target.value)}
        placeholder="I'm auto-focused!"
        style={{
          padding: '10px',
          fontSize: '16px',
          width: '300px',
          border: '2px solid #007bff',
        }}
      />

      <p>Value: {value}</p>
    </div>
  );
}
```

**Variations:**

```jsx
// âœ… Pattern: Focus khi condition changes
function ConditionalFocus() {
  const [show, setShow] = useState(false);
  const inputRef = useRef(null);

  useEffect(() => {
    if (show && inputRef.current) {
      // Delay Ä‘á»ƒ Ä‘áº£m báº£o element Ä‘Ã£ render
      setTimeout(() => {
        inputRef.current?.focus();
      }, 0);
    }
  }, [show]); // Re-run when show changes

  return (
    <div style={{ padding: '20px' }}>
      <button onClick={() => setShow(!show)}>
        {show ? 'Hide' : 'Show'} Input
      </button>

      {show && (
        <input
          ref={inputRef}
          type='text'
          placeholder='I appear and get focused!'
          style={{ marginTop: '10px', padding: '10px' }}
        />
      )}
    </div>
  );
}

// âœ… Pattern: Focus next input after max length
function OTPInput() {
  const [otp, setOtp] = useState(['', '', '', '']);
  const inputRefs = useRef([]); // Array of refs!

  const handleChange = (index, value) => {
    // Chá»‰ cho nháº­p 1 kÃ½ tá»±
    const newValue = value.slice(0, 1);

    // Update OTP
    const newOtp = [...otp];
    newOtp[index] = newValue;
    setOtp(newOtp);

    // Auto-focus next input
    if (newValue && index < 3) {
      inputRefs.current[index + 1]?.focus();
    }
  };

  const handleKeyDown = (index, e) => {
    // Backspace: focus previous
    if (e.key === 'Backspace' && !otp[index] && index > 0) {
      inputRefs.current[index - 1]?.focus();
    }
  };

  return (
    <div style={{ padding: '20px' }}>
      <h2>OTP Input</h2>
      <div style={{ display: 'flex', gap: '10px' }}>
        {otp.map((digit, index) => (
          <input
            key={index}
            ref={(el) => (inputRefs.current[index] = el)} // ğŸ¯ Store ref in array
            type='text'
            inputMode='numeric'
            value={digit}
            onChange={(e) => handleChange(index, e.target.value)}
            onKeyDown={(e) => handleKeyDown(index, e)}
            style={{
              width: '50px',
              height: '50px',
              fontSize: '24px',
              textAlign: 'center',
              border: '2px solid #ccc',
              borderRadius: '4px',
            }}
          />
        ))}
      </div>
      <p>OTP: {otp.join('')}</p>
    </div>
  );
}
```

### Demo 2: Ká»‹ch Báº£n Thá»±c Táº¿ - Scroll to Element â­â­

```jsx
/**
 * ğŸ¯ Use case: Scroll to section, smooth scroll, scroll to bottom
 * ğŸ’¼ Real-world: Chat apps, long forms, documentation pages
 */

import { useState, useRef, useEffect } from 'react';

function ScrollToDemo() {
  const [messages, setMessages] = useState([
    { id: 1, text: 'Hello!' },
    { id: 2, text: 'How are you?' },
    { id: 3, text: 'I am good, thanks!' },
  ]);

  const messagesEndRef = useRef(null);
  const containerRef = useRef(null);

  // âœ… Pattern 1: Scroll to bottom on new message
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({
      behavior: 'smooth',
    });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]); // Scroll when messages change

  // âœ… Pattern 2: Scroll to specific message
  const scrollToMessage = (id) => {
    const element = document.getElementById(`message-${id}`);
    element?.scrollIntoView({
      behavior: 'smooth',
      block: 'center', // Scroll to center of viewport
    });
  };

  // âœ… Pattern 3: Check if scrolled to bottom
  const [isAtBottom, setIsAtBottom] = useState(true);

  const handleScroll = () => {
    if (!containerRef.current) return;

    const { scrollTop, scrollHeight, clientHeight } = containerRef.current;
    const atBottom = scrollHeight - scrollTop - clientHeight < 10; // 10px threshold
    setIsAtBottom(atBottom);
  };

  const addMessage = () => {
    const newMessage = {
      id: messages.length + 1,
      text: `Message ${messages.length + 1}`,
    };
    setMessages([...messages, newMessage]);
  };

  return (
    <div style={{ padding: '20px' }}>
      <h2>Scroll to Demo</h2>

      {/* Controls */}
      <div style={{ marginBottom: '10px', display: 'flex', gap: '10px' }}>
        <button onClick={addMessage}>Add Message</button>
        <button onClick={scrollToBottom}>Scroll to Bottom</button>
        <button onClick={() => scrollToMessage(1)}>Go to Message 1</button>
      </div>

      {/* Scroll indicator */}
      {!isAtBottom && (
        <div
          style={{
            position: 'fixed',
            bottom: '20px',
            right: '20px',
            backgroundColor: '#007bff',
            color: 'white',
            padding: '10px 15px',
            borderRadius: '20px',
            cursor: 'pointer',
            boxShadow: '0 2px 10px rgba(0,0,0,0.2)',
          }}
          onClick={scrollToBottom}
        >
          â†“ New messages
        </div>
      )}

      {/* Messages container */}
      <div
        ref={containerRef}
        onScroll={handleScroll}
        style={{
          height: '300px',
          overflowY: 'auto',
          border: '2px solid #ccc',
          borderRadius: '8px',
          padding: '10px',
          backgroundColor: '#f9f9f9',
        }}
      >
        {messages.map((message) => (
          <div
            key={message.id}
            id={`message-${message.id}`}
            style={{
              padding: '10px',
              marginBottom: '10px',
              backgroundColor: 'white',
              borderRadius: '4px',
              border: '1px solid #ddd',
            }}
          >
            <strong>Message #{message.id}:</strong> {message.text}
          </div>
        ))}

        {/* Invisible element at bottom */}
        <div ref={messagesEndRef} />
      </div>
    </div>
  );
}
```

**Key Patterns:**

```jsx
// Pattern 1: Scroll to bottom (chat apps)
const endRef = useRef(null);
useEffect(() => {
  endRef.current?.scrollIntoView({ behavior: 'smooth' });
}, [messages]);

// Pattern 2: Scroll to specific element
const scrollToId = (id) => {
  document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' });
};

// Pattern 3: Detect scroll position
const handleScroll = (e) => {
  const { scrollTop, scrollHeight, clientHeight } = e.target;
  const isAtBottom = scrollHeight - scrollTop === clientHeight;
  // Do something based on position
};

// Pattern 4: Programmatic scroll
const containerRef = useRef(null);
containerRef.current?.scrollTo({
  top: 0,
  behavior: 'smooth',
});
```

### Demo 3: Edge Cases - Video Player Control â­â­â­

```jsx
/**
 * ğŸ¯ Use case: Control video playback imperatively
 * âš ï¸ Edge cases:
 *    - Video not loaded yet
 *    - Multiple play/pause calls
 *    - Cleanup on unmount
 *    - Browser autoplay policies
 */

import { useState, useRef, useEffect } from 'react';

function VideoPlayer() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);

  const videoRef = useRef(null);
  const progressIntervalRef = useRef(null);

  // âœ… Pattern: Play/Pause with error handling
  const togglePlay = async () => {
    if (!videoRef.current) return;

    try {
      if (isPlaying) {
        videoRef.current.pause();
        setIsPlaying(false);
      } else {
        // âš ï¸ play() returns a promise - can fail!
        await videoRef.current.play();
        setIsPlaying(true);
      }
    } catch (error) {
      console.error('Playback failed:', error);
      // âš ï¸ Autoplay might be blocked by browser
      if (error.name === 'NotAllowedError') {
        alert('Autoplay blocked. Click play button to start.');
      }
    }
  };

  // âœ… Pattern: Seek to position
  const handleSeek = (e) => {
    if (!videoRef.current) return;

    const rect = e.currentTarget.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const percentage = clickX / rect.width;

    videoRef.current.currentTime = percentage * duration;
  };

  // âœ… Pattern: Volume control
  const handleVolumeChange = (e) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);

    if (videoRef.current) {
      videoRef.current.volume = newVolume;
    }
  };

  // âœ… Pattern: Track progress
  useEffect(() => {
    if (isPlaying) {
      progressIntervalRef.current = setInterval(() => {
        if (videoRef.current) {
          setCurrentTime(videoRef.current.currentTime);
        }
      }, 100); // Update every 100ms
    } else {
      if (progressIntervalRef.current) {
        clearInterval(progressIntervalRef.current);
      }
    }

    return () => {
      if (progressIntervalRef.current) {
        clearInterval(progressIntervalRef.current);
      }
    };
  }, [isPlaying]);

  // âœ… Pattern: Handle video events
  const handleLoadedMetadata = () => {
    if (videoRef.current) {
      setDuration(videoRef.current.duration);
    }
  };

  const handleEnded = () => {
    setIsPlaying(false);
    setCurrentTime(0);
  };

  // âœ… Pattern: Cleanup on unmount
  useEffect(() => {
    return () => {
      // Pause video when component unmounts
      if (videoRef.current) {
        videoRef.current.pause();
      }
    };
  }, []);

  // Format time helper
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h2>Custom Video Player</h2>

      {/* Video element */}
      <video
        ref={videoRef}
        onLoadedMetadata={handleLoadedMetadata}
        onEnded={handleEnded}
        style={{
          width: '100%',
          borderRadius: '8px',
          backgroundColor: '#000',
        }}
      >
        <source
          src='https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4'
          type='video/mp4'
        />
        Your browser does not support video.
      </video>

      {/* Custom controls */}
      <div style={{ marginTop: '15px' }}>
        {/* Progress bar */}
        <div
          onClick={handleSeek}
          style={{
            width: '100%',
            height: '8px',
            backgroundColor: '#ddd',
            borderRadius: '4px',
            cursor: 'pointer',
            position: 'relative',
            marginBottom: '15px',
          }}
        >
          <div
            style={{
              width: `${(currentTime / duration) * 100}%`,
              height: '100%',
              backgroundColor: '#007bff',
              borderRadius: '4px',
              transition: 'width 0.1s',
            }}
          />
        </div>

        {/* Time display */}
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            marginBottom: '15px',
            fontSize: '14px',
            color: '#666',
          }}
        >
          <span>{formatTime(currentTime)}</span>
          <span>{formatTime(duration)}</span>
        </div>

        {/* Control buttons */}
        <div
          style={{
            display: 'flex',
            gap: '10px',
            alignItems: 'center',
          }}
        >
          <button
            onClick={togglePlay}
            style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            {isPlaying ? 'â¸ Pause' : 'â–¶ Play'}
          </button>

          <button
            onClick={() => {
              if (videoRef.current) {
                videoRef.current.currentTime = 0;
                setCurrentTime(0);
              }
            }}
            style={{
              padding: '10px 20px',
              fontSize: '16px',
              backgroundColor: '#6c757d',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            â® Reset
          </button>

          {/* Volume control */}
          <div
            style={{
              display: 'flex',
              alignItems: 'center',
              gap: '10px',
              marginLeft: 'auto',
            }}
          >
            <span>ğŸ”Š</span>
            <input
              type='range'
              min='0'
              max='1'
              step='0.1'
              value={volume}
              onChange={handleVolumeChange}
              style={{ width: '100px' }}
            />
            <span>{Math.round(volume * 100)}%</span>
          </div>
        </div>
      </div>

      {/* Debug info */}
      <details style={{ marginTop: '20px', fontSize: '12px' }}>
        <summary style={{ cursor: 'pointer', fontWeight: 'bold' }}>
          Debug Info
        </summary>
        <div
          style={{
            marginTop: '10px',
            padding: '10px',
            backgroundColor: '#f8f9fa',
            borderRadius: '4px',
            fontFamily: 'monospace',
          }}
        >
          <p>Is Playing: {isPlaying ? 'Yes' : 'No'}</p>
          <p>Current Time: {currentTime.toFixed(2)}s</p>
          <p>Duration: {duration.toFixed(2)}s</p>
          <p>Volume: {volume}</p>
          <p>Video Ready: {videoRef.current ? 'Yes' : 'No'}</p>
        </div>
      </details>
    </div>
  );
}
```

**Edge Cases Handled:**

```jsx
// âš ï¸ Edge Case 1: Video not loaded
const play = async () => {
  if (!videoRef.current) {
    console.warn('Video ref not ready');
    return; // âœ… Early return
  }
  await videoRef.current.play();
};

// âš ï¸ Edge Case 2: Autoplay blocked
try {
  await videoRef.current.play();
} catch (error) {
  if (error.name === 'NotAllowedError') {
    // âœ… Handle browser autoplay policy
    alert('Click to play');
  }
}

// âš ï¸ Edge Case 3: Seeking beyond duration
const seek = (time) => {
  if (videoRef.current) {
    // âœ… Clamp to valid range
    videoRef.current.currentTime = Math.min(
      Math.max(0, time),
      videoRef.current.duration,
    );
  }
};

// âš ï¸ Edge Case 4: Component unmount during playback
useEffect(() => {
  return () => {
    if (videoRef.current) {
      videoRef.current.pause(); // âœ… Cleanup
    }
  };
}, []);
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Exercise 1: Click Outside Detector (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Detect clicks outside element (dropdown, modal)
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useReducer, Context, custom hooks
 *
 * Requirements:
 * 1. Dropdown má»Ÿ khi click button
 * 2. Dropdown Ä‘Ã³ng khi click outside
 * 3. KhÃ´ng Ä‘Ã³ng khi click inside dropdown
 * 4. Cleanup event listener properly
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - useRef Ä‘á»ƒ reference dropdown element
 * - useEffect Ä‘á»ƒ add/remove document click listener
 * - event.target Ä‘á»ƒ check click location
 */

// âŒ CÃ¡ch SAI: KhÃ´ng dÃ¹ng ref, logic phá»©c táº¡p
function BadDropdown() {
  const [isOpen, setIsOpen] = useState(false);

  // âš ï¸ KhÃ´ng reliable, cÃ³ thá»ƒ click vÃ o child elements
  const handleDocumentClick = (e) => {
    if (e.target.className !== 'dropdown') {
      setIsOpen(false);
    }
  };

  useEffect(() => {
    document.addEventListener('click', handleDocumentClick);
    return () => document.removeEventListener('click', handleDocumentClick);
  }, []);

  return (
    <div className='dropdown'>
      <button onClick={() => setIsOpen(!isOpen)}>Toggle</button>
      {isOpen && <div>Dropdown Content</div>}
    </div>
  );
}

// âœ… CÃ¡ch ÄÃšNG: DÃ¹ng ref vá»›i contains()
function GoodDropdown() {
  // TODO: Implement using useRef
  // Step 1: Create ref for dropdown container
  // Step 2: useEffect vá»›i document click listener
  // Step 3: Check if click is outside using ref.current.contains()
  // Step 4: Close dropdown if outside
  // Step 5: Cleanup listener
}

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  // TODO: const dropdownRef = useRef(null);

  // TODO: Implement click outside detection
  useEffect(() => {
    // const handleClickOutside = (event) => {
    //   if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
    //     setIsOpen(false);
    //   }
    // };
    // if (isOpen) {
    //   document.addEventListener('mousedown', handleClickOutside);
    // }
    // return () => {
    //   document.removeEventListener('mousedown', handleClickOutside);
    // };
  }, [isOpen]);

  return (
    <div style={{ padding: '20px' }}>
      <h2>Click Outside Detector</h2>

      {/* TODO: Add ref to container */}
      <div style={{ position: 'relative', display: 'inline-block' }}>
        <button
          onClick={() => setIsOpen(!isOpen)}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          {isOpen ? 'Close' : 'Open'} Dropdown
        </button>

        {isOpen && (
          <div
            style={{
              position: 'absolute',
              top: '100%',
              left: 0,
              marginTop: '5px',
              padding: '15px',
              backgroundColor: 'white',
              border: '2px solid #007bff',
              borderRadius: '4px',
              boxShadow: '0 2px 10px rgba(0,0,0,0.1)',
              minWidth: '200px',
              zIndex: 1000,
            }}
          >
            <p>This is dropdown content</p>
            <button style={{ padding: '5px 10px' }}>Action 1</button>
            <button style={{ padding: '5px 10px', marginLeft: '5px' }}>
              Action 2
            </button>
          </div>
        )}
      </div>

      <div
        style={{
          marginTop: '20px',
          padding: '20px',
          backgroundColor: '#f0f0f0',
        }}
      >
        <p>Click anywhere in this gray area to test</p>
        <p>Dropdown should close when you click here</p>
      </div>
    </div>
  );
}

// âœ… Expected behavior:
// 1. Click button â†’ dropdown opens
// 2. Click inside dropdown â†’ stays open
// 3. Click outside dropdown â†’ closes
// 4. Click button again â†’ toggles
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Dropdown component with click-outside-to-close functionality
 * Uses useRef + useEffect to detect clicks outside the dropdown container
 */
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  useEffect(() => {
    const handleClickOutside = (event) => {
      // Chá»‰ xá»­ lÃ½ khi dropdown Ä‘ang má»Ÿ
      if (
        isOpen &&
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target)
      ) {
        setIsOpen(false);
      }
    };

    // Sá»­ dá»¥ng 'mousedown' thay vÃ¬ 'click' Ä‘á»ƒ báº¯t sá»± kiá»‡n sá»›m hÆ¡n
    document.addEventListener('mousedown', handleClickOutside);

    // Cleanup
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]); // Dependency: isOpen â†’ chá»‰ re-attach khi tráº¡ng thÃ¡i má»Ÿ thay Ä‘á»•i

  return (
    <div style={{ padding: '20px' }}>
      <h2>Click Outside Detector</h2>

      <div
        style={{ position: 'relative', display: 'inline-block' }}
        ref={dropdownRef}
      >
        <button
          onClick={() => setIsOpen(!isOpen)}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          {isOpen ? 'Close' : 'Open'} Dropdown
        </button>

        {isOpen && (
          <div
            style={{
              position: 'absolute',
              top: '100%',
              left: 0,
              marginTop: '5px',
              padding: '15px',
              backgroundColor: 'white',
              border: '2px solid #007bff',
              borderRadius: '4px',
              boxShadow: '0 2px 10px rgba(0,0,0,0.1)',
              minWidth: '200px',
              zIndex: 1000,
            }}
          >
            <p>This is dropdown content</p>
            <button style={{ padding: '5px 10px' }}>Action 1</button>
            <button style={{ padding: '5px 10px', marginLeft: '5px' }}>
              Action 2
            </button>
          </div>
        )}
      </div>

      <div
        style={{
          marginTop: '20px',
          padding: '20px',
          backgroundColor: '#f0f0f0',
        }}
      >
        <p>Click anywhere in this gray area to test</p>
        <p>Dropdown should close when you click here</p>
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i:
- Click nÃºt â†’ dropdown má»Ÿ
- Click bÃªn trong dropdown (ká»ƒ cáº£ nÃºt Action 1/2) â†’ váº«n má»Ÿ
- Click báº¥t ká»³ Ä‘Ã¢u bÃªn ngoÃ i vÃ¹ng dropdown â†’ Ä‘Ã³ng
- Click láº¡i nÃºt khi Ä‘ang má»Ÿ â†’ Ä‘Ã³ng (toggle behavior)
*/
```

</details>

### â­â­ Exercise 2: Image Zoom Viewer (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Measure vÃ  manipulate DOM Ä‘á»ƒ create image zoom
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario:
 * E-commerce product image viewer - hover to zoom.
 * Cáº§n calculate mouse position vÃ  adjust image transform.
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 *
 * Approach A: Pure CSS (transform-origin)
 * Pros: Simple, performant
 * Cons: Limited control, fixed zoom ratio
 *
 * Approach B: JS vá»›i refs (calculate vÃ  set style)
 * Pros: Full control, custom zoom logic
 * Cons: More complex, need refs
 *
 * ğŸ’­ Chá»n Approach B Ä‘á»ƒ thá»±c hÃ nh refs!
 *
 * Requirements:
 * 1. Image zoom on hover
 * 2. Zoom follows mouse position
 * 3. Smooth zoom in/out
 * 4. Reset on mouse leave
 */

import { useState, useRef } from 'react';

function ImageZoomViewer() {
  const [isZoomed, setIsZoomed] = useState(false);
  const imageRef = useRef(null);
  const containerRef = useRef(null);

  // TODO: Implement zoom logic
  const handleMouseMove = (e) => {
    if (!imageRef.current || !containerRef.current) return;

    // Get container bounds
    // const rect = containerRef.current.getBoundingClientRect();

    // Calculate mouse position relative to container (0-1)
    // const x = (e.clientX - rect.left) / rect.width;
    // const y = (e.clientY - rect.top) / rect.height;

    // Set transform origin based on mouse position
    // imageRef.current.style.transformOrigin = `${x * 100}% ${y * 100}%`;
  };

  const handleMouseEnter = () => {
    setIsZoomed(true);
  };

  const handleMouseLeave = () => {
    setIsZoomed(false);
    // TODO: Reset transform origin
  };

  return (
    <div style={{ padding: '20px' }}>
      <h2>Image Zoom Viewer</h2>

      <div
        ref={containerRef}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onMouseMove={handleMouseMove}
        style={{
          width: '400px',
          height: '400px',
          border: '2px solid #ccc',
          borderRadius: '8px',
          overflow: 'hidden',
          cursor: isZoomed ? 'zoom-in' : 'default',
          position: 'relative',
        }}
      >
        <img
          ref={imageRef}
          src='https://images.unsplash.com/photo-1505740420928-5e560c06d30e?w=800'
          alt='Product'
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            transform: isZoomed ? 'scale(2)' : 'scale(1)',
            transition: 'transform 0.3s ease',
            transformOrigin: 'center center',
          }}
        />
      </div>

      <p style={{ marginTop: '10px', color: '#666' }}>
        Hover over image to zoom. Move mouse to pan.
      </p>
    </div>
  );
}

// ğŸ¯ Expected behavior:
// - Hover â†’ image zooms 2x
// - Move mouse â†’ zoom follows cursor
// - Leave â†’ zoom resets smoothly
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Image Zoom Viewer - Hover to zoom with mouse-following pan effect
 * Uses useRef to access container and image DOM nodes for dynamic transform-origin
 */
function ImageZoomViewer() {
  const [isZoomed, setIsZoomed] = useState(false);
  const imageRef = useRef(null);
  const containerRef = useRef(null);

  const handleMouseMove = (e) => {
    if (!isZoomed || !containerRef.current || !imageRef.current) return;

    const rect = containerRef.current.getBoundingClientRect();

    // TÃ­nh vá»‹ trÃ­ chuá»™t tÆ°Æ¡ng Ä‘á»‘i trong container (0 â†’ 1)
    const x = (e.clientX - rect.left) / rect.width;
    const y = (e.clientY - rect.top) / rect.height;

    // Giá»›i háº¡n trong khoáº£ng 0-100%
    const originX = Math.max(0, Math.min(100, x * 100));
    const originY = Math.max(0, Math.min(100, y * 100));

    // Cáº­p nháº­t transform-origin Ä‘á»ƒ zoom táº­p trung vÃ o vá»‹ trÃ­ chuá»™t
    imageRef.current.style.transformOrigin = `${originX}% ${originY}%`;
  };

  const handleMouseEnter = () => {
    setIsZoomed(true);
  };

  const handleMouseLeave = () => {
    setIsZoomed(false);
    if (imageRef.current) {
      // Reset vá» giá»¯a khi rá»i chuá»™t
      imageRef.current.style.transformOrigin = 'center center';
    }
  };

  return (
    <div style={{ padding: '20px' }}>
      <h2>Image Zoom Viewer</h2>

      <div
        ref={containerRef}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onMouseMove={handleMouseMove}
        style={{
          width: '400px',
          height: '400px',
          border: '2px solid #ccc',
          borderRadius: '8px',
          overflow: 'hidden',
          cursor: isZoomed ? 'zoom-in' : 'default',
          position: 'relative',
          backgroundColor: '#f8f9fa',
        }}
      >
        <img
          ref={imageRef}
          src='https://images.unsplash.com/photo-1505740420928-5e560c06d30e?w=800'
          alt='Product'
          style={{
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            transform: isZoomed ? 'scale(2)' : 'scale(1)',
            transition: 'transform 0.3s ease',
            transformOrigin: 'center center',
            willChange: 'transform', // Cáº£i thiá»‡n hiá»‡u suáº¥t animation
          }}
        />
      </div>

      <p style={{ marginTop: '10px', color: '#666' }}>
        Hover over image to zoom Ã—2. Move mouse to look around.
      </p>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i:
- Ban Ä‘áº§u: hÃ¬nh áº£nh hiá»ƒn thá»‹ bÃ¬nh thÆ°á»ng (scale 1)
- Di chuá»™t vÃ o vÃ¹ng áº£nh â†’ zoom lÃªn gáº¥p 2 láº§n (scale 2)
- Di chuyá»ƒn chuá»™t â†’ Ä‘iá»ƒm zoom (transform-origin) theo vá»‹ trÃ­ chuá»™t
- Rá»i chuá»™t khá»i vÃ¹ng â†’ áº£nh trá»Ÿ vá» scale 1, origin vá» giá»¯a
- Hiá»‡u á»©ng mÆ°á»£t mÃ  nhá» transition vÃ  willChange
*/
```

</details>

### â­â­â­ Exercise 3: Infinite Scroll List (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Implement infinite scroll vá»›i Intersection Observer
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  user, tÃ´i muá»‘n scroll vÃ  load more items tá»± Ä‘á»™ng"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Load 20 items initially
 * - [ ] Detect when scrolled near bottom
 * - [ ] Load 20 more items automatically
 * - [ ] Show loading indicator
 * - [ ] Handle "no more items" state
 * - [ ] Smooth scroll experience
 *
 * ğŸ¨ Technical Constraints:
 * - DÃ¹ng Intersection Observer API
 * - useRef cho observer vÃ  sentinel element
 * - Mock API vá»›i setTimeout
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Loading already in progress (prevent duplicate requests)
 * - Scroll too fast (debounce/throttle)
 * - Component unmount during loading
 * - No more items to load
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] Create sentinel element at list bottom
 * - [ ] Setup Intersection Observer
 * - [ ] Load more when sentinel visible
 * - [ ] Cleanup observer on unmount
 * - [ ] Loading states
 * - [ ] Empty/end states
 */

import { useState, useRef, useEffect, useCallback } from 'react';

function InfiniteScrollList() {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);

  // Refs
  const observerRef = useRef(null);
  const sentinelRef = useRef(null);
  const loadingRef = useRef(false); // Prevent duplicate loads

  // Mock API
  const fetchItems = async (pageNum) => {
    // Simulate API delay
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Generate mock items
    const newItems = Array.from({ length: 20 }, (_, i) => ({
      id: (pageNum - 1) * 20 + i + 1,
      title: `Item ${(pageNum - 1) * 20 + i + 1}`,
      description: `Description for item ${(pageNum - 1) * 20 + i + 1}`,
    }));

    // Simulate "no more items" after page 5
    return {
      items: newItems,
      hasMore: pageNum < 5,
    };
  };

  // Load more items
  const loadMore = useCallback(async () => {
    // TODO: Implement
    // 1. Check if already loading (loadingRef)
    // 2. Check if has more items
    // 3. Set loading states
    // 4. Fetch items
    // 5. Update items array
    // 6. Update page number
    // 7. Update hasMore
    // 8. Reset loading state
  }, [page, hasMore]);

  // Setup Intersection Observer
  useEffect(() => {
    // TODO: Implement
    // 1. Create IntersectionObserver
    // 2. Observe sentinel element
    // 3. When intersecting â†’ loadMore()
    // 4. Cleanup observer on unmount
    // const options = {
    //   root: null, // viewport
    //   rootMargin: '100px', // Load before reaching bottom
    //   threshold: 0.1
    // };
    // observerRef.current = new IntersectionObserver((entries) => {
    //   const [entry] = entries;
    //   if (entry.isIntersecting && !loadingRef.current && hasMore) {
    //     loadMore();
    //   }
    // }, options);
    // if (sentinelRef.current) {
    //   observerRef.current.observe(sentinelRef.current);
    // }
    // return () => {
    //   if (observerRef.current) {
    //     observerRef.current.disconnect();
    //   }
    // };
  }, [loadMore, hasMore]);

  // Initial load
  useEffect(() => {
    loadMore();
  }, []); // Load once on mount

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h2>Infinite Scroll List</h2>

      {/* Items list */}
      <div style={{ marginTop: '20px' }}>
        {items.map((item) => (
          <div
            key={item.id}
            style={{
              padding: '15px',
              marginBottom: '10px',
              backgroundColor: 'white',
              border: '1px solid #ddd',
              borderRadius: '4px',
            }}
          >
            <h3 style={{ margin: '0 0 5px 0' }}>{item.title}</h3>
            <p style={{ margin: 0, color: '#666', fontSize: '14px' }}>
              {item.description}
            </p>
          </div>
        ))}
      </div>

      {/* Loading indicator */}
      {loading && (
        <div
          style={{
            padding: '20px',
            textAlign: 'center',
            color: '#007bff',
          }}
        >
          Loading more items...
        </div>
      )}

      {/* Sentinel element - invisible trigger */}
      {hasMore && (
        <div
          ref={sentinelRef}
          style={{
            height: '20px',
            margin: '10px 0',
          }}
        />
      )}

      {/* End message */}
      {!hasMore && (
        <div
          style={{
            padding: '20px',
            textAlign: 'center',
            color: '#999',
            borderTop: '2px solid #eee',
          }}
        >
          ğŸ‰ You've reached the end!
        </div>
      )}

      {/* Debug info */}
      <div
        style={{
          position: 'fixed',
          bottom: '20px',
          right: '20px',
          padding: '10px',
          backgroundColor: 'rgba(0,0,0,0.8)',
          color: 'white',
          borderRadius: '4px',
          fontSize: '12px',
          fontFamily: 'monospace',
        }}
      >
        <div>Items: {items.length}</div>
        <div>Page: {page}</div>
        <div>Loading: {loading ? 'Yes' : 'No'}</div>
        <div>Has More: {hasMore ? 'Yes' : 'No'}</div>
      </div>
    </div>
  );
}

// ğŸ¯ Expected behavior:
// 1. Loads 20 items initially
// 2. Scroll down â†’ auto-loads more when near bottom
// 3. Shows loading indicator during fetch
// 4. Stops at page 5 with "end" message
// 5. No duplicate requests
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Infinite Scroll List using Intersection Observer + useRef
 * Loads more items automatically when nearing the bottom
 */
function InfiniteScrollList() {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);

  // Refs
  const observerRef = useRef(null);
  const sentinelRef = useRef(null);
  const loadingRef = useRef(false); // Prevent duplicate loads

  // Mock API simulation
  const fetchItems = async (pageNum) => {
    await new Promise((resolve) => setTimeout(resolve, 1200)); // Simulate network delay

    const newItems = Array.from({ length: 20 }, (_, i) => ({
      id: (pageNum - 1) * 20 + i + 1,
      title: `Item ${(pageNum - 1) * 20 + i + 1}`,
      description: `This is description for item number ${(pageNum - 1) * 20 + i + 1}`,
    }));

    // Simulate end of content after page 5
    const hasMoreItems = pageNum < 5;

    return { items: newItems, hasMore: hasMoreItems };
  };

  // Load more function - memoized with useCallback
  const loadMore = useCallback(async () => {
    // Prevent concurrent loads
    if (loadingRef.current || !hasMore) return;

    loadingRef.current = true;
    setLoading(true);

    try {
      const { items: newItems, hasMore: moreAvailable } =
        await fetchItems(page);

      setItems((prev) => [...prev, ...newItems]);
      setPage((prev) => prev + 1);
      setHasMore(moreAvailable);
    } catch (err) {
      console.error('Failed to load items:', err);
      setHasMore(false);
    } finally {
      setLoading(false);
      loadingRef.current = false;
    }
  }, [page, hasMore]);

  // Setup Intersection Observer
  useEffect(() => {
    if (!hasMore || loading) return;

    const options = {
      root: null, // viewport
      rootMargin: '200px', // trigger 200px before reaching sentinel
      threshold: 0.1,
    };

    observerRef.current = new IntersectionObserver((entries) => {
      const [entry] = entries;
      if (entry.isIntersecting && !loadingRef.current) {
        loadMore();
      }
    }, options);

    if (sentinelRef.current) {
      observerRef.current.observe(sentinelRef.current);
    }

    // Cleanup
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, [loadMore, hasMore, loading]);

  // Initial load
  useEffect(() => {
    loadMore();
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  return (
    <div style={{ padding: '20px', maxWidth: '600px', margin: '0 auto' }}>
      <h2>Infinite Scroll List</h2>

      {/* Items list */}
      <div style={{ marginTop: '20px' }}>
        {items.map((item) => (
          <div
            key={item.id}
            style={{
              padding: '15px',
              marginBottom: '10px',
              backgroundColor: 'white',
              border: '1px solid #ddd',
              borderRadius: '4px',
              boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
            }}
          >
            <h3 style={{ margin: '0 0 8px 0' }}>{item.title}</h3>
            <p style={{ margin: 0, color: '#555', fontSize: '14px' }}>
              {item.description}
            </p>
          </div>
        ))}
      </div>

      {/* Loading indicator */}
      {loading && (
        <div
          style={{
            padding: '30px',
            textAlign: 'center',
            color: '#007bff',
            fontSize: '16px',
          }}
        >
          Loading more items...
        </div>
      )}

      {/* Sentinel element - triggers load more when visible */}
      {hasMore && !loading && (
        <div
          ref={sentinelRef}
          style={{
            height: '40px',
            margin: '20px 0',
          }}
        />
      )}

      {/* End of content message */}
      {!hasMore && items.length > 0 && (
        <div
          style={{
            padding: '30px',
            textAlign: 'center',
            color: '#6c757d',
            fontSize: '18px',
            borderTop: '2px solid #eee',
            marginTop: '20px',
          }}
        >
          ğŸ‰ You've reached the end of the list!
        </div>
      )}

      {/* Debug info (optional) */}
      <div
        style={{
          position: 'fixed',
          bottom: '20px',
          right: '20px',
          padding: '10px 14px',
          backgroundColor: 'rgba(0,0,0,0.7)',
          color: 'white',
          borderRadius: '6px',
          fontSize: '12px',
          fontFamily: 'monospace',
        }}
      >
        Items: {items.length} | Page: {page} | Loading: {loading ? 'Yes' : 'No'}
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i:
- Trang táº£i 20 items Ä‘áº§u tiÃªn ngay khi mount
- Khi scroll gáº§n Ä‘Ã¡y (cÃ¡ch ~200px), tá»± Ä‘á»™ng load thÃªm 20 items
- Hiá»ƒn thá»‹ "Loading more items..." trong lÃºc chá»
- Sau khi load trang 5 â†’ hiá»ƒn thá»‹ thÃ´ng bÃ¡o "You've reached the end"
- KhÃ´ng load trÃ¹ng láº·p (nhá» loadingRef)
- Observer tá»± Ä‘á»™ng cleanup khi component unmount
*/
```

</details>

### â­â­â­â­ Exercise 4: Resizable Split Pane (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Build resizable panels vá»›i drag handle
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Nhiá»‡m vá»¥:
 * 1. So sÃ¡nh approaches:
 *    A. CSS Flexbox vá»›i dynamic flex values
 *    B. Absolute positioning vá»›i width calculations
 *    C. CSS Grid vá»›i template columns
 * 2. Document pros/cons
 * 3. Chá»n approach
 * 4. Viáº¿t ADR
 *
 * Requirements:
 * - Two panels side by side
 * - Draggable divider in middle
 * - Min/max width constraints
 * - Smooth resize
 * - Save sizes to localStorage
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 * ğŸ§ª PHASE 3: Testing (10 phÃºt)
 */

import { useState, useRef, useEffect } from 'react';

function ResizableSplitPane({
  leftContent,
  rightContent,
  initialLeftWidth = 50, // percentage
  minWidth = 20,
  maxWidth = 80,
}) {
  const [leftWidth, setLeftWidth] = useState(initialLeftWidth);
  const [isDragging, setIsDragging] = useState(false);

  const containerRef = useRef(null);
  const startXRef = useRef(0);
  const startWidthRef = useRef(0);

  // TODO: Implement drag logic
  const handleMouseDown = (e) => {
    // Start drag
    // Save initial mouse X and current width
    // Set dragging state
  };

  useEffect(() => {
    if (!isDragging) return;

    const handleMouseMove = (e) => {
      // TODO: Calculate new width
      // Get container width
      // Calculate delta X
      // Calculate new width percentage
      // Clamp between min/max
      // Update state
    };

    const handleMouseUp = () => {
      // TODO: End drag
      // Save to localStorage
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDragging, minWidth, maxWidth]);

  // Load from localStorage
  useEffect(() => {
    const saved = localStorage.getItem('splitPaneWidth');
    if (saved) {
      setLeftWidth(Number(saved));
    }
  }, []);

  return (
    <div style={{ padding: '20px' }}>
      <h2>Resizable Split Pane</h2>

      <div
        ref={containerRef}
        style={{
          display: 'flex',
          height: '400px',
          border: '2px solid #ccc',
          borderRadius: '8px',
          overflow: 'hidden',
          userSelect: isDragging ? 'none' : 'auto',
          cursor: isDragging ? 'col-resize' : 'default',
        }}
      >
        {/* Left panel */}
        <div
          style={{
            width: `${leftWidth}%`,
            backgroundColor: '#f0f8ff',
            padding: '20px',
            overflowY: 'auto',
          }}
        >
          {leftContent || (
            <div>
              <h3>Left Panel</h3>
              <p>Width: {leftWidth.toFixed(1)}%</p>
              <p>Drag the divider to resize</p>
            </div>
          )}
        </div>

        {/* Divider */}
        <div
          onMouseDown={handleMouseDown}
          style={{
            width: '4px',
            backgroundColor: isDragging ? '#007bff' : '#ccc',
            cursor: 'col-resize',
            transition: isDragging ? 'none' : 'background-color 0.2s',
            position: 'relative',
          }}
        >
          {/* Drag handle visual */}
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              width: '20px',
              height: '40px',
              backgroundColor: isDragging ? '#007bff' : '#999',
              borderRadius: '4px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              color: 'white',
              fontSize: '12px',
            }}
          >
            â‹®
          </div>
        </div>

        {/* Right panel */}
        <div
          style={{
            flex: 1,
            backgroundColor: '#fff5f5',
            padding: '20px',
            overflowY: 'auto',
          }}
        >
          {rightContent || (
            <div>
              <h3>Right Panel</h3>
              <p>Width: {(100 - leftWidth).toFixed(1)}%</p>
              <p>This panel takes remaining space</p>
            </div>
          )}
        </div>
      </div>

      {/* Controls */}
      <div style={{ marginTop: '15px', display: 'flex', gap: '10px' }}>
        <button onClick={() => setLeftWidth(50)}>Reset (50/50)</button>
        <button onClick={() => setLeftWidth(minWidth)}>Min Left</button>
        <button onClick={() => setLeftWidth(maxWidth)}>Max Left</button>
      </div>
    </div>
  );
}

// ğŸ§ª PHASE 3: Testing Checklist
// - [ ] Drag works smoothly
// - [ ] Width clamped to min/max
// - [ ] Cursor changes on hover/drag
// - [ ] Saves to localStorage
// - [ ] Loads from localStorage on mount
// - [ ] No text selection during drag
// - [ ] Works with different content
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Resizable Split Pane with drag-to-resize functionality
 * Uses useRef for container reference and mouse event tracking
 * Persists split position in localStorage
 */
function ResizableSplitPane({
  leftContent,
  rightContent,
  initialLeftWidth = 50, // percentage
  minWidth = 20,
  maxWidth = 80,
}) {
  const [leftWidth, setLeftWidth] = useState(() => {
    // Load from localStorage if available
    const saved = localStorage.getItem('splitPaneWidth');
    return saved ? Number(saved) : initialLeftWidth;
  });

  const [isDragging, setIsDragging] = useState(false);
  const containerRef = useRef(null);
  const startXRef = useRef(0);
  const startWidthRef = useRef(0);

  const handleMouseDown = (e) => {
    e.preventDefault();
    setIsDragging(true);

    startXRef.current = e.clientX;
    startWidthRef.current = leftWidth;

    // Prevent text selection during drag
    document.body.style.userSelect = 'none';
  };

  useEffect(() => {
    if (!isDragging) return;

    const handleMouseMove = (e) => {
      if (!containerRef.current) return;

      const containerRect = containerRef.current.getBoundingClientRect();
      const deltaX = e.clientX - startXRef.current;
      const deltaPercent = (deltaX / containerRect.width) * 100;

      const newWidth = startWidthRef.current + deltaPercent;

      // Clamp between min and max
      const clampedWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));

      setLeftWidth(clampedWidth);
    };

    const handleMouseUp = () => {
      setIsDragging(false);

      // Save to localStorage
      localStorage.setItem('splitPaneWidth', leftWidth.toFixed(1));

      // Restore text selection
      document.body.style.userSelect = '';
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.body.style.userSelect = '';
    };
  }, [isDragging, leftWidth, minWidth, maxWidth]);

  return (
    <div style={{ padding: '20px' }}>
      <h2>Resizable Split Pane</h2>

      <div
        ref={containerRef}
        style={{
          display: 'flex',
          height: '400px',
          border: '2px solid #ccc',
          borderRadius: '8px',
          overflow: 'hidden',
          userSelect: isDragging ? 'none' : 'auto',
          cursor: isDragging ? 'col-resize' : 'default',
        }}
      >
        {/* Left panel */}
        <div
          style={{
            width: `${leftWidth}%`,
            backgroundColor: '#f0f8ff',
            padding: '20px',
            overflowY: 'auto',
            transition: isDragging ? 'none' : 'width 0.1s ease',
          }}
        >
          {leftContent || (
            <div>
              <h3>Left Panel</h3>
              <p>Width: {leftWidth.toFixed(1)}%</p>
              <p>Drag the middle bar to resize</p>
              <p>
                Current width is preserved across page reloads via localStorage
              </p>
            </div>
          )}
        </div>

        {/* Draggable divider */}
        <div
          onMouseDown={handleMouseDown}
          style={{
            width: '8px',
            backgroundColor: isDragging ? '#007bff' : '#ccc',
            cursor: 'col-resize',
            transition: isDragging ? 'none' : 'background-color 0.2s',
            position: 'relative',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
          }}
        >
          <div
            style={{
              width: '24px',
              height: '48px',
              backgroundColor: isDragging ? '#0056b3' : '#999',
              borderRadius: '4px',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              color: 'white',
              fontSize: '14px',
              fontWeight: 'bold',
            }}
          >
            â‹®
          </div>
        </div>

        {/* Right panel - takes remaining space */}
        <div
          style={{
            flex: 1,
            backgroundColor: '#fff5f5',
            padding: '20px',
            overflowY: 'auto',
          }}
        >
          {rightContent || (
            <div>
              <h3>Right Panel</h3>
              <p>Width: {(100 - leftWidth).toFixed(1)}%</p>
              <p>This panel automatically fills the remaining space</p>
            </div>
          )}
        </div>
      </div>

      {/* Quick controls */}
      <div style={{ marginTop: '15px', display: 'flex', gap: '10px' }}>
        <button
          onClick={() => {
            setLeftWidth(50);
            localStorage.setItem('splitPaneWidth', '50');
          }}
          style={{ padding: '8px 16px' }}
        >
          Reset 50/50
        </button>
        <button
          onClick={() => {
            setLeftWidth(minWidth);
            localStorage.setItem('splitPaneWidth', minWidth.toString());
          }}
          style={{ padding: '8px 16px' }}
        >
          Min Left ({minWidth}%)
        </button>
        <button
          onClick={() => {
            setLeftWidth(maxWidth);
            localStorage.setItem('splitPaneWidth', maxWidth.toString());
          }}
          style={{ padding: '8px 16px' }}
        >
          Max Left ({maxWidth}%)
        </button>
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i:
- Ban Ä‘áº§u chia 50/50 (hoáº·c giÃ¡ trá»‹ Ä‘Ã£ lÆ°u trÆ°á»›c Ä‘Ã³)
- KÃ©o thanh giá»¯a â†’ thay Ä‘á»•i kÃ­ch thÆ°á»›c hai panel mÆ°á»£t mÃ 
- Giá»›i háº¡n minWidth (20%) vÃ  maxWidth (80%)
- Khi tháº£ chuá»™t â†’ lÆ°u vá»‹ trÃ­ vÃ o localStorage
- Táº£i láº¡i trang â†’ khÃ´i phá»¥c Ä‘Ãºng tá»· lá»‡ Ä‘Ã£ lÆ°u
- CÃ¡c nÃºt Reset/Min/Max hoáº¡t Ä‘á»™ng vÃ  cÅ©ng lÆ°u láº¡i
- KhÃ´ng chá»n text khi Ä‘ang kÃ©o (user-select: none)
*/
```

</details>

### â­â­â­â­â­ Exercise 5: Rich Text Editor Integration (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Integrate third-party editor (Quill) vá»›i React
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 *
 * Build rich text editor component vá»›i:
 * 1. Quill editor integration
 * 2. Controlled value (sync with React state)
 * 3. Custom toolbar
 * 4. Character counter
 * 5. Auto-save draft
 * 6. Read-only mode
 * 7. HTML export
 * 8. Image upload handling
 *
 * ğŸ—ï¸ Technical Design Doc:
 *
 * 1. Component Architecture:
 *    - useRef for editor container
 *    - useRef for Quill instance
 *    - useState for content
 *    - useEffect for initialization
 *
 * 2. Integration Strategy:
 *    - Initialize Quill in useEffect
 *    - Sync changes back to React state
 *    - Handle cleanup on unmount
 *    - Prevent double initialization
 *
 * 3. Challenges:
 *    - Quill mutates DOM directly (not React way)
 *    - Need to sync external state
 *    - Event listeners management
 *    - Preventing memory leaks
 *
 * âœ… Production Checklist:
 * - [ ] Proper Quill initialization
 * - [ ] Controlled component pattern
 * - [ ] Event listener cleanup
 * - [ ] No double initialization
 * - [ ] Loading state handling
 * - [ ] Error boundaries
 * - [ ] TypeScript types (JSDoc)
 * - [ ] Accessibility (ARIA labels)
 * - [ ] Mobile responsive toolbar
 */

import { useState, useRef, useEffect } from 'react';

/**
 * Rich Text Editor using Quill
 *
 * Note: In real app, install Quill:
 * npm install quill
 * import Quill from 'quill';
 * import 'quill/dist/quill.snow.css';
 */

function RichTextEditor({
  initialValue = '',
  onChange,
  placeholder = 'Start typing...',
  readOnly = false,
  maxLength = 5000,
}) {
  const [content, setContent] = useState(initialValue);
  const [charCount, setCharCount] = useState(0);

  // Refs
  const editorRef = useRef(null);
  const quillRef = useRef(null);
  const isInitializedRef = useRef(false);

  // Initialize Quill
  useEffect(() => {
    if (isInitializedRef.current) return;
    if (!editorRef.current) return;

    // TODO: In real implementation
    // const quill = new Quill(editorRef.current, {
    //   theme: 'snow',
    //   placeholder,
    //   readOnly,
    //   modules: {
    //     toolbar: [
    //       ['bold', 'italic', 'underline'],
    //       ['link', 'image'],
    //       [{ list: 'ordered' }, { list: 'bullet' }],
    //       ['clean']
    //     ]
    //   }
    // });

    // Set initial content
    // if (initialValue) {
    //   quill.clipboard.dangerouslyPasteHTML(initialValue);
    // }

    // Listen to changes
    // quill.on('text-change', () => {
    //   const html = quill.root.innerHTML;
    //   const text = quill.getText();
    //
    //   setContent(html);
    //   setCharCount(text.trim().length);
    //   onChange?.(html);
    //
    //   // Enforce max length
    //   if (text.length > maxLength) {
    //     quill.deleteText(maxLength, text.length);
    //   }
    // });

    // quillRef.current = quill;
    isInitializedRef.current = true;

    // Cleanup
    return () => {
      // quillRef.current = null;
    };
  }, []);

  // Update readOnly mode
  useEffect(() => {
    if (quillRef.current) {
      // quillRef.current.enable(!readOnly);
    }
  }, [readOnly]);

  // Export functions
  const getHTML = () => {
    return quillRef.current?.root.innerHTML || '';
  };

  const getText = () => {
    return quillRef.current?.getText() || '';
  };

  const clear = () => {
    quillRef.current?.setText('');
    setContent('');
    setCharCount(0);
  };

  const insertText = (text) => {
    const range = quillRef.current?.getSelection();
    if (range) {
      quillRef.current?.insertText(range.index, text);
    }
  };

  return (
    <div style={{ padding: '20px', maxWidth: '800px', margin: '0 auto' }}>
      <h2>Rich Text Editor</h2>

      {/* Toolbar info */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '10px',
          padding: '10px',
          backgroundColor: '#f8f9fa',
          borderRadius: '4px',
        }}
      >
        <div style={{ fontSize: '14px', color: '#666' }}>
          Characters: {charCount} / {maxLength}
        </div>
        <div style={{ display: 'flex', gap: '5px' }}>
          <button
            onClick={clear}
            style={{
              padding: '5px 10px',
              fontSize: '12px',
              backgroundColor: '#dc3545',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Clear
          </button>
          <button
            onClick={() => insertText('Hello World')}
            style={{
              padding: '5px 10px',
              fontSize: '12px',
              backgroundColor: '#28a745',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Insert Text
          </button>
        </div>
      </div>

      {/* Editor container */}
      <div
        ref={editorRef}
        style={{
          minHeight: '300px',
          backgroundColor: 'white',
          border: '1px solid #ccc',
          borderRadius: '4px',
        }}
      />

      {/* Preview */}
      <details style={{ marginTop: '20px' }}>
        <summary style={{ cursor: 'pointer', fontWeight: 'bold' }}>
          HTML Preview
        </summary>
        <pre
          style={{
            marginTop: '10px',
            padding: '15px',
            backgroundColor: '#f8f9fa',
            borderRadius: '4px',
            overflow: 'auto',
            fontSize: '12px',
          }}
        >
          {content || '<p><br></p>'}
        </pre>
      </details>

      {/* Instructions */}
      <div
        style={{
          marginTop: '20px',
          padding: '15px',
          backgroundColor: '#e7f3ff',
          border: '1px solid #007bff',
          borderRadius: '4px',
          fontSize: '14px',
        }}
      >
        <p>
          <strong>ğŸ“ Instructions:</strong>
        </p>
        <p>This is a placeholder for Quill integration.</p>
        <p>In a real implementation:</p>
        <ul>
          <li>
            Install: <code>npm install quill</code>
          </li>
          <li>Import Quill and CSS</li>
          <li>Uncomment initialization code in useEffect</li>
          <li>Handle image uploads with custom handler</li>
          <li>Implement auto-save with debouncing</li>
        </ul>
      </div>
    </div>
  );
}

// ğŸ“ Implementation Notes:
//
// Real Quill integration pattern:
//
// 1. Installation:
//    npm install quill
//    npm install @types/quill --save-dev
//
// 2. Import:
//    import Quill from 'quill';
//    import 'quill/dist/quill.snow.css';
//
// 3. Custom image handler:
//    const imageHandler = () => {
//      const input = document.createElement('input');
//      input.setAttribute('type', 'file');
//      input.setAttribute('accept', 'image/*');
//      input.click();
//
//      input.onchange = async () => {
//        const file = input.files[0];
//        const url = await uploadImage(file);
//        const range = quill.getSelection();
//        quill.insertEmbed(range.index, 'image', url);
//      };
//    };
//
// 4. Toolbar config:
//    modules: {
//      toolbar: {
//        container: [
//          [{ header: [1, 2, 3, false] }],
//          ['bold', 'italic', 'underline', 'strike'],
//          [{ color: [] }, { background: [] }],
//          [{ list: 'ordered' }, { list: 'bullet' }],
//          ['link', 'image', 'video'],
//          ['clean']
//        ],
//        handlers: {
//          image: imageHandler
//        }
//      }
//    }
//
// 5. Auto-save pattern:
//    const autoSaveRef = useRef(null);
//
//    quill.on('text-change', () => {
//      clearTimeout(autoSaveRef.current);
//      autoSaveRef.current = setTimeout(() => {
//        saveContent(quill.root.innerHTML);
//      }, 2000);
//    });
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Rich Text Editor using Quill (placeholder implementation)
 * Demonstrates proper useRef pattern for third-party library integration
 * Features: controlled value, character counter, clear/insert controls
 *
 * Note: This is a complete placeholder version showing the React + Quill integration pattern.
 * In a real project, you would:
 * 1. npm install quill
 * 2. import Quill from 'quill';
 * 3. import 'quill/dist/quill.snow.css';
 * and uncomment the Quill initialization code.
 */
function RichTextEditor({
  initialValue = '',
  onChange,
  placeholder = 'Start typing here...',
  readOnly = false,
  maxLength = 5000,
}) {
  const [content, setContent] = useState(initialValue);
  const [charCount, setCharCount] = useState(initialValue.length);

  const editorRef = useRef(null);
  const quillRef = useRef(null);
  const isInitializedRef = useRef(false);

  // Initialize Quill (placeholder - real implementation would use Quill library)
  useEffect(() => {
    if (isInitializedRef.current || !editorRef.current) return;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Real Quill initialization (commented out - enable when Quill is installed)
    /*
    const quill = new Quill(editorRef.current, {
      theme: 'snow',
      placeholder,
      readOnly,
      modules: {
        toolbar: [
          ['bold', 'italic', 'underline', 'strike'],
          ['link', 'image'],
          [{ list: 'ordered' }, { list: 'bullet' }],
          ['clean']
        ]
      }
    });

    // Set initial content safely
    if (initialValue) {
      quill.clipboard.dangerouslyPasteHTML(initialValue);
    }

    // Listen to text changes
    quill.on('text-change', () => {
      const html = quill.root.innerHTML;
      const text = quill.getText().trim();
      
      setContent(html);
      setCharCount(text.length);
      onChange?.(html);

      // Enforce max length
      if (text.length > maxLength) {
        quill.deleteText(maxLength, text.length - maxLength);
      }
    });

    quillRef.current = quill;
    */

    isInitializedRef.current = true;

    // Cleanup (would destroy Quill instance)
    return () => {
      // if (quillRef.current) {
      //   quillRef.current = null;
      // }
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  // Sync readOnly prop changes
  useEffect(() => {
    // if (quillRef.current) {
    //   quillRef.current.enable(!readOnly);
    // }
  }, [readOnly]);

  // Public API methods
  const getHTML = () => {
    // return quillRef.current?.root.innerHTML || '';
    return content;
  };

  const getText = () => {
    // return quillRef.current?.getText().trim() || '';
    return content.replace(/<[^>]+>/g, '').trim();
  };

  const clear = () => {
    // quillRef.current?.setText('');
    setContent('');
    setCharCount(0);
    onChange?.('');
  };

  const insertText = (text) => {
    // const range = quillRef.current?.getSelection();
    // if (range) {
    //   quillRef.current?.insertText(range.index, text);
    // }
    setContent((prev) => prev + text);
    setCharCount((prev) => prev + text.length);
    onChange?.(content + text);
  };

  return (
    <div style={{ padding: '20px', maxWidth: '800px', margin: '0 auto' }}>
      <h2>Rich Text Editor (Quill Placeholder)</h2>

      {/* Toolbar / Controls */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '12px',
          padding: '10px',
          backgroundColor: '#f8f9fa',
          borderRadius: '6px',
          fontSize: '14px',
        }}
      >
        <div style={{ color: charCount > maxLength ? '#dc3545' : '#666' }}>
          Characters: {charCount} / {maxLength}
        </div>

        <div style={{ display: 'flex', gap: '8px' }}>
          <button
            onClick={clear}
            style={{
              padding: '6px 14px',
              backgroundColor: '#dc3545',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Clear
          </button>
          <button
            onClick={() => insertText('Hello World! ')}
            style={{
              padding: '6px 14px',
              backgroundColor: '#28a745',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Insert "Hello World!"
          </button>
        </div>
      </div>

      {/* Editor container */}
      <div
        ref={editorRef}
        style={{
          minHeight: '320px',
          backgroundColor: 'white',
          border: '1px solid #ced4da',
          borderRadius: '6px',
          padding: '12px',
          fontFamily: 'inherit',
          fontSize: '16px',
        }}
      >
        {/* Quill would render here */}
        {/* Placeholder content when Quill is not loaded */}
        <p style={{ color: '#6c757d', margin: 0 }}>
          {content ||
            'Rich text editor would appear here when Quill is integrated...'}
        </p>
      </div>

      {/* HTML Preview */}
      <details style={{ marginTop: '20px' }}>
        <summary
          style={{ cursor: 'pointer', fontWeight: 'bold', color: '#007bff' }}
        >
          View HTML Output
        </summary>
        <pre
          style={{
            marginTop: '12px',
            padding: '16px',
            backgroundColor: '#f8f9fa',
            borderRadius: '6px',
            overflowX: 'auto',
            fontSize: '13px',
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-all',
          }}
        >
          {content || '<p><br></p>'}
        </pre>
      </details>

      {/* Integration reminder */}
      <div
        style={{
          marginTop: '24px',
          padding: '16px',
          backgroundColor: '#e7f3ff',
          border: '1px solid #b3d4fc',
          borderRadius: '6px',
          fontSize: '14px',
        }}
      >
        <strong>Next steps to make it real:</strong>
        <ul style={{ margin: '12px 0 0 20px', paddingLeft: 0 }}>
          <li>npm install quill</li>
          <li>Import Quill and CSS</li>
          <li>Uncomment Quill initialization code in useEffect</li>
          <li>Add custom image upload handler if needed</li>
          <li>Implement auto-save with debounce</li>
        </ul>
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i (vá»›i placeholder):
- Hiá»ƒn thá»‹ giao diá»‡n editor vá»›i controls Clear & Insert
- Character counter cáº­p nháº­t khi insert text
- Clear button xÃ³a ná»™i dung
- HTML preview hiá»ƒn thá»‹ ná»™i dung hiá»‡n táº¡i
- Khi tÃ­ch há»£p Quill tháº­t â†’ editor sáº½ trá»Ÿ thÃ nh rich text Ä‘áº§y Ä‘á»§ tÃ­nh nÄƒng
- Ref Ä‘Æ°á»£c sá»­ dá»¥ng Ä‘Ãºng cÃ¡ch: chá»‰ khá»Ÿi táº¡o 1 láº§n, cleanup Ä‘Ãºng, khÃ´ng double-init
*/
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: Khi nÃ o dÃ¹ng Refs vs State cho DOM

| Scenario                    | useState        | useRef          | LÃ½ do                                                  |
| --------------------------- | --------------- | --------------- | ------------------------------------------------------ |
| **Show/Hide element**       | âœ… Recommended  | âŒ Anti-pattern | State triggers re-render â†’ React updates DOM correctly |
| **Toggle CSS class**        | âœ… Recommended  | âŒ Avoid        | Conditional className based on state is declarative    |
| **Focus input**             | âŒ Cannot do    | âœ… Required     | DOM method `.focus()` cáº§n imperative access            |
| **Scroll to position**      | âŒ Cannot do    | âœ… Required     | `.scrollTo()` lÃ  DOM API                               |
| **Play/Pause video**        | âŒ Cannot do    | âœ… Required     | Media APIs cáº§n DOM reference                           |
| **Measure element size**    | âŒ Cannot do    | âœ… Required     | `.offsetWidth` etc. lÃ  DOM properties                  |
| **Animate with CSS**        | âœ… Recommended  | âŒ Avoid        | CSS transitions vá»›i state changes                      |
| **Animate with JS library** | âŒ Insufficient | âœ… Required     | Libraries like GSAP cáº§n DOM nodes                      |
| **Form validation**         | âœ… Recommended  | âš ï¸ Sometimes    | State cho messages, ref cho native validation          |
| **Third-party lib**         | âŒ Cannot do    | âœ… Required     | Charts, editors cáº§n DOM mount point                    |

### Decision Tree: Ref vs State

```
                Cáº§n thay Ä‘á»•i DOM?
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                             â”‚
       CÃ³                           KhÃ´ng
        â”‚                             â”‚
  React cÃ³ prop/state           (khÃ´ng cáº§n gÃ¬)
  há»— trá»£ khÃ´ng?
        â”‚
   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
   â”‚         â”‚
  CÃ³       KhÃ´ng
   â”‚         â”‚
useState   useRef
   â”‚         â”‚
Examples:   Examples:
- show     - focus()
- disabled - play()
- value    - scrollTo()
- checked  - getBoundingClientRect()
```

### Pattern Combinations

#### Pattern 1: State + Ref cho Controlled Focus

```jsx
// âœ… GOOD: Combine state vÃ  ref
function SearchWithAutocomplete() {
  const [query, setQuery] = useState(''); // UI state
  const [suggestions, setSuggestions] = useState([]);
  const [selectedIndex, setSelectedIndex] = useState(0);

  const inputRef = useRef(null); // DOM access
  const listRef = useRef(null);

  // State controls UI
  useEffect(() => {
    if (query.length > 2) {
      fetchSuggestions(query).then(setSuggestions);
    } else {
      setSuggestions([]);
    }
  }, [query]);

  // Ref controls focus
  const selectSuggestion = (suggestion) => {
    setQuery(suggestion);
    setSuggestions([]);
    inputRef.current?.focus(); // âœ… Ref for imperative focus
  };

  return (
    <div>
      <input
        ref={inputRef}
        value={query} // âœ… State for value
        onChange={(e) => setQuery(e.target.value)}
      />
      {suggestions.length > 0 && (
        <ul ref={listRef}>
          {suggestions.map((s, i) => (
            <li
              key={i}
              onClick={() => selectSuggestion(s)}
              style={{
                backgroundColor: i === selectedIndex ? '#e0e0e0' : 'white',
              }}
            >
              {s}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

#### Pattern 2: Callback Refs cho Dynamic Elements

```jsx
// âœ… GOOD: Callback ref khi element cÃ³ thá»ƒ thay Ä‘á»•i
function DynamicList({ items }) {
  const [selectedId, setSelectedId] = useState(null);
  const elementRefs = useRef({});

  // Callback ref pattern
  const setElementRef = (id) => (element) => {
    if (element) {
      elementRefs.current[id] = element;
    } else {
      delete elementRefs.current[id];
    }
  };

  const scrollToItem = (id) => {
    elementRefs.current[id]?.scrollIntoView({
      behavior: 'smooth',
      block: 'center',
    });
  };

  return (
    <div>
      {items.map((item) => (
        <div
          key={item.id}
          ref={setElementRef(item.id)} // âœ… Callback ref
          onClick={() => {
            setSelectedId(item.id);
            scrollToItem(item.id);
          }}
        >
          {item.name}
        </div>
      ))}
    </div>
  );
}
```

#### Pattern 3: Forward Refs cho Reusable Components

```jsx
// âœ… PATTERN: forwardRef Ä‘á»ƒ expose DOM ref
import { forwardRef, useRef } from 'react';

const FancyInput = forwardRef((props, ref) => {
  return (
    <input
      ref={ref} // âœ… Forward ref to DOM element
      {...props}
      style={{
        padding: '10px',
        border: '2px solid blue',
        borderRadius: '4px',
      }}
    />
  );
});

// Usage
function Parent() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current?.focus();
  };

  return (
    <div>
      <FancyInput
        ref={inputRef}
        placeholder='Type here'
      />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
```

**ChÃº Ã½ vá» forwardRef:**

```jsx
// âŒ KHÃ”NG thá»ƒ ref component thÆ°á»ng
function MyInput(props) {
  return <input {...props} />;
}

function Parent() {
  const ref = useRef();
  return <MyInput ref={ref} />; // âš ï¸ Error: Function components cannot be given refs
}

// âœ… PHáº¢I dÃ¹ng forwardRef
const MyInput = forwardRef((props, ref) => {
  return (
    <input
      ref={ref}
      {...props}
    />
  );
});

function Parent() {
  const ref = useRef();
  return <MyInput ref={ref} />; // âœ… Works!
}
```

### Anti-patterns to Avoid

```jsx
// âŒ ANTI-PATTERN 1: DÃ¹ng ref thay vÃ¬ state
function BadToggle() {
  const divRef = useRef(null);

  const toggle = () => {
    const current = divRef.current.style.display;
    divRef.current.style.display = current === 'none' ? 'block' : 'none';
  };

  return (
    <div>
      <button onClick={toggle}>Toggle</button>
      <div ref={divRef}>Content</div>
    </div>
  );
}

// âŒ ANTI-PATTERN 2: Access ref trong render
function BadRender() {
  const divRef = useRef(null);
  const width = divRef.current?.offsetWidth; // âš ï¸ null on first render!

  return <div ref={divRef}>Width: {width}</div>;
}

// âŒ ANTI-PATTERN 3: Modify ref.current trong render
function BadModify() {
  const countRef = useRef(0);
  countRef.current += 1; // âš ï¸ Side effect in render!

  return <div>Count: {countRef.current}</div>;
}

// âŒ ANTI-PATTERN 4: KhÃ´ng cleanup listeners
function BadListener() {
  const divRef = useRef(null);

  useEffect(() => {
    divRef.current.addEventListener('click', handler);
    // âš ï¸ No cleanup!
  }, []);

  return <div ref={divRef}>Click me</div>;
}
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Ref is null on First Render â­

```jsx
// âŒ BUG: Trying to use ref before it's set
function BuggyAutoFocus() {
  const inputRef = useRef(null);

  // âš ï¸ Cháº¡y trong render phase - ref chÆ°a Ä‘Æ°á»£c set!
  inputRef.current.focus(); // âŒ TypeError: Cannot read property 'focus' of null

  return <input ref={inputRef} />;
}
```

**ğŸ” Debug Questions:**

1. Táº¡i sao `inputRef.current` lÃ  null?
2. Khi nÃ o React set giÃ¡ trá»‹ cho ref?
3. LÃ m sao fix?

**ğŸ’¡ Giáº£i thÃ­ch:**

```jsx
// Timeline:
// 1. Component function runs (render phase)
//    â†’ inputRef.current = null
// 2. JSX created with ref={inputRef}
// 3. React commits to DOM
//    â†’ Creates <input> element
//    â†’ Sets inputRef.current = <input>
// 4. useEffect runs
//    â†’ NOW ref.current has value!

// âœ… SOLUTION: DÃ¹ng useEffect
function FixedAutoFocus() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current?.focus(); // âœ… Safe - runs after commit
  }, []);

  return <input ref={inputRef} />;
}

// âœ… ALTERNATIVE: Callback ref
function AlternativeAutoFocus() {
  const setInputRef = (element) => {
    if (element) {
      element.focus(); // âœ… Called when element mounts
    }
  };

  return <input ref={setInputRef} />;
}
```

### Bug 2: Stale Ref in Event Handler â­â­

```jsx
// âŒ BUG: Ref not updating in scroll handler
function BuggyScrollTracker() {
  const [items, setItems] = useState([1, 2, 3]);
  const listRef = useRef(null);

  useEffect(() => {
    const handleScroll = () => {
      console.log('Items count:', items.length); // âš ï¸ Always logs 3!
      // Even after adding items, shows stale count
    };

    listRef.current.addEventListener('scroll', handleScroll);

    return () => {
      listRef.current?.removeEventListener('scroll', handleScroll);
    };
  }, []); // âš ï¸ Missing dependency: items

  const addItem = () => {
    setItems([...items, items.length + 1]);
  };

  return (
    <div>
      <button onClick={addItem}>Add Item</button>
      <div
        ref={listRef}
        style={{ height: '200px', overflow: 'auto' }}
      >
        {items.map((i) => (
          <div key={i}>Item {i}</div>
        ))}
      </div>
    </div>
  );
}
```

**ğŸ” Debug Questions:**

1. Táº¡i sao `items.length` luÃ´n lÃ  3?
2. ÄÃ¢u lÃ  váº¥n Ä‘á» vá»›i dependencies?
3. CÃ¡ch fix mÃ  khÃ´ng re-attach listener má»—i láº§n items thay Ä‘á»•i?

**ğŸ’¡ Giáº£i thÃ­ch:**

```jsx
// âŒ Váº¤N Äá»€: Closure captures initial items value
// useEffect runs once, handleScroll captures items = [1,2,3]
// Even when items changes, old handler still has old value

// âœ… SOLUTION 1: Add items to dependencies (not ideal)
useEffect(() => {
  const handleScroll = () => {
    console.log('Items:', items.length); // âœ… Updated
  };

  listRef.current.addEventListener('scroll', handleScroll);

  return () => {
    listRef.current?.removeEventListener('scroll', handleScroll);
  };
}, [items]); // âš ï¸ Re-attaches listener every time items change!

// âœ… SOLUTION 2: Use ref to store latest items
function FixedScrollTracker() {
  const [items, setItems] = useState([1, 2, 3]);
  const listRef = useRef(null);
  const itemsRef = useRef(items);

  // Keep ref in sync
  useEffect(() => {
    itemsRef.current = items;
  }, [items]);

  useEffect(() => {
    const handleScroll = () => {
      console.log('Items:', itemsRef.current.length); // âœ… Always current!
    };

    listRef.current.addEventListener('scroll', handleScroll);

    return () => {
      listRef.current?.removeEventListener('scroll', handleScroll);
    };
  }, []); // âœ… Only attach once, but handler has latest value

  const addItem = () => {
    setItems([...items, items.length + 1]);
  };

  return (
    <div>
      <button onClick={addItem}>Add Item</button>
      <div
        ref={listRef}
        style={{ height: '200px', overflow: 'auto' }}
      >
        {items.map((i) => (
          <div
            key={i}
            style={{ height: '50px' }}
          >
            Item {i}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### Bug 3: Memory Leak from Intersection Observer â­â­â­

```jsx
// âŒ BUG: Observer khÃ´ng Ä‘Æ°á»£c cleanup
function BuggyLazyImage({ src }) {
  const imgRef = useRef(null);
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          setIsLoaded(true);
          // âš ï¸ KhÃ´ng disconnect observer!
        }
      });
    });

    if (imgRef.current) {
      observer.observe(imgRef.current);
    }

    // âš ï¸ No cleanup!
  }, []);

  return (
    <img
      ref={imgRef}
      src={isLoaded ? src : 'placeholder.jpg'}
      alt='Lazy loaded'
    />
  );
}
```

**ğŸ” Debug Questions:**

1. Äiá»u gÃ¬ xáº£y ra khi component unmount?
2. Observer cÃ³ bá»‹ cleanup khÃ´ng?
3. LÃ m sao test memory leak?

**ğŸ’¡ Giáº£i thÃ­ch:**

```jsx
// âŒ Váº¤N Äá»€:
// 1. Observer Ä‘Æ°á»£c táº¡o vÃ  observe element
// 2. Component unmount
// 3. Observer váº«n tá»“n táº¡i â†’ references old DOM node
// 4. Memory leak!

// âœ… SOLUTION: Proper cleanup
function FixedLazyImage({ src }) {
  const imgRef = useRef(null);
  const observerRef = useRef(null); // Store observer in ref
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    // Create observer
    observerRef.current = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting && !isLoaded) {
          setIsLoaded(true);

          // âœ… Disconnect after loading (optional optimization)
          if (observerRef.current && imgRef.current) {
            observerRef.current.unobserve(imgRef.current);
          }
        }
      });
    });

    // Start observing
    if (imgRef.current) {
      observerRef.current.observe(imgRef.current);
    }

    // âœ… Cleanup
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect(); // Disconnect all observations
        observerRef.current = null;
      }
    };
  }, []); // Empty deps - setup once

  return (
    <img
      ref={imgRef}
      src={
        isLoaded
          ? src
          : 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"/>'
      }
      alt='Lazy loaded'
      style={{
        minHeight: '200px',
        backgroundColor: '#f0f0f0',
      }}
    />
  );
}

// ğŸ” Test for memory leaks:
function TestHarness() {
  const [show, setShow] = useState(true);
  const [count, setCount] = useState(0);

  return (
    <div>
      <button
        onClick={() => {
          setShow(false);
          setTimeout(() => setShow(true), 100);
          setCount((c) => c + 1);
        }}
      >
        Remount ({count} times)
      </button>

      <p>Open DevTools â†’ Memory â†’ Take snapshots</p>
      <p>Click button 10 times, take snapshot</p>
      <p>Check for detached DOM nodes</p>

      {show && <FixedLazyImage src='https://via.placeholder.com/400' />}
    </div>
  );
}
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u cÃ¡c cÃ¢u báº¡n cÃ³ thá»ƒ tráº£ lá»i tá»± tin:

- [ ] LÃ m sao attach ref vÃ o DOM element?
- [ ] Khi nÃ o React set giÃ¡ trá»‹ cho ref.current?
- [ ] Táº¡i sao khÃ´ng thá»ƒ access ref.current trong render phase?
- [ ] forwardRef lÃ  gÃ¬ vÃ  khi nÃ o cáº§n dÃ¹ng?
- [ ] Callback ref pattern hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o?
- [ ] Sá»± khÃ¡c biá»‡t giá»¯a ref object vÃ  callback ref?
- [ ] LÃ m sao cleanup third-party library instances?
- [ ] Intersection Observer cáº§n cleanup nhÆ° tháº¿ nÃ o?
- [ ] Khi nÃ o dÃ¹ng ref vs state Ä‘á»ƒ control DOM?
- [ ] LÃ m sao handle conditional refs (element cÃ³ thá»ƒ khÃ´ng tá»“n táº¡i)?

### Code Review Checklist

Khi review code cÃ³ DOM refs, check:

#### âœ… Correct Usage:

- [ ] Refs only accessed in useEffect/event handlers (not render)
- [ ] Null checks before using ref.current
- [ ] forwardRef used when exposing refs from components
- [ ] Refs used for imperative operations only
- [ ] State used for declarative UI control

#### âœ… Cleanup:

- [ ] Event listeners removed on unmount
- [ ] Intersection/Mutation/Resize Observers disconnected
- [ ] Third-party library instances destroyed
- [ ] Refs set to null in cleanup (if needed)

#### âœ… Edge Cases:

- [ ] Conditional rendering handled (element may not exist)
- [ ] Multiple refs managed correctly (arrays/maps)
- [ ] Ref timing considered (useEffect vs useLayoutEffect)
- [ ] Browser API availability checked (if needed)

#### âœ… Performance:

- [ ] No unnecessary re-attachments of listeners
- [ ] Latest values accessed via refs in long-lived closures
- [ ] Heavy operations debounced/throttled
- [ ] Memory leaks prevented

#### âŒ Common Mistakes:

- [ ] KhÃ´ng access ref trong render
- [ ] KhÃ´ng skip null checks
- [ ] KhÃ´ng dÃ¹ng ref thay vÃ¬ state cho UI
- [ ] KhÃ´ng cleanup observers/listeners

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

#### Exercise: Custom useClickOutside Hook

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Táº¡o reusable hook cho click outside detection
 *
 * Requirements:
 * 1. Hook nháº­n ref vÃ  callback
 * 2. Call callback khi click outside element
 * 3. Proper cleanup
 * 4. Handle multiple refs (optional)
 *
 * API:
 * useClickOutside(ref, () => console.log('Clicked outside'));
 */

function useClickOutside(ref, handler) {
  // TODO: Implement
  // Hints:
  // - useEffect Ä‘á»ƒ add document listener
  // - Check ref.current.contains(event.target)
  // - Call handler if outside
  // - Cleanup listener
  // - Consider using useCallback for handler?
}

// Usage example:
function DropdownWithHook() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  useClickOutside(dropdownRef, () => {
    setIsOpen(false);
  });

  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(true)}>Open</button>
      {isOpen && <div>Dropdown content</div>}
    </div>
  );
}
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook to detect clicks outside a specified element
 * Useful for closing modals, dropdowns, popovers, etc.
 *
 * @param {React.RefObject} ref - React ref attached to the target element
 * @param {Function} handler - Callback function to call when click is outside
 * @param {string} [mouseEvent='mousedown'] - Event type to listen for
 */
function useClickOutside(ref, handler, mouseEvent = 'mousedown') {
  useEffect(() => {
    const listener = (event) => {
      // Do nothing if clicking ref's element or children
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }

      handler(event);
    };

    document.addEventListener(mouseEvent, listener);

    // Optional: also listen to touch events for mobile
    document.addEventListener('touchstart', listener);

    return () => {
      document.removeEventListener(mouseEvent, listener);
      document.removeEventListener('touchstart', listener);
    };
  }, [ref, handler, mouseEvent]); // Re-run if any of these change
}

/**
 * Example usage: Dropdown that closes when clicking outside
 */
function DropdownWithHook() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  useClickOutside(dropdownRef, () => {
    setIsOpen(false);
  });

  return (
    <div style={{ padding: '20px' }}>
      <h2>Dropdown with useClickOutside Hook</h2>

      <div
        ref={dropdownRef}
        style={{ position: 'relative', display: 'inline-block' }}
      >
        <button
          onClick={() => setIsOpen(!isOpen)}
          style={{
            padding: '10px 20px',
            fontSize: '16px',
            backgroundColor: '#007bff',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          {isOpen ? 'Close Dropdown' : 'Open Dropdown'}
        </button>

        {isOpen && (
          <div
            style={{
              position: 'absolute',
              top: '100%',
              left: 0,
              marginTop: '8px',
              padding: '16px',
              backgroundColor: 'white',
              border: '1px solid #ccc',
              borderRadius: '6px',
              boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
              minWidth: '220px',
              zIndex: 1000,
            }}
          >
            <p style={{ margin: '0 0 12px 0' }}>Dropdown content</p>
            <button style={{ marginRight: '8px' }}>Option 1</button>
            <button>Option 2</button>
          </div>
        )}
      </div>

      <div
        style={{
          marginTop: '40px',
          padding: '20px',
          backgroundColor: '#f8f9fa',
          borderRadius: '6px',
        }}
      >
        <p>Click anywhere outside the dropdown to close it automatically.</p>
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i:
- Click nÃºt â†’ dropdown má»Ÿ/Ä‘Ã³ng (toggle)
- Click bÃªn trong dropdown (bao gá»“m cÃ¡c nÃºt Option) â†’ khÃ´ng Ä‘Ã³ng
- Click báº¥t ká»³ Ä‘Ã¢u bÃªn ngoÃ i vÃ¹ng dropdown â†’ tá»± Ä‘á»™ng Ä‘Ã³ng
- Hook cleanup Ä‘Ãºng cÃ¡ch khi component unmount
- Hoáº¡t Ä‘á»™ng tá»‘t trÃªn cáº£ desktop (mousedown) vÃ  mobile (touchstart)
*/
```

</details>

### NÃ¢ng cao (60 phÃºt)

#### Exercise: Custom useElementSize Hook

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Track element size vá»›i ResizeObserver
 *
 * Scenario:
 * Build responsive component cáº§n biáº¿t kÃ­ch thÆ°á»›c thá»±c táº¿ cá»§a element.
 *
 * Requirements:
 * 1. Return ref vÃ  size { width, height }
 * 2. Update size khi element resize
 * 3. Use ResizeObserver API
 * 4. Debounce updates (optional)
 * 5. Cleanup properly
 *
 * API:
 * const [ref, size] = useElementSize();
 * <div ref={ref}>Size: {size.width}x{size.height}</div>
 */

function useElementSize() {
  const [size, setSize] = useState({ width: 0, height: 0 });
  const ref = useRef(null);
  const observerRef = useRef(null);

  useEffect(() => {
    if (!ref.current) return;

    // TODO: Implement ResizeObserver
    // observerRef.current = new ResizeObserver((entries) => {
    //   const entry = entries[0];
    //   if (entry) {
    //     setSize({
    //       width: entry.contentRect.width,
    //       height: entry.contentRect.height
    //     });
    //   }
    // });

    // observerRef.current.observe(ref.current);

    // return () => {
    //   if (observerRef.current) {
    //     observerRef.current.disconnect();
    //   }
    // };
  }, []);

  return [ref, size];
}

// Usage:
function ResponsiveCard() {
  const [ref, size] = useElementSize();

  return (
    <div
      ref={ref}
      style={{ resize: 'both', overflow: 'auto', border: '1px solid' }}
    >
      <p>Width: {size.width}px</p>
      <p>Height: {size.height}px</p>
      <p>Try resizing this box!</p>
    </div>
  );
}
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * Custom hook to track the size of a DOM element using ResizeObserver
 * Returns a ref to attach to the element and the current dimensions
 */
function useElementSize() {
  const [size, setSize] = useState({ width: 0, height: 0 });
  const ref = useRef(null);
  const observerRef = useRef(null);

  useEffect(() => {
    if (!ref.current) return;

    // Create ResizeObserver only once
    observerRef.current = new ResizeObserver((entries) => {
      const entry = entries[0];
      if (entry) {
        const { width, height } = entry.contentRect;
        setSize({ width, height });
      }
    });

    // Start observing the element
    observerRef.current.observe(ref.current);

    // Initial size (in case element already has size before observer)
    const { width, height } = ref.current.getBoundingClientRect();
    setSize({ width, height });

    // Cleanup
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
        observerRef.current = null;
      }
    };
  }, []); // Only run once on mount

  return [ref, size];
}

/**
 * Demo component showing how to use the hook
 */
function ResponsiveCard() {
  const [ref, size] = useElementSize();

  return (
    <div style={{ padding: '20px' }}>
      <h2>Element Size Tracker (Resize Me!)</h2>

      <div
        ref={ref}
        style={{
          resize: 'both',
          overflow: 'auto',
          width: '400px',
          height: '300px',
          minWidth: '200px',
          minHeight: '150px',
          border: '2px dashed #007bff',
          borderRadius: '8px',
          padding: '20px',
          backgroundColor: '#f8f9fa',
          margin: '20px auto',
          cursor: 'se-resize',
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
        }}
      >
        <h3 style={{ marginTop: 0 }}>Resizable Box</h3>
        <p>Current size:</p>
        <div
          style={{
            fontSize: '24px',
            fontWeight: 'bold',
            color: '#007bff',
            margin: '20px 0',
          }}
        >
          {Math.round(size.width)} Ã— {Math.round(size.height)} px
        </div>
        <p style={{ color: '#666', fontSize: '14px' }}>
          Drag the bottom-right corner to resize this box and watch the
          dimensions update in real-time.
        </p>
      </div>

      <div
        style={{
          padding: '16px',
          backgroundColor: '#e9f5ff',
          borderRadius: '6px',
          maxWidth: '500px',
          margin: '0 auto',
        }}
      >
        <strong>Features of useElementSize hook:</strong>
        <ul style={{ margin: '12px 0 0 20px' }}>
          <li>Uses native ResizeObserver API</li>
          <li>Returns real pixel dimensions (contentRect)</li>
          <li>Proper cleanup on unmount</li>
          <li>Initial size captured immediately</li>
          <li>Only one observer instance</li>
        </ul>
      </div>
    </div>
  );
}

/*
Káº¿t quáº£ mong Ä‘á»£i:
- Khi component mount â†’ hiá»ƒn thá»‹ kÃ­ch thÆ°á»›c ban Ä‘áº§u cá»§a box (~400Ã—300)
- Khi kÃ©o resize box â†’ kÃ­ch thÆ°á»›c cáº­p nháº­t realtime (width Ã— height)
- GiÃ¡ trá»‹ thay Ä‘á»•i mÆ°á»£t mÃ  má»—i khi element resize
- Khi component unmount â†’ observer Ä‘Æ°á»£c disconnect, khÃ´ng memory leak
- Hoáº¡t Ä‘á»™ng tá»‘t vá»›i báº¥t ká»³ element nÃ o cÃ³ ref (div, img, canvas, etc.)
*/
```

</details>

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - Manipulating the DOM with Refs:**
   https://react.dev/learn/manipulating-the-dom-with-refs

2. **React Docs - forwardRef:**
   https://react.dev/reference/react/forwardRef

3. **MDN - Intersection Observer API:**
   https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API

### Äá»c thÃªm

1. **When to use refs vs state:**
   https://blog.logrocket.com/complete-guide-react-refs/

2. **ResizeObserver API:**
   https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver

3. **React Hook Form (uses refs extensively):**
   https://react-hook-form.com/

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (cáº§n biáº¿t tá»« trÆ°á»›c)

- **NgÃ y 21:** useRef cho mutable values (timer IDs, previous values)
- **NgÃ y 16-20:** useEffect vÃ  cleanup patterns
- **NgÃ y 11-14:** useState vs useRef decision making

### HÆ°á»›ng tá»›i (sáº½ dÃ¹ng á»Ÿ)

- **NgÃ y 23:** useLayoutEffect - khi cáº§n measure/update DOM synchronously
- **NgÃ y 24:** Custom hooks - extract ref logic into reusable hooks
- **NgÃ y 25:** Project - combine all hooks Ä‘á»ƒ build dashboard
- **NgÃ y 36-38:** Forms - refs cho uncontrolled components

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

#### 1. Accessibility vá»›i Refs

```jsx
// âœ… GOOD: Use refs Ä‘á»ƒ improve accessibility
function AccessibleModal({ isOpen, onClose, children }) {
  const modalRef = useRef(null);
  const previousFocusRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      // Save currently focused element
      previousFocusRef.current = document.activeElement;

      // Focus modal
      modalRef.current?.focus();

      // Trap focus trong modal
      const handleTab = (e) => {
        if (e.key === 'Tab') {
          const focusable = modalRef.current?.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
          );
          const first = focusable[0];
          const last = focusable[focusable.length - 1];

          if (e.shiftKey && document.activeElement === first) {
            e.preventDefault();
            last.focus();
          } else if (!e.shiftKey && document.activeElement === last) {
            e.preventDefault();
            first.focus();
          }
        }
      };

      document.addEventListener('keydown', handleTab);

      return () => {
        document.removeEventListener('keydown', handleTab);
        // Restore focus
        previousFocusRef.current?.focus();
      };
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <div
      ref={modalRef}
      tabIndex={-1}
      role='dialog'
      aria-modal='true'
      style={{
        position: 'fixed',
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
        background: 'white',
        padding: '20px',
        zIndex: 1000,
      }}
    >
      {children}
      <button onClick={onClose}>Close</button>
    </div>
  );
}
```

#### 2. Performance Monitoring vá»›i Refs

```jsx
// âœ… GOOD: Track component performance
function usePerformanceMonitor(componentName) {
  const renderCountRef = useRef(0);
  const renderTimesRef = useRef([]);
  const startTimeRef = useRef(null);

  // Track renders
  renderCountRef.current += 1;

  useEffect(() => {
    // Measure render time
    const renderTime =
      performance.now() - (startTimeRef.current || performance.now());
    renderTimesRef.current.push(renderTime);

    // Log slow renders
    if (renderTime > 16) {
      // 60fps threshold
      console.warn(
        `Slow render in ${componentName}:`,
        renderTime.toFixed(2),
        'ms',
      );
    }

    // Report metrics periodically
    if (renderCountRef.current % 10 === 0) {
      const avg =
        renderTimesRef.current.reduce((a, b) => a + b, 0) /
        renderTimesRef.current.length;
      console.log(`${componentName} avg render time:`, avg.toFixed(2), 'ms');
    }
  });

  // Start timing next render
  startTimeRef.current = performance.now();

  return {
    renderCount: renderCountRef.current,
    avgRenderTime:
      renderTimesRef.current.reduce((a, b) => a + b, 0) /
      renderTimesRef.current.length,
  };
}
```

#### 3. Canvas Animation vá»›i Refs

```jsx
// âœ… GOOD: Animated canvas
function AnimatedCanvas() {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  const frameCountRef = useRef(0);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    let x = 0;

    const animate = () => {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw
      ctx.fillStyle = 'blue';
      ctx.fillRect(x, 50, 50, 50);

      // Update
      x = (x + 2) % canvas.width;
      frameCountRef.current += 1;

      // Continue animation
      animationRef.current = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      console.log('Total frames:', frameCountRef.current);
    };
  }, []);

  return (
    <canvas
      ref={canvasRef}
      width={400}
      height={200}
    />
  );
}
```

### CÃ¢u Há»i Phá»ng Váº¥n

#### Junior Level:

**Q1: "LÃ m sao focus má»™t input khi component mount?"**

Expected answer:

```jsx
const inputRef = useRef(null);

useEffect(() => {
  inputRef.current?.focus();
}, []);

return <input ref={inputRef} />;
```

**Q2: "Sá»± khÃ¡c biá»‡t giá»¯a ref vÃ  state?"**

Expected answer:

- State: Triggers re-render, cho UI data
- Ref: KhÃ´ng trigger re-render, cho DOM access vÃ  mutable values
- State: Async updates, Ref: Sync
- DÃ¹ng state cho UI, ref cho imperative operations

#### Mid Level:

**Q3: "Implement click outside Ä‘á»ƒ close dropdown."**

Expected answer:

```jsx
const dropdownRef = useRef(null);

useEffect(() => {
  const handleClick = (e) => {
    if (dropdownRef.current && !dropdownRef.current.contains(e.target)) {
      setIsOpen(false);
    }
  };

  document.addEventListener('mousedown', handleClick);
  return () => document.removeEventListener('mousedown', handleClick);
}, []);
```

**Q4: "Táº¡i sao khÃ´ng nÃªn access ref.current trong render?"**

Expected answer:

- Render phase: ref.current chÆ°a Ä‘Æ°á»£c set (váº«n null)
- React sets refs trong commit phase (sau render)
- Access trong render â†’ timing issues, potential null errors
- ÄÃºng: Access trong useEffect hoáº·c event handlers

#### Senior Level:

**Q5: "Design má»™t system Ä‘á»ƒ manage focus trong complex form vá»›i validation."**

Expected answer:

```jsx
function useFormFocus(fields) {
  const refs = useRef({});
  const [errors, setErrors] = useState({});

  const register = (name) => (element) => {
    refs.current[name] = element;
  };

  const focusError = () => {
    const firstError = Object.keys(errors)[0];
    if (firstError && refs.current[firstError]) {
      refs.current[firstError].focus();
      refs.current[firstError].scrollIntoView({
        behavior: 'smooth',
        block: 'center',
      });
    }
  };

  const focusNext = (currentName) => {
    const fieldNames = Object.keys(fields);
    const currentIndex = fieldNames.indexOf(currentName);
    const nextField = fieldNames[currentIndex + 1];

    if (nextField && refs.current[nextField]) {
      refs.current[nextField].focus();
    }
  };

  return { register, focusError, focusNext };
}
```

**Q6: "Explain memory leaks vá»›i DOM refs vÃ  cÃ¡ch prevent."**

Expected answer:

- Common causes:
  - Event listeners khÃ´ng removed
  - Observers (Intersection, Mutation, Resize) khÃ´ng disconnected
  - Refs trá» Ä‘áº¿n large DOM trees khÃ´ng cleared
  - Circular references vá»›i closures
- Prevention:
  - Always cleanup trong useEffect return
  - Set refs to null when no longer needed
  - Use WeakMap/WeakRef cho caching
  - Disconnect observers properly
  - Remove event listeners

### War Stories

#### Story 1: The Autofocus Bug

Production bug: Modal khÃ´ng auto-focus khi má»Ÿ, phÃ¡ accessibility.

```jsx
// âŒ BUG in production:
function Modal({ isOpen }) {
  const firstInputRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      firstInputRef.current?.focus(); // âš ï¸ Doesn't work!
    }
  }, [isOpen]);

  return isOpen ? (
    <div>
      <input ref={firstInputRef} />
    </div>
  ) : null;
}

// Váº¤N Äá»€: Khi isOpen thay Ä‘á»•i trueâ†’true, effect khÃ´ng cháº¡y láº¡i!

// âœ… FIX:
function Modal({ isOpen }) {
  const firstInputRef = useRef(null);

  useEffect(() => {
    if (isOpen && firstInputRef.current) {
      // Delay Ä‘á»ƒ Ä‘áº£m báº£o DOM ready
      setTimeout(() => {
        firstInputRef.current?.focus();
      }, 0);
    }
  }, [isOpen]);

  return isOpen ? (
    <div>
      <input ref={firstInputRef} />
    </div>
  ) : null;
}
```

**Lesson learned:**

- Timing issues vá»›i refs phá»©c táº¡p hÆ¡n mong Ä‘á»£i
- Test accessibility thoroughly
- setTimeout(0) Ä‘Ã´i khi cáº§n thiáº¿t cho DOM operations

#### Story 2: The Infinite Scroll Performance Issue

Infinite scroll component lÃ m browser freeze khi scroll nhanh.

```jsx
// âŒ PERFORMANCE BUG:
function InfiniteList() {
  const observerRef = useRef(null);

  useEffect(() => {
    observerRef.current = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            loadMore(); // âš ï¸ No throttling!
          }
        });
      },
      { threshold: 0.1 },
    ); // âš ï¸ Too sensitive!
  }, []);
}

// âœ… FIX: Throttle + better threshold
function InfiniteList() {
  const observerRef = useRef(null);
  const loadingRef = useRef(false);
  const lastLoadRef = useRef(0);

  const loadMore = async () => {
    const now = Date.now();
    if (loadingRef.current || now - lastLoadRef.current < 1000) {
      return; // Throttle: min 1s between loads
    }

    loadingRef.current = true;
    lastLoadRef.current = now;

    await fetchData();

    loadingRef.current = false;
  };

  useEffect(() => {
    observerRef.current = new IntersectionObserver(
      (entries) => {
        const [entry] = entries;
        if (entry?.isIntersecting) {
          loadMore();
        }
      },
      {
        threshold: 0.5, // Less sensitive
        rootMargin: '100px', // Pre-load
      },
    );
  }, []);
}
```

**Lesson learned:**

- Always throttle/debounce scroll/resize handlers
- Refs perfect cho tracking throttle state
- Test vá»›i slow devices

---

## ğŸ¯ PREVIEW NGÃ€Y MAI

**NgÃ y 23: useLayoutEffect - Synchronous DOM Updates** âš™ï¸

NgÃ y mai chÃºng ta sáº½ há»c hook Ä‘áº·c biá»‡t: **useLayoutEffect**.

Báº¡n sáº½ há»c:

- Sá»± khÃ¡c biá»‡t useEffect vs useLayoutEffect
- Khi nÃ o PHáº¢I dÃ¹ng useLayoutEffect
- DOM measurements before paint
- Preventing visual flickering
- Tooltip positioning
- Animation setup

Chuáº©n bá»‹ mental model:

```
useEffect:         [Render] â†’ [Paint] â†’ [Effect]
useLayoutEffect:   [Render] â†’ [Effect] â†’ [Paint]
                                â†‘
                    Sync - blocks painting!
```

See you tomorrow! ğŸš€

---

## âœ… CHECKLIST HOÃ€N THÃ€NH

TrÆ°á»›c khi káº¿t thÃºc ngÃ y há»c, check:

- [ ] Hiá»ƒu sÃ¢u useRef cho DOM access
- [ ] LÃ m Ä‘á»§ 5 exercises
- [ ] Äá»c React docs vá» refs
- [ ] LÃ m bÃ i táº­p vá» nhÃ 
- [ ] Review debug lab
- [ ] Thá»±c hÃ nh vá»›i third-party libraries
- [ ] Chuáº©n bá»‹ cho useLayoutEffect

**ğŸ‰ Congratulations! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 22!**

Báº¡n Ä‘Ã£ há»c Ä‘Æ°á»£c:
âœ… DOM refs fundamentals
âœ… Focus & scroll control
âœ… Video/audio manipulation
âœ… Intersection Observer
âœ… Third-party library integration
âœ… Click outside detection
âœ… Memory leak prevention

Tomorrow: useLayoutEffect cho synchronous DOM operations! ğŸ’ª
