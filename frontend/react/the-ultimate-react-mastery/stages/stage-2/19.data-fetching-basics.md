# ğŸ“… NGÃ€Y 19: Data Fetching - Basics

## ğŸ“ Phase 2, Tuáº§n 4, NgÃ y 19 cá»§a 45

## â±ï¸ Thá»i lÆ°á»£ng: 3-4 giá»

---

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

- [ ] Hiá»ƒu cÃ¡ch sá»­ dá»¥ng **fetch API** trong useEffect
- [ ] Implement **Loading/Error/Success states** pattern chuáº©n
- [ ] Xá»­ lÃ½ **async/await** trong effects má»™t cÃ¡ch an toÃ n
- [ ] Biáº¿t cÃ¡ch **retry** failed requests
- [ ] Apply **error handling** best practices cho data fetching

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

TrÆ°á»›c khi báº¯t Ä‘áº§u, hÃ£y tráº£ lá»i 3 cÃ¢u há»i sau:

1. **CÃ¢u 1:** Cleanup function cháº¡y khi nÃ o?
   - _ÄÃ¡p Ã¡n: TrÆ°á»›c effect re-run vÃ  khi unmount (Ä‘Ã£ há»c NgÃ y 18)_

2. **CÃ¢u 2:** Náº¿u component unmount trong khi fetch Ä‘ang pending, Ä‘iá»u gÃ¬ xáº£y ra?
   - _ÄÃ¡p Ã¡n: setState sau unmount â†’ Warning! (Cáº§n cleanup - NgÃ y 18)_

3. **CÃ¢u 3:** fetch API return gÃ¬? Promise hay data trá»±c tiáº¿p?
   - _ÄÃ¡p Ã¡n: Promise - cáº§n .then() hoáº·c await_

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

Háº§u háº¿t React apps cáº§n fetch data tá»« API:

```jsx
// âŒ NAIVE ATTEMPT: Fetch trong render
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);

  // âŒ WRONG: Fetch trong render function
  fetch(`/api/users/${userId}`)
    .then((res) => res.json())
    .then((data) => setUser(data));

  return <div>{user?.name}</div>;
}

// PROBLEMS:
// 1. Fetch cháº¡y Má»–I render â†’ Infinite loop! (setState â†’ re-render â†’ fetch â†’ setState...)
// 2. KhÃ´ng cÃ³ loading state â†’ UI flash
// 3. KhÃ´ng handle errors
// 4. KhÃ´ng cleanup khi unmount
```

**Váº¥n Ä‘á»:**

- Fetch lÃ  **side effect** â†’ KhÃ´ng nÃªn trong render
- Cáº§n control **KHI NÃ€O** fetch
- Cáº§n handle **3 states**: Loading, Success, Error
- Cáº§n cleanup Ä‘á»ƒ avoid memory leaks

---

### 1.2 Giáº£i PhÃ¡p: fetch trong useEffect

**Pattern chuáº©n cho data fetching:**

```jsx
function UserProfile({ userId }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // Reset states khi userId thay Ä‘á»•i
    setLoading(true);
    setError(null);

    fetch(`/api/users/${userId}`)
      .then((response) => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then((data) => {
        setData(data);
        setLoading(false);
      })
      .catch((error) => {
        setError(error.message);
        setLoading(false);
      });
  }, [userId]); // â† Refetch khi userId thay Ä‘á»•i

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  return <div>{data?.name}</div>;
}
```

**Táº¡i sao pattern nÃ y tá»‘t:**

1. âœ… **useEffect**: Fetch lÃ  side effect, Ä‘Ãºng chá»—
2. âœ… **Dependencies [userId]**: Refetch khi cáº§n
3. âœ… **3 states**: Loading/Error/Success
4. âœ… **Error handling**: Catch network & HTTP errors
5. âœ… **Conditional render**: UI phÃ¹ há»£p vá»›i state

---

### 1.3 Mental Model: Data Fetching Lifecycle

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              DATA FETCHING LIFECYCLE                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

INITIAL MOUNT:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Component mounts
   State: { loading: true, data: null, error: null }
   UI: "Loading..."
   â†“
2. useEffect runs
   â†“
3. fetch() initiated
   (Network request in flight...)
   â†“
4. Response received (2 paths)

   â”Œâ”€ SUCCESS PATH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ response.ok = true             â”‚
   â”‚ â†“                              â”‚
   â”‚ Parse JSON                     â”‚
   â”‚ â†“                              â”‚
   â”‚ setData(data)                  â”‚
   â”‚ setLoading(false)              â”‚
   â”‚ State: { loading: false,       â”‚
   â”‚         data: {...},           â”‚
   â”‚         error: null }          â”‚
   â”‚ UI: Display data âœ…            â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

   â”Œâ”€ ERROR PATH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Network error OR               â”‚
   â”‚ response.ok = false            â”‚
   â”‚ â†“                              â”‚
   â”‚ throw Error                    â”‚
   â”‚ â†“                              â”‚
   â”‚ .catch(error)                  â”‚
   â”‚ setError(error.message)        â”‚
   â”‚ setLoading(false)              â”‚
   â”‚ State: { loading: false,       â”‚
   â”‚         data: null,            â”‚
   â”‚         error: "..." }         â”‚
   â”‚ UI: Error message âŒ           â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DEPENDENCY CHANGE (e.g., userId: 1 â†’ 2):
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. userId changes
   â†“
2. useEffect re-runs
   â†“
3. Reset states:
   setLoading(true)
   setError(null)
   State: { loading: true, data: <old data>, error: null }
   UI: "Loading..." (old data cleared optionally)
   â†“
4. New fetch with new userId
   â†“
5. Success/Error paths (same as above)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STATE TRANSITIONS:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

IDLE â†’ LOADING â†’ SUCCESS
IDLE â†’ LOADING â†’ ERROR â†’ LOADING (retry) â†’ SUCCESS
SUCCESS â†’ LOADING (refetch) â†’ SUCCESS
```

**Analogy dá»… hiá»ƒu:**

> Data fetching nhÆ° Ä‘áº·t hÃ ng online:
>
> 1. **Loading**: "Äang xá»­ lÃ½ Ä‘Æ¡n hÃ ng..."
> 2. **Success**: "ÄÆ¡n hÃ ng Ä‘Ã£ giao!" â†’ Hiá»ƒn thá»‹ sáº£n pháº©m
> 3. **Error**: "Giao hÃ ng tháº¥t báº¡i!" â†’ Hiá»ƒn thá»‹ lá»—i
>
> Dependencies nhÆ° Ä‘á»‹a chá»‰ giao hÃ ng:
>
> - Äá»‹a chá»‰ thay Ä‘á»•i â†’ Äáº·t hÃ ng má»›i Ä‘áº¿n Ä‘á»‹a chá»‰ má»›i

---

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

#### âŒ Hiá»ƒu láº§m #1: "fetch return data trá»±c tiáº¿p"

```jsx
// âŒ WRONG
useEffect(() => {
  const data = fetch("/api/users"); // data is a Promise, NOT the actual data!
  setData(data); // Setting Promise object!
}, []);

// âœ… CORRECT
useEffect(() => {
  fetch("/api/users")
    .then((res) => res.json()) // Parse response
    .then((data) => setData(data)); // Then set data
}, []);
```

**âœ… ÄÃºng:** fetch return **Promise**, cáº§n `.then()` hoáº·c `await` Ä‘á»ƒ láº¥y data.

---

#### âŒ Hiá»ƒu láº§m #2: "response.ok luÃ´n true náº¿u fetch thÃ nh cÃ´ng"

```jsx
// âŒ WRONG: KhÃ´ng check response.ok
useEffect(() => {
  fetch("/api/users")
    .then((res) => res.json()) // 404/500 váº«n parse JSON!
    .then(setData)
    .catch(setError); // Only catches network errors
}, []);

// âœ… CORRECT: Check response.ok
useEffect(() => {
  fetch("/api/users")
    .then((res) => {
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      return res.json();
    })
    .then(setData)
    .catch(setError); // Catches network AND HTTP errors
}, []);
```

**âœ… ÄÃºng:** fetch chá»‰ reject vá»›i **network errors**. HTTP errors (404, 500) cáº§n check `response.ok`.

---

#### âŒ Hiá»ƒu láº§m #3: "async function trong useEffect trá»±c tiáº¿p OK"

```jsx
// âŒ WRONG: async useEffect
useEffect(async () => {
  const res = await fetch("/api/users");
  const data = await res.json();
  setData(data);
}, []); // Error: useEffect callback cannot be async!

// âœ… CORRECT: async function BÃŠN TRONG effect
useEffect(() => {
  async function fetchData() {
    const res = await fetch("/api/users");
    const data = await res.json();
    setData(data);
  }
  fetchData();
}, []);
```

**âœ… ÄÃºng:** useEffect callback KHÃ”NG Ä‘Æ°á»£c async. Táº¡o async function bÃªn trong rá»“i gá»i.

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Pattern CÆ¡ Báº£n - Simple Data Fetch â­

```jsx
/**
 * Demo: Basic data fetching pattern
 * Concepts: Loading/Error/Success states, fetch trong useEffect
 */

import { useState, useEffect } from "react";

// Mock API endpoint
const USERS_API = "https://jsonplaceholder.typicode.com/users";

function UserList() {
  // 3 states pattern
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    console.log("ğŸ”„ Fetching users...");

    // Method 1: .then() chain
    fetch(USERS_API)
      .then((response) => {
        console.log("ğŸ“¡ Response received:", response.status);

        // Check if response OK
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        return response.json();
      })
      .then((data) => {
        console.log("âœ… Data parsed:", data.length, "users");
        setUsers(data);
        setLoading(false);
      })
      .catch((error) => {
        console.error("âŒ Fetch error:", error.message);
        setError(error.message);
        setLoading(false);
      });
  }, []); // Empty deps â†’ Fetch once on mount

  // Conditional rendering based on state
  if (loading) {
    return (
      <div style={{ textAlign: "center", padding: "20px" }}>
        <div className="spinner">ğŸ”„ Loading users...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div
        style={{
          color: "red",
          padding: "20px",
          border: "1px solid red",
          borderRadius: "4px",
          background: "#fff0f0",
        }}
      >
        <strong>Error:</strong> {error}
      </div>
    );
  }

  return (
    <div>
      <h2>User List ({users.length} users)</h2>
      <ul>
        {users.map((user) => (
          <li key={user.id}>
            <strong>{user.name}</strong> - {user.email}
          </li>
        ))}
      </ul>

      <div
        style={{ marginTop: "20px", padding: "10px", background: "#f0f0f0" }}
      >
        <h3>ğŸ“Š State Timeline:</h3>
        <ol>
          <li>Initial: loading=true, data=[], error=null â†’ "Loading..."</li>
          <li>Fetch initiated â†’ Network request in flight</li>
          <li>Success: loading=false, data=[...], error=null â†’ Display list</li>
          <li>OR Error: loading=false, data=[], error="..." â†’ Display error</li>
        </ol>
      </div>
    </div>
  );
}

export default UserList;
```

---

### Demo 2: Ká»‹ch Báº£n Thá»±c Táº¿ - User Detail Fetch â­â­

```jsx
/**
 * Demo: Fetch vá»›i dependencies - refetch khi ID thay Ä‘á»•i
 * Use case: User profile page vá»›i dynamic userId
 */

import { useState, useEffect } from "react";

const USERS_API = "https://jsonplaceholder.typicode.com/users";

function UserDetail({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    console.log(`ğŸ”„ Fetching user ${userId}...`);

    // Reset states khi userId thay Ä‘á»•i
    setLoading(true);
    setError(null);
    // Optional: Clear old data Ä‘á»ƒ khÃ´ng flash old user
    // setUser(null);

    // Method 2: async/await (cleaner!)
    async function fetchUser() {
      try {
        const response = await fetch(`${USERS_API}/${userId}`);

        if (!response.ok) {
          throw new Error(`User not found (${response.status})`);
        }

        const data = await response.json();
        console.log("âœ… User loaded:", data.name);

        setUser(data);
        setLoading(false);
      } catch (err) {
        console.error("âŒ Fetch error:", err.message);
        setError(err.message);
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]); // â† Refetch khi userId thay Ä‘á»•i

  if (loading) {
    return <div>Loading user {userId}...</div>;
  }

  if (error) {
    return <div style={{ color: "red" }}>Error: {error}</div>;
  }

  return (
    <div
      style={{ padding: "20px", border: "1px solid #ddd", borderRadius: "8px" }}
    >
      <h2>{user.name}</h2>
      <p>
        <strong>Email:</strong> {user.email}
      </p>
      <p>
        <strong>Phone:</strong> {user.phone}
      </p>
      <p>
        <strong>Website:</strong> {user.website}
      </p>

      <div
        style={{ marginTop: "20px", padding: "10px", background: "#f9f9f9" }}
      >
        <strong>Address:</strong>
        <p>
          {user.address.street}, {user.address.city}
        </p>
      </div>
    </div>
  );
}

// Demo wrapper with user selection
function UserDetailDemo() {
  const [selectedUserId, setSelectedUserId] = useState(1);

  return (
    <div>
      <h2>User Detail Demo</h2>

      <div style={{ marginBottom: "20px" }}>
        <label>Select User: </label>
        <select
          value={selectedUserId}
          onChange={(e) => setSelectedUserId(Number(e.target.value))}
        >
          {[1, 2, 3, 4, 5].map((id) => (
            <option key={id} value={id}>
              User {id}
            </option>
          ))}
        </select>
      </div>

      <UserDetail userId={selectedUserId} />

      <div
        style={{ marginTop: "20px", padding: "10px", background: "#f0f0f0" }}
      >
        <h3>ğŸ§ª Test Scenario:</h3>
        <ol>
          <li>Má»Ÿ Console</li>
          <li>Change user â†’ Effect re-runs</li>
          <li>Loading state shown</li>
          <li>New data fetched vÃ  displayed</li>
        </ol>

        <h3>ğŸ” Key Observations:</h3>
        <ul>
          <li>âœ… Dependencies [userId] trigger refetch</li>
          <li>âœ… States reset on each fetch</li>
          <li>âœ… async/await cleaner than .then()</li>
          <li>âœ… Error handling vá»›i try/catch</li>
        </ul>
      </div>
    </div>
  );
}

export default UserDetailDemo;
```

---

### Demo 3: Edge Cases - Retry & Manual Refetch â­â­â­

```jsx
/**
 * Demo: Advanced patterns - Retry failed requests, Manual refetch
 * Edge case: Network failures, stale data
 */

import { useState, useEffect } from "react";

const POSTS_API = "https://jsonplaceholder.typicode.com/posts";

function PostsWithRetry() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);
  const [refetchTrigger, setRefetchTrigger] = useState(0);

  useEffect(() => {
    console.log(`ğŸ”„ Fetching posts (attempt ${retryCount + 1})...`);

    setLoading(true);
    setError(null);

    async function fetchPosts() {
      try {
        // Simulate random failure (30% chance)
        if (Math.random() < 0.3) {
          throw new Error("Simulated network error");
        }

        const response = await fetch(POSTS_API);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        console.log("âœ… Posts loaded:", data.length);

        setPosts(data);
        setLoading(false);
        setRetryCount(0); // Reset retry count on success
      } catch (err) {
        console.error("âŒ Fetch failed:", err.message);
        setError(err.message);
        setLoading(false);
      }
    }

    fetchPosts();
  }, [retryCount, refetchTrigger]); // Trigger refetch khi retry hoáº·c manual refetch

  const handleRetry = () => {
    setRetryCount((prev) => prev + 1);
  };

  const handleRefresh = () => {
    setRefetchTrigger((prev) => prev + 1);
  };

  if (loading) {
    return (
      <div style={{ textAlign: "center", padding: "40px" }}>
        <div style={{ fontSize: "48px" }}>ğŸ”„</div>
        <p>Loading posts...</p>
        {retryCount > 0 && (
          <p style={{ color: "#666" }}>Retry attempt {retryCount}</p>
        )}
      </div>
    );
  }

  if (error) {
    return (
      <div
        style={{
          padding: "20px",
          border: "2px solid #f44336",
          borderRadius: "8px",
          background: "#fff0f0",
          textAlign: "center",
        }}
      >
        <h3 style={{ color: "#f44336" }}>âŒ Failed to load posts</h3>
        <p>{error}</p>

        <div style={{ marginTop: "20px" }}>
          <button
            onClick={handleRetry}
            style={{
              padding: "10px 20px",
              background: "#4CAF50",
              color: "white",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer",
              fontSize: "16px",
            }}
          >
            ğŸ”„ Retry
          </button>
        </div>

        <p style={{ marginTop: "20px", fontSize: "14px", color: "#666" }}>
          Retry count: {retryCount}
        </p>
      </div>
    );
  }

  return (
    <div>
      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          marginBottom: "20px",
        }}
      >
        <h2>Posts ({posts.length})</h2>

        <button
          onClick={handleRefresh}
          style={{
            padding: "8px 16px",
            background: "#2196F3",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          ğŸ”„ Refresh
        </button>
      </div>

      <div
        style={{
          display: "grid",
          gap: "10px",
        }}
      >
        {posts.slice(0, 10).map((post) => (
          <div
            key={post.id}
            style={{
              padding: "15px",
              border: "1px solid #ddd",
              borderRadius: "4px",
              background: "white",
            }}
          >
            <h4>{post.title}</h4>
            <p style={{ color: "#666", fontSize: "14px" }}>
              {post.body.substring(0, 100)}...
            </p>
          </div>
        ))}
      </div>

      <div
        style={{
          marginTop: "30px",
          padding: "15px",
          background: "#f0f0f0",
          borderRadius: "4px",
        }}
      >
        <h3>ğŸ¯ Features Demonstrated:</h3>
        <ul>
          <li>
            âœ… <strong>Retry mechanism:</strong> Click Retry button on error
          </li>
          <li>
            âœ… <strong>Manual refetch:</strong> Click Refresh button anytime
          </li>
          <li>
            âœ… <strong>Retry counter:</strong> Track retry attempts
          </li>
          <li>
            âœ… <strong>Simulated failures:</strong> 30% chance to test error
            handling
          </li>
        </ul>

        <h3>ğŸ” Implementation Details:</h3>
        <pre
          style={{
            background: "white",
            padding: "10px",
            borderRadius: "4px",
            overflow: "auto",
          }}
        >
          {`useEffect(() => {
  fetchPosts();
}, [retryCount, refetchTrigger]);
// â†‘ Triggers: 
// - retryCount changes â†’ Retry
// - refetchTrigger changes â†’ Manual refresh`}
        </pre>
      </div>
    </div>
  );
}

export default PostsWithRetry;
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Level 1: Ãp Dá»¥ng Concept (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Implement basic data fetching pattern
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useRef, custom hooks, libraries
 *
 * Requirements:
 * 1. Fetch danh sÃ¡ch todos tá»« API
 * 2. Display loading state
 * 3. Display error state náº¿u fetch fail
 * 4. Display todos list khi success
 * 5. Show completed/incomplete status
 *
 * API: https://jsonplaceholder.typicode.com/todos
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - 3 states: todos, loading, error
 * - useEffect vá»›i empty deps []
 * - Conditional rendering
 */

// âŒ CÃ¡ch SAI (Anti-pattern):
function WrongTodoList() {
  const [todos, setTodos] = useState([]);

  // âŒ Fetch trong render â†’ Infinite loop!
  fetch("https://jsonplaceholder.typicode.com/todos")
    .then((res) => res.json())
    .then((data) => setTodos(data)); // setState â†’ re-render â†’ fetch again!

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}

// Táº¡i sao sai?
// - Fetch trong render â†’ Má»—i render táº¡o request má»›i
// - setState trigger re-render â†’ Infinite loop
// - KhÃ´ng cÃ³ loading/error states

// âœ… CÃ¡ch ÄÃšNG (Best practice):
function CorrectTodoList() {
  const [todos, setTodos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // âœ… Fetch trong effect
    async function fetchTodos() {
      try {
        const response = await fetch(
          "https://jsonplaceholder.typicode.com/todos",
        );

        if (!response.ok) {
          throw new Error("Failed to fetch todos");
        }

        const data = await response.json();
        setTodos(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    fetchTodos();
  }, []); // âœ… Empty deps â†’ Fetch once

  if (loading) return <div>Loading todos...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <ul>
      {todos.slice(0, 10).map((todo) => (
        <li key={todo.id}>
          {todo.completed ? "âœ…" : "â­•"} {todo.title}
        </li>
      ))}
    </ul>
  );
}

// Táº¡i sao tá»‘t hÆ¡n?
// âœ… Fetch trong effect â†’ Controlled timing
// âœ… Empty deps â†’ Fetch once on mount
// âœ… Loading/Error states â†’ Better UX
// âœ… Conditional rendering

// ğŸ¯ NHIá»†M Vá»¤ Cá»¦A Báº N:
function TodoList() {
  // TODO: Declare states (todos, loading, error)

  // TODO: useEffect to fetch todos
  // API: https://jsonplaceholder.typicode.com/todos
  // Handle loading, success, error

  // TODO: Conditional rendering
  // - if loading â†’ "Loading..."
  // - if error â†’ Display error
  // - if success â†’ Display todos (show first 20)

  return (
    <div>
      <h2>Todo List</h2>
      {/* TODO: Implement UI */}
    </div>
  );
}

// âœ… Expected behavior:
// 1. On mount â†’ "Loading todos..."
// 2. After fetch â†’ List of 20 todos with completed status
// 3. On error â†’ "Error: [message]"

export default TodoList;
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * TodoList - Level 1: Basic data fetching pattern
 * Fetch todos from jsonplaceholder, show loading/error/success states
 * Display first 20 todos with completed status indicator
 */
import { useState, useEffect } from "react";

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchTodos() {
      try {
        const response = await fetch(
          "https://jsonplaceholder.typicode.com/todos",
        );

        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }

        const data = await response.json();
        setTodos(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    fetchTodos();
  }, []);

  if (loading) {
    return <div>Loading todos...</div>;
  }

  if (error) {
    return <div>Error: {error}</div>;
  }

  return (
    <div>
      <h2>Todo List (first 20)</h2>
      <ul>
        {todos.slice(0, 20).map((todo) => (
          <li key={todo.id}>
            {todo.completed ? "âœ…" : "â­•"} {todo.title}
          </li>
        ))}
      </ul>
    </div>
  );
}

export default TodoList;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi cháº¡y:**

- Ban Ä‘áº§u: "Loading todos..."
- Sau ~0.5â€“1 giÃ¢y: hiá»ƒn thá»‹ danh sÃ¡ch 20 todo Ä‘áº§u tiÃªn  
  VÃ­ dá»¥:
  - âœ… delectus aut autem
  - â­• quis ut nam facilis et officia qui
  - âœ… fugiat veniam minus
  - â­• et porro tempora

</details>

---

### â­â­ Level 2: Nháº­n Biáº¿t Pattern (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Fetch vá»›i dependencies - refetch khi params thay Ä‘á»•i
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: Photo gallery vá»›i pagination
 * API: https://jsonplaceholder.typicode.com/photos
 *
 * Requirements:
 * - Fetch photos vá»›i pagination (_page, _limit)
 * - Previous/Next buttons
 * - Refetch khi page thay Ä‘á»•i
 * - Loading state má»—i láº§n fetch
 * - Display page sá»‘
 *
 * ğŸ¤” IMPLEMENTATION STRATEGY:
 * - State: photos, loading, error, currentPage
 * - useEffect deps: [currentPage]
 * - API: /photos?_page=${page}&_limit=10
 */

function PhotoGallery() {
  const [photos, setPhotos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentPage, setCurrentPage] = useState(1);

  const PHOTOS_PER_PAGE = 10;

  // TODO: useEffect to fetch photos
  useEffect(() => {
    async function fetchPhotos() {
      try {
        // TODO:
        // 1. Set loading = true, error = null
        // 2. Fetch from API with currentPage
        // 3. Check response.ok
        // 4. Parse JSON
        // 5. Set photos, loading = false

        setLoading(true);
        setError(null);

        const response = await fetch(
          `https://jsonplaceholder.typicode.com/photos?_page=${currentPage}&_limit=${PHOTOS_PER_PAGE}`,
        );

        if (!response.ok) {
          throw new Error("Failed to fetch photos");
        }

        const data = await response.json();
        setPhotos(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    fetchPhotos();
  }, [currentPage]); // â† Refetch khi page thay Ä‘á»•i

  const handlePrevious = () => {
    setCurrentPage((prev) => Math.max(1, prev - 1));
  };

  const handleNext = () => {
    setCurrentPage((prev) => prev + 1);
  };

  if (loading) {
    return (
      <div style={{ textAlign: "center", padding: "40px" }}>
        <div style={{ fontSize: "48px" }}>ğŸ“¸</div>
        <p>Loading photos...</p>
      </div>
    );
  }

  if (error) {
    return <div style={{ color: "red" }}>Error: {error}</div>;
  }

  return (
    <div>
      <h2>Photo Gallery - Page {currentPage}</h2>

      {/* Pagination Controls */}
      <div
        style={{
          marginBottom: "20px",
          display: "flex",
          gap: "10px",
          alignItems: "center",
        }}
      >
        <button
          onClick={handlePrevious}
          disabled={currentPage === 1}
          style={{
            padding: "8px 16px",
            background: currentPage === 1 ? "#ccc" : "#4CAF50",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: currentPage === 1 ? "not-allowed" : "pointer",
          }}
        >
          â† Previous
        </button>

        <span>Page {currentPage}</span>

        <button
          onClick={handleNext}
          style={{
            padding: "8px 16px",
            background: "#4CAF50",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          Next â†’
        </button>
      </div>

      {/* Photo Grid */}
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fill, minmax(150px, 1fr))",
          gap: "10px",
        }}
      >
        {photos.map((photo) => (
          <div
            key={photo.id}
            style={{
              border: "1px solid #ddd",
              borderRadius: "4px",
              overflow: "hidden",
              background: "white",
            }}
          >
            <img
              src={photo.thumbnailUrl}
              alt={photo.title}
              style={{ width: "100%", display: "block" }}
            />
            <div style={{ padding: "10px", fontSize: "12px" }}>
              {photo.title.substring(0, 30)}...
            </div>
          </div>
        ))}
      </div>

      <div
        style={{ marginTop: "30px", padding: "15px", background: "#f0f0f0" }}
      >
        <h3>ğŸ” Key Learnings:</h3>
        <ul>
          <li>
            âœ… <strong>Dependencies:</strong> [currentPage] triggers refetch
          </li>
          <li>
            âœ… <strong>State reset:</strong> setLoading(true) on each fetch
          </li>
          <li>
            âœ… <strong>Pagination:</strong> _page vÃ  _limit query params
          </li>
          <li>
            âœ… <strong>UX:</strong> Disable "Previous" on page 1
          </li>
        </ul>

        <h3>ğŸ§ª Test:</h3>
        <ol>
          <li>Má»Ÿ Console</li>
          <li>Click Next â†’ New fetch triggered</li>
          <li>Loading state shown briefly</li>
          <li>New photos loaded</li>
        </ol>
      </div>
    </div>
  );
}

export default PhotoGallery;
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * PhotoGallery - Level 2: Pagination with dependencies
 * Fetch photos from jsonplaceholder with _page and _limit
 * Refetch when currentPage changes
 * Show loading/error states
 * Previous/Next pagination controls
 */
import { useState, useEffect } from "react";

function PhotoGallery() {
  const [photos, setPhotos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentPage, setCurrentPage] = useState(1);

  const PHOTOS_PER_PAGE = 10;

  useEffect(() => {
    async function fetchPhotos() {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch(
          `https://jsonplaceholder.typicode.com/photos?_page=${currentPage}&_limit=${PHOTOS_PER_PAGE}`,
        );

        if (!response.ok) {
          throw new Error(
            `Failed to fetch photos - Status: ${response.status}`,
          );
        }

        const data = await response.json();
        setPhotos(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    fetchPhotos();
  }, [currentPage]);

  const handlePrevious = () => {
    setCurrentPage((prev) => Math.max(1, prev - 1));
  };

  const handleNext = () => {
    setCurrentPage((prev) => prev + 1);
  };

  if (loading) {
    return <div>Loading photos (page {currentPage})...</div>;
  }

  if (error) {
    return <div>Error: {error}</div>;
  }

  return (
    <div>
      <h2>Photo Gallery - Page {currentPage}</h2>

      <div
        style={{
          marginBottom: "1rem",
          display: "flex",
          gap: "1rem",
          alignItems: "center",
        }}
      >
        <button onClick={handlePrevious} disabled={currentPage === 1}>
          â† Previous
        </button>
        <span>Page {currentPage}</span>
        <button onClick={handleNext}>Next â†’</button>
      </div>

      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fill, minmax(180px, 1fr))",
          gap: "1rem",
        }}
      >
        {photos.map((photo) => (
          <div
            key={photo.id}
            style={{
              border: "1px solid #ddd",
              borderRadius: "4px",
              overflow: "hidden",
            }}
          >
            <img
              src={photo.thumbnailUrl}
              alt={photo.title}
              style={{ width: "100%", height: "auto", display: "block" }}
            />
            <div style={{ padding: "0.5rem", fontSize: "0.875rem" }}>
              {photo.title.substring(0, 40)}
              {photo.title.length > 40 ? "..." : ""}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

export default PhotoGallery;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi cháº¡y:**

- Ban Ä‘áº§u: "Loading photos (page 1)..."
- Sau fetch: hiá»ƒn thá»‹ 10 áº£nh thumbnail Ä‘áº§u tiÃªn (page 1) + nÃºt Previous (disabled) vÃ  Next
- Nháº¥n Next â†’ "Loading photos (page 2)..." â†’ hiá»ƒn thá»‹ 10 áº£nh tiáº¿p theo (id 11-20)
- Nháº¥n Previous â†’ quay vá» page 1
- Náº¿u máº¡ng lá»—i hoáº·c API tráº£ vá» status â‰  2xx â†’ hiá»ƒn thá»‹ "Error: Failed to fetch photos - Status: ..."

</details>

---

### â­â­â­ Level 3: Ká»‹ch Báº£n Thá»±c Táº¿ (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Search vá»›i debounce + data fetching
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  user, tÃ´i muá»‘n search users by name,
 * káº¿t quáº£ update real-time khi tÃ´i typing"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Search input
 * - [ ] Debounce 500ms (khÃ´ng search má»—i keystroke)
 * - [ ] Fetch filtered results tá»« API
 * - [ ] Loading state during search
 * - [ ] Empty state khi no results
 * - [ ] Error handling
 *
 * ğŸ¨ Technical Constraints:
 * - API: https://jsonplaceholder.typicode.com/users
 * - Client-side filtering (API khÃ´ng support search)
 * - Debounce vá»›i useState + useEffect
 *
 * ğŸš¨ Edge Cases:
 * - Query empty â†’ Show all users
 * - Query < 2 chars â†’ Don't search
 * - Clear query â†’ Reset results
 *
 * ğŸ“ Implementation Checklist:
 * - [ ] State: searchQuery, debouncedQuery, users, loading, error
 * - [ ] Effect 1: Debounce searchQuery â†’ debouncedQuery
 * - [ ] Effect 2: Fetch users khi debouncedQuery thay Ä‘á»•i
 * - [ ] Client-side filter by name
 */

import { useState, useEffect } from "react";

const USERS_API = "https://jsonplaceholder.typicode.com/users";

function UserSearch() {
  // Search states
  const [searchQuery, setSearchQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");

  // Data states
  const [allUsers, setAllUsers] = useState([]);
  const [filteredUsers, setFilteredUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [isSearching, setIsSearching] = useState(false);
  const [error, setError] = useState(null);

  // Effect 1: Fetch all users on mount
  useEffect(() => {
    console.log("ğŸ“¥ Fetching all users...");

    async function fetchUsers() {
      try {
        const response = await fetch(USERS_API);

        if (!response.ok) {
          throw new Error("Failed to fetch users");
        }

        const data = await response.json();
        console.log("âœ… Users loaded:", data.length);

        setAllUsers(data);
        setFilteredUsers(data); // Initially show all
        setLoading(false);
      } catch (err) {
        console.error("âŒ Fetch error:", err.message);
        setError(err.message);
        setLoading(false);
      }
    }

    fetchUsers();
  }, []); // Fetch once

  // Effect 2: Debounce search query
  useEffect(() => {
    setIsSearching(true);

    const timerId = setTimeout(() => {
      console.log("ğŸ” Debounced query:", searchQuery);
      setDebouncedQuery(searchQuery);
      setIsSearching(false);
    }, 500); // 500ms debounce

    return () => {
      clearTimeout(timerId);
    };
  }, [searchQuery]);

  // Effect 3: Filter users khi debouncedQuery thay Ä‘á»•i
  useEffect(() => {
    if (!debouncedQuery || debouncedQuery.length < 2) {
      // Show all users if query empty or too short
      setFilteredUsers(allUsers);
      return;
    }

    console.log("ğŸ” Filtering users by:", debouncedQuery);

    const filtered = allUsers.filter(
      (user) =>
        user.name.toLowerCase().includes(debouncedQuery.toLowerCase()) ||
        user.email.toLowerCase().includes(debouncedQuery.toLowerCase()),
    );

    setFilteredUsers(filtered);
  }, [debouncedQuery, allUsers]);

  if (loading) {
    return (
      <div style={{ textAlign: "center", padding: "40px" }}>
        Loading users...
      </div>
    );
  }

  if (error) {
    return <div style={{ color: "red", padding: "20px" }}>Error: {error}</div>;
  }

  return (
    <div style={{ maxWidth: "800px", margin: "0 auto", padding: "20px" }}>
      <h2>User Search</h2>

      {/* Search Input */}
      <div style={{ marginBottom: "20px" }}>
        <input
          type="text"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          placeholder="Search by name or email..."
          style={{
            width: "100%",
            padding: "12px",
            fontSize: "16px",
            border: "2px solid #ddd",
            borderRadius: "4px",
            outline: "none",
          }}
        />

        <div
          style={{
            marginTop: "10px",
            fontSize: "14px",
            color: "#666",
            display: "flex",
            justifyContent: "space-between",
          }}
        >
          <span>
            {isSearching
              ? "ğŸ” Searching..."
              : `Found ${filteredUsers.length} user(s)`}
          </span>
          {searchQuery && searchQuery.length < 2 && (
            <span style={{ color: "#ff9800" }}>
              Type at least 2 characters to search
            </span>
          )}
        </div>
      </div>

      {/* Results */}
      {filteredUsers.length === 0 ? (
        <div
          style={{
            textAlign: "center",
            padding: "40px",
            background: "#f9f9f9",
            borderRadius: "8px",
          }}
        >
          <div style={{ fontSize: "48px" }}>ğŸ”</div>
          <p>No users found matching "{debouncedQuery}"</p>
        </div>
      ) : (
        <div style={{ display: "grid", gap: "10px" }}>
          {filteredUsers.map((user) => (
            <div
              key={user.id}
              style={{
                padding: "15px",
                border: "1px solid #ddd",
                borderRadius: "4px",
                background: "white",
              }}
            >
              <h3 style={{ margin: "0 0 5px 0" }}>{user.name}</h3>
              <p style={{ margin: "0", color: "#666", fontSize: "14px" }}>
                ğŸ“§ {user.email}
              </p>
              <p
                style={{ margin: "5px 0 0 0", color: "#666", fontSize: "14px" }}
              >
                ğŸ¢ {user.company.name}
              </p>
            </div>
          ))}
        </div>
      )}

      {/* Debug Info */}
      <div
        style={{
          marginTop: "30px",
          padding: "15px",
          background: "#f0f0f0",
          borderRadius: "4px",
          fontSize: "14px",
        }}
      >
        <h3>ğŸ” Debug Info:</h3>
        <p>
          <strong>Search Query:</strong> "{searchQuery}"
        </p>
        <p>
          <strong>Debounced Query:</strong> "{debouncedQuery}"
        </p>
        <p>
          <strong>Is Searching:</strong> {isSearching ? "Yes" : "No"}
        </p>
        <p>
          <strong>Total Users:</strong> {allUsers.length}
        </p>
        <p>
          <strong>Filtered Users:</strong> {filteredUsers.length}
        </p>
      </div>

      {/* Explanation */}
      <div
        style={{
          marginTop: "20px",
          padding: "15px",
          background: "#e3f2fd",
          borderRadius: "4px",
        }}
      >
        <h3>ğŸ’¡ How It Works:</h3>
        <ol>
          <li>
            <strong>Effect 1:</strong> Fetch all users on mount
          </li>
          <li>
            <strong>Effect 2:</strong> Debounce searchQuery (500ms delay)
          </li>
          <li>
            <strong>Effect 3:</strong> Filter users when debouncedQuery changes
          </li>
        </ol>

        <h3>ğŸ¯ Why This Pattern:</h3>
        <ul>
          <li>âœ… Debounce prevents excessive filtering</li>
          <li>âœ… Client-side filter = instant results</li>
          <li>âœ… Separate concerns = easier to maintain</li>
          <li>âœ… Loading states = better UX</li>
        </ul>
      </div>
    </div>
  );
}

export default UserSearch;
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * UserSearch - Level 3: Search with debounce + client-side filtering
 * - Fetch all users once on mount
 * - Debounce search input (500ms)
 * - Filter users by name or email (client-side)
 * - Show loading / searching / empty / error states
 * - Minimum 2 characters to start filtering
 */
import { useState, useEffect } from "react";

function UserSearch() {
  const [searchQuery, setSearchQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");
  const [allUsers, setAllUsers] = useState([]);
  const [filteredUsers, setFilteredUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [isSearching, setIsSearching] = useState(false);
  const [error, setError] = useState(null);

  // Fetch all users once on mount
  useEffect(() => {
    async function fetchUsers() {
      try {
        const response = await fetch(
          "https://jsonplaceholder.typicode.com/users",
        );
        if (!response.ok) {
          throw new Error(`Failed to fetch users - ${response.status}`);
        }
        const data = await response.json();
        setAllUsers(data);
        setFilteredUsers(data); // initially show everyone
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }
    fetchUsers();
  }, []);

  // Debounce search input
  useEffect(() => {
    setIsSearching(true);
    const timer = setTimeout(() => {
      setDebouncedQuery(searchQuery.trim());
      setIsSearching(false);
    }, 500);

    return () => clearTimeout(timer);
  }, [searchQuery]);

  // Filter users when debounced query changes
  useEffect(() => {
    if (!debouncedQuery || debouncedQuery.length < 2) {
      setFilteredUsers(allUsers);
      return;
    }

    const lowerQuery = debouncedQuery.toLowerCase();
    const results = allUsers.filter(
      (user) =>
        user.name.toLowerCase().includes(lowerQuery) ||
        user.email.toLowerCase().includes(lowerQuery),
    );
    setFilteredUsers(results);
  }, [debouncedQuery, allUsers]);

  if (loading) {
    return <div>Loading users...</div>;
  }

  if (error) {
    return <div>Error: {error}</div>;
  }

  return (
    <div>
      <h2>User Search</h2>

      <input
        type="text"
        value={searchQuery}
        onChange={(e) => setSearchQuery(e.target.value)}
        placeholder="Search by name or email..."
        style={{ width: "100%", padding: "8px", marginBottom: "12px" }}
      />

      <div style={{ marginBottom: "16px", color: "#555", fontSize: "0.9rem" }}>
        {isSearching ? "Searching..." : `Found ${filteredUsers.length} user(s)`}
        {searchQuery && searchQuery.length < 2 && (
          <span style={{ color: "#e67e22", marginLeft: "12px" }}>
            (Type at least 2 characters to search)
          </span>
        )}
      </div>

      {filteredUsers.length === 0 && debouncedQuery.length >= 2 ? (
        <div>No users found matching "{debouncedQuery}"</div>
      ) : (
        <div style={{ display: "grid", gap: "12px" }}>
          {filteredUsers.map((user) => (
            <div
              key={user.id}
              style={{
                padding: "12px",
                border: "1px solid #ddd",
                borderRadius: "6px",
                background: "#fafafa",
              }}
            >
              <strong>{user.name}</strong>
              <div style={{ color: "#555", fontSize: "0.9rem" }}>
                {user.email}
              </div>
              <div
                style={{ color: "#777", fontSize: "0.85rem", marginTop: "4px" }}
              >
                {user.company.name}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

export default UserSearch;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi cháº¡y:**

- Ban Ä‘áº§u: Loading users... â†’ hiá»ƒn thá»‹ toÃ n bá»™ 10 users
- GÃµ "le" â†’ sau 500ms: "Found 10 user(s)" (váº«n hiá»‡n táº¥t cáº£ vÃ¬ < 2 kÃ½ tá»± thá»±c sá»± lá»c)
- GÃµ "Lea" â†’ sau debounce: chá»‰ hiá»‡n ngÆ°á»i cÃ³ "Lea" trong name hoáº·c email  
  VÃ­ dá»¥:
  - Leanne Graham (Sincere@april.biz)
  - Clementine Bauch (Nathan@yesenia.net)
- GÃµ "xyz" â†’ "No users found matching "xyz""
- XÃ³a input â†’ quay láº¡i hiá»ƒn thá»‹ táº¥t cáº£ users

</details>

---

### â­â­â­â­ Level 4: Quyáº¿t Äá»‹nh Kiáº¿n TrÃºc (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Comments System vá»›i Nested Data Fetching
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Context:
 * XÃ¢y dá»±ng comment system:
 * - Fetch posts
 * - Click post â†’ Fetch comments cho post Ä‘Ã³
 * - Nested loading states
 * - Error handling cho tá»«ng level
 *
 * APPROACH OPTIONS:
 *
 * APPROACH 1: Single component, multiple states
 * Pros:
 * - ÄÆ¡n giáº£n, táº¥t cáº£ trong 1 component
 * - Dá»… share state
 * Cons:
 * - Component lá»›n, khÃ³ Ä‘á»c
 * - Many states to manage
 * - Hard to reuse
 *
 * APPROACH 2: Separate components (Post List + Comment List)
 * Pros:
 * - Separation of concerns
 * - Easier to test
 * - Reusable components
 * Cons:
 * - Props drilling
 * - More files
 *
 * APPROACH 3: Compound pattern vá»›i shared state
 * Pros:
 * - Best of both worlds
 * - Clear responsibilities
 * - Maintainable
 * Cons:
 * - Slightly more complex
 *
 * ğŸ’­ RECOMMENDATION: Approach 2 (Separate Components)
 *
 * ADR:
 * ---
 * # ADR: Comment System Architecture
 *
 * ## Decision
 * Use separate PostList and CommentList components
 *
 * ## Rationale
 * - Each component handles its own data fetching
 * - Clear separation: posts vs comments
 * - Easier to add features (reply, edit, etc.)
 * - Better testability
 * ---
 */

// ğŸ’» PHASE 2: Implementation (30 phÃºt)

import { useState, useEffect } from "react";

const POSTS_API = "https://jsonplaceholder.typicode.com/posts";
const COMMENTS_API = "https://jsonplaceholder.typicode.com/comments";

// Component 1: Post List
function PostList({ onSelectPost }) {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchPosts() {
      try {
        const response = await fetch(`${POSTS_API}?_limit=10`);

        if (!response.ok) {
          throw new Error("Failed to fetch posts");
        }

        const data = await response.json();
        setPosts(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    fetchPosts();
  }, []);

  if (loading) return <div>Loading posts...</div>;
  if (error) return <div style={{ color: "red" }}>Error: {error}</div>;

  return (
    <div>
      <h3>Posts</h3>
      <div style={{ display: "grid", gap: "10px" }}>
        {posts.map((post) => (
          <div
            key={post.id}
            onClick={() => onSelectPost(post.id)}
            style={{
              padding: "15px",
              border: "2px solid #ddd",
              borderRadius: "4px",
              cursor: "pointer",
              background: "white",
              transition: "all 0.2s",
            }}
            onMouseEnter={(e) => {
              e.currentTarget.style.borderColor = "#4CAF50";
              e.currentTarget.style.background = "#f9f9f9";
            }}
            onMouseLeave={(e) => {
              e.currentTarget.style.borderColor = "#ddd";
              e.currentTarget.style.background = "white";
            }}
          >
            <h4 style={{ margin: "0 0 10px 0" }}>{post.title}</h4>
            <p style={{ margin: 0, color: "#666", fontSize: "14px" }}>
              {post.body.substring(0, 100)}...
            </p>
            <p
              style={{ marginTop: "10px", color: "#4CAF50", fontSize: "12px" }}
            >
              Click to view comments â†’
            </p>
          </div>
        ))}
      </div>
    </div>
  );
}

// Component 2: Comment List
function CommentList({ postId }) {
  const [comments, setComments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!postId) return;

    console.log(`ğŸ“¥ Fetching comments for post ${postId}...`);

    setLoading(true);
    setError(null);

    async function fetchComments() {
      try {
        const response = await fetch(`${COMMENTS_API}?postId=${postId}`);

        if (!response.ok) {
          throw new Error("Failed to fetch comments");
        }

        const data = await response.json();
        console.log(`âœ… Loaded ${data.length} comments`);
        setComments(data);
        setLoading(false);
      } catch (err) {
        console.error("âŒ Fetch error:", err.message);
        setError(err.message);
        setLoading(false);
      }
    }

    fetchComments();
  }, [postId]); // Refetch khi postId thay Ä‘á»•i

  if (!postId) {
    return (
      <div
        style={{
          textAlign: "center",
          padding: "40px",
          background: "#f9f9f9",
          borderRadius: "8px",
        }}
      >
        <div style={{ fontSize: "48px" }}>ğŸ’¬</div>
        <p>Select a post to view comments</p>
      </div>
    );
  }

  if (loading) {
    return (
      <div style={{ textAlign: "center", padding: "40px" }}>
        <div style={{ fontSize: "32px" }}>ğŸ’¬</div>
        <p>Loading comments...</p>
      </div>
    );
  }

  if (error) {
    return <div style={{ color: "red" }}>Error: {error}</div>;
  }

  return (
    <div>
      <h3>Comments ({comments.length})</h3>
      <div style={{ display: "grid", gap: "10px" }}>
        {comments.map((comment) => (
          <div
            key={comment.id}
            style={{
              padding: "15px",
              border: "1px solid #ddd",
              borderRadius: "4px",
              background: "white",
            }}
          >
            <div
              style={{
                display: "flex",
                justifyContent: "space-between",
                marginBottom: "10px",
              }}
            >
              <strong style={{ color: "#2196F3" }}>{comment.name}</strong>
              <span style={{ fontSize: "12px", color: "#999" }}>
                {comment.email}
              </span>
            </div>
            <p style={{ margin: 0, color: "#666", fontSize: "14px" }}>
              {comment.body}
            </p>
          </div>
        ))}
      </div>
    </div>
  );
}

// Parent Component
function CommentSystem() {
  const [selectedPostId, setSelectedPostId] = useState(null);

  return (
    <div style={{ maxWidth: "1200px", margin: "0 auto", padding: "20px" }}>
      <h2>Comment System</h2>

      <div
        style={{
          display: "grid",
          gridTemplateColumns: "1fr 1fr",
          gap: "20px",
          marginTop: "20px",
        }}
      >
        {/* Left: Post List */}
        <div>
          <PostList onSelectPost={setSelectedPostId} />
        </div>

        {/* Right: Comment List */}
        <div>
          <CommentList postId={selectedPostId} />
        </div>
      </div>

      {/* Architecture Explanation */}
      <div
        style={{
          marginTop: "30px",
          padding: "20px",
          background: "#f0f0f0",
          borderRadius: "8px",
        }}
      >
        <h3>ğŸ—ï¸ Architecture Highlights:</h3>

        <h4>Component Separation:</h4>
        <ul>
          <li>
            <strong>PostList:</strong> Fetches & displays posts
          </li>
          <li>
            <strong>CommentList:</strong> Fetches & displays comments for
            selected post
          </li>
          <li>
            <strong>CommentSystem:</strong> Coordinates both, manages
            selectedPostId
          </li>
        </ul>

        <h4>Data Flow:</h4>
        <ol>
          <li>PostList fetches posts on mount</li>
          <li>User clicks post â†’ onSelectPost(postId) called</li>
          <li>selectedPostId state updates</li>
          <li>CommentList receives new postId via props</li>
          <li>CommentList effect re-runs â†’ Fetches comments</li>
        </ol>

        <h4>Benefits:</h4>
        <ul>
          <li>âœ… Each component handles its own data fetching</li>
          <li>âœ… Independent loading/error states</li>
          <li>âœ… Easy to test each component separately</li>
          <li>âœ… Reusable CommentList component</li>
        </ul>
      </div>
    </div>
  );
}

export default CommentSystem;

// ğŸ§ª PHASE 3: Testing (10 phÃºt)
// Manual testing checklist:
// - [ ] Posts load on mount
// - [ ] Click post â†’ Comments load
// - [ ] Click different post â†’ New comments load
// - [ ] Loading states show during fetch
// - [ ] Error states display if fetch fails
// - [ ] No selected post â†’ "Select a post" message
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * CommentSystem - Level 4: Nested Data Fetching with separate components
 * - PostList: fetches and displays list of posts
 * - CommentList: fetches comments for selected post (lazy loading)
 * - Parent manages selected post ID
 * - Independent loading/error states for each section
 */
import { useState, useEffect } from "react";

const POSTS_API = "https://jsonplaceholder.typicode.com/posts";
const COMMENTS_API = "https://jsonplaceholder.typicode.com/comments";

// Component: List of posts
function PostList({ onSelectPost }) {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchPosts() {
      try {
        const response = await fetch(`${POSTS_API}?_limit=10`);
        if (!response.ok) {
          throw new Error(`Failed to load posts (${response.status})`);
        }
        const data = await response.json();
        setPosts(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }
    fetchPosts();
  }, []);

  if (loading) return <div>Loading posts...</div>;
  if (error) return <div style={{ color: "red" }}>Error: {error}</div>;

  return (
    <div>
      <h3>Posts</h3>
      {posts.map((post) => (
        <div
          key={post.id}
          onClick={() => onSelectPost(post.id)}
          style={{
            padding: "12px",
            marginBottom: "8px",
            border: "1px solid #ddd",
            borderRadius: "6px",
            cursor: "pointer",
            background: "#f9f9f9",
          }}
        >
          <h4 style={{ margin: "0 0 6px 0" }}>{post.title}</h4>
          <p style={{ margin: 0, color: "#666", fontSize: "0.9rem" }}>
            {post.body.substring(0, 80)}...
          </p>
          <small
            style={{ color: "#4CAF50", marginTop: "6px", display: "block" }}
          >
            Click to view comments â†’
          </small>
        </div>
      ))}
    </div>
  );
}

// Component: Comments for selected post
function CommentList({ postId }) {
  const [comments, setComments] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (!postId) return;

    setLoading(true);
    setError(null);

    async function fetchComments() {
      try {
        const response = await fetch(`${COMMENTS_API}?postId=${postId}`);
        if (!response.ok) {
          throw new Error(`Failed to load comments (${response.status})`);
        }
        const data = await response.json();
        setComments(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    fetchComments();
  }, [postId]);

  if (!postId) {
    return (
      <div style={{ padding: "30px", textAlign: "center", color: "#777" }}>
        Select a post to view its comments
      </div>
    );
  }

  if (loading) return <div>Loading comments...</div>;
  if (error) return <div style={{ color: "red" }}>Error: {error}</div>;

  return (
    <div>
      <h3>Comments ({comments.length})</h3>
      {comments.map((comment) => (
        <div
          key={comment.id}
          style={{
            padding: "12px",
            marginBottom: "12px",
            border: "1px solid #eee",
            borderRadius: "6px",
            background: "white",
          }}
        >
          <div
            style={{
              display: "flex",
              justifyContent: "space-between",
              marginBottom: "6px",
            }}
          >
            <strong style={{ color: "#1976d2" }}>{comment.name}</strong>
            <small style={{ color: "#888" }}>{comment.email}</small>
          </div>
          <p style={{ margin: 0, color: "#444" }}>{comment.body}</p>
        </div>
      ))}
    </div>
  );
}

// Main component
function CommentSystem() {
  const [selectedPostId, setSelectedPostId] = useState(null);

  return (
    <div style={{ maxWidth: "1100px", margin: "0 auto", padding: "20px" }}>
      <h2>Comment System (Posts + Comments)</h2>

      <div
        style={{
          display: "grid",
          gridTemplateColumns: "1fr 1fr",
          gap: "24px",
          marginTop: "20px",
        }}
      >
        <PostList onSelectPost={setSelectedPostId} />
        <CommentList postId={selectedPostId} />
      </div>
    </div>
  );
}

export default CommentSystem;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi cháº¡y:**

- Ban Ä‘áº§u:
  - BÃªn trÃ¡i: 10 bÃ i post Ä‘áº§u tiÃªn (title + excerpt)
  - BÃªn pháº£i: "Select a post to view its comments"

- Click vÃ o má»™t post (vÃ­ dá»¥ post id 3):
  - BÃªn pháº£i chuyá»ƒn sang "Loading comments..." â†’ hiá»ƒn thá»‹ danh sÃ¡ch comments cá»§a post Ä‘Ã³
    VÃ­ dá»¥:
    - id labore ex et dolorem culpa qui (user@example.com)
    - laudantium enim quasi est quidem magnam...

- Click post khÃ¡c â†’ CommentList tá»± Ä‘á»™ng refetch vÃ  hiá»ƒn thá»‹ comments má»›i
- Má»—i pháº§n cÃ³ loading/error state riÃªng biá»‡t
- KhÃ´ng fetch comments cho Ä‘áº¿n khi ngÆ°á»i dÃ¹ng chá»n post

</details>

---

### â­â­â­â­â­ Level 5: Production Challenge (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Dashboard vá»›i Multiple Data Sources
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * XÃ¢y dá»±ng analytics dashboard fetch tá»« nhiá»u endpoints:
 * 1. User stats
 * 2. Post stats
 * 3. Comment stats
 * 4. Todo completion stats
 * 5. Album/Photo stats
 *
 * ğŸ—ï¸ Technical Design:
 *
 * 1. Component Architecture:
 *    - Dashboard (parent)
 *    - StatCard (reusable display)
 *    - Each stat fetched independently
 *
 * 2. State Strategy:
 *    - Individual loading/error states per stat
 *    - Global "allLoaded" state
 *    - Refresh mechanism
 *
 * 3. Data Fetching:
 *    - Parallel fetches (not sequential!)
 *    - Error handling per endpoint
 *    - Retry failed fetches
 *
 * 4. Performance:
 *    - Show partial data as it loads
 *    - Don't block entire UI on one failure
 *    - Cache data (localStorage)
 *
 * 5. UX:
 *    - Skeleton loaders
 *    - Progressive enhancement
 *    - Refresh button
 *    - Last updated timestamp
 *
 * âœ… Production Checklist:
 * - [ ] Parallel data fetching
 * - [ ] Individual error handling
 * - [ ] Loading states per stat
 * - [ ] Retry mechanism
 * - [ ] Refresh all data
 * - [ ] localStorage caching
 * - [ ] Timestamp display
 * - [ ] Responsive grid
 * - [ ] Error recovery
 */

import { useState, useEffect } from "react";

const API_BASE = "https://jsonplaceholder.typicode.com";

// Reusable StatCard component
function StatCard({ title, value, icon, loading, error, onRetry }) {
  if (loading) {
    return (
      <div
        style={{
          padding: "20px",
          background: "#f5f5f5",
          borderRadius: "8px",
          textAlign: "center",
        }}
      >
        <div style={{ fontSize: "32px", marginBottom: "10px" }}>â³</div>
        <div>Loading...</div>
      </div>
    );
  }

  if (error) {
    return (
      <div
        style={{
          padding: "20px",
          background: "#fff0f0",
          border: "2px solid #f44336",
          borderRadius: "8px",
          textAlign: "center",
        }}
      >
        <div style={{ fontSize: "32px", marginBottom: "10px" }}>âŒ</div>
        <div style={{ color: "#f44336", marginBottom: "10px" }}>{error}</div>
        <button
          onClick={onRetry}
          style={{
            padding: "5px 15px",
            background: "#4CAF50",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div
      style={{
        padding: "20px",
        background: "white",
        border: "2px solid #4CAF50",
        borderRadius: "8px",
        textAlign: "center",
      }}
    >
      <div style={{ fontSize: "32px", marginBottom: "10px" }}>{icon}</div>
      <div style={{ fontSize: "12px", color: "#666", marginBottom: "5px" }}>
        {title}
      </div>
      <div style={{ fontSize: "32px", fontWeight: "bold", color: "#4CAF50" }}>
        {value}
      </div>
    </div>
  );
}

function AnalyticsDashboard() {
  // Stats data
  const [stats, setStats] = useState({
    users: { value: null, loading: true, error: null },
    posts: { value: null, loading: true, error: null },
    comments: { value: null, loading: true, error: null },
    todos: { value: null, loading: true, error: null },
    albums: { value: null, loading: true, error: null },
  });

  // Global state
  const [lastUpdated, setLastUpdated] = useState(null);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // Generic fetch function
  const fetchStat = async (endpoint, statKey) => {
    try {
      console.log(`ğŸ“¥ Fetching ${statKey}...`);

      // Update loading state
      setStats((prev) => ({
        ...prev,
        [statKey]: { ...prev[statKey], loading: true, error: null },
      }));

      const response = await fetch(`${API_BASE}/${endpoint}`);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();
      const value = Array.isArray(data) ? data.length : data;

      console.log(`âœ… ${statKey}: ${value}`);

      // Update success state
      setStats((prev) => ({
        ...prev,
        [statKey]: { value, loading: false, error: null },
      }));

      // Cache to localStorage
      try {
        localStorage.setItem(
          `stat_${statKey}`,
          JSON.stringify({ value, timestamp: Date.now() }),
        );
      } catch (err) {
        console.warn("localStorage error:", err);
      }
    } catch (err) {
      console.error(`âŒ ${statKey} error:`, err.message);

      // Update error state
      setStats((prev) => ({
        ...prev,
        [statKey]: { value: null, loading: false, error: err.message },
      }));
    }
  };

  // Effect: Fetch all stats
  useEffect(() => {
    console.log("ğŸ”„ Fetching all stats...");

    // Load cached data first
    Object.keys(stats).forEach((key) => {
      try {
        const cached = localStorage.getItem(`stat_${key}`);
        if (cached) {
          const { value, timestamp } = JSON.parse(cached);
          const age = Date.now() - timestamp;

          // Use cache if < 5 minutes old
          if (age < 5 * 60 * 1000) {
            setStats((prev) => ({
              ...prev,
              [key]: { value, loading: false, error: null },
            }));
          }
        }
      } catch (err) {
        console.warn("Cache load error:", err);
      }
    });

    // Fetch all in parallel
    Promise.all([
      fetchStat("users", "users"),
      fetchStat("posts", "posts"),
      fetchStat("comments", "comments"),
      fetchStat("todos", "todos"),
      fetchStat("albums", "albums"),
    ]).then(() => {
      setLastUpdated(new Date());
      console.log("âœ… All stats loaded");
    });
  }, [refreshTrigger]); // Refetch when refreshTrigger changes

  const handleRefresh = () => {
    setRefreshTrigger((prev) => prev + 1);
  };

  const handleRetry = (statKey, endpoint) => {
    fetchStat(endpoint, statKey);
  };

  // Check if all loaded
  const allLoaded = Object.values(stats).every((stat) => !stat.loading);
  const anyError = Object.values(stats).some((stat) => stat.error);

  return (
    <div style={{ maxWidth: "1200px", margin: "0 auto", padding: "20px" }}>
      {/* Header */}
      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          marginBottom: "30px",
        }}
      >
        <div>
          <h2 style={{ margin: 0 }}>Analytics Dashboard</h2>
          {lastUpdated && (
            <p style={{ margin: "5px 0 0 0", color: "#666", fontSize: "14px" }}>
              Last updated: {lastUpdated.toLocaleTimeString()}
            </p>
          )}
        </div>

        <button
          onClick={handleRefresh}
          style={{
            padding: "10px 20px",
            background: "#4CAF50",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
            fontSize: "16px",
          }}
        >
          ğŸ”„ Refresh All
        </button>
      </div>

      {/* Status Bar */}
      <div
        style={{
          padding: "15px",
          background: allLoaded
            ? anyError
              ? "#fff3cd"
              : "#d4edda"
            : "#cfe2ff",
          border: `2px solid ${allLoaded ? (anyError ? "#ffc107" : "#4CAF50") : "#2196F3"}`,
          borderRadius: "4px",
          marginBottom: "20px",
          textAlign: "center",
        }}
      >
        {!allLoaded && "â³ Loading stats..."}
        {allLoaded && !anyError && "âœ… All stats loaded successfully"}
        {allLoaded && anyError && "âš ï¸ Some stats failed to load"}
      </div>

      {/* Stats Grid */}
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))",
          gap: "20px",
          marginBottom: "30px",
        }}
      >
        <StatCard
          title="Total Users"
          value={stats.users.value}
          icon="ğŸ‘¥"
          loading={stats.users.loading}
          error={stats.users.error}
          onRetry={() => handleRetry("users", "users")}
        />

        <StatCard
          title="Total Posts"
          value={stats.posts.value}
          icon="ğŸ“"
          loading={stats.posts.loading}
          error={stats.posts.error}
          onRetry={() => handleRetry("posts", "posts")}
        />

        <StatCard
          title="Total Comments"
          value={stats.comments.value}
          icon="ğŸ’¬"
          loading={stats.comments.loading}
          error={stats.comments.error}
          onRetry={() => handleRetry("comments", "comments")}
        />

        <StatCard
          title="Total Todos"
          value={stats.todos.value}
          icon="âœ“"
          loading={stats.todos.loading}
          error={stats.todos.error}
          onRetry={() => handleRetry("todos", "todos")}
        />

        <StatCard
          title="Total Albums"
          value={stats.albums.value}
          icon="ğŸ“¸"
          loading={stats.albums.loading}
          error={stats.albums.error}
          onRetry={() => handleRetry("albums", "albums")}
        />
      </div>

      {/* Technical Details */}
      <div
        style={{
          padding: "20px",
          background: "#f0f0f0",
          borderRadius: "8px",
        }}
      >
        <h3>ğŸ—ï¸ Technical Implementation:</h3>

        <h4>Parallel Fetching:</h4>
        <pre
          style={{
            background: "white",
            padding: "10px",
            borderRadius: "4px",
            overflow: "auto",
          }}
        >
          {`Promise.all([
  fetchStat('users', 'users'),
  fetchStat('posts', 'posts'),
  fetchStat('comments', 'comments'),
  fetchStat('todos', 'todos'),
  fetchStat('albums', 'albums'),
]);

// All requests fire simultaneously!
// Don't wait for one to finish before starting next`}
        </pre>

        <h4>Key Features:</h4>
        <ul>
          <li>
            âœ… <strong>Parallel fetching:</strong> All endpoints called at once
          </li>
          <li>
            âœ… <strong>Individual states:</strong> Each stat has own
            loading/error
          </li>
          <li>
            âœ… <strong>Progressive display:</strong> Show data as it arrives
          </li>
          <li>
            âœ… <strong>Error recovery:</strong> Retry button per stat
          </li>
          <li>
            âœ… <strong>localStorage cache:</strong> Fast initial load
          </li>
          <li>
            âœ… <strong>Refresh mechanism:</strong> Refetch all data
          </li>
        </ul>

        <h4>State Structure:</h4>
        <pre
          style={{
            background: "white",
            padding: "10px",
            borderRadius: "4px",
            overflow: "auto",
          }}
        >
          {`stats = {
  users: { value: 10, loading: false, error: null },
  posts: { value: 100, loading: false, error: null },
  comments: { value: 500, loading: true, error: null },
  // ... etc
}`}
        </pre>
      </div>
    </div>
  );
}

export default AnalyticsDashboard;

// ğŸ“‹ TESTING CHECKLIST:
// - [ ] All stats load on mount
// - [ ] Loading states show while fetching
// - [ ] Stats display when loaded
// - [ ] Error states show for failed fetches
// - [ ] Retry button refetches failed stat
// - [ ] Refresh All button refetches everything
// - [ ] localStorage caching works (check DevTools)
// - [ ] Timestamp updates after refresh
// - [ ] Status bar shows correct state
// - [ ] Partial failures handled gracefully
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * AnalyticsDashboard - Level 5: Production-ready dashboard with multiple parallel data sources
 * - Parallel fetching from 5 different endpoints
 * - Individual loading/error/retry states per statistic
 * - Global refresh button + per-stat retry
 * - Basic localStorage caching (5-minute TTL)
 * - Last updated timestamp
 * - Progressive loading (show data as soon as available)
 */
import { useState, useEffect } from "react";

const API_BASE = "https://jsonplaceholder.typicode.com";

function StatCard({ title, value, icon, loading, error, onRetry }) {
  if (loading) {
    return (
      <div
        style={{
          padding: "20px",
          background: "#f5f5f5",
          borderRadius: "8px",
          textAlign: "center",
        }}
      >
        Loading {title}...
      </div>
    );
  }

  if (error) {
    return (
      <div
        style={{
          padding: "20px",
          background: "#fff0f0",
          border: "1px solid #f44336",
          borderRadius: "8px",
          textAlign: "center",
        }}
      >
        <div style={{ color: "#f44336", marginBottom: "8px" }}>
          Error loading {title}
        </div>
        <div style={{ fontSize: "0.9rem", marginBottom: "12px" }}>{error}</div>
        <button
          onClick={onRetry}
          style={{
            padding: "6px 16px",
            background: "#4CAF50",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div
      style={{
        padding: "20px",
        background: "white",
        border: "1px solid #4CAF50",
        borderRadius: "8px",
        textAlign: "center",
      }}
    >
      <div style={{ fontSize: "2.5rem", marginBottom: "8px" }}>{icon}</div>
      <div style={{ fontSize: "0.9rem", color: "#666", marginBottom: "4px" }}>
        {title}
      </div>
      <div style={{ fontSize: "2.2rem", fontWeight: "bold", color: "#4CAF50" }}>
        {value !== null ? value.toLocaleString() : "â€”"}
      </div>
    </div>
  );
}

function AnalyticsDashboard() {
  const [stats, setStats] = useState({
    users: { value: null, loading: true, error: null },
    posts: { value: null, loading: true, error: null },
    comments: { value: null, loading: true, error: null },
    todos: { value: null, loading: true, error: null },
    albums: { value: null, loading: true, error: null },
  });

  const [lastUpdated, setLastUpdated] = useState(null);
  const [refreshTrigger, setRefreshTrigger] = useState(0);

  // Helper to fetch one statistic
  const fetchStat = async (endpoint, key) => {
    try {
      // Update state to loading
      setStats((prev) => ({
        ...prev,
        [key]: { ...prev[key], loading: true, error: null },
      }));

      const response = await fetch(`${API_BASE}/${endpoint}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      const data = await response.json();
      const count = Array.isArray(data) ? data.length : 0;

      setStats((prev) => ({
        ...prev,
        [key]: { value: count, loading: false, error: null },
      }));

      // Cache
      try {
        localStorage.setItem(
          `stat_${key}`,
          JSON.stringify({ value: count, timestamp: Date.now() }),
        );
      } catch (e) {
        // silent fail
      }
    } catch (err) {
      setStats((prev) => ({
        ...prev,
        [key]: { value: null, loading: false, error: err.message },
      }));
    }
  };

  // Load from cache + fetch fresh data
  useEffect(() => {
    // Try to load from cache first (fast initial render)
    const keys = ["users", "posts", "comments", "todos", "albums"];
    keys.forEach((key) => {
      try {
        const cached = localStorage.getItem(`stat_${key}`);
        if (cached) {
          const { value, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp < 5 * 60 * 1000) {
            // 5 minutes
            setStats((prev) => ({
              ...prev,
              [key]: { value, loading: false, error: null },
            }));
          }
        }
      } catch (e) {
        // ignore cache errors
      }
    });

    // Then fetch fresh data in parallel
    const fetches = [
      fetchStat("users", "users"),
      fetchStat("posts", "posts"),
      fetchStat("comments", "comments"),
      fetchStat("todos", "todos"),
      fetchStat("albums", "albums"),
    ];

    Promise.all(fetches).then(() => {
      setLastUpdated(new Date());
    });
  }, [refreshTrigger]);

  const handleRefresh = () => {
    setRefreshTrigger((prev) => prev + 1);
  };

  const handleRetry = (key, endpoint) => {
    fetchStat(endpoint, key);
  };

  const allLoaded = Object.values(stats).every((s) => !s.loading);
  const hasError = Object.values(stats).some((s) => s.error !== null);

  return (
    <div style={{ maxWidth: "1200px", margin: "0 auto", padding: "20px" }}>
      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          marginBottom: "24px",
        }}
      >
        <div>
          <h2>Analytics Dashboard</h2>
          {lastUpdated && (
            <p
              style={{ color: "#666", fontSize: "0.9rem", margin: "4px 0 0 0" }}
            >
              Last updated: {lastUpdated.toLocaleTimeString()}
            </p>
          )}
        </div>
        <button
          onClick={handleRefresh}
          style={{
            padding: "10px 20px",
            background: "#2196F3",
            color: "white",
            border: "none",
            borderRadius: "6px",
            cursor: "pointer",
          }}
        >
          Refresh All
        </button>
      </div>

      <div
        style={{
          padding: "12px",
          marginBottom: "24px",
          background: allLoaded
            ? hasError
              ? "#fff3cd"
              : "#e8f5e9"
            : "#e3f2fd",
          border: `1px solid ${allLoaded ? (hasError ? "#ffb74d" : "#81c784") : "#64b5f6"}`,
          borderRadius: "6px",
          textAlign: "center",
          fontWeight: "500",
        }}
      >
        {!allLoaded && "Loading dashboard data..."}
        {allLoaded && !hasError && "All statistics loaded successfully"}
        {allLoaded &&
          hasError &&
          "Some statistics failed to load â€” check individual cards"}
      </div>

      <div
        style={{
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))",
          gap: "20px",
        }}
      >
        <StatCard
          title="Total Users"
          value={stats.users.value}
          icon="ğŸ‘¤"
          loading={stats.users.loading}
          error={stats.users.error}
          onRetry={() => handleRetry("users", "users")}
        />
        <StatCard
          title="Total Posts"
          value={stats.posts.value}
          icon="ğŸ“"
          loading={stats.posts.loading}
          error={stats.posts.error}
          onRetry={() => handleRetry("posts", "posts")}
        />
        <StatCard
          title="Total Comments"
          value={stats.comments.value}
          icon="ğŸ’¬"
          loading={stats.comments.loading}
          error={stats.comments.error}
          onRetry={() => handleRetry("comments", "comments")}
        />
        <StatCard
          title="Total Todos"
          value={stats.todos.value}
          icon="âœ“"
          loading={stats.todos.loading}
          error={stats.todos.error}
          onRetry={() => handleRetry("todos", "todos")}
        />
        <StatCard
          title="Total Albums"
          value={stats.albums.value}
          icon="ğŸ“€"
          loading={stats.albums.loading}
          error={stats.albums.error}
          onRetry={() => handleRetry("albums", "albums")}
        />
      </div>
    </div>
  );
}

export default AnalyticsDashboard;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi cháº¡y:**

- Láº§n Ä‘áº§u má»Ÿ:
  - Táº¥t cáº£ card hiá»ƒn thá»‹ "Loading ..." ráº¥t nhanh (náº¿u cÃ³ cache) hoáº·c báº¯t Ä‘áº§u fetch
  - Dáº§n dáº§n tá»«ng card hoÃ n thÃ nh (do parallel fetch) â†’ sá»‘ liá»‡u xuáº¥t hiá»‡n láº§n lÆ°á»£t
  - VÃ­ dá»¥: Total Users: 10, Total Posts: 100, Total Comments: 500, Total Todos: 200, Total Albums: 100

- Nháº¥n "Refresh All" â†’ táº¥t cáº£ card quay vá» loading â†’ fetch láº¡i â†’ cáº­p nháº­t timestamp

- Náº¿u má»™t endpoint lá»—i (giáº£ sá»­ máº¡ng cháº­p chá»n):
  - Chá»‰ card Ä‘Ã³ hiá»ƒn thá»‹ lá»—i + nÃºt Retry
  - CÃ¡c card khÃ¡c váº«n hiá»ƒn thá»‹ bÃ¬nh thÆ°á»ng
  - Status bar chuyá»ƒn sang mÃ u vÃ ng + thÃ´ng bÃ¡o "Some statistics failed to load"

- Sau 5 phÃºt, refresh láº¡i â†’ dÃ¹ng dá»¯ liá»‡u cache cÅ© cho Ä‘áº¿n khi fetch má»›i hoÃ n táº¥t

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh: fetch Patterns

| Pattern           | Code                                                           | Pros                             | Cons                                         | Use Case           |
| ----------------- | -------------------------------------------------------------- | -------------------------------- | -------------------------------------------- | ------------------ |
| **.then() chain** | `fetch(url).then(res => res.json()).then(setData)`             | âœ… Simple<br>âœ… No async wrapper | âŒ Callback hell<br>âŒ Harder error handling | Simple fetches     |
| **async/await**   | `const res = await fetch(url); const data = await res.json();` | âœ… Readable<br>âœ… try/catch      | âŒ Need wrapper function                     | Complex logic      |
| **Promise.all**   | `Promise.all([fetch(url1), fetch(url2)])`                      | âœ… Parallel<br>âœ… Fast           | âŒ All-or-nothing                            | Multiple endpoints |

### Báº£ng So SÃ¡nh: State Patterns

| States                  | Code                                                                                                                                        | Pros                                    | Cons                    | When to Use        |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------- | ----------------------- | ------------------ |
| **3 separate states**   | `const [data, setData] = useState(null);`<br>`const [loading, setLoading] = useState(true);`<br>`const [error, setError] = useState(null);` | âœ… Clear<br>âœ… Easy to understand       | âŒ 3 setStates          | Standard approach  |
| **Single state object** | `const [state, setState] = useState({ data: null, loading: true, error: null });`                                                           | âœ… Atomic updates<br>âœ… Fewer setStates | âŒ More verbose updates | Complex state      |
| **useReducer**          | `const [state, dispatch] = useReducer(reducer, initialState);`                                                                              | âœ… Predictable<br>âœ… Testable           | âŒ More boilerplate     | Will learn NgÃ y 12 |

### Decision Tree: Khi nÃ o fetch data?

```
Component cáº§n data tá»« API?
â”‚
â”œâ”€ Data STATIC (khÃ´ng Ä‘á»•i theo props)?
â”‚  â†’ useEffect(() => fetch(), [])
â”‚  â†’ Fetch once on mount
â”‚  â†’ Example: App configuration, static lists
â”‚
â”œâ”€ Data depends on PROPS/STATE?
â”‚  â†’ useEffect(() => fetch(), [prop, state])
â”‚  â†’ Refetch khi deps thay Ä‘á»•i
â”‚  â†’ Example: User profile (depends on userId)
â”‚
â”œâ”€ Data from USER ACTION (click, submit)?
â”‚  â”‚
â”‚  â”œâ”€ Needs to refetch automatically sau action?
â”‚  â”‚  â†’ Event handler + state update + useEffect
â”‚  â”‚  â†’ Example: Delete item â†’ Refetch list
â”‚  â”‚
â”‚  â””â”€ One-time fetch (khÃ´ng cáº§n refetch)?
â”‚     â†’ fetch trong event handler trá»±c tiáº¿p
â”‚     â†’ Example: Submit form â†’ POST data
â”‚
â””â”€ NHIá»€U data sources cÃ¹ng lÃºc?
   â”‚
   â”œâ”€ Sequential (A depends on B)?
   â”‚  â†’ useEffect chain hoáº·c nested effects (NgÃ y 20)
   â”‚
   â””â”€ Parallel (independent)?
      â†’ Promise.all() trong 1 effect
      â†’ Example: Dashboard stats
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug #1: Missing response.ok Check ğŸš¨

```jsx
/**
 * ğŸ› BUG: 404/500 errors khÃ´ng Ä‘Æ°á»£c catch
 * ğŸ¯ Nhiá»‡m vá»¥: Add proper error handling
 */

function BuggyUserFetch({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // âŒ BUG: KhÃ´ng check response.ok
    fetch(`/api/users/${userId}`)
      .then((res) => res.json()) // Parse JSON even if 404!
      .then((data) => {
        setUser(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);

  // Render...
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. userId = 999 (khÃ´ng tá»“n táº¡i) â†’ Response 404
// 2. .then(res => res.json()) cÃ³ cháº¡y khÃ´ng?
// 3. data lÃ  gÃ¬? setUser(data) tháº¿ nÃ o?
// 4. .catch() cÃ³ báº¯t Ä‘Æ°á»£c error khÃ´ng?

// ğŸ’¡ GIáº¢I THÃCH:
// - fetch() chá»‰ reject vá»›i NETWORK errors (no internet, DNS fail, etc.)
// - HTTP errors (404, 500) â†’ fetch resolves successfully!
// - res.json() váº«n cháº¡y, parse error message tá»« server
// - data = { error: "User not found" } â†’ setUser vá»›i error object!
// - UI hiá»ƒn thá»‹ "undefined" hoáº·c crash

// âœ… FIX: Check response.ok
function Fixed({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchUser() {
      try {
        const response = await fetch(`/api/users/${userId}`);

        // âœ… Check response.ok BEFORE parsing
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        setUser(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]);

  // Render...
}

// ğŸ“ BÃ€I Há»ŒC:
// - LUÃ”N check response.ok trÆ°á»›c khi parse
// - fetch khÃ´ng auto-throw cho HTTP errors
// - HTTP errors cáº§n handle manually
```

---

### Bug #2: setState After Unmount âš ï¸

```jsx
/**
 * ğŸ› BUG: setState trÃªn unmounted component
 * ğŸ¯ Nhiá»‡m vá»¥: Add cleanup flag
 */

function BuggySlowFetch({ endpoint }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // âŒ No cleanup!
    async function fetchData() {
      const response = await fetch(endpoint);
      const data = await response.json();

      // Sau 3 giÃ¢y, náº¿u component unmount â†’ Warning!
      setTimeout(() => {
        setData(data);
        setLoading(false);
      }, 3000);
    }

    fetchData();
  }, [endpoint]);

  // Render...
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. Component mount â†’ Fetch starts
// 2. User navigates away sau 1 giÃ¢y â†’ Component unmounts
// 3. 2 giÃ¢y sau (total 3s) â†’ setTimeout callback runs
// 4. GÃ¬ xáº£y ra?

// ğŸ’¡ GIáº¢I THÃCH:
// - setTimeout callback váº«n cháº¡y sau unmount
// - setData() + setLoading() called on unmounted component
// - React warning: "Can't perform a React state update on an unmounted component"
// - Memory leak potential

// âœ… FIX: Cleanup flag
function Fixed({ endpoint }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    let isCancelled = false; // â† Cleanup flag

    async function fetchData() {
      const response = await fetch(endpoint);
      const data = await response.json();

      setTimeout(() => {
        // âœ… Only setState if not cancelled
        if (!isCancelled) {
          setData(data);
          setLoading(false);
        }
      }, 3000);
    }

    fetchData();

    // Cleanup: Set flag
    return () => {
      isCancelled = true;
    };
  }, [endpoint]);

  // Render...
}

// ğŸ“ BÃ€I Há»ŒC:
// - Async operations cáº§n cleanup flag
// - Check flag trÆ°á»›c má»i setState
// - Prevents warnings vÃ  memory leaks
```

---

### Bug #3: Infinite Fetch Loop ğŸ”

```jsx
/**
 * ğŸ› BUG: Fetch trigger infinite re-renders
 * ğŸ¯ Nhiá»‡m vá»¥: Fix dependencies
 */

function BuggyFilteredList() {
  const [items, setItems] = useState([]);
  const [filter, setFilter] = useState({ category: "all" });

  useEffect(() => {
    // âŒ BUG: filter object trong deps
    async function fetchItems() {
      const response = await fetch(`/api/items?category=${filter.category}`);
      const data = await response.json();
      setItems(data);
    }

    fetchItems();
  }, [filter]); // â† filter is an object!

  const handleFilter = (category) => {
    // âŒ Creates NEW object â†’ filter ref changes â†’ Effect re-runs
    setFilter({ category });
  };

  // Render...
}

// ğŸ¤” CÃ‚U Há»I DEBUG:
// 1. Initial render â†’ filter = { category: 'all' }
// 2. Effect runs â†’ Fetch items
// 3. Click filter "electronics" â†’ setFilter({ category: 'electronics' })
// 4. filter object reference thay Ä‘á»•i?
// 5. Effect re-run â†’ Expected
// 6. NhÆ°ng náº¿u click "electronics" láº§n 2?

// ğŸ’¡ GIáº¢I THÃCH:
// - setFilter({ category: 'electronics' }) creates NEW object
// - Even same values â†’ Different reference
// - React compares deps with Object.is() (===)
// - { category: 'electronics' } !== { category: 'electronics' }
// - Effect re-runs unnecessarily!
// - If fetching triggers filter update â†’ Infinite loop

// âœ… FIX #1: Use primitive value
function FixedV1() {
  const [items, setItems] = useState([]);
  const [category, setCategory] = useState("all"); // â† Primitive!

  useEffect(() => {
    async function fetchItems() {
      const response = await fetch(`/api/items?category=${category}`);
      const data = await response.json();
      setItems(data);
    }

    fetchItems();
  }, [category]); // â† Primitive comparison

  const handleFilter = (newCategory) => {
    setCategory(newCategory); // String comparison works!
  };

  // Render...
}

// âœ… FIX #2: Extract object property
function FixedV2() {
  const [items, setItems] = useState([]);
  const [filter, setFilter] = useState({ category: "all" });

  useEffect(() => {
    async function fetchItems() {
      const response = await fetch(`/api/items?category=${filter.category}`);
      const data = await response.json();
      setItems(data);
    }

    fetchItems();
  }, [filter.category]); // â† Primitive property!

  // Render...
}

// ğŸ“ BÃ€I Há»ŒC:
// - Avoid objects/arrays trong deps
// - Use primitive values (string, number, boolean)
// - Extract object properties náº¿u cáº§n
// - useMemo (NgÃ y 28) cho complex objects
```

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

ÄÃ¡nh dáº¥u âœ… nhá»¯ng Ä‘iá»u báº¡n Ä‘Ã£ hiá»ƒu:

#### Concepts:

- [ ] TÃ´i hiá»ƒu fetch API return Promise
- [ ] TÃ´i biáº¿t check response.ok cho HTTP errors
- [ ] TÃ´i hiá»ƒu 3 states pattern (data, loading, error)
- [ ] TÃ´i biáº¿t khi nÃ o dÃ¹ng .then() vs async/await
- [ ] TÃ´i hiá»ƒu dependencies trigger refetch

#### Practices:

- [ ] TÃ´i cÃ³ thá»ƒ fetch data trong useEffect
- [ ] TÃ´i implement loading/error states properly
- [ ] TÃ´i handle HTTP errors correctly
- [ ] TÃ´i biáº¿t refetch khi props/state thay Ä‘á»•i
- [ ] TÃ´i trÃ¡nh Ä‘Æ°á»£c infinite loops

#### Debugging:

- [ ] TÃ´i nháº­n biáº¿t Ä‘Æ°á»£c missing response.ok check
- [ ] TÃ´i biáº¿t fix setState after unmount
- [ ] TÃ´i hiá»ƒu object dependencies gÃ¢y re-fetch
- [ ] TÃ´i cÃ³ thá»ƒ debug fetch failures
- [ ] TÃ´i trace Ä‘Æ°á»£c data flow

---

### Code Review Checklist

Khi review data fetching code:

#### Fetch Logic:

- [ ] fetch trong useEffect (khÃ´ng pháº£i render)
- [ ] response.ok checked before parsing
- [ ] try/catch hoáº·c .catch() error handling
- [ ] Dependencies array Ä‘Ãºng

#### State Management:

- [ ] 3 states: data, loading, error
- [ ] States reset khi refetch
- [ ] Conditional rendering based on states
- [ ] No setState after unmount

#### Error Handling:

- [ ] Network errors caught
- [ ] HTTP errors caught (response.ok)
- [ ] Error messages displayed to user
- [ ] Retry mechanism (optional)

#### Performance:

- [ ] No unnecessary refetches
- [ ] Primitive dependencies (not objects)
- [ ] Cleanup for async operations
- [ ] Loading states prevent multiple clicks

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**BÃ i 1: Weather App**

```jsx
/**
 * Táº¡o weather app:
 * - Fetch weather data tá»« API
 * - Display current temperature, conditions
 * - Search by city name
 * - Loading/Error states
 *
 * API: https://api.openweathermap.org/data/2.5/weather?q=London&appid=YOUR_KEY
 * (Hoáº·c dÃ¹ng mock data náº¿u khÃ´ng cÃ³ API key)
 *
 * Requirements:
 * - Input field cho city name
 * - Fetch khi user submit
 * - Display weather info
 * - Handle errors (city not found)
 */
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * WeatherApp - BÃ i táº­p vá» nhÃ  1: Weather information by city
 * - Input city name â†’ fetch weather data on submit
 * - Display temperature, condition, feels like, humidity, wind
 * - Loading and error states
 * - Simple responsive layout
 *
 * API: Open-Meteo (free, no key needed)
 * Endpoint: https://api.open-meteo.com/v1/forecast?latitude=...&longitude=...&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m
 *
 * Note: VÃ¬ jsonplaceholder khÃ´ng cÃ³ weather, dÃ¹ng Open-Meteo + geocode qua Nominatim
 */
import { useState } from "react";

function WeatherApp() {
  const [city, setCity] = useState("");
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchWeather = async (cityName) => {
    if (!cityName.trim()) return;

    setLoading(true);
    setError(null);
    setWeather(null);

    try {
      // BÆ°á»›c 1: Geocode city â†’ lat/lon (dÃ¹ng Nominatim - OpenStreetMap)
      const geoRes = await fetch(
        `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(cityName)}&format=json&limit=1`,
      );
      if (!geoRes.ok) throw new Error("KhÃ´ng tÃ¬m tháº¥y thÃ nh phá»‘");
      const geoData = await geoRes.json();

      if (geoData.length === 0) {
        throw new Error(`KhÃ´ng tÃ¬m tháº¥y "${cityName}"`);
      }

      const { lat, lon } = geoData[0];

      // BÆ°á»›c 2: Fetch weather tá»« Open-Meteo
      const weatherRes = await fetch(
        `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m&timezone=auto`,
      );
      if (!weatherRes.ok) throw new Error("Lá»—i khi láº¥y dá»¯ liá»‡u thá»i tiáº¿t");
      const weatherData = await weatherRes.json();

      const current = weatherData.current;

      setWeather({
        city: geoData[0].display_name.split(",")[0],
        temperature: current.temperature_2m,
        feelsLike: current.apparent_temperature,
        humidity: current.relative_humidity_2m,
        windSpeed: current.wind_speed_10m,
        condition: getWeatherCondition(current.weather_code),
        time: new Date(current.time).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        }),
      });
    } catch (err) {
      setError(err.message || "CÃ³ lá»—i xáº£y ra. Vui lÃ²ng thá»­ láº¡i.");
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    fetchWeather(city);
  };

  // Simple weather code â†’ description (WMO codes)
  const getWeatherCondition = (code) => {
    const conditions = {
      0: "Trá»i quang Ä‘Ã£ng",
      1: "Ãt mÃ¢y",
      2: "MÃ¢y ráº£i rÃ¡c",
      3: "Nhiá»u mÃ¢y",
      45: "SÆ°Æ¡ng mÃ¹",
      51: "MÆ°a phÃ¹n nháº¹",
      61: "MÆ°a nháº¹",
      63: "MÆ°a vá»«a",
      71: "Tuyáº¿t nháº¹",
      80: "MÆ°a rÃ o nháº¹",
      95: "CÃ³ sáº¥m sÃ©t",
    };
    return conditions[code] || "KhÃ´ng xÃ¡c Ä‘á»‹nh";
  };

  return (
    <div
      style={{
        maxWidth: "500px",
        margin: "40px auto",
        padding: "20px",
        textAlign: "center",
      }}
    >
      <h1>Weather App</h1>

      <form onSubmit={handleSubmit} style={{ marginBottom: "24px" }}>
        <input
          type="text"
          value={city}
          onChange={(e) => setCity(e.target.value)}
          placeholder="Nháº­p tÃªn thÃ nh phá»‘ (vÃ­ dá»¥: Hanoi, Saigon, London)"
          style={{
            width: "100%",
            padding: "12px",
            fontSize: "16px",
            borderRadius: "6px",
            border: "1px solid #ccc",
            marginBottom: "12px",
          }}
        />
        <button
          type="submit"
          disabled={loading || !city.trim()}
          style={{
            padding: "12px 24px",
            fontSize: "16px",
            background: loading ? "#ccc" : "#2196F3",
            color: "white",
            border: "none",
            borderRadius: "6px",
            cursor: loading ? "not-allowed" : "pointer",
          }}
        >
          {loading ? "Äang táº£i..." : "Xem thá»i tiáº¿t"}
        </button>
      </form>

      {error && (
        <div
          style={{
            color: "red",
            margin: "20px 0",
            padding: "12px",
            background: "#ffebee",
            borderRadius: "6px",
          }}
        >
          {error}
        </div>
      )}

      {weather && (
        <div
          style={{
            padding: "24px",
            background: "linear-gradient(135deg, #e3f2fd, #bbdefb)",
            borderRadius: "12px",
            boxShadow: "0 4px 12px rgba(0,0,0,0.1)",
          }}
        >
          <h2>{weather.city}</h2>
          <p
            style={{ fontSize: "0.95rem", color: "#555", marginBottom: "16px" }}
          >
            Cáº­p nháº­t lÃºc: {weather.time}
          </p>

          <div
            style={{ fontSize: "3.5rem", fontWeight: "bold", margin: "16px 0" }}
          >
            {weather.temperature}Â°C
          </div>

          <div style={{ fontSize: "1.4rem", marginBottom: "20px" }}>
            {weather.condition}
          </div>

          <div
            style={{
              display: "grid",
              gridTemplateColumns: "1fr 1fr",
              gap: "16px",
              fontSize: "1.1rem",
            }}
          >
            <div>
              <strong>Cáº£m giÃ¡c nhÆ°:</strong> {weather.feelsLike}Â°C
            </div>
            <div>
              <strong>Äá»™ áº©m:</strong> {weather.humidity}%
            </div>
            <div>
              <strong>GiÃ³:</strong> {weather.windSpeed} km/h
            </div>
          </div>
        </div>
      )}

      {!weather && !error && !loading && (
        <div style={{ color: "#777", marginTop: "40px" }}>
          Nháº­p tÃªn thÃ nh phá»‘ vÃ  nháº¥n "Xem thá»i tiáº¿t"
        </div>
      )}
    </div>
  );
}

export default WeatherApp;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi cháº¡y:**

- Nháº­p "Hanoi" â†’ nháº¥n Xem thá»i tiáº¿t  
  â†’ Hiá»ƒn thá»‹:  
  Hanoi  
  Cáº­p nháº­t lÃºc: 14:30  
  28Â°C  
  Trá»i quang Ä‘Ã£ng / MÆ°a nháº¹ / ...  
  Cáº£m giÃ¡c nhÆ°: 30Â°C  
  Äá»™ áº©m: 75%  
  GiÃ³: 12 km/h

- Nháº­p "Paris" â†’ tÆ°Æ¡ng tá»± vá»›i dá»¯ liá»‡u Paris
- Nháº­p "abcxyz" â†’ Error: KhÃ´ng tÃ¬m tháº¥y "abcxyz"
- KhÃ´ng nháº­p gÃ¬ â†’ nÃºt disabled
- Khi Ä‘ang fetch â†’ nÃºt chuyá»ƒn thÃ nh "Äang táº£i..." vÃ  disabled

</details>

**BÃ i 2: Product Catalog vá»›i Filter**

```jsx
/**
 * Táº¡o product catalog:
 * - Fetch products tá»« API
 * - Filter by category (dropdown)
 * - Refetch khi category thay Ä‘á»•i
 * - Loading state
 *
 * API: https://fakestoreapi.com/products
 * Categories API: https://fakestoreapi.com/products/categories
 *
 * Requirements:
 * - Fetch categories on mount
 * - Display category dropdown
 * - Fetch products filtered by category
 * - Grid layout
 */
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * ProductCatalog - BÃ i táº­p vá» nhÃ  2: Product catalog with category filter
 * - Fetch all categories on mount
 * - Fetch products filtered by selected category
 * - Dropdown to select category ("All" = no filter)
 * - Loading and error states
 * - Responsive grid layout for products
 *
 * API: https://fakestoreapi.com
 */
import { useState, useEffect } from "react";

function ProductCatalog() {
  const [products, setProducts] = useState([]);
  const [categories, setCategories] = useState([]);
  const [selectedCategory, setSelectedCategory] = useState("all");
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Fetch categories once on mount
  useEffect(() => {
    async function fetchCategories() {
      try {
        const res = await fetch("https://fakestoreapi.com/products/categories");
        if (!res.ok) throw new Error("Failed to load categories");
        const data = await res.json();
        setCategories(["all", ...data]); // ThÃªm "all" vÃ o Ä‘áº§u
      } catch (err) {
        setError(err.message);
      }
    }
    fetchCategories();
  }, []);

  // Fetch products when selectedCategory changes
  useEffect(() => {
    async function fetchProducts() {
      setLoading(true);
      setError(null);

      try {
        let url = "https://fakestoreapi.com/products";
        if (selectedCategory !== "all") {
          url = `https://fakestoreapi.com/products/category/${encodeURIComponent(selectedCategory)}`;
        }

        const res = await fetch(url);
        if (!res.ok) throw new Error("Failed to load products");
        const data = await res.json();
        setProducts(data);
        setLoading(false);
      } catch (err) {
        setError(err.message);
        setLoading(false);
      }
    }

    fetchProducts();
  }, [selectedCategory]);

  const handleCategoryChange = (e) => {
    setSelectedCategory(e.target.value);
  };

  if (error) {
    return (
      <div style={{ color: "red", padding: "20px", textAlign: "center" }}>
        Error: {error}
      </div>
    );
  }

  return (
    <div style={{ maxWidth: "1200px", margin: "0 auto", padding: "20px" }}>
      <h1>Product Catalog</h1>

      <div style={{ marginBottom: "24px" }}>
        <label
          htmlFor="category"
          style={{ marginRight: "12px", fontWeight: "500" }}
        >
          Filter by category:
        </label>
        <select
          id="category"
          value={selectedCategory}
          onChange={handleCategoryChange}
          disabled={loading}
          style={{
            padding: "8px 12px",
            fontSize: "16px",
            borderRadius: "6px",
            border: "1px solid #ccc",
            minWidth: "220px",
          }}
        >
          {categories.map((cat) => (
            <option key={cat} value={cat}>
              {cat === "all"
                ? "All Categories"
                : cat.charAt(0).toUpperCase() + cat.slice(1)}
            </option>
          ))}
        </select>
      </div>

      {loading ? (
        <div
          style={{ textAlign: "center", padding: "60px 0", fontSize: "1.2rem" }}
        >
          Loading products...
        </div>
      ) : products.length === 0 ? (
        <div style={{ textAlign: "center", padding: "40px", color: "#666" }}>
          No products found in this category.
        </div>
      ) : (
        <div
          style={{
            display: "grid",
            gridTemplateColumns: "repeat(auto-fill, minmax(280px, 1fr))",
            gap: "24px",
          }}
        >
          {products.map((product) => (
            <div
              key={product.id}
              style={{
                border: "1px solid #ddd",
                borderRadius: "8px",
                overflow: "hidden",
                background: "white",
                boxShadow: "0 2px 8px rgba(0,0,0,0.1)",
                display: "flex",
                flexDirection: "column",
              }}
            >
              <img
                src={product.image}
                alt={product.title}
                style={{
                  width: "100%",
                  height: "220px",
                  objectFit: "contain",
                  padding: "16px",
                  background: "#f9f9f9",
                }}
              />
              <div
                style={{
                  padding: "16px",
                  flexGrow: 1,
                  display: "flex",
                  flexDirection: "column",
                }}
              >
                <h3
                  style={{
                    margin: "0 0 8px 0",
                    fontSize: "1.1rem",
                    lineHeight: "1.4",
                  }}
                >
                  {product.title}
                </h3>
                <p
                  style={{
                    color: "#555",
                    fontSize: "0.95rem",
                    margin: "0 0 12px 0",
                    flexGrow: 1,
                  }}
                >
                  {product.description.substring(0, 120)}...
                </p>
                <div
                  style={{
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                  }}
                >
                  <span
                    style={{
                      fontSize: "1.3rem",
                      fontWeight: "bold",
                      color: "#2e7d32",
                    }}
                  >
                    ${product.price.toFixed(2)}
                  </span>
                  <span style={{ color: "#757575", fontSize: "0.9rem" }}>
                    {product.category}
                  </span>
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

export default ProductCatalog;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi cháº¡y:**

- Ban Ä‘áº§u: Dropdown cÃ³ "All Categories", "electronics", "jewelery", "men's clothing", "women's clothing"  
  â†’ Hiá»ƒn thá»‹ táº¥t cáº£ ~20 sáº£n pháº©m

- Chá»n "electronics" â†’ Loading... â†’ chá»‰ hiá»‡n 5 sáº£n pháº©m Ä‘iá»‡n tá»­ (MacBook, iPhone, monitor, v.v.)

- Chá»n "women's clothing" â†’ chá»‰ hiá»‡n quáº§n Ã¡o ná»¯

- Chá»n "All Categories" â†’ quay láº¡i toÃ n bá»™ sáº£n pháº©m

- Náº¿u API lá»—i â†’ hiá»ƒn thá»‹ thÃ´ng bÃ¡o lá»—i Ä‘á»
- Grid tá»± Ä‘á»™ng responsive: 4 cá»™t trÃªn mÃ n lá»›n, 2â€“3 cá»™t trÃªn tablet, 1 cá»™t trÃªn mobile

</details>

---

### NÃ¢ng cao (60 phÃºt)

**BÃ i 3: GitHub User Search**

```jsx
/**
 * Táº¡o GitHub user search:
 * - Search users by username
 * - Debounce 500ms
 * - Display user info (avatar, repos, followers)
 * - Link to GitHub profile
 * - Rate limit handling
 *
 * API: https://api.github.com/users/{username}
 *
 * Challenges:
 * - Debounced search
 * - Handle 404 (user not found)
 * - Handle rate limits (403)
 * - Display meaningful errors
 */
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * GitHubUserSearch - BÃ i táº­p vá» nhÃ  3: GitHub user search with debounce
 * - Search GitHub users by username (real-time with debounce 500ms)
 * - Display avatar, name, bio, followers, public repos, location
 * - Handle 404 (user not found), rate limit (403), network errors
 * - Loading state during search
 * - Direct link to GitHub profile
 */
import { useState, useEffect } from "react";

function GitHubUserSearch() {
  const [query, setQuery] = useState("");
  const [debouncedQuery, setDebouncedQuery] = useState("");
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Debounce input
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(query.trim());
    }, 500);

    return () => clearTimeout(timer);
  }, [query]);

  // Fetch user when debounced query changes (and is not empty)
  useEffect(() => {
    if (!debouncedQuery || debouncedQuery.length < 2) {
      setUser(null);
      setError(null);
      return;
    }

    async function fetchUser() {
      setLoading(true);
      setError(null);

      try {
        const response = await fetch(
          `https://api.github.com/users/${debouncedQuery}`,
        );

        if (response.status === 404) {
          throw new Error("User not found");
        }
        if (response.status === 403) {
          throw new Error("Rate limit exceeded. Please try again later.");
        }
        if (!response.ok) {
          throw new Error(`GitHub API error: ${response.status}`);
        }

        const data = await response.json();

        setUser({
          login: data.login,
          name: data.name,
          avatar: data.avatar_url,
          bio: data.bio,
          followers: data.followers,
          repos: data.public_repos,
          location: data.location,
          profileUrl: data.html_url,
          created: new Date(data.created_at).toLocaleDateString(),
        });
      } catch (err) {
        setError(err.message);
        setUser(null);
      } finally {
        setLoading(false);
      }
    }

    fetchUser();
  }, [debouncedQuery]);

  return (
    <div style={{ maxWidth: "600px", margin: "40px auto", padding: "20px" }}>
      <h1>GitHub User Search</h1>

      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Enter GitHub username (e.g. torvalds, octocat)"
        style={{
          width: "100%",
          padding: "12px",
          fontSize: "16px",
          border: "1px solid #ccc",
          borderRadius: "6px",
          marginBottom: "16px",
        }}
      />

      {loading && (
        <div style={{ textAlign: "center", padding: "20px", color: "#666" }}>
          Searching for @{debouncedQuery}...
        </div>
      )}

      {error && (
        <div
          style={{
            padding: "16px",
            background: "#ffebee",
            color: "#c62828",
            borderRadius: "6px",
            margin: "16px 0",
            textAlign: "center",
          }}
        >
          {error}
        </div>
      )}

      {user && (
        <div
          style={{
            border: "1px solid #ddd",
            borderRadius: "12px",
            overflow: "hidden",
            boxShadow: "0 4px 12px rgba(0,0,0,0.1)",
            background: "white",
          }}
        >
          <div
            style={{
              background: "#0366d6",
              padding: "20px",
              textAlign: "center",
            }}
          >
            <img
              src={user.avatar}
              alt={`${user.login} avatar`}
              style={{
                width: "120px",
                height: "120px",
                borderRadius: "50%",
                border: "4px solid white",
                objectFit: "cover",
              }}
            />
          </div>

          <div style={{ padding: "24px" }}>
            <h2 style={{ margin: "0 0 8px 0" }}>
              {user.name || user.login}
              <small
                style={{
                  color: "#666",
                  fontSize: "0.9rem",
                  marginLeft: "12px",
                }}
              >
                @{user.login}
              </small>
            </h2>

            {user.bio && (
              <p
                style={{
                  color: "#444",
                  margin: "0 0 20px 0",
                  lineHeight: "1.5",
                }}
              >
                {user.bio}
              </p>
            )}

            <div
              style={{
                display: "grid",
                gridTemplateColumns: "1fr 1fr",
                gap: "16px",
                marginBottom: "20px",
              }}
            >
              <div style={{ textAlign: "center" }}>
                <div
                  style={{
                    fontSize: "1.8rem",
                    fontWeight: "bold",
                    color: "#2e7d32",
                  }}
                >
                  {user.followers.toLocaleString()}
                </div>
                <div style={{ color: "#666", fontSize: "0.9rem" }}>
                  Followers
                </div>
              </div>
              <div style={{ textAlign: "center" }}>
                <div
                  style={{
                    fontSize: "1.8rem",
                    fontWeight: "bold",
                    color: "#1976d2",
                  }}
                >
                  {user.repos}
                </div>
                <div style={{ color: "#666", fontSize: "0.9rem" }}>
                  Public Repos
                </div>
              </div>
            </div>

            {user.location && (
              <p style={{ color: "#555", margin: "0 0 16px 0" }}>
                ğŸ“ {user.location}
              </p>
            )}

            <p
              style={{
                color: "#777",
                fontSize: "0.9rem",
                margin: "0 0 20px 0",
              }}
            >
              Joined GitHub: {user.created}
            </p>

            <a
              href={user.profileUrl}
              target="_blank"
              rel="noopener noreferrer"
              style={{
                display: "inline-block",
                padding: "12px 24px",
                background: "#24292e",
                color: "white",
                textDecoration: "none",
                borderRadius: "6px",
                fontWeight: "500",
              }}
            >
              View Profile on GitHub â†’
            </a>
          </div>
        </div>
      )}

      {!user && !loading && !error && debouncedQuery.length >= 2 && (
        <div style={{ textAlign: "center", color: "#777", padding: "40px 0" }}>
          No user found for "{debouncedQuery}"
        </div>
      )}

      {debouncedQuery.length < 2 && query.length > 0 && (
        <div style={{ textAlign: "center", color: "#888", padding: "20px 0" }}>
          Type at least 2 characters to search
        </div>
      )}
    </div>
  );
}

export default GitHubUserSearch;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi cháº¡y:**

- GÃµ "torvalds" â†’ sau ~500ms: hiá»ƒn thá»‹ Linus Torvalds
  - Avatar lá»›n
  - TÃªn: Linus Torvalds @torvalds
  - Bio (náº¿u cÃ³)
  - Followers: ~70k+
  - Public Repos: hÃ ng trÄƒm
  - Location: (náº¿u cÃ´ng khai)
  - NÃºt View Profile on GitHub

- GÃµ "octocat" â†’ hiá»ƒn thá»‹ Octocat (mascot cá»§a GitHub)

- GÃµ "nonexistentuser123456" â†’ "User not found"

- GÃµ quÃ¡ nhanh â†’ debounce ngÄƒn fetch liÃªn tá»¥c
- Náº¿u bá»‹ rate limit (thá»­ nhiá»u láº§n) â†’ "Rate limit exceeded. Please try again later."

</details>

**BÃ i 4: Multi-Tab Data Manager**

```jsx
/**
 * Táº¡o tabbed interface:
 * - Tabs: Users, Posts, Comments
 * - Fetch data khi switch tab
 * - Cache fetched data (don't refetch same tab)
 * - Refresh button per tab
 *
 * Requirements:
 * - Tab navigation
 * - Lazy load data (only fetch when tab clicked)
 * - Cache in state
 * - Individual refresh buttons
 *
 * Challenge:
 * - How to cache without re-fetching?
 * - Hint: Track which tabs have been loaded
 */
```

<details><summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * MultiTabDataManager - BÃ i táº­p vá» nhÃ  4: Tabbed interface with lazy loading & caching
 * - Tabs: Users / Posts / Comments
 * - Fetch data chá»‰ khi tab Ä‘Æ°á»£c chá»n láº§n Ä‘áº§u
 * - Cache káº¿t quáº£ Ä‘Ã£ fetch (khÃ´ng fetch láº¡i khi quay láº¡i tab)
 * - NÃºt Refresh riÃªng cho tá»«ng tab
 * - Loading & error state riÃªng biá»‡t cho má»—i tab
 */
import { useState, useEffect } from "react";

const API_BASE = "https://jsonplaceholder.typicode.com";

function TabButton({ label, isActive, onClick }) {
  return (
    <button
      onClick={onClick}
      style={{
        padding: "12px 24px",
        fontSize: "16px",
        fontWeight: isActive ? "bold" : "normal",
        background: isActive ? "#1976d2" : "#e0e0e0",
        color: isActive ? "white" : "#333",
        border: "none",
        borderRadius: "8px 8px 0 0",
        cursor: "pointer",
        marginRight: "4px",
      }}
    >
      {label}
    </button>
  );
}

function DataTab({ endpoint, title, renderItem }) {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [lastFetched, setLastFetched] = useState(null);

  const fetchData = async () => {
    setLoading(true);
    setError(null);

    try {
      const res = await fetch(`${API_BASE}/${endpoint}?_limit=8`);
      if (!res.ok) throw new Error(`Failed to load ${title.toLowerCase()}`);
      const result = await res.json();
      setData(result);
      setLastFetched(new Date());
      setLoading(false);
    } catch (err) {
      setError(err.message);
      setLoading(false);
    }
  };

  // Chá»‰ fetch láº§n Ä‘áº§u khi component mount (lazy load)
  useEffect(() => {
    // VÃ¬ tab chá»‰ render khi active â†’ effect cháº¡y khi tab Ä‘Æ°á»£c chá»n láº§n Ä‘áº§u
    fetchData();
  }, []); // empty deps â†’ chá»‰ cháº¡y 1 láº§n khi tab mount

  const handleRefresh = () => {
    fetchData();
  };

  if (loading) {
    return (
      <div style={{ padding: "40px", textAlign: "center" }}>
        Loading {title}...
      </div>
    );
  }

  if (error) {
    return (
      <div style={{ padding: "20px", textAlign: "center", color: "#c62828" }}>
        <p>Error: {error}</p>
        <button
          onClick={handleRefresh}
          style={{
            padding: "10px 20px",
            background: "#d32f2f",
            color: "white",
            border: "none",
            borderRadius: "6px",
            cursor: "pointer",
            marginTop: "12px",
          }}
        >
          Retry
        </button>
      </div>
    );
  }

  return (
    <div>
      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          marginBottom: "16px",
        }}
      >
        <h2 style={{ margin: 0 }}>
          {title} ({data.length})
        </h2>
        <div>
          {lastFetched && (
            <small style={{ color: "#666", marginRight: "16px" }}>
              Last updated: {lastFetched.toLocaleTimeString()}
            </small>
          )}
          <button
            onClick={handleRefresh}
            disabled={loading}
            style={{
              padding: "8px 16px",
              background: "#4CAF50",
              color: "white",
              border: "none",
              borderRadius: "6px",
              cursor: loading ? "not-allowed" : "pointer",
            }}
          >
            {loading ? "Refreshing..." : "Refresh"}
          </button>
        </div>
      </div>

      <div style={{ display: "grid", gap: "16px" }}>
        {data.map((item) => renderItem(item))}
      </div>
    </div>
  );
}

function MultiTabDataManager() {
  const [activeTab, setActiveTab] = useState("users");

  const tabs = [
    { id: "users", label: "Users" },
    { id: "posts", label: "Posts" },
    { id: "comments", label: "Comments" },
  ];

  return (
    <div style={{ maxWidth: "1000px", margin: "40px auto", padding: "20px" }}>
      <h1>Multi-Tab Data Manager</h1>

      <div
        style={{
          display: "flex",
          marginBottom: "24px",
          borderBottom: "2px solid #ddd",
        }}
      >
        {tabs.map((tab) => (
          <TabButton
            key={tab.id}
            label={tab.label}
            isActive={activeTab === tab.id}
            onClick={() => setActiveTab(tab.id)}
          />
        ))}
      </div>

      <div
        style={{
          padding: "20px",
          background: "#f9f9f9",
          borderRadius: "0 8px 8px 8px",
        }}
      >
        {activeTab === "users" && (
          <DataTab
            endpoint="users"
            title="Users"
            renderItem={(user) => (
              <div
                key={user.id}
                style={{
                  padding: "16px",
                  border: "1px solid #ddd",
                  borderRadius: "8px",
                  background: "white",
                }}
              >
                <h3 style={{ margin: "0 0 8px 0" }}>{user.name}</h3>
                <p style={{ margin: "0 0 4px 0", color: "#555" }}>
                  {user.email}
                </p>
                <p style={{ margin: 0, color: "#777", fontSize: "0.9rem" }}>
                  {user.company.name} â€¢ {user.website}
                </p>
              </div>
            )}
          />
        )}

        {activeTab === "posts" && (
          <DataTab
            endpoint="posts"
            title="Posts"
            renderItem={(post) => (
              <div
                key={post.id}
                style={{
                  padding: "16px",
                  border: "1px solid #ddd",
                  borderRadius: "8px",
                  background: "white",
                }}
              >
                <h3 style={{ margin: "0 0 8px 0" }}>{post.title}</h3>
                <p style={{ margin: 0, color: "#444" }}>
                  {post.body.substring(0, 150)}...
                </p>
              </div>
            )}
          />
        )}

        {activeTab === "comments" && (
          <DataTab
            endpoint="comments"
            title="Comments"
            renderItem={(comment) => (
              <div
                key={comment.id}
                style={{
                  padding: "16px",
                  border: "1px solid #ddd",
                  borderRadius: "8px",
                  background: "white",
                }}
              >
                <div
                  style={{
                    display: "flex",
                    justifyContent: "space-between",
                    marginBottom: "8px",
                  }}
                >
                  <strong style={{ color: "#1976d2" }}>{comment.name}</strong>
                  <small style={{ color: "#777" }}>{comment.email}</small>
                </div>
                <p style={{ margin: 0, color: "#444" }}>{comment.body}</p>
              </div>
            )}
          />
        )}
      </div>

      <div
        style={{
          marginTop: "32px",
          padding: "16px",
          background: "#e3f2fd",
          borderRadius: "8px",
        }}
      >
        <h3 style={{ marginTop: 0 }}>CÃ¡ch hoáº¡t Ä‘á»™ng:</h3>
        <ul>
          <li>Dá»¯ liá»‡u chá»‰ fetch khi tab Ä‘Æ°á»£c chá»n láº§n Ä‘áº§u (lazy loading)</li>
          <li>Quay láº¡i tab cÅ© â†’ dá»¯ liá»‡u tá»« cache (state), khÃ´ng fetch láº¡i</li>
          <li>Má»—i tab cÃ³ nÃºt Refresh riÃªng Ä‘á»ƒ táº£i láº¡i dá»¯ liá»‡u</li>
          <li>Loading & error state Ä‘á»™c láº­p cho tá»«ng tab</li>
        </ul>
      </div>
    </div>
  );
}

export default MultiTabDataManager;
```

**Káº¿t quáº£ vÃ­ dá»¥ khi cháº¡y:**

- Má»Ÿ trang â†’ tab "Users" active â†’ tá»± Ä‘á»™ng fetch vÃ  hiá»ƒn thá»‹ 8 users
- Chuyá»ƒn sang tab "Posts" â†’ fetch posts â†’ hiá»ƒn thá»‹ 8 bÃ i post
- Chuyá»ƒn sang "Comments" â†’ fetch comments
- Quay láº¡i tab "Users" â†’ hiá»ƒn thá»‹ dá»¯ liá»‡u cÅ© ngay láº­p tá»©c (khÃ´ng loading láº¡i)
- Nháº¥n "Refresh" trong tab Posts â†’ loading... â†’ táº£i láº¡i 8 posts má»›i nháº¥t
- Má»—i tab cÃ³ tráº¡ng thÃ¡i loading/error/refresh riÃªng biá»‡t
- KhÃ´ng fetch láº¡i dá»¯ liá»‡u khi chuyá»ƒn tab trá»« khi nháº¥n Refresh

</details>

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **fetch API MDN**
   - https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
   - response.ok explanation
   - Error handling

2. **React Docs - Data Fetching**
   - https://react.dev/learn/synchronizing-with-effects#fetching-data
   - Best practices
   - Common pitfalls

### Äá»c thÃªm

3. **Async/Await Error Handling**
   - try/catch patterns
   - Promise rejection

4. **HTTP Status Codes**
   - 2xx Success
   - 4xx Client errors
   - 5xx Server errors

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (Ä‘Ã£ há»c):

- **NgÃ y 17:** Dependencies
  - Káº¿t ná»‘i: [userId] trigger refetch

- **NgÃ y 18:** Cleanup
  - Káº¿t ná»‘i: isCancelled flag cho async

### HÆ°á»›ng tá»›i (sáº½ há»c):

- **NgÃ y 20:** Advanced Patterns
  - AbortController
  - Race conditions
  - Parallel requests

---

## ğŸ’¡ SENIOR INSIGHTS

### Production Patterns

```jsx
// âœ… PRODUCTION FETCH TEMPLATE
function useDataFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let isCancelled = false;

    async function fetchData() {
      try {
        setLoading(true);
        setError(null);

        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();

        if (!isCancelled) {
          setData(data);
          setLoading(false);
        }
      } catch (err) {
        if (!isCancelled) {
          setError(err.message);
          setLoading(false);
        }
      }
    }

    fetchData();

    return () => {
      isCancelled = true;
    };
  }, [url]);

  return { data, loading, error };
}
```

---

## ğŸ¯ NGÃ€Y MAI: Data Fetching - Advanced Patterns

Preview:

- AbortController
- Race conditions
- Dependent requests
- Parallel fetching

**ğŸ”¥ Chuáº©n bá»‹:**

- Practice hÃ´m nay
- Ã”n cleanup (NgÃ y 18)

---

**ğŸ‰ ChÃºc má»«ng! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 19!**

Báº¡n Ä‘Ã£:

- âœ… Master fetch API trong useEffect
- âœ… Implement Loading/Error/Success states
- âœ… Handle HTTP errors properly
- âœ… Apply refetch vá»›i dependencies
- âœ… Build production-ready data fetching

**Tomorrow: Advanced patterns Ä‘á»ƒ handle complex scenarios! ğŸš€**
