# ğŸ“š NGÃ€Y 2: ES6+ NÃ¢ng cao

## ğŸ“ Phase 1, Week 1, Day 2 of 169

## I. KNOWLEDGE CHECK-IN

### âœ… Kiáº¿n thá»©c tá»« NgÃ y 1:

- `let`/`const` vÃ  block scope
- Arrow functions vÃ  `this` binding
- Template literals
- Destructuring (objects & arrays)
- Spread/Rest operators
- Array methods: `map`, `filter`, `reduce`

### ğŸ¯ HÃ´m nay sáº½ há»c:

1. Promises - Hiá»ƒu cÃ¡ch hoáº¡t Ä‘á»™ng (CHÆ¯A dÃ¹ng trong React)
2. Async/Await - Modern asynchronous patterns
3. ES6 Modules - import/export organization
4. Optional chaining (?.) vÃ  Nullish coalescing (??)
5. Advanced array methods: `find`, `findIndex`, `some`, `every`, `flatMap`
6. Object methods: `Object.keys()`, `Object.values()`, `Object.entries()`

### ğŸ”— NgÃ y mai sáº½ dÃ¹ng Ä‘á»ƒ:

- Táº¡o React app Ä‘áº§u tiÃªn
- Hiá»ƒu JSX syntax
- Import/export React components
- Xá»­ lÃ½ data trong components

---

## II. MENTAL MODELS (15 phÃºt)

### ğŸ§  Big Picture: Asynchronous JavaScript Journey

```
Synchronous (Blocking)          Asynchronous (Non-blocking)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Code cháº¡y line by line         Code cÃ³ thá»ƒ cháº¡y sau
Chá» task xong má»›i next         KhÃ´ng block main thread

                               Evolution:
                               1. Callbacks (old, messy)
                               2. Promises (better)
                               3. Async/Await (best)

                    â†“
        Essential for React (API calls, data fetching)
```

### ğŸ¯ Today's Learning Path:

```
1. Promises
   â””â”€â†’ Understanding async operations

2. Async/Await
   â””â”€â†’ Clean async code syntax

3. Modules
   â””â”€â†’ Code organization (critical for React)

4. Optional Chaining & Nullish Coalescing
   â””â”€â†’ Safe data access (prevents crashes)

5. Advanced Array Methods
   â””â”€â†’ More powerful data manipulation

6. Object Methods
   â””â”€â†’ Working with object data
```

---

## III. CONTENT DEEP DIVE

## ğŸ“Œ 1. PROMISES (45 phÃºt)

### Mental Model:

```
Promise = "IOU" (I Owe You)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Real Life:                      JavaScript:
Order coffee â˜•                 Fetch API data
â”œâ”€ Pending: Making coffee      â”œâ”€ Pending: Request in progress
â”œâ”€ Fulfilled: Here's coffee    â”œâ”€ Fulfilled: Got response
â””â”€ Rejected: Out of beans      â””â”€ Rejected: Network error

Timeline:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Now          Future (unknown time)
â”‚            â”‚
â”‚            â”œâ”€ Success â†’ .then()
â”‚            â””â”€ Error â†’ .catch()
Create Promise
```

### Core Concept:

```javascript
// Promise has 3 states:
// 1. Pending - Initial state
// 2. Fulfilled - Operation succeeded
// 3. Rejected - Operation failed

// Creating a Promise
const promise = new Promise((resolve, reject) => {
  // Async operation here
  const success = true;

  if (success) {
    resolve("Success!"); // Fulfilled
  } else {
    reject("Error!"); // Rejected
  }
});

// Using a Promise
promise
  .then((result) => console.log(result)) // Fulfilled
  .catch((error) => console.log(error)) // Rejected
  .finally(() => console.log("Done")); // Always runs
```

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Callback hell (pyramid of doom)
fetchUser(userId, (user) => {
  fetchPosts(user.id, (posts) => {
    fetchComments(posts[0].id, (comments) => {
      console.log(comments); // Deeply nested!
    });
  });
});

// âŒ WRONG: Not handling errors
fetch("/api/data")
  .then((response) => response.json())
  .then((data) => console.log(data));
// No .catch()! Silent failures!

// âŒ WRONG: Creating unnecessary promises
const getData = () => {
  return new Promise((resolve) => {
    resolve(fetch("/api/data")); // fetch already returns Promise!
  });
};

// âŒ WRONG: Not returning in .then() chain
fetch("/api/user")
  .then((response) => {
    response.json(); // Missing return!
  })
  .then((data) => {
    console.log(data); // undefined!
  });

// âŒ WRONG: Multiple .catch() for same promise
promise
  .then((result) => console.log(result))
  .catch((error) => console.log("Error 1"))
  .catch((error) => console.log("Error 2")); // This won't catch promise errors!
```

### âœ… Best Practices:

```javascript
// âœ… RIGHT: Promise chain
fetchUser(userId)
  .then((user) => fetchPosts(user.id))
  .then((posts) => fetchComments(posts[0].id))
  .then((comments) => console.log(comments))
  .catch((error) => console.error("Error:", error));

// âœ… RIGHT: Always handle errors
fetch("/api/data")
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return response.json();
  })
  .then((data) => console.log(data))
  .catch((error) => console.error("Failed:", error));

// âœ… RIGHT: Return promises in chains
fetch("/api/user")
  .then((response) => response.json()) // Return promise
  .then((data) => {
    console.log(data); // Works!
    return fetch(`/api/posts/${data.id}`); // Return next promise
  })
  .then((response) => response.json())
  .then((posts) => console.log(posts))
  .catch((error) => console.error(error));

// âœ… RIGHT: Promise.all for parallel requests
const userPromise = fetch("/api/user").then((r) => r.json());
const postsPromise = fetch("/api/posts").then((r) => r.json());
const commentsPromise = fetch("/api/comments").then((r) => r.json());

Promise.all([userPromise, postsPromise, commentsPromise])
  .then(([user, posts, comments]) => {
    console.log("All data:", { user, posts, comments });
  })
  .catch((error) => console.error("One failed:", error));

// âœ… RIGHT: Promise.race for timeout
const fetchWithTimeout = (url, timeout = 5000) => {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), timeout)
  );

  return Promise.race([fetchPromise, timeoutPromise]);
};

// âœ… RIGHT: Promise.allSettled to handle all results
const promises = [
  fetch("/api/user"),
  fetch("/api/posts"),
  fetch("/api/invalid"), // This might fail
];

Promise.allSettled(promises).then((results) => {
  results.forEach((result, index) => {
    if (result.status === "fulfilled") {
      console.log(`Promise ${index} succeeded:`, result.value);
    } else {
      console.log(`Promise ${index} failed:`, result.reason);
    }
  });
});
```

### ğŸ¯ Common Promise Patterns:

```javascript
// Pattern 1: Retry logic
const fetchWithRetry = (url, retries = 3) => {
  return fetch(url).catch((error) => {
    if (retries > 0) {
      console.log(`Retrying... (${retries} attempts left)`);
      return fetchWithRetry(url, retries - 1);
    }
    throw error;
  });
};

// Pattern 2: Sequential execution
const runSequentially = (tasks) => {
  return tasks.reduce((promise, task) => {
    return promise.then((results) => {
      return task().then((result) => [...results, result]);
    });
  }, Promise.resolve([]));
};

// Usage
const tasks = [
  () => fetch("/api/step1").then((r) => r.json()),
  () => fetch("/api/step2").then((r) => r.json()),
  () => fetch("/api/step3").then((r) => r.json()),
];

runSequentially(tasks).then((results) => console.log("All done:", results));

// Pattern 3: Promise wrapper
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// Usage
console.log("Start");
delay(2000).then(() => console.log("After 2 seconds"));

// Pattern 4: Promisify callback-based function
const readFilePromise = (filename) => {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, "utf8", (error, data) => {
      if (error) reject(error);
      else resolve(data);
    });
  });
};
```

---

## ğŸ“Œ 2. ASYNC/AWAIT (45 phÃºt)

### Mental Model:

```
Promises (.then)                Async/Await
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€               â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Chaining callbacks             Write nhÆ° sync code
.then().then().then()          Step by step
Harder to read                 Easier to read

                    â†“
            Same thing, different syntax
            Async/Await = Sugar over Promises
```

### Core Concept:

```javascript
// Async function always returns a Promise
async function fetchData() {
  return "Hello"; // Automatically wrapped in Promise.resolve()
}

fetchData().then((data) => console.log(data)); // 'Hello'

// Await pauses execution until Promise resolves
async function getData() {
  const response = await fetch("/api/data"); // Wait for response
  const data = await response.json(); // Wait for parsing
  return data;
}
```

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Not using async with await
function getData() {
  const data = await fetch('/api/data'); // SyntaxError!
  return data;
}

// âŒ WRONG: Not handling errors
async function fetchUser() {
  const response = await fetch('/api/user');
  const user = await response.json();
  return user;
  // What if fetch fails? Unhandled error!
}

// âŒ WRONG: Sequential when parallel is possible
async function getAllData() {
  const user = await fetchUser();     // Waits
  const posts = await fetchPosts();   // Waits
  const comments = await fetchComments(); // Waits
  // Total time: 3x (sequential)
}

// âŒ WRONG: Mixing async/await with .then
async function getData() {
  const response = await fetch('/api/data');
  return response.json().then(data => data); // Don't mix!
}

// âŒ WRONG: Not returning await in some cases
async function processData() {
  try {
    await saveToDatabase(data);
    // If this throws, catch won't handle it properly
    // because function returns before error
  } catch (error) {
    console.error(error);
  }
}
```

### âœ… Best Practices:

```javascript
// âœ… RIGHT: Always use try/catch
async function fetchUser() {
  try {
    const response = await fetch("/api/user");

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const user = await response.json();
    return user;
  } catch (error) {
    console.error("Failed to fetch user:", error);
    throw error; // Re-throw or handle
  }
}

// âœ… RIGHT: Parallel execution with Promise.all
async function getAllData() {
  try {
    const [user, posts, comments] = await Promise.all([
      fetchUser(),
      fetchPosts(),
      fetchComments(),
    ]);
    // Total time: 1x (parallel - runs simultaneously)

    return { user, posts, comments };
  } catch (error) {
    console.error("Failed to fetch data:", error);
    throw error;
  }
}

// âœ… RIGHT: Conditional parallel execution
async function getOptionalData(includeComments) {
  const [user, posts] = await Promise.all([fetchUser(), fetchPosts()]);

  let comments = null;
  if (includeComments) {
    comments = await fetchComments(); // Only if needed
  }

  return { user, posts, comments };
}

// âœ… RIGHT: Error handling with specific messages
async function createUser(userData) {
  try {
    const response = await fetch("/api/users", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userData),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || "Failed to create user");
    }

    return await response.json();
  } catch (error) {
    if (error.message.includes("Network")) {
      console.error("Network error - check your connection");
    } else if (error.message.includes("400")) {
      console.error("Invalid data - check your input");
    } else {
      console.error("Unexpected error:", error);
    }
    throw error;
  }
}

// âœ… RIGHT: Sequential when needed (dependency)
async function processUserPosts(userId) {
  try {
    // Must get user first
    const user = await fetchUser(userId);

    // Then get their posts (depends on user.id)
    const posts = await fetchPosts(user.id);

    // Then process posts
    const processed = await processPosts(posts);

    return { user, posts: processed };
  } catch (error) {
    console.error("Failed to process:", error);
    throw error;
  }
}

// âœ… RIGHT: Cleanup with finally
async function uploadFile(file) {
  let connection;

  try {
    connection = await openConnection();
    await connection.upload(file);
    console.log("Upload successful");
  } catch (error) {
    console.error("Upload failed:", error);
    throw error;
  } finally {
    // Always runs (success or error)
    if (connection) {
      await connection.close();
      console.log("Connection closed");
    }
  }
}
```

### ğŸ¯ Async/Await Patterns:

```javascript
// Pattern 1: Async IIFE (Immediately Invoked Function Expression)
(async () => {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
})();

// Pattern 2: Top-level await (ES2022 - in modules only)
// In module file:
const data = await fetchData();
console.log(data);

// Pattern 3: Async iteration
async function processItems(items) {
  for (const item of items) {
    await processItem(item); // Sequential processing
  }
}

// Pattern 4: Parallel with map
async function processAllItems(items) {
  const promises = items.map((item) => processItem(item));
  const results = await Promise.all(promises);
  return results;
}

// Pattern 5: Race condition handling
async function fetchWithFallback(primaryUrl, fallbackUrl) {
  try {
    return await fetch(primaryUrl);
  } catch (error) {
    console.log("Primary failed, trying fallback");
    return await fetch(fallbackUrl);
  }
}

// Pattern 6: Timeout wrapper
const withTimeout = (promise, ms) => {
  const timeout = new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), ms)
  );
  return Promise.race([promise, timeout]);
};

// Usage
try {
  const data = await withTimeout(fetchData(), 5000);
  console.log(data);
} catch (error) {
  console.error("Request timed out");
}

// Pattern 7: Retry with exponential backoff
async function fetchWithRetry(url, maxRetries = 3, baseDelay = 1000) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url);
      if (response.ok) return await response.json();
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      if (attempt === maxRetries) throw error;

      const delay = baseDelay * Math.pow(2, attempt);
      console.log(`Retry ${attempt + 1}/${maxRetries} after ${delay}ms`);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
}

// Pattern 8: Queue processing
class AsyncQueue {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  async add(task) {
    this.queue.push(task);
    if (!this.processing) {
      await this.process();
    }
  }

  async process() {
    this.processing = true;

    while (this.queue.length > 0) {
      const task = this.queue.shift();
      try {
        await task();
      } catch (error) {
        console.error("Task failed:", error);
      }
    }

    this.processing = false;
  }
}

// Usage
const queue = new AsyncQueue();
queue.add(() => fetch("/api/task1"));
queue.add(() => fetch("/api/task2"));
```

### ğŸ”„ Promise vs Async/Await Comparison:

```javascript
// Same functionality, different syntax

// With Promises:
function getUserData() {
  return fetch("/api/user")
    .then((response) => {
      if (!response.ok) throw new Error("Failed");
      return response.json();
    })
    .then((user) => fetch(`/api/posts/${user.id}`))
    .then((response) => response.json())
    .then((posts) => {
      console.log("Posts:", posts);
      return posts;
    })
    .catch((error) => {
      console.error("Error:", error);
      throw error;
    });
}

// With Async/Await:
async function getUserData() {
  try {
    const userResponse = await fetch("/api/user");
    if (!userResponse.ok) throw new Error("Failed");

    const user = await userResponse.json();

    const postsResponse = await fetch(`/api/posts/${user.id}`);
    const posts = await postsResponse.json();

    console.log("Posts:", posts);
    return posts;
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

// Async/Await is:
// âœ… Easier to read (linear flow)
// âœ… Easier to debug (stack traces)
// âœ… Easier to write (no chaining)
// âŒ Can be slower if not parallelized properly
```

---

## ğŸ“Œ 3. ES6 MODULES (30 phÃºt)

### Mental Model:

```
Old Way (Global Scope)          Modern Way (Modules)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
All code in one file           Split into modules
<script src="a.js">            import { func } from './a.js'
<script src="b.js">
<script src="c.js">

Variables are global           Variables are scoped
Name collisions               Clean namespace
Hard to maintain              Easy to organize

                    â†“
            Critical for React (component files)
```

### Core Concepts:

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: utils.js (exporting)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Named exports (can have multiple)
export const PI = 3.14159;

export function add(a, b) {
  return a + b;
}

export const multiply = (a, b) => a * b;

// Or export at end
const subtract = (a, b) => a - b;
const divide = (a, b) => a / b;

export { subtract, divide };

// Default export (only one per file)
export default function calculate(a, b, operation) {
  switch (operation) {
    case "add":
      return add(a, b);
    case "subtract":
      return subtract(a, b);
    case "multiply":
      return multiply(a, b);
    case "divide":
      return divide(a, b);
    default:
      return 0;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: main.js (importing)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Import default export
import calculate from "./utils.js";

// Import named exports
import { add, multiply, PI } from "./utils.js";

// Import with alias
import { subtract as minus } from "./utils.js";

// Import all as namespace
import * as MathUtils from "./utils.js";

// Import default + named
import calculate, { add, PI } from "./utils.js";

// Usage
console.log(calculate(10, 5, "add")); // 15
console.log(add(10, 5)); // 15
console.log(PI); // 3.14159
console.log(minus(10, 5)); // 5
console.log(MathUtils.multiply(2, 3)); // 6
```

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Mixing default and named exports of same thing
// utils.js
export default function add(a, b) { return a + b; }
export const add = (a, b) => a + b; // Confusing!

// âŒ WRONG: Not using file extension in imports (Node.js)
import { add } from './utils'; // Might not work

// âœ… RIGHT: Always use extension
import { add } from './utils.js';

// âŒ WRONG: Default export of object
// config.js
export default {
  API_URL: 'https://api.example.com',
  TIMEOUT: 5000
};

// âœ… RIGHT: Named exports for configuration
export const API_URL = 'https://api.example.com';
export const TIMEOUT = 5000;
// Better: Can import only what you need

// âŒ WRONG: Re-exporting with wrong syntax
// index.js
export * from './utils.js'; // Doesn't export default!
export default from './utils.js'; // Syntax error!

// âœ… RIGHT: Re-exporting properly
export * from './utils.js';
export { default } from './utils.js';
// Or:
export { default as calculate } from './utils.js';

// âŒ WRONG: Circular dependencies
// a.js
import { b } from './b.js';
export const a = b + 1;

// b.js
import { a } from './a.js';
export const b = a + 1; // Circular! Causes issues

// âœ… RIGHT: Restructure to avoid circles
// shared.js
export const base = 1;

// a.js
import { base } from './shared.js';
export const a = base + 1;

// b.js
import { base } from './shared.js';
export const b = base + 2;
```

### âœ… Best Practices:

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 1: Barrel Exports (index.js pattern)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// components/Button.js
export default function Button() { /* ... */ }

// components/Input.js
export default function Input() { /* ... */ }

// components/Card.js
export default function Card() { /* ... */ }

// components/index.js (barrel file)
export { default as Button } from './Button.js';
export { default as Input } from './Input.js';
export { default as Card } from './Card.js';

// Usage in other files:
import { Button, Input, Card } from './components/index.js';
// Instead of:
// import Button from './components/Button.js';
// import Input from './components/Input.js';
// import Card from './components/Card.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 2: Constants module
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// constants.js
export const API_URL = 'https://api.example.com';
export const TIMEOUT = 5000;
export const MAX_RETRIES = 3;

export const STATUS = {
  IDLE: 'idle',
  LOADING: 'loading',
  SUCCESS: 'success',
  ERROR: 'error'
};

export const COLORS = {
  PRIMARY: '#007bff',
  SECONDARY: '#6c757d',
  SUCCESS: '#28a745',
  DANGER: '#dc3545'
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 3: Utilities module
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// utils.js
export const formatDate = (date) => {
  return new Date(date).toLocaleDateString();
};

export const capitalize = (str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

export const truncate = (str, length) => {
  return str.length > length ? str.slice(0, length) + '...' : str;
};

// Group related utilities
export const string = {
  capitalize,
  truncate
};

export const date = {
  formatDate
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 4: Service modules (API calls)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// services/api.js
const BASE_URL = 'https://api.example.com';

const handleResponse = async (response) => {
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}`);
  }
  return response.json();
};

export const api = {
  get: async (endpoint) => {
    const response = await fetch(`${BASE_URL}${endpoint}`);
    return handleResponse(response);
  },

  post: async (endpoint, data) => {
    const response = await fetch(`${BASE_URL}${endpoint}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    return handleResponse(response);
  }
};

// services/userService.js
import { api } from './api.js';

export const getUser = (id) => api.get(`/users/${id}`);
export const createUser = (data) => api.post('/users', data);
export const updateUser = (id, data) => api.post(`/users/${id}`, data);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 5: Dynamic imports (code splitting)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Load module only when needed
async function loadHeavyModule() {
  if (needHeavyFeature) {
    const module = await import('./heavyModule.js');
    module.doSomething();
  }
}

// Conditional loading
const loadChart = async (type) => {
  if (type === 'bar') {
    const { BarChart } = await import('./BarChart.js');
    return BarChart;
  } else {
    const { LineChart } = await import('./LineChart.js');
    return LineChart;
  }
};
```

### ğŸ¯ Module Organization Best Practices:

```
project/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/         # React components
â”‚   â”‚   â”œâ”€â”€ Button.js
â”‚   â”‚   â”œâ”€â”€ Input.js
â”‚   â”‚   â””â”€â”€ index.js       # Barrel export
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/             # Utility functions
â”‚   â”‚   â”œâ”€â”€ string.js
â”‚   â”‚   â”œâ”€â”€ date.js
â”‚   â”‚   â””â”€â”€ index.js
â”‚   â”‚
â”‚   â”œâ”€â”€ services/          # API services
â”‚   â”‚   â”œâ”€â”€ api.js
â”‚   â”‚   â”œâ”€â”€ userService.js
â”‚   â”‚   â””â”€â”€ index.js
â”‚   â”‚
â”‚   â”œâ”€â”€ constants/         # Constants & config
â”‚   â”‚   â”œâ”€â”€ api.js
â”‚   â”‚   â”œâ”€â”€ colors.js
â”‚   â”‚   â””â”€â”€ index.js
â”‚   â”‚
â”‚   â””â”€â”€ index.js           # Main entry
```

---

## ğŸ“Œ 4. OPTIONAL CHAINING & NULLISH COALESCING (30 phÃºt)

### Mental Model:

```
Problem: Deeply nested objects
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Old Way (Verbose):              New Way (Clean):
if (user &&                     const city = user?.address?.city;
    user.address &&
    user.address.city) {
  const city = user.address.city;
}

                    â†“
            Prevents "Cannot read property of undefined"
```

### Core Concepts:

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTIONAL CHAINING (?.)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const user = {
  name: "John",
  address: {
    street: "123 Main St",
    // city is missing
  },
};

// âŒ Old way: Crashes if any part is undefined
// const city = user.address.city.toUpperCase();
// TypeError: Cannot read property 'toUpperCase' of undefined

// âŒ Old way: Verbose checking
const city =
  user && user.address && user.address.city
    ? user.address.city.toUpperCase()
    : "Unknown";

// âœ… New way: Optional chaining
const city = user?.address?.city?.toUpperCase() ?? "Unknown";
// Returns 'Unknown' if any part is null/undefined

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NULLISH COALESCING (??)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ?? only checks for null/undefined (not falsy values)

const value1 = 0;
const value2 = "";
const value3 = false;
const value4 = null;
const value5 = undefined;

// || treats ALL falsy values as "use default"
console.log(value1 || 10); // 10 (0 is falsy)
console.log(value2 || "default"); // 'default' ('' is falsy)
console.log(value3 || true); // true (false is falsy)

// ?? only treats null/undefined as "use default"
console.log(value1 ?? 10); // 0 (0 is not null/undefined)
console.log(value2 ?? "default"); // '' (string exists)
console.log(value3 ?? true); // false (boolean exists)
console.log(value4 ?? 10); // 10 (null)
console.log(value5 ?? 10); // 10 (undefined)
```

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Excessive chaining
const value = obj?.a?.b?.c?.d?.e?.f?.g?.h?.i?.j;
// Too deep! Redesign data structure

// âŒ WRONG: Using || when you mean ??
const port = process.env.PORT || 3000;
// Problem: If PORT is "0", uses 3000 (wrong!)

// âœ… RIGHT: Use ??
const port = process.env.PORT ?? 3000;
// "0" is valid, only null/undefined use 3000

// âŒ WRONG: Not handling the default case
const name = user?.name?.toUpperCase();
// If user or name is undefined, name is undefined
// UI might show "undefined"

// âœ… RIGHT: Provide default
const name = user?.name?.toUpperCase() ?? "Guest";

// âŒ WRONG: Checking for falsy when you mean null/undefined
if (!value) {
  /* ... */
}
// Triggers for 0, '', false (might not want that)

// âœ… RIGHT: Explicit null/undefined check
if (value == null) {
  /* ... */
}
// Only triggers for null or undefined

// âŒ WRONG: Optional call on non-function
const result = obj.method?.();
// If method doesn't exist, result is undefined (might want error)

// âœ… RIGHT: Check if it exists first
if (typeof obj.method === "function") {
  obj.method();
}
```

### âœ… Best Practices:

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 1: Safe property access
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const user = {
  /* ... */
};

// âœ… Safe access with defaults
const userName = user?.name ?? "Anonymous";
const userEmail = user?.email ?? "no-email@example.com";
const userAge = user?.age ?? 0;

// âœ… Safe nested access
const city = user?.address?.city ?? "Unknown";
const zip = user?.address?.zip ?? "00000";

// âœ… Safe array access
const firstPost = user?.posts?.[0]?.title ?? "No posts";
const lastPost = user?.posts?.[user.posts.length - 1]?.title ?? "No posts";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 2: Safe function calls
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const user = {
  name: "John",
  greet: () => "Hello!",
  // farewell doesn't exist
};

// âœ… Safe method call
const greeting = user.greet?.() ?? "No greeting";
const farewell = user.farewell?.() ?? "Goodbye";

console.log(greeting); // 'Hello!'
console.log(farewell); // 'Goodbye'

// âœ… Safe callback execution
const onClick = (callback) => {
  callback?.(); // Only calls if callback exists
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 3: API response handling
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fetchUser(id) {
  try {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();

    // âœ… Safe extraction with defaults
    return {
      id: data?.id ?? null,
      name: data?.name ?? "Unknown",
      email: data?.email ?? "",
      avatar: data?.profile?.avatar ?? "/default-avatar.png",
      bio: data?.profile?.bio ?? "No bio available",
      followers: data?.stats?.followers ?? 0,
      following: data?.stats?.following ?? 0,
    };
  } catch (error) {
    console.error("Fetch failed:", error);
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 4: Configuration with defaults
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function initializeApp(config = {}) {
  const settings = {
    theme: config?.theme ?? "light",
    language: config?.language ?? "en",
    timeout: config?.timeout ?? 5000,
    retries: config?.retries ?? 3,
    enableLogging: config?.enableLogging ?? false,
    apiUrl: config?.apiUrl ?? "https://api.example.com",
    // Nested config
    cache: {
      enabled: config?.cache?.enabled ?? true,
      ttl: config?.cache?.ttl ?? 3600,
      maxSize: config?.cache?.maxSize ?? 100,
    },
  };

  return settings;
}

// Usage
const app1 = initializeApp(); // All defaults
const app2 = initializeApp({ theme: "dark", cache: { ttl: 7200 } });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 5: Form data handling
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function validateForm(formData) {
  const errors = {};

  // âœ… Safe validation with nullish coalescing
  if ((formData?.name?.length ?? 0) < 3) {
    errors.name = "Name must be at least 3 characters";
  }

  if ((formData?.email?.length ?? 0) === 0) {
    errors.email = "Email is required";
  }

  if ((formData?.age ?? 0) < 18) {
    errors.age = "Must be 18 or older";
  }

  return {
    isValid: Object.keys(errors).length === 0,
    errors,
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 6: React component props
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function UserCard({ user }) {
  // âœ… Safe rendering with defaults
  return (
    <div className="user-card">
      <img
        src={user?.avatar ?? "/default-avatar.png"}
        alt={user?.name ?? "User"}
      />
      <h2>{user?.name ?? "Unknown User"}</h2>
      <p>{user?.bio ?? "No bio available"}</p>
      <div>
        <span>Followers: {user?.stats?.followers ?? 0}</span>
        <span>Following: {user?.stats?.following ?? 0}</span>
      </div>
    </div>
  );
}
```

### ğŸ¯ Decision Matrix:

```javascript
// When to use what?

// Use || when:
// - You want to treat ALL falsy values as "use default"
// - Legacy code compatibility
const name = input || "default"; // '', 0, false, null, undefined â†’ 'default'

// Use ?? when:
// - You only care about null/undefined
// - Legitimate falsy values (0, '', false) should be preserved
const count = userInput ?? 0; // Only null/undefined â†’ 0

// Use ?. when:
// - Accessing properties that might not exist
// - Preventing "Cannot read property" errors
// - Chaining optional properties
const value = obj?.prop?.nested?.value;

// Combine ?. and ?? when:
// - You need safe access AND a default value
const city = user?.address?.city ?? "Unknown";
```

---

## ğŸ“Œ 5. ADVANCED ARRAY METHODS (45 phÃºt)

### Methods Overview:

```javascript
// find() - First item that matches
// findIndex() - Index of first match
// findLast() - Last item that matches (ES2023)
// findLastIndex() - Index of last match (ES2023)
// some() - Any item matches?
// every() - All items match?
// flatMap() - Map then flatten
// flat() - Flatten nested arrays
```

### `find()` & `findIndex()`:

```javascript
const users = [
  { id: 1, name: "John", age: 25, active: true },
  { id: 2, name: "Jane", age: 30, active: false },
  { id: 3, name: "Bob", age: 35, active: true },
];

// âŒ Old way
let found = null;
for (let i = 0; i < users.length; i++) {
  if (users[i].id === 2) {
    found = users[i];
    break;
  }
}

// âœ… find() - Returns first matching item (or undefined)
const user = users.find((u) => u.id === 2);
console.log(user); // { id: 2, name: 'Jane', ... }

const activeUser = users.find((u) => u.active);
console.log(activeUser); // { id: 1, name: 'John', ... }

const missing = users.find((u) => u.id === 999);
console.log(missing); // undefined

// âœ… findIndex() - Returns index (or -1)
const index = users.findIndex((u) => u.id === 2);
console.log(index); // 1

const missingIndex = users.findIndex((u) => u.id === 999);
console.log(missingIndex); // -1

// âœ… Real-world: Update item in array
const updateUser = (users, id, updates) => {
  const index = users.findIndex((u) => u.id === id);

  if (index === -1) return users; // Not found

  return [
    ...users.slice(0, index),
    { ...users[index], ...updates },
    ...users.slice(index + 1),
  ];
};

const updated = updateUser(users, 2, { age: 31 });
```

### `some()` & `every()`:

```javascript
const numbers = [1, 2, 3, 4, 5];
const users = [
  { name: "John", age: 25, verified: true },
  { name: "Jane", age: 17, verified: false },
  { name: "Bob", age: 35, verified: true },
];

// âŒ Old way
let hasEven = false;
for (let i = 0; i < numbers.length; i++) {
  if (numbers[i] % 2 === 0) {
    hasEven = true;
    break;
  }
}

// âœ… some() - At least ONE item matches?
const hasEven = numbers.some((n) => n % 2 === 0);
console.log(hasEven); // true

const hasLarge = numbers.some((n) => n > 100);
console.log(hasLarge); // false

// âœ… Real-world: Validation
const hasMinor = users.some((u) => u.age < 18);
console.log(hasMinor); // true

const hasUnverified = users.some((u) => !u.verified);
console.log(hasUnverified); // true

// âœ… every() - ALL items match?
const allEven = numbers.every((n) => n % 2 === 0);
console.log(allEven); // false

const allPositive = numbers.every((n) => n > 0);
console.log(allPositive); // true

// âœ… Real-world: Validation
const allAdults = users.every((u) => u.age >= 18);
console.log(allAdults); // false

const allVerified = users.every((u) => u.verified);
console.log(allVerified); // false

// âœ… Combining some() and every()
const canProceed = (users) => {
  return users.every((u) => u.age >= 18) && users.every((u) => u.verified);
};

// Or more concise:
const canProceed = (users) => {
  return users.every((u) => u.age >= 18 && u.verified);
};
```

### `flat()` & `flatMap()`:

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// flat() - Flatten nested arrays
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const nested1 = [1, [2, 3], 4, [5, 6]];
console.log(nested1.flat()); // [1, 2, 3, 4, 5, 6]

const nested2 = [1, [2, [3, [4]]]];
console.log(nested2.flat()); // [1, 2, [3, [4]]] - default depth 1
console.log(nested2.flat(2)); // [1, 2, 3, [4]] - depth 2
console.log(nested2.flat(Infinity)); // [1, 2, 3, 4] - all levels

// âœ… Real-world: Flatten API responses
const categories = [
  { name: "Electronics", items: ["Laptop", "Phone"] },
  { name: "Clothing", items: ["Shirt", "Pants"] },
  { name: "Books", items: ["Fiction", "Non-fiction"] },
];

const allItems = categories.map((c) => c.items).flat();
console.log(allItems);
// ['Laptop', 'Phone', 'Shirt', 'Pants', 'Fiction', 'Non-fiction']

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// flatMap() - Map then flatten (more efficient)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// âŒ Old way: map then flat
const result1 = categories.map((c) => c.items).flat();

// âœ… New way: flatMap (one pass, more efficient)
const result2 = categories.flatMap((c) => c.items);

// âœ… Real-world: Process and expand
const users = [
  { name: "John", skills: ["React", "Node"] },
  { name: "Jane", skills: ["Python", "Django"] },
];

// Get all skills with user names
const skillsWithUsers = users.flatMap((user) =>
  user.skills.map((skill) => ({ skill, userName: user.name }))
);
console.log(skillsWithUsers);
// [
//   { skill: 'React', userName: 'John' },
//   { skill: 'Node', userName: 'John' },
//   { skill: 'Python', userName: 'Jane' },
//   { skill: 'Django', userName: 'Jane' }
// ]

// âœ… Filter and flatten
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.flatMap(
  (n) => (n % 2 === 0 ? [n * 2] : []) // Return empty array to skip
);
console.log(doubled); // [4, 8]

// âœ… Duplicate items
const duplicate = (arr) => arr.flatMap((item) => [item, item]);
console.log(duplicate([1, 2, 3])); // [1, 1, 2, 2, 3, 3]
```

### ğŸ¯ Practical Examples:

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Example 1: Search and highlight
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const products = [
  { id: 1, name: "Laptop", category: "Electronics", price: 1000 },
  { id: 2, name: "Mouse", category: "Electronics", price: 50 },
  { id: 3, name: "Desk", category: "Furniture", price: 300 },
  { id: 4, name: "Chair", category: "Furniture", price: 200 },
];

function searchProducts(query) {
  const lowerQuery = query.toLowerCase();

  return products.filter(
    (p) =>
      p.name.toLowerCase().includes(lowerQuery) ||
      p.category.toLowerCase().includes(lowerQuery)
  );
}

console.log(searchProducts("elect"));
// [{ id: 1, ... }, { id: 2, ... }]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Example 2: Validation helpers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const validateUser = (user) => {
  const errors = [];

  if (!user.name || user.name.length < 3) {
    errors.push("Name must be at least 3 characters");
  }

  if (!user.email || !user.email.includes("@")) {
    errors.push("Valid email is required");
  }

  if (user.age < 18) {
    errors.push("Must be 18 or older");
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
};

const validateUsers = (users) => {
  return {
    allValid: users.every((u) => validateUser(u).isValid),
    someValid: users.some((u) => validateUser(u).isValid),
    results: users.map((u) => ({
      user: u,
      validation: validateUser(u),
    })),
  };
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Example 3: Nested data processing
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const departments = [
  {
    name: "Engineering",
    teams: [
      { name: "Frontend", members: ["Alice", "Bob"] },
      { name: "Backend", members: ["Charlie", "David"] },
    ],
  },
  {
    name: "Design",
    teams: [{ name: "UI/UX", members: ["Eve", "Frank"] }],
  },
];

// Get all members across all departments and teams
const allMembers = departments.flatMap((dept) =>
  dept.teams.flatMap((team) => team.members)
);
console.log(allMembers);
// ['Alice', 'Bob', 'Charlie', 'David', 'Eve', 'Frank']

// Find if specific person exists
const hasMember = (name) => allMembers.some((member) => member === name);
console.log(hasMember("Alice")); // true

// Get all team names
const allTeams = departments.flatMap((dept) =>
  dept.teams.map((team) => team.name)
);
console.log(allTeams);
// ['Frontend', 'Backend', 'UI/UX']

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Example 4: Filter chain optimization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const items = [
  { id: 1, name: "Item 1", active: true, featured: true, price: 100 },
  { id: 2, name: "Item 2", active: true, featured: false, price: 200 },
  { id: 3, name: "Item 3", active: false, featured: true, price: 150 },
];

// âŒ Multiple passes (less efficient)
const result1 = items
  .filter((item) => item.active)
  .filter((item) => item.featured)
  .filter((item) => item.price < 150);

// âœ… Single pass (more efficient)
const result2 = items.filter(
  (item) => item.active && item.featured && item.price < 150
);

// âœ… Reusable predicates
const isActive = (item) => item.active;
const isFeatured = (item) => item.featured;
const isAffordable = (item) => item.price < 150;

const result3 = items.filter(
  (item) => isActive(item) && isFeatured(item) && isAffordable(item)
);
```

---

## ğŸ“Œ 6. OBJECT METHODS (30 phÃºt)

### Core Methods:

```javascript
const user = {
  id: 1,
  name: "John",
  email: "john@example.com",
  age: 25,
  role: "admin",
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Object.keys() - Returns array of keys
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const keys = Object.keys(user);
console.log(keys); // ['id', 'name', 'email', 'age', 'role']

// âœ… Use case: Count properties
const propertyCount = Object.keys(user).length; // 5

// âœ… Use case: Check if empty
const isEmpty = (obj) => Object.keys(obj).length === 0;
console.log(isEmpty(user)); // false
console.log(isEmpty({})); // true

// âœ… Use case: Iterate over properties
Object.keys(user).forEach((key) => {
  console.log(`${key}: ${user[key]}`);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Object.values() - Returns array of values
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const values = Object.values(user);
console.log(values); // [1, 'John', 'john@example.com', 25, 'admin']

// âœ… Use case: Sum numeric values
const scores = { math: 90, english: 85, science: 92 };
const total = Object.values(scores).reduce((sum, score) => sum + score, 0);
console.log(total); // 267

// âœ… Use case: Check if value exists
const hasValue = (obj, value) => Object.values(obj).includes(value);
console.log(hasValue(user, "John")); // true

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Object.entries() - Returns array of [key, value] pairs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const entries = Object.entries(user);
console.log(entries);
// [
//   ['id', 1],
//   ['name', 'John'],
//   ['email', 'john@example.com'],
//   ['age', 25],
//   ['role', 'admin']
// ]

// âœ… Use case: Transform object
const transformed = Object.entries(user).map(([key, value]) => ({
  key,
  value,
  type: typeof value,
}));

// âœ… Use case: Filter object
const filtered = Object.entries(user)
  .filter(([key, value]) => typeof value === "string")
  .reduce((obj, [key, value]) => {
    obj[key] = value;
    return obj;
  }, {});
console.log(filtered); // { name: 'John', email: '...', role: 'admin' }

// âœ… Use case: Convert to Map
const userMap = new Map(Object.entries(user));

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Object.fromEntries() - Create object from entries
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const pairs = [
  ["name", "John"],
  ["age", 25],
  ["email", "john@example.com"],
];

const obj = Object.fromEntries(pairs);
console.log(obj); // { name: 'John', age: 25, email: '...' }

// âœ… Use case: Transform values
const prices = { laptop: 1000, mouse: 50, keyboard: 100 };
const discounted = Object.fromEntries(
  Object.entries(prices).map(([item, price]) => [item, price * 0.9])
);
console.log(discounted);
// { laptop: 900, mouse: 45, keyboard: 90 }

// âœ… Use case: Swap keys and values
const swap = (obj) =>
  Object.fromEntries(Object.entries(obj).map(([key, value]) => [value, key]));

const roles = { admin: "Administrator", user: "User", guest: "Guest" };
const swapped = swap(roles);
console.log(swapped);
// { Administrator: 'admin', User: 'user', Guest: 'guest' }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Object.assign() - Merge objects (shallow)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const defaults = { theme: "light", lang: "en" };
const userPrefs = { theme: "dark" };

const settings = Object.assign({}, defaults, userPrefs);
console.log(settings); // { theme: 'dark', lang: 'en' }

// Note: Spread operator is usually preferred
const settings2 = { ...defaults, ...userPrefs };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Object.hasOwn() - Check if property exists (modern)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

console.log(Object.hasOwn(user, "name")); // true
console.log(Object.hasOwn(user, "toString")); // false (inherited)

// Old way (less reliable):
console.log(user.hasOwnProperty("name")); // true
console.log("name" in user); // true (includes inherited)
```

### ğŸ¯ Real-world Patterns:

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 1: Object validation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const validateObject = (obj, requiredKeys) => {
  const objKeys = Object.keys(obj);
  const missing = requiredKeys.filter((key) => !objKeys.includes(key));

  return {
    isValid: missing.length === 0,
    missing,
  };
};

const userInput = { name: "John", email: "john@example.com" };
const validation = validateObject(userInput, ["name", "email", "age"]);
console.log(validation);
// { isValid: false, missing: ['age'] }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 2: Object diff
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const getDifferences = (obj1, obj2) => {
  const allKeys = [...new Set([...Object.keys(obj1), ...Object.keys(obj2)])];

  return allKeys.reduce((diff, key) => {
    if (obj1[key] !== obj2[key]) {
      diff[key] = { old: obj1[key], new: obj2[key] };
    }
    return diff;
  }, {});
};

const oldUser = { name: "John", age: 25, email: "john@example.com" };
const newUser = { name: "John", age: 26, email: "newemail@example.com" };

console.log(getDifferences(oldUser, newUser));
// {
//   age: { old: 25, new: 26 },
//   email: { old: 'john@example.com', new: 'newemail@example.com' }
// }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 3: Pick/Omit utilities
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const pick = (obj, keys) =>
  Object.fromEntries(Object.entries(obj).filter(([key]) => keys.includes(key)));

const omit = (obj, keys) =>
  Object.fromEntries(
    Object.entries(obj).filter(([key]) => !keys.includes(key))
  );

const user = {
  id: 1,
  name: "John",
  email: "john@example.com",
  password: "secret",
  role: "admin",
};

console.log(pick(user, ["name", "email"]));
// { name: 'John', email: 'john@example.com' }

console.log(omit(user, ["password"]));
// { id: 1, name: 'John', email: '...', role: 'admin' }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 4: Map object values
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const mapValues = (obj, fn) =>
  Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [key, fn(value, key)])
  );

const prices = { laptop: 1000, mouse: 50, keyboard: 100 };

// Apply 10% discount
const discounted = mapValues(prices, (price) => price * 0.9);
console.log(discounted);
// { laptop: 900, mouse: 45, keyboard: 90 }

// Format as currency
const formatted = mapValues(prices, (price) => `$${price.toFixed(2)}`);
console.log(formatted);
// { laptop: '$1000.00', mouse: '$50.00', keyboard: '$100.00' }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 5: Group by key
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const groupBy = (array, key) =>
  array.reduce((groups, item) => {
    const groupKey = typeof key === "function" ? key(item) : item[key];
    groups[groupKey] = groups[groupKey] || [];
    groups[groupKey].push(item);
    return groups;
  }, {});

const products = [
  { id: 1, name: "Laptop", category: "Electronics" },
  { id: 2, name: "Mouse", category: "Electronics" },
  { id: 3, name: "Desk", category: "Furniture" },
];

const byCategory = groupBy(products, "category");
console.log(byCategory);
// {
//   Electronics: [{...}, {...}],
//   Furniture: [{...}]
// }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Pattern 6: Merge deep
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const mergeDeep = (target, source) => {
  const output = { ...target };

  if (isObject(target) && isObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isObject(source[key])) {
        if (!(key in target)) {
          output[key] = source[key];
        } else {
          output[key] = mergeDeep(target[key], source[key]);
        }
      } else {
        output[key] = source[key];
      }
    });
  }

  return output;
};

const isObject = (item) =>
  item && typeof item === "object" && !Array.isArray(item);

const config1 = {
  server: { host: "localhost", port: 3000 },
  database: { host: "localhost" },
};

const config2 = {
  server: { port: 4000, ssl: true },
  database: { port: 5432 },
};

console.log(mergeDeep(config1, config2));
// {
//   server: { host: 'localhost', port: 4000, ssl: true },
//   database: { host: 'localhost', port: 5432 }
// }
```

---

## IV. LIVE CODING DEMOS (45 phÃºt)

### ğŸ¯ Demo 1: Async Data Fetcher with Error Handling (â­â­)

```javascript
// Requirement: Build robust data fetching utility

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Version 1: Basic Promise
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function fetchUserBasic(userId) {
  return fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then((user) => {
      console.log("User:", user);
      return user;
    })
    .catch((error) => {
      console.error("Error:", error);
      throw error;
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Version 2: Async/Await (Cleaner)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fetchUser(userId) {
  try {
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/users/${userId}`
    );

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const user = await response.json();
    return user;
  } catch (error) {
    console.error("Failed to fetch user:", error);
    throw error;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Version 3: With Retry Logic
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fetchWithRetry(url, retries = 3, delay = 1000) {
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      if (attempt === retries) {
        throw new Error(`Failed after ${retries} attempts: ${error.message}`);
      }

      console.log(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);
      await new Promise((resolve) => setTimeout(resolve, delay));
      delay *= 2; // Exponential backoff
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Version 4: Complete Utility with Timeout
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const createFetcher = () => {
  const cache = new Map();

  const fetchWithTimeout = async (url, timeout = 5000) => {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, { signal: controller.signal });
      clearTimeout(timeoutId);
      return response;
    } catch (error) {
      clearTimeout(timeoutId);
      if (error.name === "AbortError") {
        throw new Error("Request timeout");
      }
      throw error;
    }
  };

  return {
    async get(url, options = {}) {
      const { useCache = true, timeout = 5000, retries = 3 } = options;

      // Check cache
      if (useCache && cache.has(url)) {
        console.log("Cache hit:", url);
        return cache.get(url);
      }

      // Fetch with retry
      for (let attempt = 0; attempt <= retries; attempt++) {
        try {
          const response = await fetchWithTimeout(url, timeout);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();

          // Cache success
          if (useCache) {
            cache.set(url, data);
          }

          return data;
        } catch (error) {
          if (attempt === retries) {
            throw error;
          }

          const delay = 1000 * Math.pow(2, attempt);
          console.log(`Retry ${attempt + 1}/${retries} after ${delay}ms...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    },

    clearCache() {
      cache.clear();
    },
  };
};

// Usage
const api = createFetcher();

async function demo() {
  try {
    // First call - fetches from API
    const user1 = await api.get(
      "https://jsonplaceholder.typicode.com/users/1",
      { useCache: true, timeout: 5000, retries: 3 }
    );
    console.log("User 1:", user1);

    // Second call - returns from cache
    const user1Again = await api.get(
      "https://jsonplaceholder.typicode.com/users/1"
    );
    console.log("User 1 (cached):", user1Again);

    // Parallel requests
    const [user2, user3] = await Promise.all([
      api.get("https://jsonplaceholder.typicode.com/users/2"),
      api.get("https://jsonplaceholder.typicode.com/users/3"),
    ]);
    console.log("Users 2 & 3:", user2, user3);
  } catch (error) {
    console.error("Demo failed:", error);
  }
}

demo();
```

---

### ğŸ¯ Demo 2: Module-Based Application (â­â­â­)

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: utils/validators.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const isEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};

export const isStrongPassword = (password) => {
  return (
    password.length >= 8 &&
    /[A-Z]/.test(password) &&
    /[a-z]/.test(password) &&
    /[0-9]/.test(password)
  );
};

export const isValidAge = (age) => {
  return typeof age === "number" && age >= 18 && age <= 120;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: utils/formatters.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const formatCurrency = (amount) => {
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
  }).format(amount);
};

export const formatDate = (date) => {
  return new Date(date).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
};

export const truncate = (str, length = 50) => {
  return str.length > length ? str.slice(0, length) + "..." : str;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: services/api.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const BASE_URL = "https://jsonplaceholder.typicode.com";

const handleResponse = async (response) => {
  if (!response.ok) {
    const error = await response.json().catch(() => ({}));
    throw new Error(error.message || `HTTP ${response.status}`);
  }
  return response.json();
};

export const api = {
  async get(endpoint) {
    const response = await fetch(`${BASE_URL}${endpoint}`);
    return handleResponse(response);
  },

  async post(endpoint, data) {
    const response = await fetch(`${BASE_URL}${endpoint}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });
    return handleResponse(response);
  },

  async put(endpoint, data) {
    const response = await fetch(`${BASE_URL}${endpoint}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });
    return handleResponse(response);
  },

  async delete(endpoint) {
    const response = await fetch(`${BASE_URL}${endpoint}`, {
      method: "DELETE",
    });
    return handleResponse(response);
  },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: services/userService.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { api } from "./api.js";
import { isEmail, isValidAge } from "../utils/validators.js";

export const userService = {
  async getUser(id) {
    const user = await api.get(`/users/${id}`);
    return this.transformUser(user);
  },

  async getAllUsers() {
    const users = await api.get("/users");
    return users.map((u) => this.transformUser(u));
  },

  async createUser(userData) {
    const validation = this.validateUser(userData);
    if (!validation.isValid) {
      throw new Error(`Validation failed: ${validation.errors.join(", ")}`);
    }

    return api.post("/users", userData);
  },

  transformUser(user) {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      city: user.address?.city ?? "Unknown",
      company: user.company?.name ?? "N/A",
    };
  },

  validateUser(userData) {
    const errors = [];

    if (!userData.name || userData.name.length < 3) {
      errors.push("Name must be at least 3 characters");
    }

    if (!isEmail(userData.email)) {
      errors.push("Invalid email");
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: main.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { userService } from "./services/userService.js";
import { formatDate, truncate } from "./utils/formatters.js";

async function displayUser(userId) {
  try {
    console.log("Fetching user...");
    const user = await userService.getUser(userId);

    console.log("\nUser Details:");
    console.log("â”€".repeat(50));
    console.log(`Name: ${user.name}`);
    console.log(`Email: ${user.email}`);
    console.log(`City: ${user.city}`);
    console.log(`Company: ${user.company}`);
  } catch (error) {
    console.error("Error:", error.message);
  }
}

async function displayAllUsers() {
  try {
    const users = await userService.getAllUsers();

    console.log("\nAll Users:");
    console.log("â”€".repeat(50));

    users.forEach((user) => {
      console.log(`${user.id}. ${user.name} - ${user.email}`);
    });
  } catch (error) {
    console.error("Error:", error.message);
  }
}

// Run demos
displayUser(1);
displayAllUsers();
```

## V. EXERCISES (90 phÃºt)

### ğŸ’ª Exercise 1: Promise Chain Basics (â­) - 15 phÃºt

**YÃªu cáº§u**: Táº¡o Promise chain Ä‘á»ƒ fetch vÃ  process user data.

```javascript
// Starter Code:
function fetchAndProcessUser(userId) {
  // TODO: Implement promise chain
  // 1. Fetch user from API
  // 2. Extract name and email
  // 3. Log result
  // 4. Handle errors
}
```

**Your Task**:

1. Fetch user tá»« `https://jsonplaceholder.typicode.com/users/${userId}`
2. Parse JSON response
3. Extract chá»‰ `name` vÃ  `email` fields
4. Log káº¿t quáº£ vá»›i format: `"User: {name} ({email})"`
5. Handle errors vá»›i meaningful messages
6. Test vá»›i userId = 1

**Expected Output**:

```
User: Leanne Graham (Sincere@april.biz)
```

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
function fetchAndProcessUser(userId) {
  return fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then((user) => {
      const processed = {
        name: user.name,
        email: user.email,
      };
      console.log(`User: ${processed.name} (${processed.email})`);
      return processed;
    })
    .catch((error) => {
      console.error("Failed to fetch user:", error.message);
      throw error;
    });
}

// Test
fetchAndProcessUser(1)
  .then((user) => console.log("Success:", user))
  .catch((error) => console.log("Error:", error.message));
```

**Key Points**:

- Promise chaining vá»›i `.then()`
- Error handling vá»›i `.catch()`
- Response validation trÆ°á»›c parse
- Clean data extraction
</details>

---

### ğŸ’ª Exercise 2: Async/Await Data Aggregation (â­â­) - 25 phÃºt

**YÃªu cáº§u**: Fetch multiple resources vÃ  aggregate results using async/await.

```javascript
// Starter Code:
async function getUserWithPosts(userId) {
  // TODO: Implement async function
  // 1. Fetch user
  // 2. Fetch their posts
  // 3. Combine data
  // 4. Return aggregated result
}
```

**Your Task**:

1. Fetch user tá»« `/users/${userId}`
2. Fetch posts cá»§a user tá»« `/posts?userId=${userId}`
3. Combine data thÃ nh object:
   ```javascript
   {
     user: { name, email },
     postCount: number,
     posts: [{ title, body }]
   }
   ```
4. Calculate post count
5. Fetch parallel khi cÃ³ thá»ƒ
6. Handle errors appropriately
7. Test vá»›i userId = 1

**Expected Output**:

```javascript
{
  user: { name: 'Leanne Graham', email: 'Sincere@april.biz' },
  postCount: 10,
  posts: [
    { title: '...', body: '...' },
    // ... 9 more posts
  ]
}
```

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
async function getUserWithPosts(userId) {
  try {
    // Fetch user vÃ  posts parallel
    const [userResponse, postsResponse] = await Promise.all([
      fetch(`https://jsonplaceholder.typicode.com/users/${userId}`),
      fetch(`https://jsonplaceholder.typicode.com/posts?userId=${userId}`),
    ]);

    // Check responses
    if (!userResponse.ok || !postsResponse.ok) {
      throw new Error("Failed to fetch data");
    }

    // Parse JSON
    const user = await userResponse.json();
    const posts = await postsResponse.json();

    // Aggregate data
    const result = {
      user: {
        name: user.name,
        email: user.email,
      },
      postCount: posts.length,
      posts: posts.map((post) => ({
        title: post.title,
        body: post.body,
      })),
    };

    return result;
  } catch (error) {
    console.error("Error fetching user with posts:", error);
    throw error;
  }
}

// Test
getUserWithPosts(1)
  .then((data) => {
    console.log("User:", data.user);
    console.log("Post Count:", data.postCount);
    console.log("First Post:", data.posts[0]);
  })
  .catch((error) => console.log("Error:", error.message));
```

**Key Points**:

- Parallel execution vá»›i `Promise.all()`
- Async/await syntax
- Data aggregation
- Error handling vá»›i try/catch
</details>

---

### ğŸ’ª Exercise 3: Module-based Calculator (â­â­â­) - 40 phÃºt

**YÃªu cáº§u**: Táº¡o calculator application sá»­ dá»¥ng ES6 modules.

**Your Task**:

1. Táº¡o `operations.js` vá»›i:

   - Named exports: `add`, `subtract`, `multiply`, `divide`
   - Má»—i operation validate inputs
   - Handle division by zero

2. Táº¡o `validators.js` vá»›i:

   - `isNumber()` - check if valid number
   - `isPositive()` - check if positive
   - `inRange(value, min, max)` - check if in range

3. Táº¡o `formatters.js` vá»›i:

   - `formatResult(value, decimals)` - format with decimals
   - `formatOperation(a, op, b, result)` - format equation string

4. Táº¡o `calculator.js` vá»›i:

   - Default export: `calculate(a, b, operation)`
   - Use all modules above
   - Handle all error cases

5. Táº¡o `main.js` Ä‘á»ƒ test

**Expected Output**:

```
10 + 5 = 15.00
10 - 5 = 5.00
10 Ã— 5 = 50.00
10 Ã· 5 = 2.00
Error: Division by zero
Error: Invalid number
```

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: operations.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const add = (a, b) => {
  return a + b;
};

export const subtract = (a, b) => {
  return a - b;
};

export const multiply = (a, b) => {
  return a * b;
};

export const divide = (a, b) => {
  if (b === 0) {
    throw new Error("Division by zero");
  }
  return a / b;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: validators.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const isNumber = (value) => {
  return typeof value === "number" && !isNaN(value) && isFinite(value);
};

export const isPositive = (value) => {
  return isNumber(value) && value > 0;
};

export const inRange = (value, min, max) => {
  return isNumber(value) && value >= min && value <= max;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: formatters.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const formatResult = (value, decimals = 2) => {
  return value.toFixed(decimals);
};

export const formatOperation = (a, op, b, result) => {
  const symbols = {
    add: "+",
    subtract: "-",
    multiply: "Ã—",
    divide: "Ã·",
  };

  const symbol = symbols[op] || op;
  return `${a} ${symbol} ${b} = ${formatResult(result)}`;
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: calculator.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { add, subtract, multiply, divide } from "./operations.js";
import { isNumber } from "./validators.js";
import { formatOperation } from "./formatters.js";

const operations = {
  add,
  subtract,
  multiply,
  divide,
};

export default function calculate(a, b, operation) {
  // Validate inputs
  if (!isNumber(a) || !isNumber(b)) {
    throw new Error("Invalid number");
  }

  // Check if operation exists
  if (!operations[operation]) {
    throw new Error(`Unknown operation: ${operation}`);
  }

  // Perform calculation
  const result = operations[operation](a, b);

  // Return formatted result
  return {
    result,
    formatted: formatOperation(a, operation, b, result),
  };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: main.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import calculate from "./calculator.js";

function runTests() {
  console.log("Calculator Tests");
  console.log("â•".repeat(50));

  // Test cases
  const tests = [
    { a: 10, b: 5, op: "add" },
    { a: 10, b: 5, op: "subtract" },
    { a: 10, b: 5, op: "multiply" },
    { a: 10, b: 5, op: "divide" },
    { a: 10, b: 0, op: "divide" }, // Error case
    { a: "ten", b: 5, op: "add" }, // Error case
    { a: 10, b: 5, op: "modulo" }, // Error case
  ];

  tests.forEach(({ a, b, op }) => {
    try {
      const { formatted } = calculate(a, b, op);
      console.log(`âœ“ ${formatted}`);
    } catch (error) {
      console.log(`âœ— Error: ${error.message}`);
    }
  });
}

runTests();
```

**Key Points**:

- Multiple module files
- Named vs default exports
- Module imports
- Error handling across modules
- Clean separation of concerns
</details>

---

### ğŸ’ª Exercise 4: Advanced Data Fetcher (â­â­â­â­) - 60 phÃºt

**YÃªu cáº§u**: Build production-ready data fetching utility vá»›i advanced features.

**Your Task**:

1. Táº¡o `DataFetcher` class vá»›i:

   - Caching mechanism
   - Retry logic vá»›i exponential backoff
   - Timeout handling
   - Request queuing (max 5 concurrent)
   - Cancel requests

2. Methods cáº§n implement:

   - `get(url, options)` - Fetch vá»›i cache
   - `post(url, data, options)` - POST request
   - `clearCache(url?)` - Clear cache
   - `cancelAll()` - Cancel pending requests

3. Options há»— trá»£:

   - `useCache` (boolean)
   - `timeout` (number)
   - `retries` (number)
   - `priority` ('high' | 'normal')

4. Events:
   - Log request start/end
   - Log cache hits
   - Log retries
   - Log errors

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
class DataFetcher {
  constructor(config = {}) {
    this.cache = new Map();
    this.pending = new Map();
    this.queue = [];
    this.maxConcurrent = config.maxConcurrent || 5;
    this.activeCalls = 0;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GET method vá»›i caching
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async get(url, options = {}) {
    const {
      useCache = true,
      timeout = 5000,
      retries = 3,
      priority = "normal",
    } = options;

    // Check cache
    if (useCache && this.cache.has(url)) {
      console.log(`[CACHE HIT] ${url}`);
      return this.cache.get(url);
    }

    // Check if already fetching
    if (this.pending.has(url)) {
      console.log(`[PENDING] Waiting for ${url}`);
      return this.pending.get(url);
    }

    // Create fetch promise
    const fetchPromise = this._fetch(url, { timeout, retries });

    // Store pending
    this.pending.set(url, fetchPromise);

    try {
      const data = await fetchPromise;

      // Cache success
      if (useCache) {
        this.cache.set(url, data);
      }

      return data;
    } finally {
      this.pending.delete(url);
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // POST method
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async post(url, data, options = {}) {
    const { timeout = 5000, retries = 3 } = options;

    return this._fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
      timeout,
      retries,
    });
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Core fetch vá»›i retry vÃ  timeout
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async _fetch(url, options) {
    const { timeout, retries, ...fetchOptions } = options;

    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        console.log(`[REQUEST] ${url} (attempt ${attempt + 1}/${retries + 1})`);

        // Create timeout promise
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);

        // Fetch vá»›i timeout
        const response = await fetch(url, {
          ...fetchOptions,
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        console.log(`[SUCCESS] ${url}`);

        return data;
      } catch (error) {
        const isLastAttempt = attempt === retries;

        if (error.name === "AbortError") {
          console.log(`[TIMEOUT] ${url}`);
        } else {
          console.log(`[ERROR] ${url}: ${error.message}`);
        }

        if (isLastAttempt) {
          throw new Error(
            `Failed after ${retries + 1} attempts: ${error.message}`
          );
        }

        // Exponential backoff
        const delay = 1000 * Math.pow(2, attempt);
        console.log(`[RETRY] Waiting ${delay}ms before retry...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Cache management
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  clearCache(url) {
    if (url) {
      this.cache.delete(url);
      console.log(`[CACHE CLEARED] ${url}`);
    } else {
      this.cache.clear();
      console.log("[CACHE CLEARED] All cache cleared");
    }
  }

  getCacheStats() {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys()),
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Batch requests
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async fetchAll(urls, options = {}) {
    console.log(`[BATCH] Fetching ${urls.length} URLs`);

    const promises = urls.map((url) =>
      this.get(url, options).catch((error) => ({ error: error.message, url }))
    );

    const results = await Promise.all(promises);

    const successful = results.filter((r) => !r.error);
    const failed = results.filter((r) => r.error);

    console.log(
      `[BATCH COMPLETE] ${successful.length} success, ${failed.length} failed`
    );

    return { successful, failed };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // Utility methods
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  getPendingRequests() {
    return Array.from(this.pending.keys());
  }

  hasPending() {
    return this.pending.size > 0;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Usage Examples
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function demo() {
  const fetcher = new DataFetcher({ maxConcurrent: 3 });

  console.log("Demo 1: Basic fetch vá»›i cache");
  console.log("â”€".repeat(50));

  // First fetch - hits API
  const user1 = await fetcher.get(
    "https://jsonplaceholder.typicode.com/users/1"
  );
  console.log("User:", user1.name);

  // Second fetch - cache hit
  const user1Again = await fetcher.get(
    "https://jsonplaceholder.typicode.com/users/1"
  );
  console.log("User (cached):", user1Again.name);

  console.log("\nDemo 2: Parallel requests");
  console.log("â”€".repeat(50));

  // Fetch multiple users
  const { successful, failed } = await fetcher.fetchAll([
    "https://jsonplaceholder.typicode.com/users/1",
    "https://jsonplaceholder.typicode.com/users/2",
    "https://jsonplaceholder.typicode.com/users/3",
  ]);

  console.log(`Fetched ${successful.length} users`);

  console.log("\nDemo 3: Cache stats");
  console.log("â”€".repeat(50));

  const stats = fetcher.getCacheStats();
  console.log("Cache size:", stats.size);
  console.log("Cached URLs:", stats.keys);

  console.log("\nDemo 4: POST request");
  console.log("â”€".repeat(50));

  const newPost = await fetcher.post(
    "https://jsonplaceholder.typicode.com/posts",
    {
      title: "Test Post",
      body: "This is a test",
      userId: 1,
    }
  );
  console.log("Created post:", newPost);

  console.log("\nDemo 5: Error handling");
  console.log("â”€".repeat(50));

  try {
    await fetcher.get("https://jsonplaceholder.typicode.com/invalid", {
      retries: 2,
      timeout: 3000,
    });
  } catch (error) {
    console.log("Caught error:", error.message);
  }
}

demo();
```

**Key Points**:

- Class-based architecture
- Caching mechanism
- Retry with exponential backoff
- Timeout handling
- Batch requests
- Error handling
- Logging system
</details>

---

### ğŸ’ª Exercise 5: Production API Service Layer (â­â­â­â­â­) - 90 phÃºt

**YÃªu cáº§u**: Build complete API service layer cho production app.

**Your Task**:

1. Create module structure:

   ```
   api/
   â”œâ”€â”€ core/
   â”‚   â”œâ”€â”€ http.js      (HTTP client)
   â”‚   â”œâ”€â”€ cache.js     (Cache manager)
   â”‚   â””â”€â”€ queue.js     (Request queue)
   â”œâ”€â”€ services/
   â”‚   â”œâ”€â”€ users.js
   â”‚   â”œâ”€â”€ posts.js
   â”‚   â””â”€â”€ comments.js
   â”œâ”€â”€ utils/
   â”‚   â”œâ”€â”€ retry.js
   â”‚   â”œâ”€â”€ timeout.js
   â”‚   â””â”€â”€ validators.js
   â””â”€â”€ index.js
   ```

2. Features cáº§n implement:

   - Request/response interceptors
   - Global error handling
   - Loading states
   - Request deduplication
   - Optimistic updates
   - Offline support (mock)

3. Service methods:
   - CRUD operations
   - Pagination
   - Filtering
   - Sorting

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: api/core/http.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class HttpClient {
  constructor(config = {}) {
    this.baseURL = config.baseURL || ''
    this.timeout = config.timeout || 5000
    this.headers = config.headers || {}
    this.interceptors = {
      request: [],
      response: [],
      error: []
    }
  }

  // Add request interceptor
  addRequestInterceptor(fn) {
    this.interceptors.request.push(fn)
  }

  // Add response interceptor
  addResponseInterceptor(fn) {
    this.interceptors.response.push(fn)
  }

  // Add error interceptor
  addErrorInterceptor(fn) {
    this.interceptors.error.push(fn)
  }

  // Process request interceptors
  async _processRequestInterceptors(config) {
    let processedConfig = { ...config }

    for (const interceptor of this.interceptors.request) {
      processedConfig = await interceptor(processedConfig)
    }

    return processedConfig
  }

  // Process response interceptors
  async _processResponseInterceptors(response) {
    let processedResponse = response

    for (const interceptor of this.interceptors.response) {
      processedResponse = await interceptor(processedResponse)
    }

    return processedResponse
  }

  // Process error interceptors
  async _processErrorInterceptors(error) {
    let processedError = error

    for (const interceptor of this.interceptors.error) {
      processedError = await interceptor(processedError)
    }

    return processedError
  }

  // Core request method
  async request(config) {
    try {
      // Process request interceptors
      const processedConfig = await this._processRequestInterceptors(config)

      // Build URL
      const url = processedConfig.url.startsWith('http')
        ? processedConfig.url
        : `${this.baseURL}${processedConfig.url}`

      // Merge headers
      const headers = {
        ...this.headers,
        ...processedConfig.headers
      }

      // Create abort controller for timeout
      const controller = new AbortController()
      const timeoutId = setTimeout(
        () => controller.abort(),
        processedConfig.timeout || this.timeout
      )

      // Make request
      const response = await fetch(url, {
        method: processedConfig.method || 'GET',
        headers,
        body: processedConfig.body,
        signal: controller.signal
      })

      clearTimeout(timeoutId)

      // Check response
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }

      // Parse response
      const data = await response.json()

      // Process response interceptors
      const processedResponse = await this._processResponseInterceptors({
        data,
        status: response.status,
        headers: response.headers,
        config: processedConfig
      })

      return processedResponse
    } catch (error) {
      // Process error interceptors
      const processedError = await this._processErrorInterceptors(error)
      throw processedError
    }
  }

  // Convenience methods
  get(url, config = {}) {
    return this.request({ ...config, method: 'GET', url })
  }

  post(url, data, config = {}) {
    return this.request({
      ...config,
      method: 'POST',
      url,
      body: JSON.stringify(data),
      headers: {
        'Content-Type': 'application/json',
        ...config.headers
      }
    })
  }

  put(url, data, config = {}) {
    return this.request({
      ...config,
      method: 'PUT',
      url,
      body: JSON.stringify(data),
      headers: {
        'Content-Type': 'application/json',
        ...config.headers
      }
    })
  }

  delete(url, config = {}) {
    return this.request({ ...config, method: 'DELETE', url })
  }
}

export default HttpClient

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: api/core/cache.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CacheManager {
  constructor(config = {}) {
    this.cache = new Map()
    this.ttl = config.ttl || 60000 // 1 minute default
  }

  _getCacheKey(url, params) {
    const paramStr = params ? JSON.stringify(params) : ''
    return `${url}${paramStr}`
  }

  get(url, params) {
    const key = this._getCacheKey(url, params)
    const cached = this.cache.get(key)

    if (!cached) return null

    // Check if expired
    if (Date.now() > cached.expiresAt) {
      this.cache.delete(key)
      return null
    }

    return cached.data
  }

  set(url, params, data, customTtl) {
    const key = this._getCacheKey(url, params)
    const ttl = customTtl || this.ttl

    this.cache.set(key, {
      data,
      expiresAt: Date.now() + ttl
    })
  }

  clear(url, params) {
    if (url) {
      const key = this._getCacheKey(url, params)
      this.cache.delete(key)
    } else {
      this.cache.clear()
    }
  }

  clearPattern(pattern) {
    const keys = Array.from(this.cache.keys())
    keys.forEach(key => {
      if (key.includes(pattern)) {
        this.cache.delete(key)
      }
    })
  }
}

export default CacheManager

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: api/services/users.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { http, cache } from '../index.js'

export const userService = {
  async getUsers(params = {}) {
    const { page = 1, limit = 10, search = '' } = params

    // Check cache
    const cached = cache.get('/users', params)
    if (cached) {
      console.log('[CACHE HIT] /users')
      return cached
    }

    // Build query string
    const queryParams = new URLSearchParams({
      _page: page,
      _limit: limit,
      ...(search && { q: search })
    })

    const response = await http.get(`/users?${queryParams}`)

    // Cache result
    cache.set('/users', params, response.data)

    return response.data
  },

  async getUser(id) {
    const cached = cache.get(`/users/${id}`)
    if (cached) {
      console.log(`[CACHE HIT] /users/${id}`)
      return cached
    }

    const response = await http.get(`/users/${id}`)
    cache.set(`/users/${id}`, null, response.data)

    return response.data
  },

  async createUser(userData) {
    const response = await http.post('/users', userData)

    // Clear users list cache
    cache.clearPattern('/users?')

    return response.data
  },

  async updateUser(id, updates) {
    const response = await http.put(`/users/${id}`, updates)

    // Clear cache
    cache.clear(`/users/${id}`)
    cache.clearPattern('/users?')

    return response.data
  },

  async deleteUser(id) {
    const response = await http.delete(`/users/${id}`)

    // Clear cache
    cache.clear(`/users/${id}`)
    cache.clearPattern('/users?')

    return response.data
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: api/index.js
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import HttpClient from './core/http.js'
import CacheManager from './core/cache.js'

// Create instances
export const http = new HttpClient({
  baseURL: 'https://jsonplaceholder.typicode.com',
  timeout: 5000
})

export const cache = new CacheManager({
  ttl: 60000 // 1 minute
})

// Add logging interceptor
http.addRequestInterceptor(config => {
  console.log(`[REQUEST] ${config.method} ${config.url}`)
  return config
})

http.addResponseInterceptor(response => {
  console.log(`[RESPONSE] ${response.status}`)
  return response
})

http.addErrorInterceptor(error => {
  console.error(`[ERROR] ${error.message}`)
  return error
})

// Export services
export { userService } from './services/users.js'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE: main.js - Usage Example
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { userService } from './api/index.js'

async function demo() {
  try {
    console.log('Demo 1: Fetch users')
    console.log('â”€'.repeat(50))

    const users = await userService.getUsers({ page: 1, limit: 5 })
    console.log(`Fetched ${users.length} users`)
    console.log('First user:', users[0].name)

    console.log('\nDemo 2: Cache hit')
    console.log('â”€'.repeat(50))

    const usersAgain = await userService.getUsers({ page: 1, limit: 5 })
    console.log('Users fetched again (from cache)')

    console.log('\nDemo 3: Get single user')
    console.log('â”€'.repeat(50))

    const user = await userService.getUser(1)
    console.log('User:', user.name, user.email)

    console.log('\nDemo 4: Create user')
    console.log('â”€'.repeat(50))

    const newUser = await userService.createUser({
      name: 'Test User',
      email: 'test@example.com'
    })
    console.log('Created user:', newUser)

    console.log('\nDemo 5: Update user')
    console.log('â”€'.repeat(50))

    const updated = await userService.updateUser(1, {
      name: 'Updated Name'
    })
    console.log('Updated user:', updated)

  } catch (error) {
    console.error('Demo failed:', error)
  }
}

demo()
```

**Key Points**:

- Complete API layer architecture
- HTTP client vá»›i interceptors
- Cache management
- Service pattern
- Error handling
- Logging
- Production-ready structure
</details>

---

## VI. DEBUG LAB (20 phÃºt)

### ğŸ› Bug 1: Promise Chain Error

```javascript
// Component nÃ y cÃ³ bug trong promise chain. TÃ¬m vÃ  fix.

function fetchUserData(userId) {
  return fetch(`/api/users/${userId}`)
    .then((response) => response.json())
    .then((user) => {
      console.log("User:", user.name);
      fetch(`/api/posts?userId=${user.id}`);
    })
    .then((posts) => {
      console.log("Posts:", posts); // undefined!
      return posts;
    })
    .catch((error) => console.error(error));
}

// Bug: Posts khÃ´ng Ä‘Æ°á»£c log ra
// Táº¡i sao posts lÃ  undefined?
```

<details>
<summary>ğŸ’¡ Solution & Explanation</summary>

```javascript
// âœ… Fixed version:

function fetchUserData(userId) {
  return fetch(`/api/users/${userId}`)
    .then((response) => response.json())
    .then((user) => {
      console.log("User:", user.name);
      // MUST return the promise!
      return fetch(`/api/posts?userId=${user.id}`);
    })
    .then((response) => response.json()) // Parse response
    .then((posts) => {
      console.log("Posts:", posts); // Now works!
      return posts;
    })
    .catch((error) => console.error(error));
}
```

**Issues Fixed**:

1. **Missing return**: `fetch()` trong `.then()` khÃ´ng Ä‘Æ°á»£c return

   - Promise chain bá»‹ break
   - Next `.then()` receives undefined

2. **Missing JSON parse**: Cáº§n parse response.json()

**Why this happens**:

```javascript
// Wrong:
.then(user => {
  fetch('/api/posts')  // Promise not returned
})
.then(posts => {
  // posts is undefined (khÃ´ng pháº£i fetch result)
})

// Right:
.then(user => {
  return fetch('/api/posts')  // Return promise
})
.then(response => response.json())
.then(posts => {
  // posts is actual data
})
```

</details>

---

### ğŸ› Bug 2: Async/Await Logic Error

```javascript
// Function nÃ y cÃ³ bug. TÃ¬m issue.

async function processUsers(userIds) {
  const users = [];

  for (const id of userIds) {
    const user = await fetchUser(id);
    users.push(user);
  }

  return users;
}

// Usage vá»›i 10 users
const users = await processUsers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);

// Bug: Ráº¥t cháº­m! Máº¥t 10 seconds thay vÃ¬ 1 second
// Táº¡i sao?
```

<details>
<summary>ğŸ’¡ Solution & Explanation</summary>

```javascript
// âœ… Fixed version - Parallel execution:

async function processUsers(userIds) {
  // Create array of promises
  const promises = userIds.map((id) => fetchUser(id));

  // Wait for all to complete
  const users = await Promise.all(promises);

  return users;
}

// Or vá»›i error handling cho tá»«ng user:
async function processUsersWithErrors(userIds) {
  const promises = userIds.map((id) =>
    fetchUser(id).catch((error) => ({
      error: error.message,
      id,
    }))
  );

  const results = await Promise.all(promises);

  return {
    successful: results.filter((r) => !r.error),
    failed: results.filter((r) => r.error),
  };
}
```

**Issues Fixed**:

1. **Sequential execution**: `await` trong loop chá» tá»«ng request

   - Request 1 â†’ wait â†’ Request 2 â†’ wait â†’ ...
   - Total time: 10 Ã— 1 second = 10 seconds

2. **Should use parallel**: Cháº¡y all requests cÃ¹ng lÃºc
   - All requests start together
   - Total time: ~1 second

**Comparison**:

```javascript
// âŒ Sequential (slow)
for (const id of ids) {
  const user = await fetchUser(id); // Wait each
}
// Time: n Ã— request_time

// âœ… Parallel (fast)
const promises = ids.map((id) => fetchUser(id));
const users = await Promise.all(promises); // Wait once
// Time: request_time
```

**When to use sequential**:

- Requests depend on previous results
- Rate limiting concerns
- Memory constraints vá»›i large datasets
</details>

---

### ğŸ› Bug 3: Module Import Error

```javascript
// Code nÃ y cÃ³ bug vá»›i modules. TÃ¬m issue.

// FILE: utils.js
export default function calculate(a, b) {
  return a + b;
}

export const PI = 3.14159;

// FILE: main.js
import calculate from "./utils.js";
import PI from "./utils.js"; // Error!

console.log(calculate(1, 2));
console.log(PI);

// Bug: Cannot import PI
// Táº¡i sao?
```

<details>
<summary>ğŸ’¡ Solution & Explanation</summary>

```javascript
// âœ… Fixed version:

// FILE: utils.js (unchanged)
export default function calculate(a, b) {
  return a + b;
}

export const PI = 3.14159;

// FILE: main.js (fixed imports)
import calculate from "./utils.js"; // Default import
import { PI } from "./utils.js"; // Named import

// Or import both together:
import calculate, { PI } from "./utils.js";

console.log(calculate(1, 2)); // 3
console.log(PI); // 3.14159
```

**Issues Fixed**:

1. **Wrong import syntax**: Named exports cáº§n curly braces `{}`
2. **Default vs Named**: KhÃ¡c syntax

**Import rules**:

```javascript
// Default export:
export default Something
import Something from './file.js'  // Any name
import AnyName from './file.js'    // Works

// Named export:
export const Something = value
import { Something } from './file.js'  // Exact name
import { Something as Other } from './file.js'  // Alias

// Both:
export default Main
export const Helper = value

import Main from './file.js'  // Default
import { Helper } from './file.js'  // Named
import Main, { Helper } from './file.js'  // Both
```

</details>

---

## VII. INTERVIEW PREP (15 phÃºt)

### ğŸ’¼ Junior Level Questions

**Q1**: Promise cÃ³ bao nhiÃªu states vÃ  lÃ  gÃ¬?

<details>
<summary>Expected Answer</summary>

**Promise cÃ³ 3 states**:

**1. Pending** (Chá»):

- Initial state khi Promise Ä‘Æ°á»£c táº¡o
- Operation chÆ°a complete
- ChÆ°a fulfilled hoáº·c rejected

**2. Fulfilled** (ThÃ nh cÃ´ng):

- Operation completed successfully
- Has resulting value
- Triggers `.then()` callbacks

**3. Rejected** (Tháº¥t báº¡i):

- Operation failed
- Has rejection reason (error)
- Triggers `.catch()` callbacks

**Diagram**:

```
      Pending
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â†“         â†“
Fulfilled  Rejected
(success)  (error)
    â”‚         â”‚
  .then()  .catch()
```

**Example**:

```javascript
const promise = new Promise((resolve, reject) => {
  // Pending state

  if (success) {
    resolve(value); // â†’ Fulfilled
  } else {
    reject(error); // â†’ Rejected
  }
});

promise
  .then((value) => {}) // Fulfilled
  .catch((error) => {}); // Rejected
```

**Key points**:

- State changes are **irreversible**
- Once fulfilled/rejected, stays that way
- Cannot change from fulfilled to rejected or vice versa
</details>

---

**Q2**: Sá»± khÃ¡c biá»‡t giá»¯a Promises vÃ  Async/Await?

<details>
<summary>Expected Answer</summary>

**Same functionality, different syntax**:

**Promises** (older):

```javascript
function getUser() {
  return fetch("/api/user")
    .then((response) => response.json())
    .then((user) => {
      console.log(user);
      return user;
    })
    .catch((error) => {
      console.error(error);
      throw error;
    });
}
```

**Async/Await** (modern):

```javascript
async function getUser() {
  try {
    const response = await fetch("/api/user");
    const user = await response.json();
    console.log(user);
    return user;
  } catch (error) {
    console.error(error);
    throw error;
  }
}
```

**Comparison**:

| Feature            | Promises                 | Async/Await          |
| ------------------ | ------------------------ | -------------------- |
| **Syntax**         | Chaining `.then()`       | Looks like sync code |
| **Readability**    | Harder vá»›i nhiá»u chains  | Easier to read       |
| **Error handling** | `.catch()`               | `try/catch`          |
| **Debugging**      | Harder stack traces      | Better stack traces  |
| **Compatibility**  | All Promise environments | ES2017+              |

**When to use each**:

- **Promises**: Simple chains, library code
- **Async/Await**: Complex logic, multiple steps, better readability

**Under the hood**: Async/Await lÃ  syntactic sugar over Promises

```javascript
async function fn() {
  return value;
}
// Equivalent to:
function fn() {
  return Promise.resolve(value);
}
```

</details>

---

**Q3**: Optional chaining (`?.`) khÃ¡c gÃ¬ vá»›i logical AND (`&&`)?

<details>
<summary>Expected Answer</summary>

**Optional Chaining (`?.`)**:

- Checks for `null` hoáº·c `undefined`
- Returns `undefined` náº¿u property khÃ´ng exist
- Short-circuits evaluation

**Logical AND (`&&`)**:

- Checks for falsy values (0, '', false, null, undefined, NaN)
- Returns first falsy value hoáº·c last value
- Used for conditional execution

**Examples**:

```javascript
const user = {
  name: "John",
  address: null,
};

// Optional chaining
console.log(user?.address?.city); // undefined (safe)
console.log(user?.phone?.number); // undefined (safe)

// Logical AND
console.log(user && user.address && user.address.city); // null
console.log(user && user.phone && user.phone.number); // undefined

// Key difference:
const data = {
  count: 0,
  text: "",
  flag: false,
};

// Optional chaining - only checks null/undefined
console.log(data?.count); // 0 (returned)
console.log(data?.text); // '' (returned)
console.log(data?.flag); // false (returned)

// Logical AND - checks all falsy
console.log(data && data.count); // 0 (falsy, so returns 0)
console.log(data && data.text); // '' (falsy, so returns '')
console.log(data && data.flag); // false (falsy, so returns false)
```

**When to use each**:

**Use `?.`**:

- Safe property access
- Accessing nested optional properties
- Calling optional methods

**Use `&&`**:

- Conditional rendering
- Short-circuit evaluation
- When you want to check for any falsy value

**Best practice**: Use `?.` cho property access, `&&` cho conditional logic

</details>

---

### ğŸ’¼ Mid Level Questions

**Q4**: Giáº£i thÃ­ch Promise.all(), Promise.race(), vÃ  Promise.allSettled(). Khi nÃ o dÃ¹ng má»—i cÃ¡i?

<details>
<summary>Expected Answer</summary>

**Promise.all()**:

- Waits for **all** promises to fulfill
- Returns array of results in same order
- **Rejects immediately** if any promise rejects
- Fast-fail behavior

```javascript
const promises = [
  fetch("/api/user"),
  fetch("/api/posts"),
  fetch("/api/comments"),
];

// All must succeed
const [user, posts, comments] = await Promise.all(promises);
// If ANY fails, entire operation fails
```

**Use cases**:

- All requests equally important
- Need all data to proceed
- Fail-fast behavior desired

**Promise.race()**:

- Returns when **first** promise settles (fulfilled or rejected)
- Ignores other promises
- Winner takes all

```javascript
const promises = [fetch("/api/primary"), fetch("/api/fallback"), timeout(5000)];

// First one to finish wins
const result = await Promise.race(promises);
```

**Use cases**:

- Timeout implementation
- Fastest server wins
- Fallback strategies

**Promise.allSettled()**:

- Waits for **all** promises to settle
- **Never rejects**
- Returns array of results with status

```javascript
const promises = [
  fetch("/api/user"), // Success
  fetch("/api/invalid"), // Fail
  fetch("/api/posts"), // Success
];

const results = await Promise.allSettled(promises);
// [
//   { status: 'fulfilled', value: ... },
//   { status: 'rejected', reason: ... },
//   { status: 'fulfilled', value: ... }
// ]
```

**Use cases**:

- Some failures acceptable
- Need to know all results
- Graceful degradation

**Comparison Table**:

| Method                 | Resolves When | Rejects When  | Use Case       |
| ---------------------- | ------------- | ------------- | -------------- |
| `Promise.all()`        | All fulfill   | Any rejects   | All or nothing |
| `Promise.race()`       | First settles | First rejects | Fastest wins   |
| `Promise.allSettled()` | All settle    | Never         | Best effort    |

**Example scenarios**:

```javascript
// Scenario 1: Loading page data (all required)
const pageData = await Promise.all([
  fetchUser(),
  fetchSettings(),
  fetchPreferences(),
]);

// Scenario 2: Timeout implementation
const data = await Promise.race([fetchData(), timeout(5000)]);

// Scenario 3: Analytics tracking (failures OK)
const results = await Promise.allSettled([
  trackEvent1(),
  trackEvent2(),
  trackEvent3(),
]);
```

</details>

---

**Q5**: LÃ m sao implement retry logic vá»›i exponential backoff?

<details>
<summary>Expected Answer</summary>

**Exponential Backoff**:

- Increase delay between retries exponentially
- Prevents overwhelming server
- Common pattern: delay = baseDelay Ã— 2^attempt

**Basic Implementation**:

```javascript
async function fetchWithRetry(url, maxRetries = 3, baseDelay = 1000) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      // Last attempt - throw error
      if (attempt === maxRetries) {
        throw new Error(
          `Failed after ${maxRetries} attempts: ${error.message}`
        );
      }

      // Calculate delay vá»›i exponential backoff
      const delay = baseDelay * Math.pow(2, attempt);

      console.log(`Attempt ${attempt + 1} failed. Retrying in ${delay}ms...`);

      // Wait before retry
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
}
```

**Delay calculation**:

```
Attempt 1: 1000ms Ã— 2^0 = 1000ms (1s)
Attempt 2: 1000ms Ã— 2^1 = 2000ms (2s)
Attempt 3: 1000ms Ã— 2^2 = 4000ms (4s)
Attempt 4: 1000ms Ã— 2^3 = 8000ms (8s)
```

**Advanced Implementation vá»›i jitter**:

```javascript
async function fetchWithRetryAdvanced(url, options = {}) {
  const {
    maxRetries = 3,
    baseDelay = 1000,
    maxDelay = 30000,
    useJitter = true,
  } = options;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fetch(url).then((r) => r.json());
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }

      // Exponential backoff
      let delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);

      // Add jitter (randomness) Ä‘á»ƒ avoid thundering herd
      if (useJitter) {
        delay = delay * (0.5 + Math.random() * 0.5);
      }

      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
}
```

**Jitter** (randomness):

- Prevents all clients retrying at same time
- Spreads load more evenly
- Formula: `delay Ã— (0.5 + random(0, 0.5))`

**When to use retry logic**:

- Network requests
- Database operations
- External API calls
- Rate-limited services

**When NOT to retry**:

- 4xx client errors (won't succeed on retry)
- Authentication failures
- Validation errors
- Operations that aren't idempotent

**Best practices**:

1. Always have max retries
2. Use exponential backoff
3. Add jitter for distributed systems
4. Cap maximum delay
5. Log retry attempts
6. Make retries opt-in, not default
</details>

---

### ğŸ’¼ Senior Level Questions

**Q6**: Design má»™t robust API client layer cho large-scale application. Nhá»¯ng features nÃ o cáº§n cÃ³ vÃ  trade-offs?

<details>
<summary>Expected Answer</summary>

**Core Features cáº§n cÃ³**:

**1. Request/Response Interceptors**:

```javascript
// Add authentication token
client.addRequestInterceptor((config) => {
  config.headers.Authorization = `Bearer ${getToken()}`;
  return config;
});

// Transform responses
client.addResponseInterceptor((response) => {
  return response.data;
});
```

**Pros**: Centralized logic, DRY code
**Cons**: Can become complex, order matters

**2. Retry Logic vá»›i Backoff**:

```javascript
const client = new APIClient({
  retries: 3,
  backoff: "exponential",
  retryCondition: (error) => error.status >= 500,
});
```

**Pros**: Resilient to transient failures
**Cons**: Increased latency, can mask issues

**3. Request Caching**:

```javascript
const data = await client.get("/users", {
  cache: true,
  ttl: 60000, // 1 minute
});
```

**Pros**: Faster responses, reduced server load
**Cons**: Stale data, memory usage, cache invalidation complexity

**4. Request Deduplication**:

```javascript
// Multiple components request same data
// Only one actual HTTP request made
Promise.all([
  client.get("/users/1"),
  client.get("/users/1"),
  client.get("/users/1"),
]);
```

**Pros**: Prevents duplicate requests, saves bandwidth
**Cons**: Complex to implement correctly

**5. Timeout Management**:

```javascript
const data = await client.get("/slow-endpoint", {
  timeout: 5000,
});
```

**Pros**: Prevents hanging requests, better UX
**Cons**: May interrupt valid slow operations

**6. Request Cancellation**:

```javascript
const controller = client.get("/data");
// Later:
controller.cancel();
```

**Pros**: Save resources, prevent race conditions
**Cons**: Complexity, cleanup required

**7. Rate Limiting**:

```javascript
const client = new APIClient({
  rateLimit: {
    requests: 100,
    per: "minute",
  },
});
```

**Pros**: Respect API limits, prevent throttling
**Cons**: Added latency, queue management

**8. Error Handling & Retry Logic**:

```javascript
client.addErrorInterceptor((error) => {
  if (error.status === 401) {
    // Refresh token
    return refreshToken().then(() => retryRequest());
  }
  throw error;
});
```

**9. Loading States**:

```javascript
client.onLoadingChange((isLoading) => {
  updateGlobalLoadingState(isLoading);
});
```

**10. Request/Response Logging**:

```javascript
if (process.env.NODE_ENV === "development") {
  client.addLogger(console.log);
}
```

**Architecture Example**:

```javascript
class APIClient {
  constructor(config) {
    this.baseURL = config.baseURL;
    this.interceptors = { request: [], response: [], error: [] };
    this.cache = new CacheManager();
    this.queue = new RequestQueue();
    this.pending = new Map(); // Deduplication
  }

  async request(config) {
    // 1. Check cache
    const cached = this.cache.get(config);
    if (cached) return cached;

    // 2. Deduplication
    const key = this.getRequestKey(config);
    if (this.pending.has(key)) {
      return this.pending.get(key);
    }

    // 3. Apply request interceptors
    config = await this.applyInterceptors("request", config);

    // 4. Rate limiting
    await this.queue.wait();

    // 5. Make request vá»›i retry
    const promise = this.fetchWithRetry(config);
    this.pending.set(key, promise);

    try {
      // 6. Execute request
      let response = await promise;

      // 7. Apply response interceptors
      response = await this.applyInterceptors("response", response);

      // 8. Cache result
      this.cache.set(config, response);

      return response;
    } catch (error) {
      // 9. Apply error interceptors
      throw await this.applyInterceptors("error", error);
    } finally {
      this.pending.delete(key);
    }
  }

  async fetchWithRetry(config) {
    for (let attempt = 0; attempt <= config.retries; attempt++) {
      try {
        return await this.fetch(config);
      } catch (error) {
        if (attempt === config.retries || !this.shouldRetry(error)) {
          throw error;
        }
        await this.delay(this.getBackoffDelay(attempt));
      }
    }
  }
}
```

**Trade-offs to consider**:

**Performance vs Features**:

- More features = more overhead
- Caching = memory usage
- Interceptors = processing time

**Complexity vs Maintainability**:

- Advanced features = harder to debug
- Many options = steeper learning curve
- Need good documentation

**Flexibility vs Simplicity**:

- Too many options = analysis paralysis
- Sensible defaults important
- Progressive enhancement

**Client-side vs Server-side**:

- Browser limitations (CORS, storage)
- Node.js capabilities (file system, etc)
- Universal code tricky

**Recommendations**:

**For small apps**: Use fetch directly or axios
**For medium apps**: Light wrapper with interceptors
**For large apps**: Full-featured client like above

**Must-haves for production**:

1. Error handling
2. Timeout management
3. Request cancellation
4. Basic caching
5. Logging (dev mode)

**Nice-to-haves**:

1. Advanced caching strategies
2. Request deduplication
3. Rate limiting
4. Retry with backoff
5. Queue management

**Test considerations**:

- Mock network requests
- Test retry logic
- Test cache invalidation
- Test error scenarios
- Test race conditions
</details>

---

## VIII. CODE REVIEW CHECKLIST (15 phÃºt)

### ğŸ“‹ ES6+ Advanced Code Review Guide

**Khi review code vá»›i async/modules, check:**

#### âœ… Promise Usage

```javascript
// âŒ BAD
fetch("/api")
  .then((r) => r.json())
  .then((data) => {
    fetch("/api2"); // Not returned!
  })
  .then((data2) => {}); // undefined

// âœ… GOOD
fetch("/api")
  .then((r) => r.json())
  .then((data) => {
    return fetch("/api2"); // Returned
  })
  .then((r) => r.json())
  .then((data2) => {});
```

**Checklist**:

- [ ] Promises returned in chains
- [ ] Error handling vá»›i `.catch()`
- [ ] No nested promise chains
- [ ] Response properly parsed

---

#### âœ… Async/Await

```javascript
// âŒ BAD
async function getData() {
  const user = await fetchUser();
  const posts = await fetchPosts(); // Sequential!
  return { user, posts };
}

// âœ… GOOD
async function getData() {
  const [user, posts] = await Promise.all([
    fetchUser(),
    fetchPosts(), // Parallel!
  ]);
  return { user, posts };
}
```

**Checklist**:

- [ ] Try/catch for error handling
- [ ] Parallel execution when possible
- [ ] No await trong loops (unless intentional)
- [ ] Proper error messages

---

#### âœ… Module Organization

```javascript
// âŒ BAD: Everything in one file
// app.js - 1000 lines

// âœ… GOOD: Split into modules
// utils/
// â”œâ”€â”€ string.js
// â”œâ”€â”€ date.js
// â””â”€â”€ index.js
// services/
// â”œâ”€â”€ api.js
// â””â”€â”€ users.js
```

**Checklist**:

- [ ] Logical module separation
- [ ] Barrel exports for related modules
- [ ] No circular dependencies
- [ ] Clear naming conventions

---

#### âœ… Optional Chaining

```javascript
// âŒ BAD: Not using optional chaining
const city = user && user.address && user.address.city;

// âœ… GOOD: Clean vá»›i ?.
const city = user?.address?.city;

// âœ… GOOD: With default
const city = user?.address?.city ?? "Unknown";
```

**Checklist**:

- [ ] Use `?.` cho nested access
- [ ] Use `??` cho defaults (not `||`)
- [ ] Don't over-chain (redesign data)

---

#### âœ… Array Methods

```javascript
// âŒ BAD: Multiple iterations
const result = arr
  .filter((x) => x.active)
  .map((x) => x.id)
  .filter((x) => x > 0); // Could combine

// âœ… GOOD: Single pass
const result = arr.filter((x) => x.active && x.id > 0).map((x) => x.id);
```

**Checklist**:

- [ ] Minimize array iterations
- [ ] Use appropriate method (find vs filter)
- [ ] Return values in map/filter
- [ ] Handle empty arrays

---

## IX. DAILY RECAP & NEXT STEPS (10 phÃºt)

### ğŸ¯ HÃ´m nay Ä‘Ã£ há»c:

#### Core Concepts:

- âœ… Promises - Async operations foundation
- âœ… Async/Await - Modern async syntax
- âœ… ES6 Modules - Code organization
- âœ… Optional Chaining - Safe property access
- âœ… Nullish Coalescing - Smart defaults
- âœ… Advanced Array Methods - Data manipulation
- âœ… Object Methods - Object operations

#### Key Takeaways:

1. **Async/Await** cleaner than Promise chains
2. **Promise.all()** cho parallel execution
3. **Modules** essential for React apps
4. **Optional chaining** prevents crashes
5. **`??` vs `||`** - know the difference

---

### ğŸ“ Self-Assessment Questions:

1. Khi nÃ o dÃ¹ng Promise.all() vs Promise.race()?
2. Sequential vs Parallel async - khi nÃ o dÃ¹ng?
3. Default export vs Named export - khÃ¡c gÃ¬?
4. `?.` vs `&&` - khi nÃ o dÃ¹ng má»—i cÃ¡i?
5. `.find()` vs `.filter()` - khÃ¡c gÃ¬?

<details>
<summary>ğŸ’¡ Answers</summary>

1. **Promise.all() vs Promise.race()**:

   - `Promise.all()`: Wait for ALL, need all results
   - `Promise.race()`: Wait for FIRST, timeout/fallback scenarios

2. **Sequential vs Parallel**:

   - Sequential: Results depend on each other
   - Parallel: Independent requests, faster

3. **Default vs Named**:

   - Default: One main export, any import name
   - Named: Multiple exports, exact import names

4. **`?.` vs `&&`**:

   - `?.`: Safe property access, null/undefined only
   - `&&`: Conditional logic, all falsy values

5. **`.find()` vs `.filter()`**:
   - `.find()`: Returns first match or undefined
   - `.filter()`: Returns array of all matches
   </details>

---

### ğŸ”— NgÃ y mai sáº½ há»c (Day 3):

#### React Basics & JSX:

- **React introduction** - What and why
- **JSX syntax** - HTML in JavaScript
- **Setting up React** - Vite project
- **First components** - Hello World
- **Rendering basics** - Display data

#### Preparation:

- [ ] Review async/await
- [ ] Understand modules
- [ ] Practice optional chaining
- [ ] Ready to build React apps!

---

### ğŸ“š Additional Resources:

#### Official Docs:

- [MDN: Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [MDN: Async/Await](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await)
- [MDN: Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)

#### Practice:

- [JavaScript.info: Promises](https://javascript.info/promise-basics)
- [JavaScript.info: Async/Await](https://javascript.info/async-await)

---

## ğŸ‰ CONGRATULATIONS!

Báº¡n Ä‘Ã£ hoÃ n thÃ nh **NgÃ y 2: ES6+ NÃ¢ng cao**!

### ğŸ“Š Progress Tracker:

```
PHASE 1: React Fundamentals (Week 1-4)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Week 1: Modern JavaScript + React Intro (Days 1-5)
â”œâ”€ [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 40% Complete
â”‚  â”œâ”€ Day 1: ES6+ Essentials âœ…
â”‚  â”œâ”€ Day 2: ES6+ Advanced âœ…
â”‚  â”œâ”€ Day 3: React Basics & JSX (Next)
â”‚  â”œâ”€ Day 4: Components & Props
â”‚  â””â”€ Day 5: Events & Conditional Rendering
```

**Great progress!** ğŸš€

---

### ğŸ’¬ Final Tips:

1. **Practice Async** - Critical cho React data fetching
2. **Master Modules** - Every React app uses them
3. **Use Optional Chaining** - Prevents so many bugs
4. **Think Parallel** - Promise.all() lÃ  friend cá»§a báº¡n
5. **Build Something** - Apply concepts trong projects

---

### âœ… Before Moving to Day 3:

Check these concepts:

- [ ] Comfortable vá»›i async/await
- [ ] Hiá»ƒu Promise chains
- [ ] Biáº¿t cÃ¡ch organize modules
- [ ] DÃ¹ng Ä‘Æ°á»£c optional chaining
- [ ] Familiar vá»›i advanced array methods

Náº¿u cÃ²n unclear á»Ÿ báº¥t ká»³ pháº§n nÃ o, review láº¡i section Ä‘Ã³ trÆ°á»›c khi Day 3!

---

**See you tomorrow for Day 3: React Basics & JSX!** ğŸ‘‹

_Tomorrow báº¡n sáº½ báº¯t Ä‘áº§u journey vá»›i React - build first component vÃ  learn JSX!_ ğŸ‰
