# üìÖ NG√ÄY 6: LISTS & KEYS - RENDERING ARRAYS HI·ªÜU QU·∫¢

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

Sau b√†i h·ªçc h√¥m nay, b·∫°n s·∫Ω:

- [ ] **Hi·ªÉu r√µ** c√°ch render arrays trong React v·ªõi `.map()`
- [ ] **N·∫Øm v·ªØng** Keys l√† g√¨ v√† T·∫†I SAO ch√∫ng quan tr·ªçng
- [ ] **Ph√¢n bi·ªát** ƒë∆∞·ª£c khi n√†o d√πng index as key, khi n√†o KH√îNG
- [ ] **Th√†nh th·∫°o** stable keys strategies cho performance
- [ ] **Tr√°nh ƒë∆∞·ª£c** common pitfalls khi l√†m vi·ªác v·ªõi lists

---

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

Tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu, h√£y tr·∫£ l·ªùi 3 c√¢u h·ªèi n√†y:

1. **Array method `.map()`** l√†m g√¨? Tr·∫£ v·ªÅ g√¨?
2. **Props** l√† g√¨? L√†m sao truy·ªÅn props v√†o component?
3. **Event handler** trong React vi·∫øt nh∆∞ th·∫ø n√†o? `onClick={func}` hay `onClick={func()}`?

<details>
<summary>üí° Xem ƒë√°p √°n</summary>

1. **`.map()`**:

```javascript
const numbers = [1, 2, 3];
const doubled = numbers.map((n) => n * 2);
// [2, 4, 6]

// T·∫°o array m·ªõi, transform m·ªói element
// KH√îNG modify original array
```

2. **Props**:

```jsx
// Pass props
<UserCard
  name='John'
  age={25}
/>;

// Receive props
function UserCard({ name, age }) {
  return (
    <div>
      {name}, {age}
    </div>
  );
}
```

3. **Event handler**:

```jsx
// ‚úÖ CORRECT: Pass reference
<button onClick={handleClick}>Click</button>

// ‚ùå WRONG: Call immediately
<button onClick={handleClick()}>Click</button>
```

</details>

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

B·∫°n c·∫ßn hi·ªÉn th·ªã 100 s·∫£n ph·∫©m. Kh√¥ng l·∫Ω vi·∫øt 100 components?

```jsx
// ‚ùå NIGHTMARE: Copy-paste 100 l·∫ßn
function ProductList() {
  return (
    <div>
      <ProductCard
        name='iPhone'
        price={999}
      />
      <ProductCard
        name='MacBook'
        price={2499}
      />
      <ProductCard
        name='iPad'
        price={599}
      />
      {/* ... 97 more products ??? */}
    </div>
  );
}
```

**V·∫•n ƒë·ªÅ:**

- üî¥ Kh√¥ng scalable (th√™m product = edit code)
- üî¥ Data hard-coded
- üî¥ Kh√¥ng th·ªÉ search, filter, sort
- üî¥ Impossible to maintain

### 1.2 Gi·∫£i Ph√°p: Render t·ª´ Data

```jsx
// ‚úÖ SOLUTION: Render t·ª´ data array
function ProductList() {
  const products = [
    { id: 1, name: 'iPhone', price: 999 },
    { id: 2, name: 'MacBook', price: 2499 },
    { id: 3, name: 'iPad', price: 599 },
    // ... c√≥ th·ªÉ 1000 products, v·∫´n OK!
  ];

  return (
    <div>
      {products.map((product) => (
        <ProductCard
          key={product.id} // ‚ö†Ô∏è IMPORTANT!
          name={product.name}
          price={product.price}
        />
      ))}
    </div>
  );
}
```

**L·ª£i √≠ch:**

- ‚úÖ Data-driven (thay ƒë·ªïi data, UI t·ª± update)
- ‚úÖ Scalable (1 product hay 10,000 - same code)
- ‚úÖ C√≥ th·ªÉ filter, sort, search
- ‚úÖ D·ªÖ maintain

### 1.3 Mental Model

```
DATA (Source of Truth)
     ‚Üì
  .map() Transform
     ‚Üì
REACT ELEMENTS (Virtual DOM)
     ‚Üì
  Reconciliation (React compares)
     ‚Üì
REAL DOM (What user sees)

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
KEYS gi√∫p React bi·∫øt:
‚Ä¢ Element n√†o changed?
‚Ä¢ Element n√†o added?
‚Ä¢ Element n√†o removed?
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
```

**üîë Keys - T·∫°i sao quan tr·ªçng?**

```
WITHOUT KEYS:
Old: [A, B, C]
New: [A, X, B, C]

React thinks:
‚ùå B changed to X
‚ùå C changed to B
‚ùå Added new C
‚Üí Re-render ALL 3 elements!

WITH KEYS:
Old: [A(1), B(2), C(3)]
New: [A(1), X(4), B(2), C(3)]

React knows:
‚úÖ A unchanged (key=1)
‚úÖ X is new (key=4)
‚úÖ B unchanged (key=2)
‚úÖ C unchanged (key=3)
‚Üí Only render X!
```

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

‚ùå **Hi·ªÉu l·∫ßm 1:** "Keys ch·ªâ ƒë·ªÉ t·∫Øt warning"

```jsx
// ‚ùå SAI: D√πng key ch·ªâ ƒë·ªÉ t·∫Øt warning
{
  items.map((item, index) => <div key={index}>{item.name}</div>);
}
// "Console s·∫°ch r·ªìi, xong!"
```

**S·ª± th·∫≠t:** Keys ·∫£nh h∆∞·ªüng TR·ª∞C TI·∫æP ƒë·∫øn performance v√† correctness!

---

‚ùå **Hi·ªÉu l·∫ßm 2:** "Index as key lu√¥n OK"

```jsx
// ‚ùå DANGEROUS khi list c√≥ th·ªÉ thay ƒë·ªïi th·ª© t·ª±
const [todos, setTodos] = useState([...]);

return todos.map((todo, index) => (
  <TodoItem key={index} todo={todo} />
));

// N·∫øu delete todo[0] ‚Üí t·∫•t c·∫£ indexes shift ‚Üí bugs!
```

**S·ª± th·∫≠t:** Index as key CH·ªà safe khi list NEVER changes (static list).

---

‚ùå **Hi·ªÉu l·∫ßm 3:** "Key ph·∫£i unique globally"

```jsx
// ‚ùå Overthinking
const globalKeyCounter = 0;
{
  items.map((item) => <div key={`global-${globalKeyCounter++}`}>...</div>);
}
```

**S·ª± th·∫≠t:** Keys ch·ªâ c·∫ßn unique trong **siblings** (anh em ru·ªôt).

```jsx
// ‚úÖ CORRECT: Key unique trong c√πng list
<div>
  {users.map(user => <User key={user.id} {...user} />)}
</div>

<div>
  {posts.map(post => <Post key={post.id} {...post} />)}
  {/* C√≥ th·ªÉ tr√πng ID v·ªõi users - OK! */}
</div>
```

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Basic List Rendering ‚≠ê

```jsx
// Simplest example
function ShoppingList() {
  const items = ['Milk', 'Bread', 'Eggs', 'Butter'];

  // ‚ùå WRONG: No key
  return (
    <ul>
      {items.map((item) => (
        <li>{item}</li> // Warning: Each child should have a unique "key"
      ))}
    </ul>
  );
}

// ‚úÖ CORRECT: With key
function ShoppingList() {
  const items = ['Milk', 'Bread', 'Eggs', 'Butter'];

  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
}

// ‚ö†Ô∏è Index as key OK here because:
// 1. List is static (never reorder/add/remove)
// 2. Items don't have unique IDs
// 3. Simple display only
```

**üéØ Khi n√†o index as key acceptable:**

- ‚úÖ Static list (hard-coded, never changes)
- ‚úÖ Display-only (no interactions)
- ‚úÖ No unique IDs available
- ‚úÖ Items won't reorder

---

### Demo 2: List with Unique IDs ‚≠ê‚≠ê

```jsx
function UserList() {
  const users = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' },
    { id: 3, name: 'Charlie', email: 'charlie@example.com' },
  ];

  // ‚ùå BAD: Using index when ID available
  return (
    <div>
      {users.map((user, index) => (
        <UserCard
          key={index}
          user={user}
        />
      ))}
    </div>
  );

  // ‚úÖ GOOD: Using unique ID
  return (
    <div>
      {users.map((user) => (
        <UserCard
          key={user.id}
          user={user}
        />
      ))}
    </div>
  );
}

function UserCard({ user }) {
  return (
    <div className='user-card'>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
}
```

**üî• Why ID is better:**

```
Scenario: Delete user Alice (index 0)

WITH INDEX KEYS:
Before: [Alice(0), Bob(1), Charlie(2)]
After:  [Bob(0), Charlie(1)]

React sees:
- Key 0: Alice ‚Üí Bob (CHANGED!)
- Key 1: Bob ‚Üí Charlie (CHANGED!)
- Key 2: Removed
‚Üí Re-renders Bob AND Charlie! ‚ùå

WITH ID KEYS:
Before: [Alice(1), Bob(2), Charlie(3)]
After:  [Bob(2), Charlie(3)]

React sees:
- Key 1: Removed
- Key 2: Unchanged ‚úì
- Key 3: Unchanged ‚úì
‚Üí Only removes Alice! ‚úÖ
```

---

### Demo 3: Nested Lists ‚≠ê‚≠ê

```jsx
function CommentThread() {
  const comments = [
    {
      id: 1,
      text: 'Great post!',
      replies: [
        { id: 101, text: 'Thanks!' },
        { id: 102, text: 'Glad you liked it' },
      ],
    },
    {
      id: 2,
      text: 'Very helpful',
      replies: [{ id: 201, text: "You're welcome!" }],
    },
  ];

  return (
    <div className='comments'>
      {comments.map((comment) => (
        <div
          key={comment.id}
          className='comment'
        >
          <p>{comment.text}</p>

          {/* Nested list - separate keys */}
          {comment.replies.length > 0 && (
            <div className='replies'>
              {comment.replies.map((reply) => (
                <div
                  key={reply.id}
                  className='reply'
                >
                  <p>{reply.text}</p>
                </div>
              ))}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

**üéØ Key Points:**

- M·ªói level c·∫ßn keys ri√™ng
- Keys ch·ªâ unique trong siblings
- Comment ID c√≥ th·ªÉ = 1, Reply ID c≈©ng = 1 (OK!)

---

### Demo 4: Keys with Events ‚≠ê‚≠ê‚≠ê

```jsx
function TodoList() {
  const todos = [
    { id: 1, text: 'Learn React', done: false },
    { id: 2, text: 'Build project', done: false },
    { id: 3, text: 'Deploy app', done: false },
  ];

  const handleToggle = (id) => {
    console.log('Toggle todo:', id);
    // S·∫Ω update state ·ªü Day 11
  };

  const handleDelete = (id) => {
    console.log('Delete todo:', id);
    // S·∫Ω update state ·ªü Day 11
  };

  return (
    <ul className='todo-list'>
      {todos.map((todo) => (
        <li
          key={todo.id}
          className='todo-item'
        >
          <input
            type='checkbox'
            checked={todo.done}
            onChange={() => handleToggle(todo.id)}
          />
          <span className={todo.done ? 'done' : ''}>{todo.text}</span>
          <button onClick={() => handleDelete(todo.id)}>üóëÔ∏è Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

**üî• Common Pattern:**

```jsx
// Pattern: map + destructure + key + event handler
{
  items.map((item) => (
    <Component
      key={item.id} // 1. Key
      {...item} // 2. Spread props
      onAction={() => handle(item.id)} // 3. Event with ID
    />
  ));
}
```

---

### Demo 5: Generating Keys (No Unique ID) ‚≠ê‚≠ê‚≠ê

```jsx
function TagCloud() {
  // Problem: Tags are just strings, no IDs
  const tags = ['React', 'JavaScript', 'CSS', 'HTML', 'Node'];

  // ‚ùå BAD: Using item as key (what if duplicate tags?)
  return (
    <div>
      {tags.map((tag) => (
        <span
          key={tag}
          className='tag'
        >
          {tag}
        </span>
      ))}
    </div>
  );

  // ‚ö†Ô∏è PROBLEM if tags = ['React', 'CSS', 'React']
  // Duplicate keys ‚Üí React warning!

  // ‚úÖ SOLUTION 1: Generate unique IDs upfront
  const tagsWithIds = tags.map((tag, index) => ({
    id: `tag-${tag}-${index}`, // Combine tag + index
    name: tag,
  }));

  return (
    <div>
      {tagsWithIds.map((tag) => (
        <span
          key={tag.id}
          className='tag'
        >
          {tag.name}
        </span>
      ))}
    </div>
  );

  // ‚úÖ SOLUTION 2: Use crypto.randomUUID() (modern browsers)
  const tagsWithUUIDs = tags.map((tag) => ({
    id: crypto.randomUUID(),
    name: tag,
  }));

  return (
    <div>
      {tagsWithUUIDs.map((tag) => (
        <span
          key={tag.id}
          className='tag'
        >
          {tag.name}
        </span>
      ))}
    </div>
  );

  // ‚ö†Ô∏è SOLUTION 3: Index (ONLY if list never changes)
  return (
    <div>
      {tags.map((tag, index) => (
        <span
          key={index}
          className='tag'
        >
          {tag}
        </span>
      ))}
    </div>
  );
}
```

**üéØ Key Generation Strategies:**

| Strategy        | When to Use          | Pros                                       | Cons                                          |
| --------------- | -------------------- | ------------------------------------------ | --------------------------------------------- |
| **Existing ID** | Data c√≥ unique ID    | ‚úÖ Best performance<br>‚úÖ Stable           | ‚ùå Requires ID field                          |
| **Combination** | `${type}-${id}`      | ‚úÖ Handle multiple lists<br>‚úÖ Descriptive | ‚ùå String concatenation                       |
| **UUID/nanoid** | Generated IDs needed | ‚úÖ Guaranteed unique<br>‚úÖ No collisions   | ‚ùå Performance cost<br>‚ùå Non-deterministic   |
| **Index**       | Static lists only    | ‚úÖ Simple<br>‚úÖ No setup                   | ‚ùå Breaks on reorder<br>‚ùå Performance issues |

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Exercise 1: Simple Product List (15 ph√∫t)

**üéØ M·ª•c ti√™u:** Render array of products  
**‚è±Ô∏è Th·ªùi gian:** 15 ph√∫t  
**üö´ KH√îNG d√πng:** State (ch∆∞a h·ªçc)

**Requirements:**

1. Render list of 5 products
2. M·ªói product c√≥: name, price, image
3. D√πng proper keys
4. Grid layout (2-3 columns)

```jsx
/**
 * üí° G·ª£i √Ω:
 * - D√πng .map() ƒë·ªÉ render array
 * - Key = product.id
 * - Format price v·ªõi $
 */

// Sample data
const products = [
  {
    id: 1,
    name: 'Laptop',
    price: 999,
    image: 'https://picsum.photos/200/150?random=1',
  },
  {
    id: 2,
    name: 'Mouse',
    price: 29,
    image: 'https://picsum.photos/200/150?random=2',
  },
  {
    id: 3,
    name: 'Keyboard',
    price: 79,
    image: 'https://picsum.photos/200/150?random=3',
  },
  {
    id: 4,
    name: 'Monitor',
    price: 299,
    image: 'https://picsum.photos/200/150?random=4',
  },
  {
    id: 5,
    name: 'Webcam',
    price: 59,
    image: 'https://picsum.photos/200/150?random=5',
  },
];

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
function ProductGrid() {
  return (
    <div className='product-grid'>
      {/* TODO: Map products to ProductCard components */}
    </div>
  );
}

function ProductCard({ product }) {
  return (
    <div className='product-card'>{/* TODO: Implement product card */}</div>
  );
}
```

<details>
<summary>üí° Solution</summary>

```jsx
function ProductGrid() {
  const products = [
    {
      id: 1,
      name: 'Laptop',
      price: 999,
      image: 'https://picsum.photos/200/150?random=1',
    },
    {
      id: 2,
      name: 'Mouse',
      price: 29,
      image: 'https://picsum.photos/200/150?random=2',
    },
    {
      id: 3,
      name: 'Keyboard',
      price: 79,
      image: 'https://picsum.photos/200/150?random=3',
    },
    {
      id: 4,
      name: 'Monitor',
      price: 299,
      image: 'https://picsum.photos/200/150?random=4',
    },
    {
      id: 5,
      name: 'Webcam',
      price: 59,
      image: 'https://picsum.photos/200/150?random=5',
    },
  ];

  return (
    <div className='container'>
      <h2>Our Products</h2>
      <div className='product-grid'>
        {products.map((product) => (
          <ProductCard
            key={product.id}
            product={product}
          />
        ))}
      </div>
    </div>
  );
}

function ProductCard({ product }) {
  return (
    <div className='product-card'>
      <img
        src={product.image}
        alt={product.name}
        className='product-image'
      />
      <h3 className='product-name'>{product.name}</h3>
      <p className='product-price'>${product.price.toLocaleString()}</p>
      <button className='add-to-cart'>Add to Cart</button>
    </div>
  );
}
```

**CSS:**

```css
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 24px;
  margin-top: 24px;
}

.product-card {
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  overflow: hidden;
  transition: transform 0.2s, box-shadow 0.2s;
}

.product-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.product-image {
  width: 100%;
  height: 200px;
  object-fit: cover;
}

.product-name {
  padding: 12px 16px 8px;
  margin: 0;
  font-size: 16px;
  font-weight: 600;
}

.product-price {
  padding: 0 16px;
  margin: 0;
  font-size: 20px;
  font-weight: bold;
  color: #1976d2;
}

.add-to-cart {
  width: 100%;
  padding: 12px;
  border: none;
  background: #1976d2;
  color: white;
  font-weight: 500;
  cursor: pointer;
  transition: background 0.2s;
}

.add-to-cart:hover {
  background: #1565c0;
}
```

</details>

---

### ‚≠ê‚≠ê Exercise 2: Filtered List (25 ph√∫t)

**üéØ M·ª•c ti√™u:** Filter array tr∆∞·ªõc khi render  
**‚è±Ô∏è Th·ªùi gian:** 25 ph√∫t

**Scenario:** T·∫°o danh s√°ch users v·ªõi filter buttons

**Requirements:**

1. List of 10 users v·ªõi role: 'admin', 'user', 'guest'
2. 4 buttons: All, Admin, User, Guest
3. Click button ‚Üí show only users v·ªõi role ƒë√≥
4. Highlight active filter button

```jsx
// Sample data
const users = [
  { id: 1, name: 'Alice', role: 'admin', email: 'alice@example.com' },
  { id: 2, name: 'Bob', role: 'user', email: 'bob@example.com' },
  { id: 3, name: 'Charlie', role: 'guest', email: 'charlie@example.com' },
  { id: 4, name: 'David', role: 'admin', email: 'david@example.com' },
  { id: 5, name: 'Eve', role: 'user', email: 'eve@example.com' },
  { id: 6, name: 'Frank', role: 'user', email: 'frank@example.com' },
  { id: 7, name: 'Grace', role: 'guest', email: 'grace@example.com' },
  { id: 8, name: 'Henry', role: 'admin', email: 'henry@example.com' },
  { id: 9, name: 'Ivy', role: 'user', email: 'ivy@example.com' },
  { id: 10, name: 'Jack', role: 'guest', email: 'jack@example.com' },
];

// üéØ NHI·ªÜM V·ª§:
function UserDirectory() {
  let activeFilter = 'all'; // TODO: Will use state on Day 11

  const handleFilterClick = (filter) => {
    activeFilter = filter;
    console.log('Filter:', filter);
  };

  // TODO: Filter users based on activeFilter
  const filteredUsers = users; // Replace with filtered array

  return (
    <div className='user-directory'>
      <div className='filters'>
        {/* TODO: Render filter buttons */}
        <button onClick={() => handleFilterClick('all')}>
          All ({users.length})
        </button>
        {/* TODO: Admin, User, Guest buttons */}
      </div>

      <div className='user-list'>{/* TODO: Map filteredUsers */}</div>
    </div>
  );
}
```

<details>
<summary>üí° Solution</summary>

```jsx
function UserDirectory() {
  const users = [
    { id: 1, name: 'Alice', role: 'admin', email: 'alice@example.com' },
    { id: 2, name: 'Bob', role: 'user', email: 'bob@example.com' },
    { id: 3, name: 'Charlie', role: 'guest', email: 'charlie@example.com' },
    { id: 4, name: 'David', role: 'admin', email: 'david@example.com' },
    { id: 5, name: 'Eve', role: 'user', email: 'eve@example.com' },
    { id: 6, name: 'Frank', role: 'user', email: 'frank@example.com' },
    { id: 7, name: 'Grace', role: 'guest', email: 'grace@example.com' },
    { id: 8, name: 'Henry', role: 'admin', email: 'henry@example.com' },
    { id: 9, name: 'Ivy', role: 'user', email: 'ivy@example.com' },
    { id: 10, name: 'Jack', role: 'guest', email: 'jack@example.com' },
  ];

  let activeFilter = 'all'; // Will use state on Day 11

  const handleFilterClick = (filter) => {
    activeFilter = filter;
    console.log('Active filter:', filter);
  };

  // Filter logic
  const filteredUsers =
    activeFilter === 'all'
      ? users
      : users.filter((user) => user.role === activeFilter);

  // Count by role
  const counts = {
    all: users.length,
    admin: users.filter((u) => u.role === 'admin').length,
    user: users.filter((u) => u.role === 'user').length,
    guest: users.filter((u) => u.role === 'guest').length,
  };

  const filters = [
    { key: 'all', label: 'All' },
    { key: 'admin', label: 'Admins' },
    { key: 'user', label: 'Users' },
    { key: 'guest', label: 'Guests' },
  ];

  return (
    <div className='user-directory'>
      <h2>User Directory</h2>

      <div className='filters'>
        {filters.map((filter) => (
          <button
            key={filter.key}
            className={`filter-btn ${
              activeFilter === filter.key ? 'active' : ''
            }`}
            onClick={() => handleFilterClick(filter.key)}
          >
            {filter.label} ({counts[filter.key]})
          </button>
        ))}
      </div>

      <div className='user-list'>
        {filteredUsers.map((user) => (
          <div
            key={user.id}
            className='user-card'
          >
            <div className='user-avatar'>{user.name.charAt(0)}</div>
            <div className='user-info'>
              <h3>{user.name}</h3>
              <p className='user-email'>{user.email}</p>
              <span className={`role-badge role-${user.role}`}>
                {user.role}
              </span>
            </div>
          </div>
        ))}
      </div>

      <div className='note'>
        <strong>Note:</strong> Filter state won't persist (need useState - Day
        11). Check console for clicks.
      </div>
    </div>
  );
}
```

**CSS:**

```css
.user-directory {
  max-width: 800px;
  margin: 20px auto;
  padding: 20px;
}

.filters {
  display: flex;
  gap: 12px;
  margin-bottom: 24px;
  flex-wrap: wrap;
}

.filter-btn {
  padding: 8px 16px;
  border: 2px solid #e0e0e0;
  border-radius: 6px;
  background: white;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s;
}

.filter-btn:hover {
  border-color: #1976d2;
  background: #f5f5f5;
}

.filter-btn.active {
  border-color: #1976d2;
  background: #1976d2;
  color: white;
}

.user-list {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.user-card {
  display: flex;
  gap: 16px;
  padding: 16px;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  transition: transform 0.2s;
}

.user-card:hover {
  transform: translateX(4px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.user-avatar {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: #1976d2;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  font-weight: bold;
}

.user-info {
  flex: 1;
}

.user-info h3 {
  margin: 0 0 4px 0;
  font-size: 16px;
}

.user-email {
  margin: 0 0 8px 0;
  font-size: 14px;
  color: #666;
}

.role-badge {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;
  text-transform: uppercase;
}

.role-admin {
  background: #ffebee;
  color: #c62828;
}

.role-user {
  background: #e3f2fd;
  color: #1565c0;
}

.role-guest {
  background: #f5f5f5;
  color: #616161;
}

.note {
  margin-top: 20px;
  padding: 12px;
  background: #fff3cd;
  border-left: 4px solid #ffc107;
  font-size: 14px;
}
```

</details>

---

### ‚≠ê‚≠ê‚≠ê Exercise 3: Sortable Table (40 ph√∫t)

**üéØ M·ª•c ti√™u:** Render table v·ªõi sort functionality  
**‚è±Ô∏è Th·ªùi gian:** 40 ph√∫t

**üìã Product Requirements:**
User Story: "L√† user, t√¥i mu·ªën xem b·∫£ng d·ªØ li·ªáu v√† sort theo c√°c columns ƒë·ªÉ d·ªÖ t√¨m th√¥ng tin."

**‚úÖ Acceptance Criteria:**

- [ ] Table v·ªõi 4 columns: Name, Age, Department, Salary
- [ ] Click column header ‚Üí sort theo column ƒë√≥
- [ ] Click l·∫ßn 2 ‚Üí reverse sort (ascending/descending)
- [ ] Visual indicator cho sort direction (‚Üë ‚Üì)
- [ ] Highlight sorted column

```jsx
// Sample data
const employees = [
  {
    id: 1,
    name: 'Alice Johnson',
    age: 28,
    department: 'Engineering',
    salary: 85000,
  },
  { id: 2, name: 'Bob Smith', age: 34, department: 'Marketing', salary: 72000 },
  {
    id: 3,
    name: 'Charlie Brown',
    age: 29,
    department: 'Engineering',
    salary: 90000,
  },
  { id: 4, name: 'Diana Prince', age: 31, department: 'Sales', salary: 78000 },
  {
    id: 5,
    name: 'Edward Norton',
    age: 42,
    department: 'Engineering',
    salary: 105000,
  },
  {
    id: 6,
    name: 'Fiona Apple',
    age: 26,
    department: 'Marketing',
    salary: 65000,
  },
  { id: 7, name: 'George Lucas', age: 38, department: 'Sales', salary: 82000 },
  { id: 8, name: 'Hannah Montana', age: 24, department: 'HR', salary: 58000 },
];

// üéØ NHI·ªÜM V·ª§:
function EmployeeTable() {
  let sortBy = 'name'; // 'name' | 'age' | 'department' | 'salary'
  let sortOrder = 'asc'; // 'asc' | 'desc'

  const handleSort = (column) => {
    if (sortBy === column) {
      // Toggle order if same column
      sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
    } else {
      // New column, default to ascending
      sortBy = column;
      sortOrder = 'asc';
    }
    console.log(`Sort by ${sortBy} ${sortOrder}`);
  };

  // TODO: Sort employees array
  const sortedEmployees = [...employees]; // Replace with sorted array

  return (
    <div className='employee-table-container'>
      <h2>Employee Directory</h2>

      <table className='employee-table'>
        <thead>
          <tr>
            <th onClick={() => handleSort('name')}>
              Name {/* TODO: Add sort indicator */}
            </th>
            <th onClick={() => handleSort('age')}>Age</th>
            <th onClick={() => handleSort('department')}>Department</th>
            <th onClick={() => handleSort('salary')}>Salary</th>
          </tr>
        </thead>
        <tbody>{/* TODO: Map sortedEmployees to table rows */}</tbody>
      </table>
    </div>
  );
}
```

<details>
<summary>üí° Solution</summary>

```jsx
function EmployeeTable() {
  const employees = [
    {
      id: 1,
      name: 'Alice Johnson',
      age: 28,
      department: 'Engineering',
      salary: 85000,
    },
    {
      id: 2,
      name: 'Bob Smith',
      age: 34,
      department: 'Marketing',
      salary: 72000,
    },
    {
      id: 3,
      name: 'Charlie Brown',
      age: 29,
      department: 'Engineering',
      salary: 90000,
    },
    {
      id: 4,
      name: 'Diana Prince',
      age: 31,
      department: 'Sales',
      salary: 78000,
    },
    {
      id: 5,
      name: 'Edward Norton',
      age: 42,
      department: 'Engineering',
      salary: 105000,
    },
    {
      id: 6,
      name: 'Fiona Apple',
      age: 26,
      department: 'Marketing',
      salary: 65000,
    },
    {
      id: 7,
      name: 'George Lucas',
      age: 38,
      department: 'Sales',
      salary: 82000,
    },
    { id: 8, name: 'Hannah Montana', age: 24, department: 'HR', salary: 58000 },
  ];

  let sortBy = 'name';
  let sortOrder = 'asc';

  const handleSort = (column) => {
    if (sortBy === column) {
      sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
    } else {
      sortBy = column;
      sortOrder = 'asc';
    }
    console.log(`Sorting by ${sortBy} (${sortOrder})`);
  };

  // Sort logic
  const sortedEmployees = [...employees].sort((a, b) => {
    let aValue = a[sortBy];
    let bValue = b[sortBy];

    // String comparison (name, department)
    if (typeof aValue === 'string') {
      aValue = aValue.toLowerCase();
      bValue = bValue.toLowerCase();
    }

    let comparison = 0;
    if (aValue > bValue) comparison = 1;
    if (aValue < bValue) comparison = -1;

    return sortOrder === 'asc' ? comparison : -comparison;
  });

  // Columns configuration
  const columns = [
    { key: 'name', label: 'Name' },
    { key: 'age', label: 'Age' },
    { key: 'department', label: 'Department' },
    { key: 'salary', label: 'Salary' },
  ];

  // Sort indicator
  const getSortIndicator = (column) => {
    if (sortBy !== column) return '‚áÖ';
    return sortOrder === 'asc' ? '‚Üë' : '‚Üì';
  };

  // Format salary
  const formatSalary = (salary) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
    }).format(salary);
  };

  return (
    <div className='employee-table-container'>
      <h2>Employee Directory</h2>
      <p className='subtitle'>Click column headers to sort</p>

      <table className='employee-table'>
        <thead>
          <tr>
            {columns.map((column) => (
              <th
                key={column.key}
                onClick={() => handleSort(column.key)}
                className={sortBy === column.key ? 'sorted' : ''}
              >
                <span className='column-header'>
                  {column.label}
                  <span className='sort-indicator'>
                    {getSortIndicator(column.key)}
                  </span>
                </span>
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {sortedEmployees.map((employee) => (
            <tr key={employee.id}>
              <td>{employee.name}</td>
              <td>{employee.age}</td>
              <td>
                <span
                  className={`dept-badge dept-${employee.department.toLowerCase()}`}
                >
                  {employee.department}
                </span>
              </td>
              <td className='salary'>{formatSalary(employee.salary)}</td>
            </tr>
          ))}
        </tbody>
      </table>

      <div className='note'>
        <strong>Note:</strong> Sort state won't persist (need useState - Day
        11). Current sort: <strong>{sortBy}</strong> ({sortOrder})
      </div>
    </div>
  );
}
```

**CSS:**

```css
.employee-table-container {
  max-width: 1000px;
  margin: 20px auto;
  padding: 20px;
}

.subtitle {
  color: #666;
  font-size: 14px;
  margin: -10px 0 20px 0;
}

.employee-table {
  width: 100%;
  border-collapse: collapse;
  background: white;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border-radius: 8px;
  overflow: hidden;
}

.employee-table thead {
  background: #f5f5f5;
}

.employee-table th {
  padding: 16px;
  text-align: left;
  font-weight: 600;
  color: #333;
  cursor: pointer;
  user-select: none;
  transition: background 0.2s;
}

.employee-table th:hover {
  background: #ebebeb;
}

.employee-table th.sorted {
  background: #e3f2fd;
  color: #1976d2;
}

.column-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.sort-indicator {
  font-size: 12px;
  margin-left: 8px;
  color: #999;
}

.employee-table th.sorted .sort-indicator {
  color: #1976d2;
}

.employee-table tbody tr {
  border-bottom: 1px solid #f0f0f0;
  transition: background 0.2s;
}

.employee-table tbody tr:hover {
  background: #fafafa;
}

.employee-table td {
  padding: 14px 16px;
}

.dept-badge {
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;
}

.dept-engineering {
  background: #e3f2fd;
  color: #1565c0;
}

.dept-marketing {
  background: #f3e5f5;
  color: #7b1fa2;
}

.dept-sales {
  background: #e8f5e9;
  color: #2e7d32;
}

.dept-hr {
  background: #fff3e0;
  color: #e65100;
}

.salary {
  font-weight: 600;
  color: #2e7d32;
}

.note {
  margin-top: 20px;
  padding: 12px;
  background: #f5f5f5;
  border-left: 4px solid #1976d2;
  font-size: 14px;
}
```

**üìö Key Learnings:**

- Sorting arrays without mutating original
- Dynamic sort based on column type (string vs number)
- Visual feedback for user interactions
- Table structure with proper semantics

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê Exercise 4: Nested Comments System (60 ph√∫t)

**üéØ M·ª•c ti√™u:** Render nested structure v·ªõi recursive pattern  
**‚è±Ô∏è Th·ªùi gian:** 60 ph√∫t

**üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)**

Thi·∫øt k·∫ø m·ªôt comment system v·ªõi nested replies (nh∆∞ Reddit/YouTube).

**Features:**

- Comment v·ªõi replies
- Replies c√≥ th·ªÉ c√≥ sub-replies (unlimited depth)
- Each comment: author, text, timestamp, replies array
- Indent nested comments visually

**ü§î DESIGN DECISIONS:**

1. **Rendering Approach:**

   - Option A: Recursive component (component calls itself)
   - Option B: Flatten tree ‚Üí render flat list
   - Decision: ?

2. **Keys for Nested Items:**
   - How to ensure unique keys at all levels?
   - Use `comment.id` or `${parentId}-${comment.id}`?

**ADR:**

```markdown
## Decision: Nested Comments Rendering

### Context

Need to render comments with unlimited nesting depth.

### Decision

[Your choice]

### Rationale

- Reason 1:
- Reason 2:

### Implementation

[Code approach]
```

---

**üíª PHASE 2: Implementation (30 ph√∫t)**

```jsx
// Sample nested data
const comments = [
  {
    id: 1,
    author: 'Alice',
    text: 'Great article!',
    timestamp: '2 hours ago',
    replies: [
      {
        id: 2,
        author: 'Bob',
        text: 'I agree!',
        timestamp: '1 hour ago',
        replies: [
          {
            id: 3,
            author: 'Charlie',
            text: 'Me too!',
            timestamp: '30 min ago',
            replies: [],
          },
        ],
      },
      {
        id: 4,
        author: 'Diana',
        text: 'Thanks for sharing',
        timestamp: '45 min ago',
        replies: [],
      },
    ],
  },
  {
    id: 5,
    author: 'Edward',
    text: 'Very helpful',
    timestamp: '3 hours ago',
    replies: [],
  },
];

// üéØ NHI·ªÜM V·ª§:
function CommentSection() {
  return (
    <div className='comment-section'>
      <h2>Comments</h2>
      {/* TODO: Render comments */}
    </div>
  );
}

// Recursive Comment Component
function Comment({ comment, depth = 0 }) {
  const hasReplies = comment.replies && comment.replies.length > 0;

  return (
    <div
      className='comment'
      style={{ marginLeft: `${depth * 24}px` }}
    >
      <div className='comment-header'>
        <strong>{comment.author}</strong>
        <span className='timestamp'>{comment.timestamp}</span>
      </div>
      <p className='comment-text'>{comment.text}</p>

      {/* TODO: Recursively render replies */}
      {hasReplies && <div className='replies'>{/* TODO: Map replies */}</div>}
    </div>
  );
}
```

<details>
<summary>üí° Solution</summary>

```jsx
function CommentSection() {
  const comments = [
    {
      id: 1,
      author: 'Alice',
      text: 'Great article! Really enjoyed the insights.',
      timestamp: '2 hours ago',
      replies: [
        {
          id: 2,
          author: 'Bob',
          text: 'I agree! Very well written.',
          timestamp: '1 hour ago',
          replies: [
            {
              id: 3,
              author: 'Charlie',
              text: "Me too! Best explanation I've seen.",
              timestamp: '30 min ago',
              replies: [],
            },
          ],
        },
        {
          id: 4,
          author: 'Diana',
          text: 'Thanks for sharing this perspective.',
          timestamp: '45 min ago',
          replies: [],
        },
      ],
    },
    {
      id: 5,
      author: 'Edward',
      text: 'Very helpful, exactly what I was looking for!',
      timestamp: '3 hours ago',
      replies: [
        {
          id: 6,
          author: 'Fiona',
          text: 'Same here!',
          timestamp: '2 hours ago',
          replies: [],
        },
      ],
    },
    {
      id: 7,
      author: 'George',
      text: 'Could you elaborate on the second point?',
      timestamp: '4 hours ago',
      replies: [],
    },
  ];

  // Count total comments (including nested)
  const countComments = (comments) => {
    return comments.reduce((total, comment) => {
      return total + 1 + countComments(comment.replies || []);
    }, 0);
  };

  const totalComments = countComments(comments);

  return (
    <div className='comment-section'>
      <h2>Comments ({totalComments})</h2>
      <div className='comments-list'>
        {comments.map((comment) => (
          <Comment
            key={comment.id}
            comment={comment}
            depth={0}
          />
        ))}
      </div>
    </div>
  );
}

// Recursive Comment Component
function Comment({ comment, depth = 0 }) {
  const hasReplies = comment.replies && comment.replies.length > 0;
  const indentColor = ['#1976d2', '#7b1fa2', '#388e3c', '#f57c00'][depth % 4];

  return (
    <div className='comment-wrapper'>
      <div
        className='comment'
        style={{
          marginLeft: `${depth * 32}px`,
          borderLeftColor: depth > 0 ? indentColor : 'transparent',
        }}
      >
        <div className='comment-avatar'>{comment.author.charAt(0)}</div>

        <div className='comment-content'>
          <div className='comment-header'>
            <strong className='comment-author'>{comment.author}</strong>
            <span className='comment-timestamp'>{comment.timestamp}</span>
          </div>

          <p className='comment-text'>{comment.text}</p>

          <div className='comment-actions'>
            <button className='comment-action'>Reply</button>
            <button className='comment-action'>Like</button>
          </div>
        </div>
      </div>

      {/* Recursively render replies */}
      {hasReplies && (
        <div className='replies'>
          {comment.replies.map((reply) => (
            <Comment
              key={reply.id}
              comment={reply}
              depth={depth + 1}
            />
          ))}
        </div>
      )}
    </div>
  );
}

// App
function App() {
  return (
    <div className='app'>
      <CommentSection />
    </div>
  );
}
```

**CSS:**

```css
.comment-section {
  max-width: 800px;
  margin: 20px auto;
  padding: 20px;
}

.comment-section h2 {
  margin-bottom: 24px;
  color: #333;
}

.comments-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.comment-wrapper {
  display: flex;
  flex-direction: column;
}

.comment {
  display: flex;
  gap: 12px;
  padding: 16px;
  background: white;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  border-left: 3px solid transparent;
  transition: background 0.2s;
}

.comment:hover {
  background: #fafafa;
}

.comment-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: #1976d2;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  flex-shrink: 0;
}

.comment-content {
  flex: 1;
  min-width: 0;
}

.comment-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}

.comment-author {
  font-size: 14px;
  color: #333;
}

.comment-timestamp {
  font-size: 12px;
  color: #999;
}

.comment-text {
  margin: 0 0 12px 0;
  line-height: 1.5;
  color: #333;
}

.comment-actions {
  display: flex;
  gap: 16px;
}

.comment-action {
  padding: 0;
  border: none;
  background: none;
  color: #666;
  font-size: 13px;
  cursor: pointer;
  transition: color 0.2s;
}

.comment-action:hover {
  color: #1976d2;
}

.replies {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 8px;
}
```

**üìö Key Concepts:**

1. **Recursion:** Component calls itself for nested data
2. **Depth Tracking:** Pass depth prop to control indentation
3. **Visual Hierarchy:** Color-coded borders for depth levels
4. **Keys:** Each comment.id unique within its level

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Exercise 5: Data Table with Pagination (90 ph√∫t)

**üéØ M·ª•c ti√™u:** Production-ready table component  
**‚è±Ô∏è Th·ªùi gian:** 90 ph√∫t

**üìã Feature Specification:**

T·∫°o data table v·ªõi:

- 50+ rows of data
- Pagination (10 items per page)
- Sort by column
- Search/Filter
- Select rows (checkboxes)
- Bulk actions

**‚úÖ Production Checklist:**

**Features:**

- [ ] Pagination controls (prev, next, page numbers)
- [ ] Items per page selector (10, 25, 50)
- [ ] Search box (filter by name)
- [ ] Sortable columns
- [ ] Select all checkbox
- [ ] Individual row checkboxes
- [ ] Bulk delete button (log selected IDs)

```jsx
// Generate 50 sample users
const generateUsers = (count) => {
  const firstNames = [
    'John',
    'Jane',
    'Alice',
    'Bob',
    'Charlie',
    'Diana',
    'Edward',
    'Fiona',
  ];
  const lastNames = [
    'Smith',
    'Johnson',
    'Williams',
    'Brown',
    'Jones',
    'Garcia',
    'Miller',
    'Davis',
  ];
  const departments = ['Engineering', 'Sales', 'Marketing', 'HR', 'Finance'];

  return Array.from({ length: count }, (_, i) => ({
    id: i + 1,
    name: `${firstNames[i % firstNames.length]} ${
      lastNames[i % lastNames.length]
    }`,
    email: `user${i + 1}@company.com`,
    department: departments[i % departments.length],
    salary: 50000 + Math.floor(Math.random() * 80000),
    age: 22 + Math.floor(Math.random() * 40),
  }));
};

// üéØ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
function DataTable() {
  const allUsers = generateUsers(50);

  // State variables (will use useState on Day 11)
  let currentPage = 1;
  let itemsPerPage = 10;
  let searchQuery = '';
  let sortBy = 'name';
  let sortOrder = 'asc';
  let selectedIds = [];

  // TODO: Implement all features

  return (
    <div className='data-table-container'>
      {/* TODO: Search & Controls */}
      {/* TODO: Table */}
      {/* TODO: Pagination */}
    </div>
  );
}
```

<details>
<summary>üí° Solution (Full Implementation)</summary>

```jsx
// Generate sample data
const generateUsers = (count) => {
  const firstNames = [
    'John',
    'Jane',
    'Alice',
    'Bob',
    'Charlie',
    'Diana',
    'Edward',
    'Fiona',
    'George',
    'Hannah',
  ];
  const lastNames = [
    'Smith',
    'Johnson',
    'Williams',
    'Brown',
    'Jones',
    'Garcia',
    'Miller',
    'Davis',
    'Wilson',
    'Moore',
  ];
  const departments = ['Engineering', 'Sales', 'Marketing', 'HR', 'Finance'];

  return Array.from({ length: count }, (_, i) => ({
    id: i + 1,
    name: `${firstNames[i % firstNames.length]} ${
      lastNames[Math.floor(i / firstNames.length) % lastNames.length]
    }`,
    email: `user${i + 1}@company.com`,
    department: departments[i % departments.length],
    salary: 50000 + Math.floor(Math.random() * 80000),
    age: 22 + Math.floor(Math.random() * 40),
  }));
};

function DataTable() {
  const allUsers = generateUsers(50);

  // Simulated state (will use useState on Day 11)
  let currentPage = 1;
  let itemsPerPage = 10;
  let searchQuery = '';
  let sortBy = 'name';
  let sortOrder = 'asc';
  let selectedIds = [];

  // Handlers
  const handleSearch = (event) => {
    searchQuery = event.target.value;
    currentPage = 1; // Reset to first page
    console.log('Search:', searchQuery);
  };

  const handleSort = (column) => {
    if (sortBy === column) {
      sortOrder = sortOrder === 'asc' ? 'desc' : 'asc';
    } else {
      sortBy = column;
      sortOrder = 'asc';
    }
    console.log(`Sort: ${sortBy} ${sortOrder}`);
  };

  const handlePageChange = (page) => {
    currentPage = page;
    console.log('Page:', page);
  };

  const handleItemsPerPageChange = (event) => {
    itemsPerPage = parseInt(event.target.value);
    currentPage = 1;
    console.log('Items per page:', itemsPerPage);
  };

  const handleSelectAll = (event) => {
    if (event.target.checked) {
      selectedIds = paginatedUsers.map((u) => u.id);
    } else {
      selectedIds = [];
    }
    console.log('Selected:', selectedIds);
  };

  const handleSelectRow = (id) => {
    const index = selectedIds.indexOf(id);
    if (index > -1) {
      selectedIds = selectedIds.filter((selectedId) => selectedId !== id);
    } else {
      selectedIds = [...selectedIds, id];
    }
    console.log('Selected:', selectedIds);
  };

  const handleBulkDelete = () => {
    console.log('Deleting users:', selectedIds);
    alert(
      `Would delete ${selectedIds.length} users: ${selectedIds.join(', ')}`
    );
  };

  // Filter by search
  const filteredUsers = searchQuery
    ? allUsers.filter(
        (user) =>
          user.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
          user.email.toLowerCase().includes(searchQuery.toLowerCase()) ||
          user.department.toLowerCase().includes(searchQuery.toLowerCase())
      )
    : allUsers;

  // Sort
  const sortedUsers = [...filteredUsers].sort((a, b) => {
    let aVal = a[sortBy];
    let bVal = b[sortBy];

    if (typeof aVal === 'string') {
      aVal = aVal.toLowerCase();
      bVal = bVal.toLowerCase();
    }

    let comparison = 0;
    if (aVal > bVal) comparison = 1;
    if (aVal < bVal) comparison = -1;

    return sortOrder === 'asc' ? comparison : -comparison;
  });

  // Pagination
  const totalPages = Math.ceil(sortedUsers.length / itemsPerPage);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const paginatedUsers = sortedUsers.slice(startIndex, endIndex);

  // Check if all visible rows selected
  const allSelected =
    paginatedUsers.length > 0 &&
    paginatedUsers.every((user) => selectedIds.includes(user.id));

  // Columns
  const columns = [
    { key: 'name', label: 'Name' },
    { key: 'email', label: 'Email' },
    { key: 'department', label: 'Department' },
    { key: 'age', label: 'Age' },
    { key: 'salary', label: 'Salary' },
  ];

  return (
    <div className='data-table-container'>
      <div className='table-header'>
        <h2>Employee Database</h2>
        <div className='table-controls'>
          <input
            type='text'
            placeholder='Search by name, email, or department...'
            onChange={handleSearch}
            className='search-input'
          />

          <select
            onChange={handleItemsPerPageChange}
            className='items-select'
          >
            <option value='10'>10 per page</option>
            <option value='25'>25 per page</option>
            <option value='50'>50 per page</option>
          </select>

          {selectedIds.length > 0 && (
            <button
              onClick={handleBulkDelete}
              className='bulk-delete-btn'
            >
              Delete ({selectedIds.length})
            </button>
          )}
        </div>
      </div>

      <div className='table-info'>
        Showing {startIndex + 1}-{Math.min(endIndex, sortedUsers.length)} of{' '}
        {sortedUsers.length} employees
      </div>

      <table className='data-table'>
        <thead>
          <tr>
            <th className='checkbox-cell'>
              <input
                type='checkbox'
                checked={allSelected}
                onChange={handleSelectAll}
              />
            </th>
            {columns.map((column) => (
              <th
                key={column.key}
                onClick={() => handleSort(column.key)}
                className={sortBy === column.key ? 'sorted' : ''}
              >
                <span className='column-header'>
                  {column.label}
                  <span className='sort-indicator'>
                    {sortBy === column.key
                      ? sortOrder === 'asc'
                        ? '‚Üë'
                        : '‚Üì'
                      : '‚áÖ'}
                  </span>
                </span>
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {paginatedUsers.map((user) => (
            <tr
              key={user.id}
              className={selectedIds.includes(user.id) ? 'selected' : ''}
            >
              <td className='checkbox-cell'>
                <input
                  type='checkbox'
                  checked={selectedIds.includes(user.id)}
                  onChange={() => handleSelectRow(user.id)}
                />
              </td>
              <td>{user.name}</td>
              <td className='email-cell'>{user.email}</td>
              <td>
                <span
                  className={`dept-badge dept-${user.department.toLowerCase()}`}
                >
                  {user.department}
                </span>
              </td>
              <td>{user.age}</td>
              <td className='salary-cell'>${user.salary.toLocaleString()}</td>
            </tr>
          ))}
        </tbody>
      </table>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className='pagination'>
          <button
            onClick={() => handlePageChange(currentPage - 1)}
            disabled={currentPage === 1}
            className='pagination-btn'
          >
            ‚Üê Previous
          </button>

          <div className='page-numbers'>
            {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => (
              <button
                key={page}
                onClick={() => handlePageChange(page)}
                className={`pagination-number ${
                  currentPage === page ? 'active' : ''
                }`}
              >
                {page}
              </button>
            ))}
          </div>

          <button
            onClick={() => handlePageChange(currentPage + 1)}
            disabled={currentPage === totalPages}
            className='pagination-btn'
          >
            Next ‚Üí
          </button>
        </div>
      )}

      <div className='note'>
        <strong>Note:</strong> State won't persist (need useState - Day 11).
        Selected IDs: {selectedIds.join(', ') || 'None'}
      </div>
    </div>
  );
}
```

**üìö Production Features Implemented:**

1. **Search:** Filter across multiple fields
2. **Sort:** Click headers to sort
3. **Pagination:** Navigate pages, change items per page
4. **Selection:** Select all/individual rows
5. **Bulk Actions:** Delete multiple rows
6. **Performance:** Only render current page (not all 50 rows)

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh: Key Strategies

| Strategy           | Example                 | Pros ‚úÖ                                                                   | Cons ‚ùå                                                          | When to Use                                      |
| ------------------ | ----------------------- | ------------------------------------------------------------------------- | ---------------------------------------------------------------- | ------------------------------------------------ |
| **Unique ID**      | `key={item.id}`         | ‚Ä¢ Best performance<br>‚Ä¢ Stable across renders<br>‚Ä¢ Correct reconciliation | ‚Ä¢ Requires ID field                                              | **DEFAULT CHOICE**<br>When data has unique IDs   |
| **Index**          | `key={index}`           | ‚Ä¢ Simple<br>‚Ä¢ No setup needed                                             | ‚Ä¢ Breaks on reorder<br>‚Ä¢ Performance issues<br>‚Ä¢ Bugs with state | **ONLY** for static lists<br>Never changes order |
| **Combination**    | `key={`${type}-${id}`}` | ‚Ä¢ Unique across types<br>‚Ä¢ Descriptive                                    | ‚Ä¢ String concat overhead                                         | Multiple list types with same IDs                |
| **Content Hash**   | `key={item.name}`       | ‚Ä¢ Works without ID                                                        | ‚Ä¢ Breaks with duplicates<br>‚Ä¢ Not stable                         | **AVOID**<br>Use only if truly unique            |
| **Generated UUID** | `key={uuidv4()}`        | ‚Ä¢ Always unique                                                           | ‚Ä¢ Different every render<br>‚Ä¢ Defeats purpose                    | **NEVER**<br>Completely wrong!                   |

---

### Index as Key: The Truth Table

| Scenario                     | Index OK? | Why                         |
| ---------------------------- | --------- | --------------------------- |
| Static list (hard-coded)     | ‚úÖ YES    | Never changes               |
| Display-only list            | ‚úÖ YES    | No interactions             |
| List can reorder             | ‚ùå NO     | Keys shift ‚Üí bugs           |
| List can filter              | ‚ùå NO     | Indexes change              |
| List can add/remove items    | ‚ùå NO     | Indexes shift               |
| List items have state/inputs | ‚ùå NO     | State gets mixed up         |
| Paginated list               | ‚ö†Ô∏è MAYBE  | If items stable within page |

---

### Decision Tree: Choosing Keys

```
Render m·ªôt array?
‚îÇ
‚îú‚îÄ Data c√≥ unique ID field?
‚îÇ   ‚îî‚îÄ ‚úÖ USE: key={item.id}
‚îÇ
‚îú‚îÄ Multiple lists, IDs might overlap?
‚îÇ   ‚îî‚îÄ ‚úÖ USE: key={`${listType}-${item.id}`}
‚îÇ
‚îú‚îÄ No IDs, items are strings?
‚îÇ   ‚îú‚îÄ Guaranteed unique (no duplicates)?
‚îÇ   ‚îÇ   ‚îî‚îÄ ‚úÖ USE: key={item}
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ Might have duplicates?
‚îÇ       ‚îî‚îÄ ‚úÖ GENERATE IDs upfront (before map)
‚îÇ
‚îú‚îÄ List is static (hard-coded)?
‚îÇ   ‚îî‚îÄ ‚ö†Ô∏è ACCEPTABLE: key={index}
‚îÇ
‚îî‚îÄ List is dynamic (can change)?
    ‚îú‚îÄ Can add IDs to data?
    ‚îÇ   ‚îî‚îÄ ‚úÖ ADD IDs then use key={item.id}
    ‚îÇ
    ‚îî‚îÄ Cannot modify data?
        ‚îî‚îÄ ‚úÖ GENERATE wrapper with IDs
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Missing Key Warning ‚ùå

```jsx
// üêõ CODE B·ªä L·ªñI:
function TodoList() {
  const todos = ['Buy milk', 'Clean room', 'Study React'];

  return (
    <ul>
      {todos.map((todo) => (
        <li>{todo}</li>
      ))}
    </ul>
  );
}

// Console: Warning: Each child in a list should have a unique "key" prop.
```

**‚ùì C√¢u h·ªèi:**

1. T·∫°i sao React warning?
2. C√≥ th·ªÉ ignore warning n√†y kh√¥ng?
3. Fix nh∆∞ th·∫ø n√†o?

<details>
<summary>üí° Gi·∫£i ƒë√°p</summary>

**1. T·∫°i sao warning:**

- React c·∫ßn keys ƒë·ªÉ track elements khi list thay ƒë·ªïi
- Kh√¥ng c√≥ keys ‚Üí React kh√¥ng bi·∫øt element n√†o changed/added/removed
- Performance degradation & potential bugs

**2. C√≥ th·ªÉ ignore?**

- ‚ùå KH√îNG N√äN! Warning n√†y quan tr·ªçng
- C√≥ th·ªÉ suppress warning nh∆∞ng v·∫•n ƒë·ªÅ v·∫´n t·ªìn t·∫°i
- Production app PH·∫¢I fix t·∫•t c·∫£ warnings

**3. Fix:**

```jsx
// ‚úÖ Solution 1: Index (OK for static list)
{
  todos.map((todo, index) => <li key={index}>{todo}</li>);
}

// ‚úÖ Solution 2: Generate IDs upfront (BETTER)
const todosWithIds = todos.map((todo, index) => ({
  id: `todo-${index}`,
  text: todo,
}));

{
  todosWithIds.map((todo) => <li key={todo.id}>{todo.text}</li>);
}

// ‚úÖ Solution 3: Use crypto.randomUUID() (BEST if available)
const todosWithUUIDs = todos.map((todo) => ({
  id: crypto.randomUUID(),
  text: todo,
}));
```

</details>

---

### Bug 2: Index Key with Dynamic List ‚ùå

```jsx
// üêõ CODE B·ªä L·ªñI:
function TodoList() {
  let todos = [
    { id: 1, text: 'Task A', done: false },
    { id: 2, text: 'Task B', done: false },
    { id: 3, text: 'Task C', done: false },
  ];

  const handleDelete = (indexToDelete) => {
    todos = todos.filter((_, index) => index !== indexToDelete);
    console.log('Deleted index:', indexToDelete);
  };

  return (
    <ul>
      {todos.map((todo, index) => (
        <li key={index}>
          <input
            type='checkbox'
            checked={todo.done}
            onChange={() => {}}
          />
          <span>{todo.text}</span>
          <button onClick={() => handleDelete(index)}>Delete</button>
        </li>
      ))}
    </ul>
  );
}
```

**Scenario:** User checks "Task B" (index 1), then deletes "Task A" (index 0)

**‚ùì C√¢u h·ªèi:**

1. Checkbox n√†o s·∫Ω checked sau khi delete?
2. T·∫°i sao behavior sai?
3. Fix nh∆∞ th·∫ø n√†o?

<details>
<summary>üí° Gi·∫£i ƒë√°p</summary>

**1. Checkbox sai:**

```
Before delete:
[0] Task A (unchecked)
[1] Task B (CHECKED)
[2] Task C (unchecked)

After delete Task A:
[0] Task B (unchecked) ‚ùå WRONG!
[1] Task C (unchecked)

React thinks:
- Index 0 (was Task A) ‚Üí now Task B, reuse DOM
- Index 1 (was Task B) ‚Üí now Task C, reuse DOM
- Checkbox states stay with indexes!
```

**2. T·∫°i sao sai:**

- Keys based on index ‚Üí index 0, 1, 2
- Delete item ‚Üí indexes shift
- React reuses DOM elements based on keys
- Checkbox state persists with DOM element (wrong item!)

**3. Fix:**

```jsx
// ‚úÖ CORRECT: Use unique ID
{
  todos.map((todo) => (
    <li key={todo.id}>
      <input
        type='checkbox'
        checked={todo.done}
        onChange={() => {}}
      />
      <span>{todo.text}</span>
      <button onClick={() => handleDelete(todo.id)}>Delete</button>
    </li>
  ));
}

const handleDelete = (idToDelete) => {
  todos = todos.filter((todo) => todo.id !== idToDelete);
};

// Now React knows:
// - Item with key=1 removed
// - Items with key=2 and key=3 unchanged
// Checkboxes stay with correct items!
```

</details>

---

### Bug 3: Duplicate Keys ‚ùå

```jsx
// üêõ CODE B·ªä L·ªñI:
function TagCloud() {
  const tags = ['React', 'JavaScript', 'React', 'CSS', 'React'];

  return (
    <div>
      {tags.map((tag) => (
        <span
          key={tag}
          className='tag'
        >
          {tag}
        </span>
      ))}
    </div>
  );
}

// Console: Warning: Encountered two children with the same key, `React`
```

**‚ùì C√¢u h·ªèi:**

1. L·ªói g√¨ x·∫£y ra?
2. T·∫°i sao duplicate keys l√† v·∫•n ƒë·ªÅ?
3. Fix nh∆∞ th·∫ø n√†o?

<details>
<summary>üí° Gi·∫£i ƒë√°p</summary>

**1. L·ªói:**

- React warning v·ªÅ duplicate keys
- Unpredictable behavior (which "React" is which?)
- Reconciliation broken

**2. T·∫°i sao v·∫•n ƒë·ªÅ:**

```
Keys must be unique among siblings
'React' appears 3 times ‚Üí React confused!

React sees:
key='React' ‚Üí ??? which instance?
```

**3. Fix:**

```jsx
// ‚úÖ Solution 1: Combine tag + index
{
  tags.map((tag, index) => (
    <span
      key={`${tag}-${index}`}
      className='tag'
    >
      {tag}
    </span>
  ));
}

// ‚úÖ Solution 2: Generate IDs upfront
const tagsWithIds = tags.map((tag, index) => ({
  id: `tag-${index}`,
  name: tag,
}));

{
  tagsWithIds.map((tag) => (
    <span
      key={tag.id}
      className='tag'
    >
      {tag.name}
    </span>
  ));
}

// ‚úÖ Solution 3: If tags should be unique, deduplicate
const uniqueTags = [...new Set(tags)];

{
  uniqueTags.map((tag) => (
    <span
      key={tag}
      className='tag'
    >
      {tag}
    </span>
  ));
}
```

</details>

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

- [ ] T√¥i hi·ªÉu c√°ch d√πng `.map()` ƒë·ªÉ render arrays
- [ ] T√¥i bi·∫øt Keys l√† g√¨ v√† T·∫†I SAO ch√∫ng quan tr·ªçng
- [ ] T√¥i bi·∫øt khi n√†o d√πng `key={item.id}` vs `key={index}`
- [ ] T√¥i hi·ªÉu index as key CH·ªà OK cho static lists
- [ ] T√¥i bi·∫øt keys ch·ªâ c·∫ßn unique trong siblings
- [ ] T√¥i bi·∫øt c√°ch generate keys khi data kh√¥ng c√≥ IDs
- [ ] T√¥i tr√°nh ƒë∆∞·ª£c duplicate keys
- [ ] T√¥i hi·ªÉu keys ·∫£nh h∆∞·ªüng ƒë·∫øn performance & correctness
- [ ] T√¥i bi·∫øt c√°ch combine filter/sort/map
- [ ] T√¥i bi·∫øt c√°ch render nested lists (recursive)

### Code Review Checklist

Khi render lists:

**Keys:**

- [ ] M·ªçi list item ƒë·ªÅu c√≥ key prop
- [ ] Keys l√† unique trong siblings
- [ ] ∆Øu ti√™n d√πng stable IDs (item.id)
- [ ] Tr√°nh index as key cho dynamic lists
- [ ] Kh√¥ng generate keys trong render (uuid trong map)
- [ ] Kh√¥ng d√πng item content as key (tr·ª´ khi guaranteed unique)

**Performance:**

- [ ] Kh√¥ng t·∫°o inline functions trong map (s·∫Ω h·ªçc optimize sau)
- [ ] L·ªçc data tr∆∞·ªõc khi render (filter ‚Üí sort ‚Üí map)
- [ ] Consider pagination cho large lists (100+ items)

**Code Quality:**

- [ ] Extract component n·∫øu map logic ph·ª©c t·∫°p
- [ ] Meaningful variable names trong map
- [ ] Handle empty state (array.length === 0)

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**1. Numbered List Component**

T·∫°o component render ordered list v·ªõi custom numbering:

- Array of items
- Start number c√≥ th·ªÉ customize (start from 5, 10...)
- Show item number v√† content
- Proper keys

```jsx
// Expected usage:
<NumberedList
  items={['First', 'Second', 'Third']}
  startFrom={5}
/>

// Output:
// 5. First
// 6. Second
// 7. Third
```

---

**2. Breadcrumb Navigation**

T·∫°o breadcrumb t·ª´ array of paths:

```jsx
const paths = [
  { name: 'Home', url: '/' },
  { name: 'Products', url: '/products' },
  { name: 'Laptops', url: '/products/laptops' },
  { name: 'MacBook Pro', url: '/products/laptops/macbook' },
];

// Render: Home > Products > Laptops > MacBook Pro
// Last item kh√¥ng clickable
```

---

### N√¢ng cao (60 ph√∫t)

**3. Timeline Component**

T·∫°o vertical timeline t·ª´ array of events:

- Array of events v·ªõi: date, title, description
- Render timeline v·ªõi dots & connecting lines
- Alternate left/right layout
- Proper keys

```jsx
const events = [
  {
    id: 1,
    date: '2024-01',
    title: 'Started Learning',
    description: 'Began React journey',
  },
  {
    id: 2,
    date: '2024-06',
    title: 'First Project',
    description: 'Built todo app',
  },
  { id: 3, date: '2024-12', title: 'Advanced', description: 'Mastered hooks' },
];
```

---

**4. Masonry Grid**

T·∫°o Pinterest-style masonry layout:

- Array of cards v·ªõi different heights
- 3 columns layout
- Distribute cards evenly across columns
- Calculate which column to place each card
- Proper keys

**Hint:** Group items v√†o 3 arrays (column 1, 2, 3), sau ƒë√≥ render 3 columns

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - Rendering Lists**
   https://react.dev/learn/rendering-lists

2. **React Docs - Keys**
   https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key

### ƒê·ªçc th√™m

3. **Why React needs Keys (Deep Dive)**
   https://react.dev/learn/preserving-and-resetting-state#option-2-resetting-state-with-a-key

4. **Index as Key is an Anti-pattern**
   https://robinpokorny.com/blog/index-as-a-key-is-an-anti-pattern/

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (ƒê√£ h·ªçc)

- **Ng√†y 1-2:** Array methods (map, filter, sort)
- **Ng√†y 4:** Props (passing data to list items)
- **Ng√†y 5:** Events (event handlers in list items), Conditional rendering

### H∆∞·ªõng t·ªõi (S·∫Ω h·ªçc)

- **Ng√†y 7:** Component Composition (children patterns v·ªõi lists)
- **Ng√†y 11:** useState (dynamic lists - add/remove/update)
- **Ng√†y 12:** useState Advanced (filtering, sorting v·ªõi state)
- **Ng√†y 15:** Project - Todo App (full list management)
- **Ng√†y 34:** useMemo (optimize expensive list operations)

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**1. Large Lists Performance:**

```jsx
// ‚ùå BAD: Render 10,000 items
function HugeList({ items }) {
  return (
    <div>
      {items.map((item) => (
        <Item
          key={item.id}
          {...item}
        />
      ))}
    </div>
  );
}
// DOM: 10,000 nodes ‚Üí slow!

// ‚úÖ GOOD: Virtual scrolling (react-window)
import { FixedSizeList } from 'react-window';

function HugeList({ items }) {
  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
    >
      {({ index, style }) => (
        <div style={style}>
          <Item {...items[index]} />
        </div>
      )}
    </FixedSizeList>
  );
}
// DOM: Only render visible items (~20) ‚Üí fast!
```

**2. Keys v·ªõi API Data:**

```jsx
// ‚úÖ GOOD: Use backend IDs
const users = await fetchUsers(); // [{ id: 'uuid-123', ... }]

{
  users.map((user) => (
    <UserCard
      key={user.id}
      user={user}
    />
  ));
}

// ‚ö†Ô∏è CAREFUL: Composite keys for related data
{
  user.posts.map((post) => (
    <Post
      key={`${user.id}-${post.id}`}
      post={post}
    />
  ));
}
```

**3. Accessibility:**

```jsx
// ‚úÖ GOOD: Semantic HTML for lists
<ul role="list">
  {items.map(item => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>

// ‚úÖ GOOD: ARIA for interactive lists
<div role="listbox" aria-label="Product options">
  {products.map(product => (
    <div
      key={product.id}
      role="option"
      aria-selected={selectedId === product.id}
      onClick={() => handleSelect(product.id)}
    >
      {product.name}
    </div>
  ))}
</div>
```

---

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior Level:**

Q1: "T·∫°i sao React c·∫ßn keys khi render lists?"  
A: Keys gi√∫p React identify elements khi list thay ƒë·ªïi. V·ªõi keys, React bi·∫øt element n√†o added/removed/reordered ‚Üí optimize re-rendering ch·ªâ nh·ªØng g√¨ c·∫ßn thay ƒë·ªïi.

Q2: "Khi n√†o c√≥ th·ªÉ d√πng index as key?"  
A: Ch·ªâ khi list l√† static (kh√¥ng thay ƒë·ªïi order, kh√¥ng add/remove items) v√† display-only (kh√¥ng c√≥ interactions ho·∫∑c state).

**Mid Level:**

Q3: "ƒêi·ªÅu g√¨ x·∫£y ra n·∫øu duplicate keys?"  
A: React warning v√† behavior unpredictable. React kh√¥ng bi·∫øt element n√†o l√† n√†o, d·∫´n ƒë·∫øn incorrect reconciliation, wrong elements re-rendered ho·∫∑c state mixed up.

Q4: "L√†m sao optimize rendering large lists (10,000+ items)?"  
A:

1. Pagination - ch·ªâ render 1 page
2. Virtual scrolling (react-window) - ch·ªâ render visible items
3. Lazy loading - load more khi scroll
4. Memoization (useMemo/React.memo) - prevent unnecessary re-renders

**Senior Level:**

Q5: "Explain React reconciliation algorithm li√™n quan ƒë·∫øn keys"  
A: React d√πng keys ƒë·ªÉ match elements gi·ªØa previous v√† next render. V·ªõi keys, React c√≥ th·ªÉ reuse DOM nodes hi·ªáu qu·∫£. Kh√¥ng c√≥ keys, React ph·∫£i so s√°nh theo position (index), d·∫´n ƒë·∫øn unnecessary re-renders khi list changes order.

---

### War Stories

**Story 1: The Checkbox Bug**

> "Production bug nghi√™m tr·ªçng: User form c√≥ list checkboxes, khi delete 1 item, checkboxes kh√°c b·ªã checked sai. Debug 4 gi·ªù, ph√°t hi·ªán: `key={index}`. Items shift ‚Üí checkboxes stay with DOM positions ‚Üí disaster! Fix: `key={item.id}`. Lesson: NEVER use index for dynamic lists!"

**Story 2: The Performance Nightmare**

> "Dashboard render 5,000 rows, app freeze 10 seconds. Root cause: render t·∫•t c·∫£ rows + kh√¥ng c√≥ keys (React re-render everything). Fix: Pagination (50/page) + proper keys. Load time: 10s ‚Üí 200ms. Lesson: Always consider performance v·ªõi large datasets!"

**Story 3: The Duplicate Key Mystery**

> "Random UI glitches: wrong items highlighted, data mixed up. Console: no errors! Sau 2 ng√†y debug: API return duplicate IDs (backend bug). React silently handle duplicate keys ‚Üí wrong reconciliation. Fix: Combine `key={`${type}-${id}`}` + report backend bug. Lesson: Validate data integrity!"

---

## üéØ PREVIEW NG√ÄY MAI

**Ng√†y 7: Component Composition - Patterns N√¢ng Cao**

Tomorrow ch√∫ng ta s·∫Ω h·ªçc:

- Composition vs Inheritance
- Children patterns (advanced)
- Slot patterns (named children)
- Compound components
- Render props pattern (gi·ªõi thi·ªáu)
- Container vs Presentational components

Chu·∫©n b·ªã:

- Review Props (Day 4) - s·∫Ω d√πng props patterns
- Review Children prop - s·∫Ω h·ªçc advanced usages
- Nghƒ© v·ªÅ c√°c UI components ph·ª©c t·∫°p (Modal, Tabs, Accordion...)

**Sneak peek:**

```jsx
// Tomorrow s·∫Ω h·ªçc pattern n√†y:
<Card>
  <Card.Header>
    <Card.Title>Hello</Card.Title>
  </Card.Header>
  <Card.Body>Content here</Card.Body>
  <Card.Footer>
    <Button>OK</Button>
  </Card.Footer>
</Card>

// Compound components - powerful & flexible!
```

---

## üéä CH√öC M·ª™NG!

B·∫°n ƒë√£ ho√†n th√†nh **Ng√†y 6: Lists & Keys**!

**H√¥m nay b·∫°n ƒë√£ h·ªçc:**
‚úÖ Render arrays v·ªõi `.map()`  
‚úÖ Keys v√† t·∫ßm quan tr·ªçng c·ªßa ch√∫ng  
‚úÖ Khi n√†o d√πng ID vs Index as key  
‚úÖ Strategies cho stable keys  
‚úÖ Filter, sort, paginate lists  
‚úÖ Nested lists (recursive rendering)  
‚úÖ Common pitfalls & debugging

**Key Takeaways:**

- **ALWAYS use keys** khi render lists
- **Prefer unique IDs** over index
- **Index as key** CH·ªà OK cho static lists
- Keys affect **performance & correctness**
- Think about **data structure** khi design

**Next steps:**

1. Ho√†n th√†nh b√†i t·∫≠p v·ªÅ nh√†
2. Practice v·ªõi different data structures
3. Th·ª≠ optimize large lists v·ªõi pagination
4. Chu·∫©n b·ªã cho Ng√†y 7: Component Composition!

**Remember:** Lists + Keys = Foundation cho dynamic UIs! üéØ

**Keep coding! üí™ See you tomorrow!** üöÄ
