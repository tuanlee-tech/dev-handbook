# ğŸ“… NGÃ€Y 13: Forms vá»›i State

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] **PhÃ¢n biá»‡t Controlled vs Uncontrolled components** vÃ  biáº¿t khi nÃ o dÃ¹ng approach nÃ o
- [ ] **Xá»­ lÃ½ multiple form inputs** má»™t cÃ¡ch hiá»‡u quáº£ vá»›i state structure há»£p lÃ½
- [ ] **Implement form validation** realtime vÃ  on-submit vá»›i useState
- [ ] **Handle form submission** Ä‘Ãºng cÃ¡ch (prevent default, clear form, error handling)
- [ ] **Optimize form performance** vá»›i cÃ¡c patterns tá»« NgÃ y 12

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

Tráº£ lá»i 3 cÃ¢u há»i sau Ä‘á»ƒ kÃ­ch hoáº¡t kiáº¿n thá»©c tá»« NgÃ y 11-12:

1. **CÃ¢u 1**: Code nÃ y cÃ³ váº¥n Ä‘á» gÃ¬?

```jsx
const [formData, setFormData] = useState({ email: '' });

const handleChange = (e) => {
  formData.email = e.target.value; // â“
  setFormData(formData);
};
```

2. **CÃ¢u 2**: Khi nÃ o nÃªn dÃ¹ng functional updates `setState(prev => ...)`?

3. **CÃ¢u 3**: Táº¡i sao khÃ´ng nÃªn store `isEmailValid` trong state náº¿u cÃ³ thá»ƒ validate tá»« `email`?

<details>
<summary>ğŸ’¡ Xem Ä‘Ã¡p Ã¡n</summary>

1. **Mutation!** Pháº£i dÃ¹ng immutable update: `setFormData(prev => ({...prev, email: e.target.value}))`
2. Khi update dá»±a trÃªn previous value, trong async operations, hoáº·c multiple updates
3. **Derived state anti-pattern!** `isEmailValid` cÃ³ thá»ƒ compute tá»« `email` â†’ khÃ´ng cáº§n store riÃªng

</details>

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

Forms lÃ  pháº§n KHáº®C NGHIá»†T NHáº¤T cá»§a React cho beginners. Táº¡i sao?

```jsx
// HTML form truyá»n thá»‘ng
<form>
  <input name="email" /> {/* Browser tá»± quáº£n lÃ½ value */}
  <button type="submit">Submit</button>
</form>

// React form - PHáº¢I quáº£n lÃ½ state
<form>
  <input
    value={email}              // â“ Láº¥y tá»« Ä‘Ã¢u?
    onChange={handleChange}    // â“ LÃ m gÃ¬?
  />
  <button type="submit">Submit</button>
</form>
```

**Challenges:**

- ğŸ¤” Form state nÃªn á»Ÿ Ä‘Ã¢u?
- ğŸ¤” LÃ m sao sync input value vá»›i state?
- ğŸ¤” Validate khi nÃ o? (onChange, onBlur, onSubmit?)
- ğŸ¤” Handle errors tháº¿ nÃ o?
- ğŸ¤” Multiple inputs â†’ nhiá»u states hay má»™t object?

HÃ´m nay sáº½ giáº£i quyáº¿t Táº¤T Cáº¢ nhá»¯ng cÃ¢u há»i nÃ y!

---

### 1.2 Giáº£i PhÃ¡p: Controlled Components

**Core Concept:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        CONTROLLED COMPONENT             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  React State = Single Source of Truth  â”‚
â”‚                                         â”‚
â”‚  User types â†’ onChange â†’ setState       â”‚
â”‚       â†“                                 â”‚
â”‚  State updates â†’ Re-render              â”‚
â”‚       â†“                                 â”‚
â”‚  Input value = state value              â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚  State   â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚  email   â”‚            â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜            â”‚             â”‚
â”‚       â”‚                  â”‚             â”‚
â”‚       â†“                  â”‚             â”‚
â”‚  <input                  â”‚             â”‚
â”‚    value={email}         â”‚             â”‚
â”‚    onChange={e => â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚      setEmail(e.target.value)          â”‚
â”‚    }                                   â”‚
â”‚  />                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**React controls the input, not the browser!**

---

### 1.3 Mental Model

HÃ£y tÆ°á»Ÿng tÆ°á»£ng form nhÆ° **dashboard vá»›i live updates**:

```
Traditional Form (Uncontrolled):
User writes â†’ Browser stores â†’ Submit â†’ Read all at once
[Like writing on paper â†’ submit when done]

React Form (Controlled):
User types â†’ React state updates â†’ UI updates instantly
[Like live dashboard â†’ see changes realtime]
```

**Analogy:**

- **Uncontrolled**: Gá»­i thÆ° qua bÆ°u Ä‘iá»‡n (submit má»›i biáº¿t ná»™i dung)
- **Controlled**: Nháº¯n tin realtime (tháº¥y tá»«ng kÃ½ tá»± ngay láº­p tá»©c)

---

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

âŒ **Myth 1**: "Controlled components phá»©c táº¡p hÆ¡n, khÃ´ng dÃ¹ng Ä‘Æ°á»£c khÃ´ng?"  
âœ… **Truth**: 95% cases nÃªn dÃ¹ng controlled. Uncontrolled chá»‰ cho edge cases.

âŒ **Myth 2**: "Má»—i input cáº§n 1 state riÃªng"  
âœ… **Truth**: NÃªn group related inputs vÃ o 1 object (NgÃ y 12!)

âŒ **Myth 3**: "Validate chá»‰ khi submit"  
âœ… **Truth**: Best UX lÃ  realtime validation + final check on submit

âŒ **Myth 4**: "Forms trong React khÃ³ hÆ¡n HTML"  
âœ… **Truth**: KhÃ³ hÆ¡n ban Ä‘áº§u, nhÆ°ng powerful hÆ¡n NHIá»€U (validation, dynamic fields, etc.)

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Controlled vs Uncontrolled - Pattern CÆ¡ Báº£n â­

#### âŒ Uncontrolled Component (Not Recommended)

```jsx
// âŒ Browser controls the input value
function UncontrolledForm() {
  const handleSubmit = (e) => {
    e.preventDefault();

    // âŒ Pháº£i query DOM Ä‘á»ƒ láº¥y value
    const email = e.target.elements.email.value;
    const password = e.target.elements.password.value;

    console.log('Submitted:', { email, password });

    // âŒ KhÃ´ng biáº¿t value trÆ°á»›c khi submit
    // âŒ KhÃ´ng validate Ä‘Æ°á»£c realtime
    // âŒ KhÃ´ng disable submit button khi invalid
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        name='email'
        type='email'
        // âŒ KhÃ´ng cÃ³ value prop â†’ Browser controls
      />
      <input
        name='password'
        type='password'
      />
      <button type='submit'>Submit</button>
    </form>
  );
}
```

**Problems:**

- âŒ KhÃ´ng biáº¿t user Ä‘ang gÃµ gÃ¬
- âŒ KhÃ´ng validate Ä‘Æ°á»£c realtime
- âŒ KhÃ´ng disable submit khi invalid
- âŒ KhÃ³ dynamic UI (show/hide fields)
- âŒ KhÃ³ auto-format (phone number, credit card)

---

#### âœ… Controlled Component (Recommended)

```jsx
// âœ… React controls the input value
function ControlledForm() {
  // âœ… State = Single Source of Truth
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();

    // âœ… ÄÃ£ cÃ³ value tá»« state
    console.log('Submitted:', { email, password });

    // âœ… Clear form sau khi submit
    setEmail('');
    setPassword('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Email:</label>
        <input
          type='email'
          value={email} // âœ… React controls value
          onChange={(e) => setEmail(e.target.value)}
        />
        <p>You typed: {email}</p> {/* âœ… Can use state anywhere */}
      </div>

      <div>
        <label>Password:</label>
        <input
          type='password'
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <p>Length: {password.length}</p> {/* âœ… Realtime info */}
      </div>

      <button
        type='submit'
        disabled={!email || password.length < 6} // âœ… Smart button!
      >
        Submit
      </button>
    </form>
  );
}
```

**Benefits:**

- âœ… Biáº¿t user Ä‘ang gÃµ gÃ¬ (realtime)
- âœ… Validate ngay khi gÃµ
- âœ… Disable submit khi invalid
- âœ… Show helpful UI (password strength, email format)
- âœ… Easy to transform input (uppercase, format, etc.)

---

### Demo 2: Multiple Inputs vá»›i Object State - Ká»‹ch Báº£n Thá»±c Táº¿ â­â­

#### âŒ CÃCH SAI: Má»—i Input 1 State RiÃªng

```jsx
// âŒ Code dÃ i dÃ²ng, khÃ³ maintain
function SignupFormBad() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [phone, setPhone] = useState('');
  const [address, setAddress] = useState('');
  const [city, setCity] = useState('');
  const [country, setCountry] = useState('');
  // ğŸ˜± 9 states cho 1 form!

  const handleSubmit = (e) => {
    e.preventDefault();

    // âŒ Pháº£i list táº¥t cáº£ fields
    const formData = {
      firstName,
      lastName,
      email,
      password,
      confirmPassword,
      phone,
      address,
      city,
      country,
    };

    console.log(formData);

    // âŒ Reset form = 9 dÃ²ng code!
    setFirstName('');
    setLastName('');
    setEmail('');
    setPassword('');
    setConfirmPassword('');
    setPhone('');
    setAddress('');
    setCity('');
    setCountry('');
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
      />
      <input
        value={lastName}
        onChange={(e) => setLastName(e.target.value)}
      />
      {/* ...7 inputs ná»¯a vá»›i 7 onChange handlers! */}
    </form>
  );
}
```

**Problems:**

- ğŸ˜± Too many states
- ğŸ˜± Too many onChange handlers
- ğŸ˜± Reset form phá»©c táº¡p
- ğŸ˜± Hard to validate related fields
- ğŸ˜± Can't easily pass to API

---

#### âœ… CÃCH ÄÃšNG: Single Object State

```jsx
// âœ… Clean, maintainable, scalable
function SignupFormGood() {
  // âœ… Group related data (apply NgÃ y 12!)
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    confirmPassword: '',
    phone: '',
    address: '',
    city: '',
    country: '',
  });

  // âœ… Generic handler cho táº¥t cáº£ inputs
  const handleChange = (e) => {
    const { name, value } = e.target;

    setFormData((prev) => ({
      ...prev, // Keep old values
      [name]: value, // Update changed field
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    // âœ… formData Ä‘Ã£ sáºµn sÃ ng Ä‘á»ƒ gá»­i API
    console.log('Submitting:', formData);

    // âœ… Reset form = 1 dÃ²ng!
    setFormData({
      firstName: '',
      lastName: '',
      email: '',
      password: '',
      confirmPassword: '',
      phone: '',
      address: '',
      city: '',
      country: '',
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>First Name:</label>
        <input
          name='firstName' // âš ï¸ IMPORTANT: name attribute!
          value={formData.firstName}
          onChange={handleChange} // âœ… Reuse same handler
        />
      </div>

      <div>
        <label>Last Name:</label>
        <input
          name='lastName'
          value={formData.lastName}
          onChange={handleChange}
        />
      </div>

      <div>
        <label>Email:</label>
        <input
          name='email'
          type='email'
          value={formData.email}
          onChange={handleChange}
        />
      </div>

      <div>
        <label>Password:</label>
        <input
          name='password'
          type='password'
          value={formData.password}
          onChange={handleChange}
        />
      </div>

      <div>
        <label>Confirm Password:</label>
        <input
          name='confirmPassword'
          type='password'
          value={formData.confirmPassword}
          onChange={handleChange}
        />
      </div>

      {/* ...more inputs... */}

      <button type='submit'>Sign Up</button>

      {/* Debug view */}
      <details>
        <summary>Form Data</summary>
        <pre>{JSON.stringify(formData, null, 2)}</pre>
      </details>
    </form>
  );
}
```

**ğŸ”¥ KEY PATTERN:**

```jsx
// Magic pattern: 1 handler for ALL inputs!
const handleChange = (e) => {
  const { name, value } = e.target; // Destructure
  setFormData((prev) => ({
    ...prev, // Immutable update (NgÃ y 12!)
    [name]: value, // Computed property name
  }));
};

// Each input needs `name` attribute matching state key
<input
  name='email' // Must match formData.email
  value={formData.email}
  onChange={handleChange}
/>;
```

---

### Demo 3: Validation & Error Handling - Edge Cases â­â­â­

```jsx
// âœ… Production-ready form with validation
function RegistrationForm() {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    age: '',
  });

  // âœ… Separate state for errors
  const [errors, setErrors] = useState({});

  // âœ… Track which fields user has touched
  const [touched, setTouched] = useState({});

  // âœ… Validation rules (pure functions)
  const validators = {
    username: (value) => {
      if (!value) return 'Username is required';
      if (value.length < 3) return 'Username must be at least 3 characters';
      if (!/^[a-zA-Z0-9_]+$/.test(value))
        return 'Only letters, numbers, underscore';
      return ''; // No error
    },

    email: (value) => {
      if (!value) return 'Email is required';
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value))
        return 'Invalid email format';
      return '';
    },

    password: (value) => {
      if (!value) return 'Password is required';
      if (value.length < 8) return 'Password must be at least 8 characters';
      if (!/[A-Z]/.test(value)) return 'Password must contain uppercase letter';
      if (!/[0-9]/.test(value)) return 'Password must contain number';
      return '';
    },

    confirmPassword: (value) => {
      if (!value) return 'Please confirm password';
      if (value !== formData.password) return 'Passwords do not match';
      return '';
    },

    age: (value) => {
      if (!value) return 'Age is required';
      const num = Number(value);
      if (isNaN(num)) return 'Age must be a number';
      if (num < 13) return 'Must be at least 13 years old';
      if (num > 120) return 'Invalid age';
      return '';
    },
  };

  // âœ… Validate single field
  const validateField = (name, value) => {
    if (validators[name]) {
      return validators[name](value);
    }
    return '';
  };

  // âœ… Validate all fields
  const validateAll = () => {
    const newErrors = {};

    Object.keys(formData).forEach((field) => {
      const error = validateField(field, formData[field]);
      if (error) {
        newErrors[field] = error;
      }
    });

    return newErrors;
  };

  // âœ… Handle input change with validation
  const handleChange = (e) => {
    const { name, value } = e.target;

    // Update form data
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));

    // Clear error for this field when user types
    if (errors[name]) {
      setErrors((prev) => ({
        ...prev,
        [name]: '',
      }));
    }

    // Validate confirmPassword when password changes
    if (name === 'password' && formData.confirmPassword) {
      const confirmError = validators.confirmPassword(formData.confirmPassword);
      setErrors((prev) => ({
        ...prev,
        confirmPassword: confirmError,
      }));
    }
  };

  // âœ… Handle blur (when user leaves field)
  const handleBlur = (e) => {
    const { name, value } = e.target;

    // Mark field as touched
    setTouched((prev) => ({
      ...prev,
      [name]: true,
    }));

    // Validate field
    const error = validateField(name, value);
    if (error) {
      setErrors((prev) => ({
        ...prev,
        [name]: error,
      }));
    }
  };

  // âœ… Handle submit
  const handleSubmit = (e) => {
    e.preventDefault();

    // Mark all fields as touched
    const allTouched = Object.keys(formData).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allTouched);

    // Validate all
    const validationErrors = validateAll();

    if (Object.keys(validationErrors).length > 0) {
      // Has errors
      setErrors(validationErrors);
      console.log('Form has errors:', validationErrors);
      return;
    }

    // âœ… Form is valid!
    console.log('Form submitted successfully:', formData);

    // Clear form
    setFormData({
      username: '',
      email: '',
      password: '',
      confirmPassword: '',
      age: '',
    });
    setErrors({});
    setTouched({});
  };

  // âœ… Derived: Is form valid?
  const isFormValid =
    Object.keys(validateAll()).length === 0 &&
    Object.keys(formData).every((key) => formData[key]);

  return (
    <form
      onSubmit={handleSubmit}
      style={{ maxWidth: '500px', margin: '0 auto', padding: '20px' }}
    >
      <h2>Registration Form</h2>

      {/* Username */}
      <div style={{ marginBottom: '15px' }}>
        <label style={{ display: 'block', marginBottom: '5px' }}>
          Username:
        </label>
        <input
          name='username'
          value={formData.username}
          onChange={handleChange}
          onBlur={handleBlur}
          style={{
            width: '100%',
            padding: '8px',
            border:
              errors.username && touched.username
                ? '2px solid red'
                : '1px solid #ccc',
          }}
        />
        {touched.username && errors.username && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.username}
          </p>
        )}
      </div>

      {/* Email */}
      <div style={{ marginBottom: '15px' }}>
        <label style={{ display: 'block', marginBottom: '5px' }}>Email:</label>
        <input
          name='email'
          type='email'
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
          style={{
            width: '100%',
            padding: '8px',
            border:
              errors.email && touched.email
                ? '2px solid red'
                : '1px solid #ccc',
          }}
        />
        {touched.email && errors.email && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.email}
          </p>
        )}
      </div>

      {/* Password */}
      <div style={{ marginBottom: '15px' }}>
        <label style={{ display: 'block', marginBottom: '5px' }}>
          Password:
        </label>
        <input
          name='password'
          type='password'
          value={formData.password}
          onChange={handleChange}
          onBlur={handleBlur}
          style={{
            width: '100%',
            padding: '8px',
            border:
              errors.password && touched.password
                ? '2px solid red'
                : '1px solid #ccc',
          }}
        />
        {touched.password && errors.password && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.password}
          </p>
        )}
        {/* Password strength indicator */}
        {formData.password && (
          <div style={{ marginTop: '5px', fontSize: '0.85em' }}>
            <span
              style={{
                color: formData.password.length >= 8 ? 'green' : 'gray',
              }}
            >
              âœ“ 8+ characters
            </span>
            {' | '}
            <span
              style={{
                color: /[A-Z]/.test(formData.password) ? 'green' : 'gray',
              }}
            >
              âœ“ Uppercase
            </span>
            {' | '}
            <span
              style={{
                color: /[0-9]/.test(formData.password) ? 'green' : 'gray',
              }}
            >
              âœ“ Number
            </span>
          </div>
        )}
      </div>

      {/* Confirm Password */}
      <div style={{ marginBottom: '15px' }}>
        <label style={{ display: 'block', marginBottom: '5px' }}>
          Confirm Password:
        </label>
        <input
          name='confirmPassword'
          type='password'
          value={formData.confirmPassword}
          onChange={handleChange}
          onBlur={handleBlur}
          style={{
            width: '100%',
            padding: '8px',
            border:
              errors.confirmPassword && touched.confirmPassword
                ? '2px solid red'
                : '1px solid #ccc',
          }}
        />
        {touched.confirmPassword && errors.confirmPassword && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.confirmPassword}
          </p>
        )}
      </div>

      {/* Age */}
      <div style={{ marginBottom: '15px' }}>
        <label style={{ display: 'block', marginBottom: '5px' }}>Age:</label>
        <input
          name='age'
          type='number'
          value={formData.age}
          onChange={handleChange}
          onBlur={handleBlur}
          style={{
            width: '100%',
            padding: '8px',
            border:
              errors.age && touched.age ? '2px solid red' : '1px solid #ccc',
          }}
        />
        {touched.age && errors.age && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.age}
          </p>
        )}
      </div>

      {/* Submit Button */}
      <button
        type='submit'
        disabled={!isFormValid}
        style={{
          width: '100%',
          padding: '12px',
          background: isFormValid ? '#4CAF50' : '#ccc',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: isFormValid ? 'pointer' : 'not-allowed',
          fontSize: '16px',
        }}
      >
        Register
      </button>

      {/* Debug */}
      <details style={{ marginTop: '20px' }}>
        <summary>Debug Info</summary>
        <div style={{ fontSize: '0.85em' }}>
          <p>
            <strong>Form Data:</strong>
          </p>
          <pre>{JSON.stringify(formData, null, 2)}</pre>
          <p>
            <strong>Errors:</strong>
          </p>
          <pre>{JSON.stringify(errors, null, 2)}</pre>
          <p>
            <strong>Touched:</strong>
          </p>
          <pre>{JSON.stringify(touched, null, 2)}</pre>
          <p>
            <strong>Is Valid:</strong> {isFormValid ? 'Yes' : 'No'}
          </p>
        </div>
      </details>
    </form>
  );
}
```

**ğŸ”¥ KEY PATTERNS:**

1. **Separate Error State:**

```jsx
const [formData, setFormData] = useState({...});
const [errors, setErrors] = useState({});      // âœ… Separate!
const [touched, setTouched] = useState({});    // âœ… Track touched fields
```

2. **Validation Timing:**

```jsx
onChange  â†’ Clear errors (good UX - don't show error while typing)
onBlur    â†’ Validate field (show error when user leaves)
onSubmit  â†’ Validate all (final check)
```

3. **Cross-field Validation:**

```jsx
// When password changes, re-validate confirmPassword
if (name === 'password' && formData.confirmPassword) {
  validateField('confirmPassword', formData.confirmPassword);
}
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Exercise 1: Basic Login Form (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Táº¡o controlled login form cÆ¡ báº£n
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useEffect, useRef, external libraries
 *
 * Requirements:
 * 1. 2 inputs: email vÃ  password (controlled)
 * 2. Submit button disabled khi email rá»—ng HOáº¶C password < 6 kÃ½ tá»±
 * 3. onSubmit: console.log form data vÃ  clear form
 * 4. Hiá»ƒn thá»‹ "Password length: X" khi user gÃµ password
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - DÃ¹ng 2 separate states hoáº·c 1 object state (báº¡n chá»n!)
 * - e.preventDefault() trong handleSubmit
 */

// âŒ Starter code (cÃ³ bugs):
function LoginForm() {
  // TODO: Add state

  const handleSubmit = (e) => {
    // TODO: Implement
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Email:</label>
        <input type='email' />
        {/* TODO: Make controlled */}
      </div>

      <div>
        <label>Password:</label>
        <input type='password' />
        {/* TODO: Make controlled */}
        {/* TODO: Show length */}
      </div>

      <button type='submit'>
        {/* TODO: Disable when invalid */}
        Login
      </button>
    </form>
  );
}

// âœ… NHIá»†M Vá»¤ Cá»¦A Báº N:
// TODO: Implement controlled inputs
// TODO: Add state management
// TODO: Implement validation
// TODO: Handle submit
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
function LoginForm() {
  // Option 1: Separate states (simple form)
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  // Option 2: Object state (recommended for larger forms)
  // const [formData, setFormData] = useState({ email: '', password: '' });

  const handleSubmit = (e) => {
    e.preventDefault(); // âœ… Prevent page reload

    console.log('Login submitted:', { email, password });

    // Clear form
    setEmail('');
    setPassword('');
  };

  // Validation logic
  const isValid = email.trim() !== '' && password.length >= 6;

  return (
    <form
      onSubmit={handleSubmit}
      style={{ maxWidth: '400px', padding: '20px' }}
    >
      <div style={{ marginBottom: '15px' }}>
        <label style={{ display: 'block', marginBottom: '5px' }}>Email:</label>
        <input
          type='email'
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder='you@example.com'
          style={{ width: '100%', padding: '8px' }}
        />
      </div>

      <div style={{ marginBottom: '15px' }}>
        <label style={{ display: 'block', marginBottom: '5px' }}>
          Password:
        </label>
        <input
          type='password'
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder='Min 6 characters'
          style={{ width: '100%', padding: '8px' }}
        />
        {password && (
          <p
            style={{
              fontSize: '0.85em',
              color: password.length >= 6 ? 'green' : 'red',
            }}
          >
            Password length: {password.length}{' '}
            {password.length >= 6 ? 'âœ“' : '(min 6)'}
          </p>
        )}
      </div>

      <button
        type='submit'
        disabled={!isValid}
        style={{
          width: '100%',
          padding: '10px',
          background: isValid ? '#007bff' : '#ccc',
          color: 'white',
          border: 'none',
          cursor: isValid ? 'pointer' : 'not-allowed',
        }}
      >
        Login
      </button>

      {/* Debug */}
      <div style={{ marginTop: '20px', fontSize: '0.85em', color: '#666' }}>
        <p>Email: {email || '(empty)'}</p>
        <p>Password: {'*'.repeat(password.length)}</p>
        <p>Valid: {isValid ? 'Yes âœ“' : 'No âœ—'}</p>
      </div>
    </form>
  );
}
```

</details>

---

### â­â­ Exercise 2: Contact Form with Multiple Inputs (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Handle multiple inputs efficiently
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: Contact form vá»›i nhiá»u fields
 *
 * ğŸ¤” PHÃ‚N TÃCH:
 * Approach A: Má»—i field 1 state riÃªng
 * Pros: ÄÆ¡n giáº£n, rÃµ rÃ ng
 * Cons: Nhiá»u states, nhiá»u onChange handlers
 *
 * Approach B: Object state + generic handler
 * Pros: Scalable, Ã­t code hÆ¡n, easy to extend
 * Cons: Phá»©c táº¡p hÆ¡n chÃºt (nhÆ°ng Ä‘Ã¡ng!)
 *
 * ğŸ’­ Báº N CHá»ŒN GÃŒ VÃ€ Táº I SAO?
 */

// Requirements:
const FIELDS = {
  name: { label: 'Full Name', type: 'text', required: true },
  email: { label: 'Email', type: 'email', required: true },
  phone: { label: 'Phone', type: 'tel', required: false },
  subject: { label: 'Subject', type: 'text', required: true },
  message: { label: 'Message', type: 'textarea', required: true },
};

// âœ… NHIá»†M Vá»¤ Cá»¦A Báº N:

function ContactForm() {
  // TODO: Design state structure (justify your choice!)

  // TODO: Implement generic handleChange
  const handleChange = (e) => {
    // Hint: const { name, value } = e.target;
  };

  // TODO: Implement handleSubmit
  const handleSubmit = (e) => {
    e.preventDefault();
    // 1. Validate required fields
    // 2. Console.log if valid
    // 3. Clear form
  };

  // TODO: Validation - check all required fields filled
  const isValid = false; // Replace with actual logic

  return (
    <form onSubmit={handleSubmit}>
      {/* TODO: Render inputs dynamically or manually */}

      <button
        type='submit'
        disabled={!isValid}
      >
        Send Message
      </button>
    </form>
  );
}

// ğŸ“ Document your decision:
/**
 * State Structure Decision:
 *
 * Chosen Approach: [A or B]
 *
 * Rationale:
 * - [Why this approach?]
 *
 * Trade-offs:
 * - [What are you giving up?]
 */
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
/**
 * State Structure Decision:
 *
 * Chosen Approach: B - Object state + generic handler
 *
 * Rationale:
 * - 5 fields â†’ would need 5 states + 5 handlers in Approach A
 * - Generic handler scales to any number of fields
 * - Easy to add/remove fields in future
 * - Form data already in object shape for API
 *
 * Trade-offs:
 * - Slightly more complex initially
 * - Need to understand computed property names
 * - Worth it for maintainability!
 */

const FIELDS = {
  name: { label: 'Full Name', type: 'text', required: true },
  email: { label: 'Email', type: 'email', required: true },
  phone: { label: 'Phone', type: 'tel', required: false },
  subject: { label: 'Subject', type: 'text', required: true },
  message: { label: 'Message', type: 'textarea', required: true },
};

function ContactForm() {
  // âœ… Single object state
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    phone: '',
    subject: '',
    message: '',
  });

  // âœ… Generic handler for all inputs
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  // âœ… Validate required fields
  const validateForm = () => {
    // Check all required fields are filled
    return Object.keys(FIELDS).every((fieldName) => {
      const field = FIELDS[fieldName];
      if (field.required) {
        return formData[fieldName].trim() !== '';
      }
      return true; // Optional fields always pass
    });
  };

  const isValid = validateForm();

  // âœ… Handle submit
  const handleSubmit = (e) => {
    e.preventDefault();

    if (!isValid) {
      console.log('Form is invalid!');
      return;
    }

    console.log('Contact form submitted:', formData);

    // Clear form
    setFormData({
      name: '',
      email: '',
      phone: '',
      subject: '',
      message: '',
    });

    alert('Message sent successfully!');
  };

  return (
    <form
      onSubmit={handleSubmit}
      style={{ maxWidth: '600px', margin: '0 auto', padding: '20px' }}
    >
      <h2>Contact Us</h2>

      {/* Render fields dynamically */}
      {Object.keys(FIELDS).map((fieldName) => {
        const field = FIELDS[fieldName];
        const isTextarea = field.type === 'textarea';

        return (
          <div
            key={fieldName}
            style={{ marginBottom: '15px' }}
          >
            <label
              style={{
                display: 'block',
                marginBottom: '5px',
                fontWeight: 'bold',
              }}
            >
              {field.label}
              {field.required && <span style={{ color: 'red' }}> *</span>}
            </label>

            {isTextarea ? (
              <textarea
                name={fieldName}
                value={formData[fieldName]}
                onChange={handleChange}
                rows={5}
                style={{ width: '100%', padding: '8px', fontFamily: 'inherit' }}
              />
            ) : (
              <input
                type={field.type}
                name={fieldName}
                value={formData[fieldName]}
                onChange={handleChange}
                style={{ width: '100%', padding: '8px' }}
              />
            )}

            {/* Show character count for message */}
            {fieldName === 'message' && formData.message && (
              <p
                style={{
                  fontSize: '0.85em',
                  color: '#666',
                  margin: '5px 0 0 0',
                }}
              >
                {formData.message.length} characters
              </p>
            )}
          </div>
        );
      })}

      <button
        type='submit'
        disabled={!isValid}
        style={{
          width: '100%',
          padding: '12px',
          background: isValid ? '#28a745' : '#ccc',
          color: 'white',
          border: 'none',
          fontSize: '16px',
          cursor: isValid ? 'pointer' : 'not-allowed',
          borderRadius: '4px',
        }}
      >
        Send Message
      </button>

      {/* Missing fields indicator */}
      {!isValid && (
        <p style={{ color: 'red', marginTop: '10px', fontSize: '0.9em' }}>
          Please fill in all required fields (*)
        </p>
      )}

      {/* Debug */}
      <details style={{ marginTop: '20px' }}>
        <summary>Debug: Form Data</summary>
        <pre
          style={{ background: '#f5f5f5', padding: '10px', overflow: 'auto' }}
        >
          {JSON.stringify(formData, null, 2)}
        </pre>
      </details>
    </form>
  );
}
```

**Key Learnings:**

1. Dynamic rendering vá»›i Object.keys().map()
2. Generic handler scales to any number of fields
3. Validation logic reusable
4. Easy to add new fields - just update FIELDS object!

</details>

---

### â­â­â­ Exercise 3: Product Review Form with Validation (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Form vá»›i validation phá»©c táº¡p
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  customer, tÃ´i muá»‘n review sáº£n pháº©m vá»›i rating vÃ  comment"
 *
 * âœ… Acceptance Criteria:
 * - [ ] Fields: productName, rating (1-5), reviewTitle, reviewText, recommend (yes/no), email
 * - [ ] Rating: sá»‘ nguyÃªn tá»« 1-5, hiá»ƒn thá»‹ stars â­
 * - [ ] Review title: 10-100 kÃ½ tá»±
 * - [ ] Review text: 50-500 kÃ½ tá»±
 * - [ ] Email: valid format
 * - [ ] Show errors onBlur (touched fields only)
 * - [ ] Character counters cho text fields
 * - [ ] Disable submit khi invalid
 *
 * ğŸ¨ Technical Constraints:
 * - Object state cho form data
 * - Object state cho errors
 * - Object state cho touched
 * - Validators object vá»›i reusable validation functions
 *
 * ğŸš¨ Edge Cases cáº§n handle:
 * - Empty strings
 * - Spaces-only strings (use .trim())
 * - Rating out of range
 * - Email format invalid
 */

// âœ… NHIá»†M Vá»¤ Cá»¦A Báº N:

function ProductReviewForm() {
  // TODO: State for form data
  const [formData, setFormData] = useState({
    productName: '',
    rating: '',
    reviewTitle: '',
    reviewText: '',
    recommend: '',
    email: '',
  });

  // TODO: State for errors
  const [errors, setErrors] = useState({});

  // TODO: State for touched fields
  const [touched, setTouched] = useState({});

  // TODO: Validation functions
  const validators = {
    productName: (value) => {
      // Required, min 2 chars
    },
    rating: (value) => {
      // Required, 1-5
    },
    reviewTitle: (value) => {
      // Required, 10-100 chars
    },
    reviewText: (value) => {
      // Required, 50-500 chars
    },
    recommend: (value) => {
      // Required
    },
    email: (value) => {
      // Required, valid email
    },
  };

  // TODO: Implement handlers
  const handleChange = (e) => {};
  const handleBlur = (e) => {};
  const handleSubmit = (e) => {};

  return (
    <form onSubmit={handleSubmit}>{/* TODO: Implement form fields */}</form>
  );
}

// ğŸ“ Implementation Checklist:
// - [ ] All validators implemented
// - [ ] handleChange clears errors
// - [ ] handleBlur validates + marks touched
// - [ ] handleSubmit validates all
// - [ ] Star rating display (â­â­â­â­â­)
// - [ ] Character counters
// - [ ] Error messages show only for touched fields
```

<details>
<summary>ğŸ’¡ Full Solution</summary>

```jsx
function ProductReviewForm() {
  const [formData, setFormData] = useState({
    productName: '',
    rating: '',
    reviewTitle: '',
    reviewText: '',
    recommend: '',
    email: '',
  });

  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [submitted, setSubmitted] = useState(false);

  // âœ… Validation functions
  const validators = {
    productName: (value) => {
      if (!value.trim()) return 'Product name is required';
      if (value.trim().length < 2)
        return 'Product name must be at least 2 characters';
      return '';
    },

    rating: (value) => {
      if (!value) return 'Please select a rating';
      const num = Number(value);
      if (isNaN(num) || num < 1 || num > 5)
        return 'Rating must be between 1 and 5';
      return '';
    },

    reviewTitle: (value) => {
      if (!value.trim()) return 'Review title is required';
      const len = value.trim().length;
      if (len < 10) return `Title too short (${len}/10 minimum)`;
      if (len > 100) return `Title too long (${len}/100 maximum)`;
      return '';
    },

    reviewText: (value) => {
      if (!value.trim()) return 'Review text is required';
      const len = value.trim().length;
      if (len < 50) return `Review too short (${len}/50 minimum)`;
      if (len > 500) return `Review too long (${len}/500 maximum)`;
      return '';
    },

    recommend: (value) => {
      if (!value) return 'Please indicate if you would recommend this product';
      return '';
    },

    email: (value) => {
      if (!value.trim()) return 'Email is required';
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(value)) return 'Invalid email format';
      return '';
    },
  };

  // âœ… Validate single field
  const validateField = (name, value) => {
    if (validators[name]) {
      return validators[name](value);
    }
    return '';
  };

  // âœ… Validate all fields
  const validateAll = () => {
    const newErrors = {};
    Object.keys(formData).forEach((field) => {
      const error = validateField(field, formData[field]);
      if (error) newErrors[field] = error;
    });
    return newErrors;
  };

  // âœ… Handle input change
  const handleChange = (e) => {
    const { name, value } = e.target;

    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));

    // Clear error when user types
    if (errors[name]) {
      setErrors((prev) => ({
        ...prev,
        [name]: '',
      }));
    }
  };

  // âœ… Handle blur
  const handleBlur = (e) => {
    const { name, value } = e.target;

    setTouched((prev) => ({
      ...prev,
      [name]: true,
    }));

    const error = validateField(name, value);
    if (error) {
      setErrors((prev) => ({
        ...prev,
        [name]: error,
      }));
    }
  };

  // âœ… Handle submit
  const handleSubmit = (e) => {
    e.preventDefault();

    // Mark all as touched
    const allTouched = Object.keys(formData).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allTouched);

    // Validate all
    const validationErrors = validateAll();

    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
      return;
    }

    // Success!
    console.log('Review submitted:', formData);
    setSubmitted(true);

    // Reset form after 2 seconds
    setTimeout(() => {
      setFormData({
        productName: '',
        rating: '',
        reviewTitle: '',
        reviewText: '',
        recommend: '',
        email: '',
      });
      setErrors({});
      setTouched({});
      setSubmitted(false);
    }, 2000);
  };

  const isFormValid = Object.keys(validateAll()).length === 0;

  // Helper: Render stars
  const renderStars = (rating) => {
    return 'â­'.repeat(Number(rating) || 0);
  };

  return (
    <form
      onSubmit={handleSubmit}
      style={{ maxWidth: '700px', margin: '0 auto', padding: '20px' }}
    >
      <h2>ğŸ“ Product Review</h2>

      {submitted && (
        <div
          style={{
            padding: '15px',
            background: '#d4edda',
            color: '#155724',
            marginBottom: '20px',
            borderRadius: '4px',
          }}
        >
          âœ… Thank you for your review!
        </div>
      )}

      {/* Product Name */}
      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Product Name *
        </label>
        <input
          name='productName'
          value={formData.productName}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder='e.g., iPhone 15 Pro'
          style={{
            width: '100%',
            padding: '10px',
            border:
              touched.productName && errors.productName
                ? '2px solid red'
                : '1px solid #ccc',
            borderRadius: '4px',
          }}
        />
        {touched.productName && errors.productName && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.productName}
          </p>
        )}
      </div>

      {/* Rating */}
      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Rating * {formData.rating && renderStars(formData.rating)}
        </label>
        <select
          name='rating'
          value={formData.rating}
          onChange={handleChange}
          onBlur={handleBlur}
          style={{
            width: '100%',
            padding: '10px',
            border:
              touched.rating && errors.rating
                ? '2px solid red'
                : '1px solid #ccc',
            borderRadius: '4px',
          }}
        >
          <option value=''>Select rating...</option>
          <option value='5'>5 - Excellent</option>
          <option value='4'>4 - Good</option>
          <option value='3'>3 - Average</option>
          <option value='2'>2 - Poor</option>
          <option value='1'>1 - Terrible</option>
        </select>
        {touched.rating && errors.rating && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.rating}
          </p>
        )}
      </div>

      {/* Review Title */}
      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Review Title *
          <span
            style={{ fontSize: '0.85em', fontWeight: 'normal', color: '#666' }}
          >
            {' '}
            ({formData.reviewTitle.trim().length}/10-100 chars)
          </span>
        </label>
        <input
          name='reviewTitle'
          value={formData.reviewTitle}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder='Sum up your review in one line'
          maxLength={100}
          style={{
            width: '100%',
            padding: '10px',
            border:
              touched.reviewTitle && errors.reviewTitle
                ? '2px solid red'
                : '1px solid #ccc',
            borderRadius: '4px',
          }}
        />
        {touched.reviewTitle && errors.reviewTitle && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.reviewTitle}
          </p>
        )}
      </div>

      {/* Review Text */}
      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Your Review *
          <span
            style={{ fontSize: '0.85em', fontWeight: 'normal', color: '#666' }}
          >
            {' '}
            ({formData.reviewText.trim().length}/50-500 chars)
          </span>
        </label>
        <textarea
          name='reviewText'
          value={formData.reviewText}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder='Tell us what you think about this product...'
          rows={6}
          maxLength={500}
          style={{
            width: '100%',
            padding: '10px',
            border:
              touched.reviewText && errors.reviewText
                ? '2px solid red'
                : '1px solid #ccc',
            borderRadius: '4px',
            fontFamily: 'inherit',
          }}
        />
        {touched.reviewText && errors.reviewText && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.reviewText}
          </p>
        )}
      </div>

      {/* Recommend */}
      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '10px', fontWeight: 'bold' }}
        >
          Would you recommend this product? *
        </label>
        <div>
          <label style={{ marginRight: '20px', cursor: 'pointer' }}>
            <input
              type='radio'
              name='recommend'
              value='yes'
              checked={formData.recommend === 'yes'}
              onChange={handleChange}
              onBlur={handleBlur}
            />{' '}
            Yes
          </label>
          <label style={{ cursor: 'pointer' }}>
            <input
              type='radio'
              name='recommend'
              value='no'
              checked={formData.recommend === 'no'}
              onChange={handleChange}
              onBlur={handleBlur}
            />{' '}
            No
          </label>
        </div>
        {touched.recommend && errors.recommend && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.recommend}
          </p>
        )}
      </div>

      {/* Email */}
      <div style={{ marginBottom: '20px' }}>
        <label
          style={{ display: 'block', marginBottom: '5px', fontWeight: 'bold' }}
        >
          Email *{' '}
          <span
            style={{ fontSize: '0.85em', fontWeight: 'normal', color: '#666' }}
          >
            (for verification)
          </span>
        </label>
        <input
          type='email'
          name='email'
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder='you@example.com'
          style={{
            width: '100%',
            padding: '10px',
            border:
              touched.email && errors.email
                ? '2px solid red'
                : '1px solid #ccc',
            borderRadius: '4px',
          }}
        />
        {touched.email && errors.email && (
          <p style={{ color: 'red', fontSize: '0.9em', margin: '5px 0 0 0' }}>
            {errors.email}
          </p>
        )}
      </div>

      {/* Submit */}
      <button
        type='submit'
        disabled={!isFormValid}
        style={{
          width: '100%',
          padding: '15px',
          background: isFormValid ? '#007bff' : '#ccc',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          fontSize: '16px',
          fontWeight: 'bold',
          cursor: isFormValid ? 'pointer' : 'not-allowed',
        }}
      >
        Submit Review
      </button>

      {/* Debug */}
      <details style={{ marginTop: '30px' }}>
        <summary>ğŸ” Debug Info</summary>
        <div style={{ fontSize: '0.85em' }}>
          <p>
            <strong>Is Valid:</strong> {isFormValid ? 'Yes âœ…' : 'No âŒ'}
          </p>
          <p>
            <strong>Form Data:</strong>
          </p>
          <pre style={{ background: '#f5f5f5', padding: '10px' }}>
            {JSON.stringify(formData, null, 2)}
          </pre>
          <p>
            <strong>Errors:</strong>
          </p>
          <pre style={{ background: '#f5f5f5', padding: '10px' }}>
            {JSON.stringify(errors, null, 2)}
          </pre>
        </div>
      </details>
    </form>
  );
}
```

</details>

---

### â­â­â­â­ Exercise 4: Multi-step Form (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Multi-step wizard form
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Requirements:
 * - 3 steps: Personal Info â†’ Account Details â†’ Preferences
 * - Step 1: firstName, lastName, email, phone
 * - Step 2: username, password, confirmPassword
 * - Step 3: newsletter (yes/no), notifications (yes/no), theme (light/dark)
 * - Next button disabled if current step invalid
 * - Back button (except step 1)
 * - Progress indicator (Step X of 3)
 * - Final review before submit
 *
 * State Design Questions:
 * 1. How to track current step?
 * 2. How to structure form data (1 object vs 3 objects)?
 * 3. How to validate per-step?
 * 4. How to prevent going to next step if invalid?
 *
 * ADR Template:
 * - Context: Multi-step form cáº§n track progress + validate per step
 * - Decision: State structure cá»§a báº¡n
 * - Rationale: Táº¡i sao?
 * - Consequences: Trade-offs
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 *
 * ğŸ§ª PHASE 3: Testing (10 phÃºt)
 * Manual test cases
 */

// âœ… NHIá»†M Vá»¤ Cá»¦A Báº N:

function MultiStepForm() {
  // TODO: Design state
  // Consider:
  // - currentStep (number)
  // - formData (how to structure?)
  // - errors per step?

  // TODO: Implement step validation

  // TODO: Implement navigation (next/back)

  // TODO: Render current step conditionally

  return (
    <div>
      {/* Progress indicator */}
      {/* Step content */}
      {/* Navigation buttons */}
    </div>
  );
}
```

<details>
<summary>ğŸ’¡ Solution vá»›i ADR</summary>

```jsx
/**
 * ADR: Multi-Step Form State Structure
 *
 * Decision:
 * - currentStep: number (1, 2, 3)
 * - formData: single flat object vá»›i táº¥t cáº£ fields
 * - errors: object vá»›i keys matching formData
 *
 * Rationale:
 * - Single formData object: dá»… submit cuá»‘i cÃ¹ng
 * - Flat structure: khÃ´ng cáº§n nested validation
 * - Validators per field, check per step
 *
 * Consequences:
 * - Must define which fields belong to which step
 * - Validation logic coupled to step definition
 * - Trade-off: simplicity vs flexibility (OK for 3 steps)
 */

function MultiStepForm() {
  const [currentStep, setCurrentStep] = useState(1);

  const [formData, setFormData] = useState({
    // Step 1
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    // Step 2
    username: '',
    password: '',
    confirmPassword: '',
    // Step 3
    newsletter: false,
    notifications: false,
    theme: 'light',
  });

  const [errors, setErrors] = useState({});

  // Define steps
  const STEPS = {
    1: {
      title: 'Personal Information',
      fields: ['firstName', 'lastName', 'email', 'phone'],
    },
    2: {
      title: 'Account Details',
      fields: ['username', 'password', 'confirmPassword'],
    },
    3: {
      title: 'Preferences',
      fields: ['newsletter', 'notifications', 'theme'],
    },
  };

  // Validators
  const validators = {
    firstName: (v) => (!v.trim() ? 'First name required' : ''),
    lastName: (v) => (!v.trim() ? 'Last name required' : ''),
    email: (v) => {
      if (!v) return 'Email required';
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v)) return 'Invalid email';
      return '';
    },
    phone: (v) => {
      if (!v) return 'Phone required';
      if (!/^\d{10}$/.test(v.replace(/\D/g, '')))
        return 'Invalid phone (10 digits)';
      return '';
    },
    username: (v) => {
      if (!v) return 'Username required';
      if (v.length < 4) return 'Username min 4 chars';
      return '';
    },
    password: (v) => {
      if (!v) return 'Password required';
      if (v.length < 8) return 'Password min 8 chars';
      return '';
    },
    confirmPassword: (v) => {
      if (!v) return 'Please confirm password';
      if (v !== formData.password) return 'Passwords do not match';
      return '';
    },
  };

  // Validate current step
  const validateStep = (step) => {
    const stepFields = STEPS[step].fields;
    const stepErrors = {};

    stepFields.forEach((field) => {
      if (validators[field]) {
        const error = validators[field](formData[field]);
        if (error) stepErrors[field] = error;
      }
    });

    return stepErrors;
  };

  const isStepValid = () => {
    return Object.keys(validateStep(currentStep)).length === 0;
  };

  // Handlers
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;

    setFormData((prev) => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value,
    }));

    // Clear error
    if (errors[name]) {
      setErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };

  const handleNext = () => {
    const stepErrors = validateStep(currentStep);

    if (Object.keys(stepErrors).length > 0) {
      setErrors(stepErrors);
      return;
    }

    if (currentStep < 3) {
      setCurrentStep((prev) => prev + 1);
    }
  };

  const handleBack = () => {
    if (currentStep > 1) {
      setCurrentStep((prev) => prev - 1);
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    // Validate all steps
    let allErrors = {};
    [1, 2, 3].forEach((step) => {
      allErrors = { ...allErrors, ...validateStep(step) };
    });

    if (Object.keys(allErrors).length > 0) {
      console.log('Form has errors:', allErrors);
      return;
    }

    console.log('Form submitted:', formData);
    alert('Registration successful!');

    // Reset
    setFormData({
      firstName: '',
      lastName: '',
      email: '',
      phone: '',
      username: '',
      password: '',
      confirmPassword: '',
      newsletter: false,
      notifications: false,
      theme: 'light',
    });
    setCurrentStep(1);
    setErrors({});
  };

  // Render step content
  const renderStep = () => {
    switch (currentStep) {
      case 1:
        return (
          <div>
            <h3>Personal Information</h3>
            <div style={{ marginBottom: '15px' }}>
              <label style={{ display: 'block', marginBottom: '5px' }}>
                First Name *
              </label>
              <input
                name='firstName'
                value={formData.firstName}
                onChange={handleChange}
                style={{ width: '100%', padding: '8px' }}
              />
              {errors.firstName && (
                <p style={{ color: 'red', fontSize: '0.9em' }}>
                  {errors.firstName}
                </p>
              )}
            </div>

            <div style={{ marginBottom: '15px' }}>
              <label style={{ display: 'block', marginBottom: '5px' }}>
                Last Name *
              </label>
              <input
                name='lastName'
                value={formData.lastName}
                onChange={handleChange}
                style={{ width: '100%', padding: '8px' }}
              />
              {errors.lastName && (
                <p style={{ color: 'red', fontSize: '0.9em' }}>
                  {errors.lastName}
                </p>
              )}
            </div>

            <div style={{ marginBottom: '15px' }}>
              <label style={{ display: 'block', marginBottom: '5px' }}>
                Email *
              </label>
              <input
                type='email'
                name='email'
                value={formData.email}
                onChange={handleChange}
                style={{ width: '100%', padding: '8px' }}
              />
              {errors.email && (
                <p style={{ color: 'red', fontSize: '0.9em' }}>
                  {errors.email}
                </p>
              )}
            </div>

            <div style={{ marginBottom: '15px' }}>
              <label style={{ display: 'block', marginBottom: '5px' }}>
                Phone *
              </label>
              <input
                type='tel'
                name='phone'
                value={formData.phone}
                onChange={handleChange}
                placeholder='1234567890'
                style={{ width: '100%', padding: '8px' }}
              />
              {errors.phone && (
                <p style={{ color: 'red', fontSize: '0.9em' }}>
                  {errors.phone}
                </p>
              )}
            </div>
          </div>
        );

      case 2:
        return (
          <div>
            <h3>Account Details</h3>
            <div style={{ marginBottom: '15px' }}>
              <label style={{ display: 'block', marginBottom: '5px' }}>
                Username *
              </label>
              <input
                name='username'
                value={formData.username}
                onChange={handleChange}
                style={{ width: '100%', padding: '8px' }}
              />
              {errors.username && (
                <p style={{ color: 'red', fontSize: '0.9em' }}>
                  {errors.username}
                </p>
              )}
            </div>

            <div style={{ marginBottom: '15px' }}>
              <label style={{ display: 'block', marginBottom: '5px' }}>
                Password *
              </label>
              <input
                type='password'
                name='password'
                value={formData.password}
                onChange={handleChange}
                style={{ width: '100%', padding: '8px' }}
              />
              {errors.password && (
                <p style={{ color: 'red', fontSize: '0.9em' }}>
                  {errors.password}
                </p>
              )}
            </div>

            <div style={{ marginBottom: '15px' }}>
              <label style={{ display: 'block', marginBottom: '5px' }}>
                Confirm Password *
              </label>
              <input
                type='password'
                name='confirmPassword'
                value={formData.confirmPassword}
                onChange={handleChange}
                style={{ width: '100%', padding: '8px' }}
              />
              {errors.confirmPassword && (
                <p style={{ color: 'red', fontSize: '0.9em' }}>
                  {errors.confirmPassword}
                </p>
              )}
            </div>
          </div>
        );

      case 3:
        return (
          <div>
            <h3>Preferences</h3>

            <div style={{ marginBottom: '15px' }}>
              <label
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  cursor: 'pointer',
                }}
              >
                <input
                  type='checkbox'
                  name='newsletter'
                  checked={formData.newsletter}
                  onChange={handleChange}
                  style={{ marginRight: '10px' }}
                />
                Subscribe to newsletter
              </label>
            </div>

            <div style={{ marginBottom: '15px' }}>
              <label
                style={{
                  display: 'flex',
                  alignItems: 'center',
                  cursor: 'pointer',
                }}
              >
                <input
                  type='checkbox'
                  name='notifications'
                  checked={formData.notifications}
                  onChange={handleChange}
                  style={{ marginRight: '10px' }}
                />
                Enable notifications
              </label>
            </div>

            <div style={{ marginBottom: '15px' }}>
              <label style={{ display: 'block', marginBottom: '5px' }}>
                Theme
              </label>
              <select
                name='theme'
                value={formData.theme}
                onChange={handleChange}
                style={{ width: '100%', padding: '8px' }}
              >
                <option value='light'>Light</option>
                <option value='dark'>Dark</option>
              </select>
            </div>

            {/* Review */}
            <div
              style={{
                background: '#f5f5f5',
                padding: '15px',
                borderRadius: '4px',
                marginTop: '20px',
              }}
            >
              <h4>Review Your Information</h4>
              <p>
                <strong>Name:</strong> {formData.firstName} {formData.lastName}
              </p>
              <p>
                <strong>Email:</strong> {formData.email}
              </p>
              <p>
                <strong>Phone:</strong> {formData.phone}
              </p>
              <p>
                <strong>Username:</strong> {formData.username}
              </p>
              <p>
                <strong>Newsletter:</strong>{' '}
                {formData.newsletter ? 'Yes' : 'No'}
              </p>
              <p>
                <strong>Notifications:</strong>{' '}
                {formData.notifications ? 'Yes' : 'No'}
              </p>
              <p>
                <strong>Theme:</strong> {formData.theme}
              </p>
            </div>
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      style={{ maxWidth: '600px', margin: '0 auto', padding: '20px' }}
    >
      <h2>Multi-Step Registration</h2>

      {/* Progress */}
      <div style={{ marginBottom: '30px' }}>
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
            marginBottom: '10px',
          }}
        >
          {[1, 2, 3].map((step) => (
            <div
              key={step}
              style={{
                flex: 1,
                textAlign: 'center',
                padding: '10px',
                background: currentStep >= step ? '#007bff' : '#e0e0e0',
                color: currentStep >= step ? 'white' : '#666',
                margin: '0 5px',
                borderRadius: '4px',
                fontWeight: currentStep === step ? 'bold' : 'normal',
              }}
            >
              Step {step}
            </div>
          ))}
        </div>
        <p style={{ textAlign: 'center', color: '#666' }}>
          {STEPS[currentStep].title}
        </p>
      </div>

      {/* Step Content */}
      <div style={{ minHeight: '300px' }}>{renderStep()}</div>

      {/* Navigation */}
      <div
        style={{
          display: 'flex',
          justifyContent: 'space-between',
          marginTop: '30px',
        }}
      >
        <button
          type='button'
          onClick={handleBack}
          disabled={currentStep === 1}
          style={{
            padding: '10px 20px',
            background: currentStep === 1 ? '#ccc' : '#6c757d',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: currentStep === 1 ? 'not-allowed' : 'pointer',
          }}
        >
          Back
        </button>

        {currentStep < 3 ? (
          <button
            type='button'
            onClick={handleNext}
            disabled={!isStepValid()}
            style={{
              padding: '10px 20px',
              background: isStepValid() ? '#007bff' : '#ccc',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: isStepValid() ? 'pointer' : 'not-allowed',
            }}
          >
            Next
          </button>
        ) : (
          <button
            type='submit'
            style={{
              padding: '10px 20px',
              background: '#28a745',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Submit
          </button>
        )}
      </div>
    </form>
  );
}
```

</details>

---

### â­â­â­â­â­ Exercise 5: Dynamic Survey Form (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Production-ready dynamic survey form
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * - Survey vá»›i questions Ä‘Æ°á»£c define trong config
 * - Question types: text, textarea, select, radio, checkbox, number
 * - Conditional questions (show Q2 only if Q1 === 'yes')
 * - Required vs optional questions
 * - Validation per question type
 * - Progress bar (X of Y questions answered)
 * - Save draft to localStorage
 * - Export results as JSON
 *
 * ğŸ—ï¸ Technical Design:
 * 1. Questions config (array of question objects)
 * 2. Answers state (object with question IDs as keys)
 * 3. Generic renderer for different question types
 * 4. Conditional logic evaluator
 * 5. Progress calculator (derived state)
 *
 * âœ… Production Checklist:
 * - [ ] Config-driven (easy to add questions)
 * - [ ] Generic question renderer
 * - [ ] Conditional logic works
 * - [ ] Validation per type
 * - [ ] Progress tracking
 * - [ ] localStorage persistence
 * - [ ] Export functionality
 * - [ ] Clear documentation
 */

// Sample survey config
const SURVEY_CONFIG = [
  {
    id: 'q1',
    type: 'radio',
    question: 'Have you used React before?',
    options: ['Yes', 'No'],
    required: true,
  },
  {
    id: 'q2',
    type: 'select',
    question: 'How long have you been using React?',
    options: ['< 6 months', '6-12 months', '1-2 years', '2+ years'],
    required: true,
    showIf: { questionId: 'q1', answer: 'Yes' }, // Conditional!
  },
  {
    id: 'q3',
    type: 'checkbox',
    question: 'Which features have you used? (select all)',
    options: ['Hooks', 'Context', 'Refs', 'Portals', 'Suspense'],
    required: false,
  },
  {
    id: 'q4',
    type: 'number',
    question: 'Rate React on scale 1-10',
    min: 1,
    max: 10,
    required: true,
  },
  {
    id: 'q5',
    type: 'textarea',
    question: 'What do you like most about React?',
    required: true,
    minLength: 20,
  },
];

// Implement the survey form!
// Hint: You'll need creative state management for checkboxes (array of selected values)
```

<details>
<summary>ğŸ’¡ Hint: State Structure</summary>

```jsx
// Suggested state structure
const [answers, setAnswers] = useState({
  q1: '', // radio: string
  q2: '', // select: string
  q3: [], // checkbox: array
  q4: '', // number: string (convert when needed)
  q5: '', // textarea: string
});

// For conditional rendering, you'll need a function like:
const shouldShowQuestion = (question) => {
  if (!question.showIf) return true;
  const { questionId, answer } = question.showIf;
  return answers[questionId] === answer;
};
```

</details>

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh Trade-offs

| Approach                                       | Pros âœ…                                                                                             | Cons âŒ                                                                                 | When to Use ğŸ¯                                                                          |
| ---------------------------------------------- | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| **Controlled Components**                      | â€¢ React controls value<br/>â€¢ Realtime validation<br/>â€¢ Dynamic UI easy<br/>â€¢ Single source of truth | â€¢ More boilerplate<br/>â€¢ onChange cho má»i input<br/>â€¢ Re-render on keystroke            | â€¢ 95% of cases<br/>â€¢ Forms cáº§n validation<br/>â€¢ Dynamic fields<br/>â€¢ **Default choice** |
| **Uncontrolled Components**<br/>(useRef)       | â€¢ Less code<br/>â€¢ Giá»‘ng HTML form<br/>â€¢ Ãt re-renders                                               | â€¢ KhÃ´ng biáº¿t value trÆ°á»›c submit<br/>â€¢ KhÃ´ng validate realtime<br/>â€¢ Hard to sync vá»›i UI | â€¢ File uploads<br/>â€¢ Integration vá»›i non-React libs<br/>â€¢ Rare edge cases               |
| **Multiple States**<br/>`[a, setA], [b, setB]` | â€¢ Simple cho 2-3 fields<br/>â€¢ Clear separation                                                      | â€¢ Many setters<br/>â€¢ Hard to group/reset<br/>â€¢ Lots of onChange handlers                | â€¢ Very simple forms (1-3 fields)<br/>â€¢ Unrelated fields                                 |
| **Single Object State**<br/>`{a, b, c}`        | â€¢ Scalable<br/>â€¢ 1 generic handler<br/>â€¢ Easy reset<br/>â€¢ API-ready                                 | â€¢ Need immutable updates<br/>â€¢ Computed property syntax                                 | â€¢ **Recommended for forms**<br/>â€¢ 4+ fields<br/>â€¢ API submission                        |
| **Validation: onChange**                       | â€¢ Instant feedback                                                                                  | â€¢ Annoying (error while typing)                                                         | â€¢ âŒ Not recommended alone                                                              |
| **Validation: onBlur**                         | â€¢ Less annoying<br/>â€¢ Show error when done                                                          | â€¢ Delayed feedback                                                                      | â€¢ âœ… Recommended primary                                                                |
| **Validation: onSubmit**                       | â€¢ Final check<br/>â€¢ Catch all errors                                                                | â€¢ Late feedback                                                                         | â€¢ âœ… Always include                                                                     |
| **Touched State**                              | â€¢ Only show errors for touched fields<br/>â€¢ Better UX                                               | â€¢ Extra state to manage                                                                 | â€¢ âœ… Production forms                                                                   |

---

### Decision Tree

```
Q1: How many form fields?
â”œâ”€ 1-2 fields â†’ Separate states OK
â””â”€ 3+ fields â†’ Use object state

Q2: Need realtime validation?
â”œâ”€ YES â†’ Controlled components (always)
â””â”€ NO â†’ Still use controlled (uncontrolled only for file inputs)

Q3: When to show validation errors?
â”œâ”€ onBlur â†’ Primary (show after user leaves field)
â”œâ”€ onSubmit â†’ Always (final check)
â””â”€ onChange â†’ Sparingly (clear errors, not show new ones)

Q4: How to structure object state?
â”œâ”€ Flat object (most cases)
â””â”€ Nested object (if logical groups, e.g., billing vs shipping address)

Q5: Need to track touched fields?
â”œâ”€ Simple form â†’ Optional
â””â”€ Production form â†’ Yes (better UX)

Q6: Validation timing strategy?
â””â”€ Best pattern:
   â€¢ onBlur: Validate + mark touched
   â€¢ onChange: Clear errors (don't show new)
   â€¢ onSubmit: Validate all + mark all touched
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: Input KhÃ´ng Update â­

```jsx
// ğŸ› BUG: User gÃµ nhÆ°ng input khÃ´ng update
function BuggyForm() {
  const [email, setEmail] = useState('');

  return (
    <form>
      <input
        type='email'
        value={email}
        // BUG: Missing onChange!
      />
    </form>
  );
}

/**
 * ğŸ” DEBUG QUESTIONS:
 * 1. Äiá»u gÃ¬ xáº£y ra khi user gÃµ?
 * 2. Táº¡i sao input khÃ´ng update?
 * 3. Fix nhÆ° tháº¿ nÃ o?
 */
```

<details>
<summary>ğŸ’¡ Solution</summary>

**Váº¥n Ä‘á»:**

- Input cÃ³ `value={email}` â†’ controlled
- NhÆ°ng KHÃ”NG cÃ³ `onChange` â†’ React khÃ´ng update state
- Input bá»‹ "frozen" á»Ÿ giÃ¡ trá»‹ initial

**Táº¡i sao:**

```
User types â†’ onChange event fires â†’ React ignores (no handler)
                                   â†“
                            State khÃ´ng update
                                   â†“
                            value váº«n = ''
                                   â†“
                            Input khÃ´ng Ä‘á»•i
```

**Fix:**

```jsx
<input
  type='email'
  value={email}
  onChange={(e) => setEmail(e.target.value)} // âœ… Add handler
/>
```

**Lesson:** Controlled input = PHáº¢I cÃ³ value + onChange

</details>

---

### Bug 2: Generic Handler KhÃ´ng Work â­â­

```jsx
// ğŸ› BUG: All inputs update cÃ¹ng lÃºc
function BuggyMultiForm() {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
  });

  const handleChange = (e) => {
    setFormData({
      [e.target.name]: e.target.value, // BUG: KhÃ´ng spread prev
    });
  };

  return (
    <form>
      <input
        name='firstName'
        value={formData.firstName}
        onChange={handleChange}
      />
      <input
        name='lastName'
        value={formData.lastName}
        onChange={handleChange}
      />
    </form>
  );
}

/**
 * ğŸ” DEBUG QUESTIONS:
 * 1. GÃµ "John" vÃ o firstName. formData sáº½ lÃ  gÃ¬?
 * 2. Sau Ä‘Ã³ gÃµ "Doe" vÃ o lastName. formData sáº½ lÃ  gÃ¬?
 * 3. firstName cÃ³ cÃ²n "John" khÃ´ng? Táº¡i sao?
 */
```

<details>
<summary>ğŸ’¡ Solution</summary>

**Váº¥n Ä‘á»:**

```jsx
// âŒ BAD: Overwrite entire object
setFormData({
  [e.target.name]: e.target.value,
});

// After typing "John" in firstName:
formData = { firstName: 'John' }; // âŒ lastName bá»‹ máº¥t!

// After typing "Doe" in lastName:
formData = { lastName: 'Doe' }; // âŒ firstName bá»‹ máº¥t!
```

**Fix:**

```jsx
// âœ… GOOD: Spread prev, then override
const handleChange = (e) => {
  setFormData((prev) => ({
    ...prev, // Keep old values
    [e.target.name]: e.target.value,
  }));
};
```

**Lesson:** Immutable updates! Spread `...prev` trÆ°á»›c khi override.

</details>

---

### Bug 3: Passwords Don't Match Validation â­â­â­

```jsx
// ğŸ› BUG: "Passwords don't match" khÃ´ng update khi password changes
function BuggyPasswordForm() {
  const [formData, setFormData] = useState({
    password: '',
    confirmPassword: '',
  });

  const [errors, setErrors] = useState({});

  const handleChange = (e) => {
    const { name, value } = e.target;

    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleBlur = (e) => {
    const { name, value } = e.target;

    if (name === 'confirmPassword') {
      if (value !== formData.password) {
        setErrors((prev) => ({
          ...prev,
          confirmPassword: 'Passwords do not match',
        }));
      }
    }
  };

  return (
    <form>
      <input
        type='password'
        name='password'
        value={formData.password}
        onChange={handleChange}
      />

      <input
        type='password'
        name='confirmPassword'
        value={formData.confirmPassword}
        onChange={handleChange}
        onBlur={handleBlur}
      />

      {errors.confirmPassword && (
        <p style={{ color: 'red' }}>{errors.confirmPassword}</p>
      )}
    </form>
  );
}

/**
 * ğŸ” DEBUG SCENARIO:
 * 1. User gÃµ "password123" vÃ o password field
 * 2. User gÃµ "password123" vÃ o confirmPassword â†’ onBlur â†’ No error âœ…
 * 3. User quay láº¡i password field, Ä‘á»•i thÃ nh "newpass456"
 * 4. ğŸ› ERROR váº«n khÃ´ng hiá»‡n! Táº¡i sao?
 * 5. LÃ m tháº¿ nÃ o Ä‘á»ƒ fix?
 */
```

<details>
<summary>ğŸ’¡ Solution</summary>

**Váº¥n Ä‘á»:**

- Khi user Ä‘á»•i `password`, error KHÃ”NG Ä‘Æ°á»£c re-validate
- `confirmPassword` onBlur chá»‰ cháº¡y khi user blur confirmPassword field
- Náº¿u user Ä‘á»•i password sau, confirmPassword khÃ´ng Ä‘Æ°á»£c check láº¡i

**Fix 1: Re-validate confirmPassword khi password changes**

```jsx
const handleChange = (e) => {
  const { name, value } = e.target;

  setFormData((prev) => ({
    ...prev,
    [name]: value,
  }));

  // âœ… If changing password, re-check confirmPassword
  if (name === 'password' && formData.confirmPassword) {
    if (value !== formData.confirmPassword) {
      setErrors((prev) => ({
        ...prev,
        confirmPassword: 'Passwords do not match',
      }));
    } else {
      // Clear error if now they match
      setErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors.confirmPassword;
        return newErrors;
      });
    }
  }
};
```

**Fix 2: Clear error onChange (better UX)**

```jsx
const handleChange = (e) => {
  const { name, value } = e.target;

  setFormData((prev) => ({
    ...prev,
    [name]: value,
  }));

  // âœ… Clear error when user types (good UX)
  if (errors[name]) {
    setErrors((prev) => {
      const newErrors = { ...prev };
      delete newErrors[name];
      return newErrors;
    });
  }

  // âœ… Cross-field validation
  if (name === 'password' && formData.confirmPassword) {
    validateConfirmPassword(value, formData.confirmPassword);
  }
};
```

**Lesson:** Cross-field validation cáº§n update khi ANY related field changes!

</details>

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

- [ ] TÃ´i hiá»ƒu controlled vs uncontrolled components
- [ ] TÃ´i biáº¿t khi nÃ o dÃ¹ng object state vs multiple states
- [ ] TÃ´i cÃ³ thá»ƒ implement generic onChange handler vá»›i `e.target.name`
- [ ] TÃ´i hiá»ƒu validation timing (onChange vs onBlur vs onSubmit)
- [ ] TÃ´i biáº¿t cÃ¡ch implement "touched" state pattern
- [ ] TÃ´i cÃ³ thá»ƒ validate cross-field dependencies (password match)
- [ ] TÃ´i hiá»ƒu táº¡i sao cáº§n `e.preventDefault()` trong onSubmit
- [ ] TÃ´i cÃ³ thá»ƒ structure validators thÃ nh reusable functions
- [ ] TÃ´i biáº¿t cÃ¡ch clear form sau submit
- [ ] TÃ´i hiá»ƒu trade-offs cá»§a má»—i validation approach

### Code Review Checklist

Khi review form code:

**State Structure:**

- [ ] Related fields grouped in object (khÃ´ng quÃ¡ nhiá»u separate states)
- [ ] Immutable updates (spread `...prev`)
- [ ] No derived state (compute isValid, khÃ´ng store)

**Controlled Components:**

- [ ] Má»i input cÃ³ `value` prop
- [ ] Má»i input cÃ³ `onChange` handler
- [ ] Input `name` attribute matches state key

**Validation:**

- [ ] Errors shown only for touched fields (good UX)
- [ ] onBlur validates field
- [ ] onChange clears errors (khÃ´ng show while typing)
- [ ] onSubmit validates all
- [ ] Cross-field validation handled

**Submit Handler:**

- [ ] `e.preventDefault()` present
- [ ] Final validation check
- [ ] Handle success (clear form, show message)
- [ ] Handle errors

**UX:**

- [ ] Submit button disabled when invalid
- [ ] Error messages clear and helpful
- [ ] Character counters where relevant
- [ ] Loading states (sáº½ há»c useEffect)

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**Exercise: Fix Broken Forms**

Cho 3 broken forms. TÃ¬m vÃ  fix bugs:

1. **Form 1**: Input khÃ´ng update khi gÃµ
2. **Form 2**: Submit khÃ´ng work (page reload)
3. **Form 3**: Email validation sai (accept invalid emails)

### NÃ¢ng cao (60 phÃºt)

**Exercise: Job Application Form**

Táº¡o form apply job vá»›i:

- Personal: name, email, phone
- Experience: yearsOfExperience (number), currentRole, resume (text describing experience)
- Motivation: why (textarea min 100 chars)
- Validation realtime + onSubmit
- Touched state pattern
- Character counters
- Progress indicator (X/Y fields completed)

Requirements:

- âœ… Object state
- âœ… Generic handlers
- âœ… Proper validation timing
- âœ… Production-ready error handling

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - Forms**
   - https://react.dev/reference/react-dom/components/input
   - Äá»c sections vá» controlled components

2. **React Docs - Managing State**
   - https://react.dev/learn/managing-state
   - Especially "Sharing State Between Components"

### Äá»c thÃªm

3. **Form Validation Best Practices**
   - https://www.smashingmagazine.com/2022/09/inline-validation-web-forms-ux/
   - UX perspective on validation timing

4. **HTML Form Validation**
   - https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation
   - Native HTML validation (Ä‘á»ƒ biáº¿t nÃªn override gÃ¬)

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (Ä‘Ã£ há»c)

- **NgÃ y 12**: useState patterns - Immutability, functional updates, object state
- **NgÃ y 11**: useState basics
- **NgÃ y 5**: Event handling - `e.target`, `e.preventDefault()`

### HÆ°á»›ng tá»›i (sáº½ há»c)

- **NgÃ y 14**: Lifting State Up - Share form state giá»¯a components
- **NgÃ y 17-21**: useEffect - Persist forms to localStorage, debounce validation
- **NgÃ y 36-38**: Forms Deep Dive - Formik, React Hook Form, advanced patterns

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**Performance:**

```jsx
// âš ï¸ Re-render on every keystroke
function ExpensiveForm() {
  const [formData, setFormData] = useState({...});

  // âŒ Expensive computation runs every render
  const validationResult = expensiveValidation(formData);

  // âœ… Will learn useMemo in NgÃ y 23 to optimize
  // For now: Keep validators fast & simple
}
```

**Accessibility:**

```jsx
// âœ… Production-ready accessible form
<form>
  <label htmlFor='email'>Email</label>
  <input
    id='email'
    name='email'
    type='email'
    value={formData.email}
    onChange={handleChange}
    aria-invalid={!!errors.email}
    aria-describedby={errors.email ? 'email-error' : undefined}
  />
  {errors.email && (
    <p
      id='email-error'
      role='alert'
    >
      {errors.email}
    </p>
  )}
</form>
```

**Security:**

```jsx
// âš ï¸ Never trust client-side validation alone!
const handleSubmit = async (e) => {
  e.preventDefault();

  // âœ… Client validation (UX)
  if (!isValid) return;

  try {
    // âœ… Server MUST validate again (security)
    const response = await fetch('/api/submit', {
      method: 'POST',
      body: JSON.stringify(formData),
    });

    // Handle server validation errors
    if (!response.ok) {
      const serverErrors = await response.json();
      setErrors(serverErrors);
    }
  } catch (err) {
    // Handle network errors
  }
};
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior:**
Q: "Controlled component lÃ  gÃ¬?"
A: Component mÃ  React controls input value through state. Input cÃ³ `value={state}` vÃ  `onChange={setState}`. React lÃ  single source of truth.

**Mid:**
Q: "LÃ m tháº¿ nÃ o handle form vá»›i nhiá»u inputs efficiently?"
A: DÃ¹ng object state + generic handler vá»›i `e.target.name`. Má»—i input cÃ³ `name` attribute match state key. Handler dÃ¹ng computed property `[name]: value` vá»›i spread operator.

**Senior:**
Q: "Design validation strategy cho complex form."
A: Multi-layer approach:

1. onBlur: Validate field, mark touched (show errors)
2. onChange: Clear errors (good UX while typing)
3. onSubmit: Validate all, mark all touched
4. Cross-field: Re-validate dependents when dependencies change
5. Server: Always validate server-side (security)
6. Consider debouncing for async validation (emails, usernames)

### War Stories

**Story 1: The Missing e.preventDefault() Bug**

> Junior dev táº¡o form, má»i thá»© work local nhÆ°ng production bá»‹ bug láº¡: form submit xong page bá»‹ blank. Root cause: QuÃªn `e.preventDefault()` â†’ browser submit form â†’ page reload â†’ blank page. Lesson: LUÃ”N preventDefault trong onSubmit React forms!

**Story 2: The Stale Password Validation**

> User complain: "Form bÃ¡o passwords khÃ¡c nhau dÃ¹ tÃ´i gÃµ giá»‘ng há»‡t!" Debug mÃ£i má»›i phÃ¡t hiá»‡n: password field dÃ¹ng autocomplete, khi user change password field, confirmPassword validation khÃ´ng re-run. Fix: re-validate confirmPassword khi password changes. Lesson: Cross-field validation cáº§n handle ALL related field changes!

**Story 3: The Performance Killer Form**

> Form vá»›i 50 fields, má»—i keystroke lag 100ms. Profiling phÃ¡t hiá»‡n: regex validation cháº¡y cho Táº¤T Cáº¢ 50 fields má»—i onChange. Fix: Chá»‰ validate field Ä‘ang change, defer full validation Ä‘áº¿n onBlur. Lesson: Validation timing affects performance dramatically!

---

## ğŸ¯ PREVIEW NGÃ€Y MAI

**NgÃ y 14: Lifting State Up**

HÃ´m nay Ä‘Ã£ master forms vá»›i local state. NgÃ y mai sáº½ há»c:

- Share state giá»¯a sibling components
- Lift state lÃªn parent
- Inverse data flow (child â†’ parent communication)
- When to lift vs when to keep local
- Props drilling vÃ  cÃ¡ch giáº£m thiá»ƒu

Preview challenge: Táº¡o shopping cart nÆ¡i ProductList vÃ  CartSummary cáº§n share state!

HÃ´m nay: Forms mastery âœ…  
NgÃ y mai: State communication ğŸ¯

---

**ğŸŠ CHÃšC Má»ªNG! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 13!**

HÃ´m nay báº¡n Ä‘Ã£ master:

1. âœ… Controlled vs Uncontrolled components
2. âœ… Multiple inputs vá»›i object state
3. âœ… Validation strategies (onBlur, onChange, onSubmit)
4. âœ… Touched state pattern
5. âœ… Cross-field validation
6. âœ… Production-ready form patterns

Forms lÃ  ná»n táº£ng cá»§a háº§u háº¿t web apps. Master forms = master React!

**Pro Tip:** Má»i form pattern há»c hÃ´m nay sáº½ scale Ä‘áº¿n báº¥t ká»³ form nÃ o - tá»« login Ä‘Æ¡n giáº£n Ä‘áº¿n checkout phá»©c táº¡p vá»›i 100+ fields!

ğŸ’ª Keep practicing! Tomorrow: State communication!
