# ğŸ“… NGÃ€Y 14: Lifting State Up

## ğŸ¯ Má»¥c tiÃªu há»c táº­p (5 phÃºt)

Sau bÃ i há»c nÃ y, báº¡n sáº½:

- [ ] **Hiá»ƒu khi nÃ o cáº§n lift state up** vs khi nÃ o giá»¯ state local
- [ ] **Share state giá»¯a sibling components** thÃ´ng qua parent
- [ ] **Implement inverse data flow** (child â†’ parent communication via callbacks)
- [ ] **Nháº­n biáº¿t vÃ  giáº£i quyáº¿t props drilling** má»™t cÃ¡ch há»£p lÃ½
- [ ] **Thiáº¿t káº¿ component hierarchy** vá»›i state placement tá»‘i Æ°u

---

## ğŸ¤” Kiá»ƒm tra Ä‘áº§u vÃ o (5 phÃºt)

Tráº£ lá»i 3 cÃ¢u há»i sau Ä‘á»ƒ kÃ­ch hoáº¡t kiáº¿n thá»©c tá»« NgÃ y 11-13:

1. **CÃ¢u 1**: State Ä‘Æ°á»£c define trong component A. Component B (con cá»§a A) cÃ³ thá»ƒ access state Ä‘Ã³ khÃ´ng? LÃ m tháº¿ nÃ o?

2. **CÃ¢u 2**: Hai sibling components cáº§n share data. NÃªn Ä‘áº·t state á»Ÿ Ä‘Ã¢u?

3. **CÃ¢u 3**: Code nÃ y cÃ³ váº¥n Ä‘á» gÃ¬?

```jsx
function Parent() {
  return <Child />;
}

function Child() {
  const [count, setCount] = useState(0);
  // Parent muá»‘n biáº¿t count value - lÃ m tháº¿ nÃ o?
}
```

<details>
<summary>ğŸ’¡ Xem Ä‘Ã¡p Ã¡n</summary>

1. Component B cÃ³ thá»ƒ access qua **props**. Parent (A) pass state xuá»‘ng: `<B value={state} />`
2. State nÃªn Ä‘áº·t á»Ÿ **parent chung gáº§n nháº¥t** (closest common ancestor)
3. **Data flow má»™t chiá»u:** Child khÃ´ng thá»ƒ tá»± send data lÃªn Parent. Cáº§n callback prop: `<Child onCountChange={handleChange} />`

</details>

---

## ğŸ“– PHáº¦N 1: GIá»šI THIá»†U KHÃI NIá»†M (30 phÃºt)

### 1.1 Váº¥n Äá» Thá»±c Táº¿

HÃ£y xem tÃ¬nh huá»‘ng nÃ y:

```jsx
// âŒ PROBLEM: Hai components cáº§n cÃ¹ng data nhÆ°ng state isolated
function ProductList() {
  const [selectedProduct, setSelectedProduct] = useState(null);

  return (
    <div>
      <h2>Products</h2>
      {/* List of products, click to select */}
    </div>
  );
}

function ProductDetails() {
  // âŒ LÃ m sao biáº¿t product nÃ o Ä‘ang selected???
  // selectedProduct á»Ÿ ProductList, khÃ´ng access Ä‘Æ°á»£c!

  return (
    <div>
      <h2>Details</h2>
      {/* Show selected product details */}
    </div>
  );
}

function App() {
  return (
    <div>
      <ProductList />
      <ProductDetails />
    </div>
  );
}
```

**Problems:**

- ProductList vÃ  ProductDetails lÃ  **siblings** (cÃ¹ng level)
- KhÃ´ng component nÃ o pass props cho nhau Ä‘Æ°á»£c
- State trong ProductList khÃ´ng thá»ƒ access tá»« ProductDetails
- **Cáº§n share state giá»¯a siblings!**

---

### 1.2 Giáº£i PhÃ¡p: Lifting State Up

**Core Principle:**

> "Khi 2+ components cáº§n share state, lift state lÃªn parent chung gáº§n nháº¥t cá»§a chÃºng"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          LIFTING STATE UP               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  BEFORE:                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Component A  â”‚  â”‚ Component B  â”‚   â”‚
â”‚  â”‚ [state] âŒ   â”‚  â”‚ needs state  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         â†‘                â†‘              â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚              Parent                     â”‚
â”‚                                         â”‚
â”‚  AFTER:                                 â”‚
â”‚              Parent                     â”‚
â”‚             [state] âœ…                  â”‚
â”‚         â†“            â†“                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Component A  â”‚  â”‚ Component B  â”‚   â”‚
â”‚  â”‚ gets props   â”‚  â”‚ gets props   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                         â”‚
â”‚  State "lifted up" to parent            â”‚
â”‚  Both children receive via props        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 1.3 Mental Model

**Analogy: Shared Whiteboard**

```
âŒ BAD: Má»—i ngÆ°á»i cÃ³ whiteboard riÃªng
Person A (whiteboard A) â†’ Person B khÃ´ng tháº¥y
Person B (whiteboard B) â†’ Person A khÃ´ng tháº¥y
[KhÃ´ng sync Ä‘Æ°á»£c!]

âœ… GOOD: DÃ¹ng chung 1 whiteboard á»Ÿ giá»¯a
       Shared Whiteboard
           â†™        â†˜
      Person A    Person B
[Cáº£ 2 Ä‘á»u tháº¥y vÃ  update cÃ¹ng data!]
```

**React Flow:**

```
Parent Component (state owner)
    â†“                    â†“
Child A            Child B
(reads via props)  (reads via props)
    â†“                    â†“
onChange callback â†’ update parent state
    â†“                    â†“
Parent state changes
    â†“                    â†“
Both children re-render with new props
```

---

### 1.4 Hiá»ƒu Láº§m Phá»• Biáº¿n

âŒ **Myth 1**: "Lifting state = always lift to App component"  
âœ… **Truth**: Chá»‰ lift Ä‘áº¿n **closest common ancestor**, khÃ´ng cao hÆ¡n cáº§n thiáº¿t

âŒ **Myth 2**: "State cÃ ng cao cÃ ng tá»‘t"  
âœ… **Truth**: State cÃ ng gáº§n nÆ¡i dÃ¹ng cÃ ng tá»‘t. Chá»‰ lift khi Cáº¦N share

âŒ **Myth 3**: "Child khÃ´ng thá»ƒ update parent state"  
âœ… **Truth**: Child CÃ“ THá»‚ update qua callback props

âŒ **Myth 4**: "Lifting state lÃ m app cháº­m"  
âœ… **Truth**: Náº¿u lift Ä‘Ãºng chá»— thÃ¬ OK. Lift quÃ¡ cao má»›i cháº­m (re-render unnecessary components)

---

## ğŸ’» PHáº¦N 2: LIVE CODING (45 phÃºt)

### Demo 1: Basic Lifting - Temperature Converter â­

#### âŒ CÃCH SAI: State Isolated

```jsx
// âŒ PROBLEM: Celsius vÃ  Fahrenheit khÃ´ng sync
function CelsiusInput() {
  const [temperature, setTemperature] = useState('');

  return (
    <div>
      <label>Celsius:</label>
      <input
        value={temperature}
        onChange={(e) => setTemperature(e.target.value)}
      />
    </div>
  );
}

function FahrenheitInput() {
  const [temperature, setTemperature] = useState('');

  return (
    <div>
      <label>Fahrenheit:</label>
      <input
        value={temperature}
        onChange={(e) => setTemperature(e.target.value)}
      />
    </div>
  );
}

function TemperatureConverter() {
  return (
    <div>
      <CelsiusInput />
      <FahrenheitInput />
      {/* âŒ GÃµ vÃ o Celsius, Fahrenheit khÃ´ng update */}
      {/* âŒ 2 states riÃªng biá»‡t, khÃ´ng sync! */}
    </div>
  );
}
```

**Problems:**

- Má»—i input cÃ³ state riÃªng
- KhÃ´ng cÃ¡ch nÃ o sync giá»¯a chÃºng
- User gÃµ vÃ o 1 field, field kia khÃ´ng update

---

#### âœ… CÃCH ÄÃšNG: Lift State Up

```jsx
// Helper functions
function toCelsius(fahrenheit) {
  return ((fahrenheit - 32) * 5) / 9;
}

function toFahrenheit(celsius) {
  return (celsius * 9) / 5 + 32;
}

// âœ… Child components nháº­n props thay vÃ¬ cÃ³ state riÃªng
function TemperatureInput({ scale, temperature, onTemperatureChange }) {
  return (
    <div style={{ marginBottom: '10px' }}>
      <label style={{ display: 'inline-block', width: '100px' }}>
        {scale === 'c' ? 'Celsius:' : 'Fahrenheit:'}
      </label>
      <input
        value={temperature}
        onChange={(e) => onTemperatureChange(e.target.value)}
        style={{ padding: '5px', width: '200px' }}
      />
    </div>
  );
}

// âœ… Parent owns the state
function TemperatureConverter() {
  const [temperature, setTemperature] = useState('');
  const [scale, setScale] = useState('c'); // 'c' or 'f'

  const handleCelsiusChange = (temp) => {
    setTemperature(temp);
    setScale('c');
  };

  const handleFahrenheitChange = (temp) => {
    setTemperature(temp);
    setScale('f');
  };

  // âœ… Calculate derived values
  const celsius =
    scale === 'f'
      ? toCelsius(parseFloat(temperature))
      : parseFloat(temperature);
  const fahrenheit =
    scale === 'c'
      ? toFahrenheit(parseFloat(temperature))
      : parseFloat(temperature);

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h2>ğŸŒ¡ï¸ Temperature Converter</h2>

      <TemperatureInput
        scale='c'
        temperature={scale === 'c' ? temperature : celsius.toFixed(1)}
        onTemperatureChange={handleCelsiusChange}
      />

      <TemperatureInput
        scale='f'
        temperature={scale === 'f' ? temperature : fahrenheit.toFixed(1)}
        onTemperatureChange={handleFahrenheitChange}
      />

      <div
        style={{
          marginTop: '20px',
          padding: '15px',
          background: '#f0f0f0',
          borderRadius: '4px',
        }}
      >
        {temperature && !isNaN(celsius) ? (
          <p>
            <strong>Result:</strong> {celsius.toFixed(2)}Â°C ={' '}
            {fahrenheit.toFixed(2)}Â°F
          </p>
        ) : (
          <p>Enter a temperature</p>
        )}
      </div>
    </div>
  );
}
```

**ğŸ”¥ KEY PATTERNS:**

1. **State Lifted to Parent:**

```jsx
// Parent owns state
const [temperature, setTemperature] = useState('');
const [scale, setScale] = useState('c');
```

2. **Children Are "Controlled":**

```jsx
// Child receives value via props (controlled component pattern)
<TemperatureInput
  temperature={temperature} // âœ… Props down
  onTemperatureChange={handleChange} // âœ… Callbacks up
/>
```

3. **Inverse Data Flow:**

```jsx
// Child calls callback when user types
<input onChange={(e) => onTemperatureChange(e.target.value)} />;

// Parent updates state
const handleCelsiusChange = (temp) => {
  setTemperature(temp); // âœ… Parent controls state
};
```

4. **Single Source of Truth:**

```jsx
// âœ… Only 1 state for temperature
// Both inputs derive their values from this state
const celsius = scale === 'f' ? toCelsius(temperature) : temperature;
const fahrenheit = scale === 'c' ? toFahrenheit(temperature) : temperature;
```

---

### Demo 2: Shopping Cart - Ká»‹ch Báº£n Thá»±c Táº¿ â­â­

```jsx
// âœ… Product Card (presentational - no state)
function ProductCard({ product, onAddToCart }) {
  return (
    <div
      style={{
        border: '1px solid #ddd',
        padding: '15px',
        borderRadius: '8px',
        marginBottom: '10px',
      }}
    >
      <h3>{product.name}</h3>
      <p style={{ color: '#666' }}>${product.price}</p>
      <button
        onClick={() => onAddToCart(product)}
        style={{
          padding: '8px 16px',
          background: '#007bff',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
        }}
      >
        Add to Cart
      </button>
    </div>
  );
}

// âœ… Product List (receives data + callbacks)
function ProductList({ products, onAddToCart }) {
  return (
    <div style={{ flex: 1, marginRight: '20px' }}>
      <h2>ğŸ“¦ Products</h2>
      {products.map((product) => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={onAddToCart}
        />
      ))}
    </div>
  );
}

// âœ… Cart Summary (receives cart data + callbacks)
function CartSummary({ cartItems, onRemoveFromCart, onClearCart }) {
  const total = cartItems.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0,
  );

  return (
    <div
      style={{
        flex: 1,
        background: '#f8f9fa',
        padding: '20px',
        borderRadius: '8px',
        height: 'fit-content',
      }}
    >
      <h2>ğŸ›’ Cart ({cartItems.length})</h2>

      {cartItems.length === 0 ? (
        <p style={{ color: '#666' }}>Cart is empty</p>
      ) : (
        <>
          {cartItems.map((item) => (
            <div
              key={item.id}
              style={{
                marginBottom: '10px',
                paddingBottom: '10px',
                borderBottom: '1px solid #ddd',
              }}
            >
              <div
                style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  alignItems: 'center',
                }}
              >
                <div>
                  <strong>{item.name}</strong>
                  <p style={{ margin: '5px 0', color: '#666' }}>
                    ${item.price} Ã— {item.quantity} = $
                    {item.price * item.quantity}
                  </p>
                </div>
                <button
                  onClick={() => onRemoveFromCart(item.id)}
                  style={{
                    padding: '5px 10px',
                    background: '#dc3545',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer',
                  }}
                >
                  Remove
                </button>
              </div>
            </div>
          ))}

          <div
            style={{
              marginTop: '20px',
              paddingTop: '20px',
              borderTop: '2px solid #333',
            }}
          >
            <h3>Total: ${total.toFixed(2)}</h3>
            <button
              onClick={onClearCart}
              style={{
                width: '100%',
                padding: '10px',
                background: '#6c757d',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                marginTop: '10px',
              }}
            >
              Clear Cart
            </button>
          </div>
        </>
      )}
    </div>
  );
}

// âœ… Parent Component - Owns State
function ShoppingApp() {
  // âœ… State lifted to parent (shared by ProductList and CartSummary)
  const [cart, setCart] = useState([]);

  // Sample products
  const products = [
    { id: 1, name: 'Laptop', price: 999 },
    { id: 2, name: 'Mouse', price: 29 },
    { id: 3, name: 'Keyboard', price: 79 },
    { id: 4, name: 'Monitor', price: 299 },
  ];

  // âœ… Handler: Add to cart
  const handleAddToCart = (product) => {
    setCart((prev) => {
      // Check if product already in cart
      const existingItem = prev.find((item) => item.id === product.id);

      if (existingItem) {
        // Increase quantity
        return prev.map((item) =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item,
        );
      } else {
        // Add new item
        return [...prev, { ...product, quantity: 1 }];
      }
    });
  };

  // âœ… Handler: Remove from cart
  const handleRemoveFromCart = (productId) => {
    setCart((prev) => prev.filter((item) => item.id !== productId));
  };

  // âœ… Handler: Clear cart
  const handleClearCart = () => {
    setCart([]);
  };

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h1>ğŸ›ï¸ Shopping Cart App</h1>

      <div style={{ display: 'flex', gap: '20px', marginTop: '20px' }}>
        {/* âœ… Pass state + callbacks down */}
        <ProductList
          products={products}
          onAddToCart={handleAddToCart}
        />

        <CartSummary
          cartItems={cart}
          onRemoveFromCart={handleRemoveFromCart}
          onClearCart={handleClearCart}
        />
      </div>
    </div>
  );
}
```

**ğŸ”¥ KEY LEARNINGS:**

1. **State Placement:**

```jsx
// âœ… State in parent (ShoppingApp)
const [cart, setCart] = useState([]);

// âŒ WRONG: State in ProductList
// CartSummary wouldn't be able to access it!
```

2. **Data Flow:**

```
ShoppingApp (state owner)
    â†“                        â†“
ProductList              CartSummary
(receives callbacks)     (receives cart data)
    â†“
ProductCard
(calls callback)
    â†“
User clicks "Add to Cart"
    â†“
Callback â†’ Parent updates state
    â†“
Cart state changes
    â†“
CartSummary re-renders with new cart
```

3. **Props Down, Callbacks Up:**

```jsx
// âœ… Data flows down via props
<CartSummary cartItems={cart} />

// âœ… Events flow up via callbacks
<ProductList onAddToCart={handleAddToCart} />
```

---

### Demo 3: Filter + List Pattern - Edge Cases â­â­â­

```jsx
// âœ… Search Bar Component
function SearchBar({ searchTerm, onSearchChange }) {
  return (
    <div style={{ marginBottom: '20px' }}>
      <input
        type='text'
        placeholder='Search users...'
        value={searchTerm}
        onChange={(e) => onSearchChange(e.target.value)}
        style={{
          width: '100%',
          padding: '10px',
          fontSize: '16px',
          border: '2px solid #ddd',
          borderRadius: '4px',
        }}
      />
    </div>
  );
}

// âœ… Filter Buttons
function FilterButtons({ activeFilter, onFilterChange }) {
  const filters = ['all', 'active', 'inactive'];

  return (
    <div style={{ marginBottom: '20px', display: 'flex', gap: '10px' }}>
      {filters.map((filter) => (
        <button
          key={filter}
          onClick={() => onFilterChange(filter)}
          style={{
            padding: '8px 16px',
            background: activeFilter === filter ? '#007bff' : '#e0e0e0',
            color: activeFilter === filter ? 'white' : '#333',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            textTransform: 'capitalize',
          }}
        >
          {filter}
        </button>
      ))}
    </div>
  );
}

// âœ… User List Component
function UserList({ users }) {
  if (users.length === 0) {
    return (
      <p style={{ textAlign: 'center', color: '#666', padding: '40px' }}>
        No users found
      </p>
    );
  }

  return (
    <div>
      {users.map((user) => (
        <div
          key={user.id}
          style={{
            padding: '15px',
            marginBottom: '10px',
            border: '1px solid #ddd',
            borderRadius: '4px',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
          }}
        >
          <div>
            <h3 style={{ margin: '0 0 5px 0' }}>{user.name}</h3>
            <p style={{ margin: 0, color: '#666' }}>{user.email}</p>
          </div>
          <span
            style={{
              padding: '4px 12px',
              background: user.isActive ? '#28a745' : '#6c757d',
              color: 'white',
              borderRadius: '12px',
              fontSize: '0.85em',
            }}
          >
            {user.isActive ? 'Active' : 'Inactive'}
          </span>
        </div>
      ))}
    </div>
  );
}

// âœ… Parent Component - Orchestrates Everything
function UserManagement() {
  // âœ… All filter state lifted here
  const [searchTerm, setSearchTerm] = useState('');
  const [activeFilter, setActiveFilter] = useState('all');

  // Sample data
  const allUsers = [
    {
      id: 1,
      name: 'Alice Johnson',
      email: 'alice@example.com',
      isActive: true,
    },
    { id: 2, name: 'Bob Smith', email: 'bob@example.com', isActive: false },
    {
      id: 3,
      name: 'Charlie Brown',
      email: 'charlie@example.com',
      isActive: true,
    },
    { id: 4, name: 'David Lee', email: 'david@example.com', isActive: false },
    { id: 5, name: 'Eve Davis', email: 'eve@example.com', isActive: true },
  ];

  // âœ… Derived state: filtered users
  const filteredUsers = allUsers.filter((user) => {
    // Filter by search term
    const matchesSearch =
      user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      user.email.toLowerCase().includes(searchTerm.toLowerCase());

    // Filter by active status
    const matchesFilter =
      activeFilter === 'all' ||
      (activeFilter === 'active' && user.isActive) ||
      (activeFilter === 'inactive' && !user.isActive);

    return matchesSearch && matchesFilter;
  });

  return (
    <div
      style={{
        maxWidth: '800px',
        margin: '0 auto',
        padding: '20px',
        fontFamily: 'system-ui',
      }}
    >
      <h1>ğŸ‘¥ User Management</h1>

      {/* âœ… All components controlled by parent */}
      <SearchBar
        searchTerm={searchTerm}
        onSearchChange={setSearchTerm}
      />

      <FilterButtons
        activeFilter={activeFilter}
        onFilterChange={setActiveFilter}
      />

      <div style={{ marginBottom: '10px', color: '#666' }}>
        Showing {filteredUsers.length} of {allUsers.length} users
      </div>

      <UserList users={filteredUsers} />

      {/* Debug info */}
      <details style={{ marginTop: '20px' }}>
        <summary>ğŸ” Debug: Filter State</summary>
        <pre
          style={{
            background: '#f5f5f5',
            padding: '10px',
            borderRadius: '4px',
          }}
        >
          {JSON.stringify(
            { searchTerm, activeFilter, resultCount: filteredUsers.length },
            null,
            2,
          )}
        </pre>
      </details>
    </div>
  );
}
```

**ğŸ”¥ Advanced Patterns:**

1. **Multiple Filter States:**

```jsx
// âœ… Parent manages multiple filter criteria
const [searchTerm, setSearchTerm] = useState('');
const [activeFilter, setActiveFilter] = useState('all');
// Could add more: sortBy, dateRange, etc.
```

2. **Derived Data (Don't Store Filtered List!):**

```jsx
// âœ… GOOD: Compute filtered list
const filteredUsers = allUsers.filter((user) => {
  return matchesSearch && matchesFilter;
});

// âŒ BAD: Store filtered list in state
// const [filteredUsers, setFilteredUsers] = useState([]);
// This is derived state anti-pattern!
```

3. **Presentational Components:**

```jsx
// âœ… Components are "dumb" - just display what they're given
function UserList({ users }) {
  // No state, no logic, just render
  return users.map((user) => <UserCard user={user} />);
}
```

---

## ğŸ”¨ PHáº¦N 3: BÃ€I Táº¬P THá»°C HÃ€NH (60 phÃºt)

### â­ Exercise 1: Parent-Child Communication (15 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Implement inverse data flow
 * â±ï¸ Thá»i gian: 15 phÃºt
 * ğŸš« KHÃ”NG dÃ¹ng: useEffect, useRef, Context
 *
 * Requirements:
 * 1. Counter component vá»›i buttons +/-
 * 2. Parent cáº§n biáº¿t count value Ä‘á»ƒ display
 * 3. Parent cÃ³ button "Reset" Ä‘á»ƒ set count vá» 0
 * 4. Counter component nháº­n initial value tá»« parent
 *
 * ğŸ’¡ Gá»£i Ã½:
 * - State á»Ÿ Ä‘Ã¢u? (Parent hay Child?)
 * - Counter lÃ  controlled component
 */

// âŒ Starter code (cáº§n sá»­a):
function Counter() {
  // TODO: Should this have state?

  return (
    <div>
      <button>-</button>
      <span>Count: ???</span>
      <button>+</button>
    </div>
  );
}

function App() {
  // TODO: Add state here?

  return (
    <div>
      <h2>Parent knows count: ???</h2>
      <Counter />
      <button>Reset to 0</button>
    </div>
  );
}

// âœ… NHIá»†M Vá»¤ Cá»¦A Báº N:
// TODO: Lift state to parent
// TODO: Make Counter controlled
// TODO: Implement reset functionality
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
// âœ… Counter is controlled component (no internal state)
function Counter({ count, onIncrement, onDecrement }) {
  return (
    <div
      style={{
        display: 'flex',
        gap: '10px',
        alignItems: 'center',
        padding: '20px',
        background: '#f0f0f0',
        borderRadius: '8px',
        width: 'fit-content',
      }}
    >
      <button
        onClick={onDecrement}
        style={{
          padding: '10px 20px',
          fontSize: '20px',
          cursor: 'pointer',
          background: '#dc3545',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
        }}
      >
        -
      </button>
      <span
        style={{
          fontSize: '24px',
          fontWeight: 'bold',
          minWidth: '50px',
          textAlign: 'center',
        }}
      >
        {count}
      </span>
      <button
        onClick={onIncrement}
        style={{
          padding: '10px 20px',
          fontSize: '20px',
          cursor: 'pointer',
          background: '#28a745',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
        }}
      >
        +
      </button>
    </div>
  );
}

// âœ… Parent owns state
function App() {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount((prev) => prev + 1);
  };

  const handleDecrement = () => {
    setCount((prev) => prev - 1);
  };

  const handleReset = () => {
    setCount(0);
  };

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h2>Parent knows count: {count}</h2>

      <Counter
        count={count}
        onIncrement={handleIncrement}
        onDecrement={handleDecrement}
      />

      <button
        onClick={handleReset}
        style={{
          marginTop: '20px',
          padding: '10px 20px',
          background: '#6c757d',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
        }}
      >
        Reset to 0
      </button>

      {/* Extra: Show if count is even/odd */}
      <p style={{ marginTop: '20px', color: '#666' }}>
        Count is {count % 2 === 0 ? 'even' : 'odd'}
      </p>
    </div>
  );
}
```

**Key Learnings:**

1. State lifted to parent (App owns count)
2. Counter is controlled via props
3. Callbacks flow up (onIncrement, onDecrement)
4. Parent can control counter (reset button)

</details>

---

### â­â­ Exercise 2: Todo List with Filter (25 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Share state giá»¯a multiple siblings
 * â±ï¸ Thá»i gian: 25 phÃºt
 *
 * Scenario: Todo app vá»›i separate components
 *
 * Components:
 * - AddTodoForm: Input + button Ä‘á»ƒ add todo
 * - FilterButtons: All / Active / Completed
 * - TodoList: Display filtered todos
 * - TodoStats: Show counts (total, active, completed)
 *
 * ğŸ¤” QUESTIONS:
 * 1. State nÃªn á»Ÿ Ä‘Ã¢u?
 * 2. Component nÃ o cáº§n callbacks?
 * 3. Derived state gÃ¬?
 */

// TODO: Implement these components

function AddTodoForm({ onAddTodo }) {
  // TODO: Local state cho input
  // TODO: Call onAddTodo callback
  return <div>Add Todo Form</div>;
}

function FilterButtons({ activeFilter, onFilterChange }) {
  // TODO: Render filter buttons
  return <div>Filter Buttons</div>;
}

function TodoList({ todos, onToggleTodo, onDeleteTodo }) {
  // TODO: Render todo items
  return <div>Todo List</div>;
}

function TodoStats({ total, active, completed }) {
  // TODO: Display statistics
  return <div>Stats</div>;
}

function TodoApp() {
  // TODO: Design state structure
  // - todos array
  // - filter ('all', 'active', 'completed')

  // TODO: Implement handlers

  // TODO: Compute filtered todos (derived state)

  // TODO: Compute stats (derived state)

  return (
    <div>
      <h1>Todo App</h1>
      {/* TODO: Compose components */}
    </div>
  );
}
```

<details>
<summary>ğŸ’¡ Solution</summary>

```jsx
// âœ… AddTodoForm - has local state for input
function AddTodoForm({ onAddTodo }) {
  const [input, setInput] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (input.trim()) {
      onAddTodo(input.trim());
      setInput(''); // Clear input
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      style={{ marginBottom: '20px' }}
    >
      <input
        type='text'
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder='What needs to be done?'
        style={{ padding: '10px', width: '300px', fontSize: '16px' }}
      />
      <button
        type='submit'
        style={{ padding: '10px 20px', marginLeft: '10px', cursor: 'pointer' }}
      >
        Add
      </button>
    </form>
  );
}

// âœ… FilterButtons
function FilterButtons({ activeFilter, onFilterChange }) {
  const filters = ['all', 'active', 'completed'];

  return (
    <div style={{ marginBottom: '20px' }}>
      {filters.map((filter) => (
        <button
          key={filter}
          onClick={() => onFilterChange(filter)}
          style={{
            padding: '8px 16px',
            marginRight: '10px',
            background: activeFilter === filter ? '#007bff' : '#e0e0e0',
            color: activeFilter === filter ? 'white' : '#333',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
            textTransform: 'capitalize',
          }}
        >
          {filter}
        </button>
      ))}
    </div>
  );
}

// âœ… TodoList
function TodoList({ todos, onToggleTodo, onDeleteTodo }) {
  if (todos.length === 0) {
    return <p style={{ color: '#666' }}>No todos to show</p>;
  }

  return (
    <div>
      {todos.map((todo) => (
        <div
          key={todo.id}
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: '10px',
            padding: '10px',
            marginBottom: '8px',
            background: '#f8f9fa',
            borderRadius: '4px',
          }}
        >
          <input
            type='checkbox'
            checked={todo.completed}
            onChange={() => onToggleTodo(todo.id)}
          />
          <span
            style={{
              flex: 1,
              textDecoration: todo.completed ? 'line-through' : 'none',
              color: todo.completed ? '#999' : '#000',
            }}
          >
            {todo.text}
          </span>
          <button
            onClick={() => onDeleteTodo(todo.id)}
            style={{
              padding: '5px 10px',
              background: '#dc3545',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
            }}
          >
            Delete
          </button>
        </div>
      ))}
    </div>
  );
}

// âœ… TodoStats
function TodoStats({ total, active, completed }) {
  return (
    <div
      style={{
        marginTop: '20px',
        padding: '15px',
        background: '#e3f2fd',
        borderRadius: '4px',
      }}
    >
      <h3>Statistics</h3>
      <p>Total: {total}</p>
      <p>Active: {active}</p>
      <p>Completed: {completed}</p>
    </div>
  );
}

// âœ… TodoApp - Parent that owns all state
function TodoApp() {
  const [todos, setTodos] = useState([
    { id: 1, text: 'Learn React', completed: false },
    { id: 2, text: 'Build a project', completed: false },
  ]);

  const [filter, setFilter] = useState('all');

  // âœ… Handler: Add todo
  const handleAddTodo = (text) => {
    const newTodo = {
      id: Date.now(),
      text,
      completed: false,
    };
    setTodos((prev) => [...prev, newTodo]);
  };

  // âœ… Handler: Toggle todo
  const handleToggleTodo = (id) => {
    setTodos((prev) =>
      prev.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo,
      ),
    );
  };

  // âœ… Handler: Delete todo
  const handleDeleteTodo = (id) => {
    setTodos((prev) => prev.filter((todo) => todo.id !== id));
  };

  // âœ… Derived: Filtered todos
  const filteredTodos = todos.filter((todo) => {
    if (filter === 'active') return !todo.completed;
    if (filter === 'completed') return todo.completed;
    return true; // 'all'
  });

  // âœ… Derived: Stats
  const stats = {
    total: todos.length,
    active: todos.filter((t) => !t.completed).length,
    completed: todos.filter((t) => t.completed).length,
  };

  return (
    <div
      style={{
        maxWidth: '600px',
        margin: '0 auto',
        padding: '20px',
        fontFamily: 'system-ui',
      }}
    >
      <h1>ğŸ“ Todo App</h1>

      <AddTodoForm onAddTodo={handleAddTodo} />

      <FilterButtons
        activeFilter={filter}
        onFilterChange={setFilter}
      />

      <TodoList
        todos={filteredTodos}
        onToggleTodo={handleToggleTodo}
        onDeleteTodo={handleDeleteTodo}
      />

      <TodoStats {...stats} />
    </div>
  );
}
```

**Architecture Decisions:**

1. **State in Parent:** todos + filter
2. **Local State in Child:** AddTodoForm input (doesn't need sharing)
3. **Derived State:** filteredTodos, stats (computed, not stored)
4. **4 Siblings:** All controlled by parent via props/callbacks

</details>

---

### â­â­â­ Exercise 3: Multi-Select List with Actions (40 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Complex state sharing vá»›i selection
 * â±ï¸ Thá»i gian: 40 phÃºt
 *
 * ğŸ“‹ Product Requirements:
 * User Story: "LÃ  admin, tÃ´i muá»‘n select nhiá»u users Ä‘á»ƒ thá»±c hiá»‡n bulk actions"
 *
 * âœ… Acceptance Criteria:
 * - [ ] User list vá»›i checkboxes
 * - [ ] "Select All" checkbox
 * - [ ] Selection count hiá»ƒn thá»‹
 * - [ ] Bulk actions: Delete Selected, Mark as Active/Inactive
 * - [ ] Actions chá»‰ available khi cÃ³ selection
 *
 * Components:
 * - UserListItem: Single user vá»›i checkbox
 * - UserList: List of users
 * - SelectionControls: Select All + count
 * - BulkActions: Action buttons
 * - UserManagementApp: Parent orchestrator
 *
 * ğŸ¨ Technical Constraints:
 * - selectedIds tracked in parent (array of IDs)
 * - Users data in parent
 * - All mutations through parent handlers
 *
 * ğŸš¨ Edge Cases:
 * - Select all / deselect all
 * - Delete selected removes from selection
 * - Individual checkbox toggle
 */

// Sample data
const INITIAL_USERS = [
  { id: 1, name: 'Alice', email: 'alice@example.com', isActive: true },
  { id: 2, name: 'Bob', email: 'bob@example.com', isActive: false },
  { id: 3, name: 'Charlie', email: 'charlie@example.com', isActive: true },
  { id: 4, name: 'David', email: 'david@example.com', isActive: false },
];

// âœ… NHIá»†M Vá»¤ Cá»¦A Báº N:

function UserListItem({ user, isSelected, onToggleSelect }) {
  // TODO: Render user vá»›i checkbox
  return <div>User Item</div>;
}

function UserList({ users, selectedIds, onToggleSelect }) {
  // TODO: Render list of UserListItem
  return <div>User List</div>;
}

function SelectionControls({
  totalUsers,
  selectedCount,
  onSelectAll,
  onDeselectAll,
}) {
  // TODO: Select All checkbox + count display
  return <div>Selection Controls</div>;
}

function BulkActions({
  selectedCount,
  onDelete,
  onMarkActive,
  onMarkInactive,
}) {
  // TODO: Action buttons (disabled if no selection)
  return <div>Bulk Actions</div>;
}

function UserManagementApp() {
  // TODO: State design
  // - users array
  // - selectedIds array

  // TODO: Handlers
  // - handleToggleSelect(id)
  // - handleSelectAll()
  // - handleDeselectAll()
  // - handleDeleteSelected()
  // - handleMarkActive()
  // - handleMarkInactive()

  return (
    <div>
      <h1>User Management</h1>
      {/* TODO: Compose components */}
    </div>
  );
}
```

<details>
<summary>ğŸ’¡ Full Solution</summary>

```jsx
const INITIAL_USERS = [
  { id: 1, name: 'Alice Johnson', email: 'alice@example.com', isActive: true },
  { id: 2, name: 'Bob Smith', email: 'bob@example.com', isActive: false },
  {
    id: 3,
    name: 'Charlie Brown',
    email: 'charlie@example.com',
    isActive: true,
  },
  { id: 4, name: 'David Lee', email: 'david@example.com', isActive: false },
  { id: 5, name: 'Eve Davis', email: 'eve@example.com', isActive: true },
];

// âœ… UserListItem
function UserListItem({ user, isSelected, onToggleSelect }) {
  return (
    <div
      style={{
        display: 'flex',
        alignItems: 'center',
        padding: '12px',
        marginBottom: '8px',
        background: isSelected ? '#e3f2fd' : 'white',
        border: `2px solid ${isSelected ? '#007bff' : '#ddd'}`,
        borderRadius: '4px',
      }}
    >
      <input
        type='checkbox'
        checked={isSelected}
        onChange={() => onToggleSelect(user.id)}
        style={{
          marginRight: '15px',
          width: '18px',
          height: '18px',
          cursor: 'pointer',
        }}
      />

      <div style={{ flex: 1 }}>
        <h4 style={{ margin: '0 0 5px 0' }}>{user.name}</h4>
        <p style={{ margin: 0, color: '#666', fontSize: '0.9em' }}>
          {user.email}
        </p>
      </div>

      <span
        style={{
          padding: '4px 12px',
          background: user.isActive ? '#28a745' : '#6c757d',
          color: 'white',
          borderRadius: '12px',
          fontSize: '0.85em',
        }}
      >
        {user.isActive ? 'Active' : 'Inactive'}
      </span>
    </div>
  );
}

// âœ… UserList
function UserList({ users, selectedIds, onToggleSelect }) {
  return (
    <div style={{ marginBottom: '20px' }}>
      {users.map((user) => (
        <UserListItem
          key={user.id}
          user={user}
          isSelected={selectedIds.includes(user.id)}
          onToggleSelect={onToggleSelect}
        />
      ))}
    </div>
  );
}

// âœ… SelectionControls
function SelectionControls({
  totalUsers,
  selectedCount,
  onSelectAll,
  onDeselectAll,
}) {
  const allSelected = selectedCount === totalUsers && totalUsers > 0;

  return (
    <div
      style={{
        marginBottom: '20px',
        padding: '15px',
        background: '#f8f9fa',
        borderRadius: '4px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
      }}
    >
      <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
        <label
          style={{ display: 'flex', alignItems: 'center', cursor: 'pointer' }}
        >
          <input
            type='checkbox'
            checked={allSelected}
            onChange={allSelected ? onDeselectAll : onSelectAll}
            style={{
              marginRight: '8px',
              width: '18px',
              height: '18px',
              cursor: 'pointer',
            }}
          />
          <span style={{ fontWeight: 'bold' }}>Select All</span>
        </label>

        <span style={{ color: '#666' }}>
          {selectedCount} of {totalUsers} selected
        </span>
      </div>

      {selectedCount > 0 && (
        <button
          onClick={onDeselectAll}
          style={{
            padding: '6px 12px',
            background: '#6c757d',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: 'pointer',
          }}
        >
          Clear Selection
        </button>
      )}
    </div>
  );
}

// âœ… BulkActions
function BulkActions({
  selectedCount,
  onDelete,
  onMarkActive,
  onMarkInactive,
}) {
  const disabled = selectedCount === 0;

  const buttonStyle = (color) => ({
    padding: '10px 20px',
    background: disabled ? '#ccc' : color,
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: disabled ? 'not-allowed' : 'pointer',
    marginRight: '10px',
    opacity: disabled ? 0.6 : 1,
  });

  return (
    <div style={{ marginBottom: '20px' }}>
      <h3>Bulk Actions {selectedCount > 0 && `(${selectedCount} selected)`}</h3>
      <div>
        <button
          onClick={onDelete}
          disabled={disabled}
          style={buttonStyle('#dc3545')}
        >
          ğŸ—‘ï¸ Delete Selected
        </button>

        <button
          onClick={onMarkActive}
          disabled={disabled}
          style={buttonStyle('#28a745')}
        >
          âœ… Mark as Active
        </button>

        <button
          onClick={onMarkInactive}
          disabled={disabled}
          style={buttonStyle('#6c757d')}
        >
          âŒ Mark as Inactive
        </button>
      </div>
    </div>
  );
}

// âœ… UserManagementApp - Parent orchestrator
function UserManagementApp() {
  const [users, setUsers] = useState(INITIAL_USERS);
  const [selectedIds, setSelectedIds] = useState([]);

  // âœ… Toggle single selection
  const handleToggleSelect = (id) => {
    setSelectedIds((prev) => {
      if (prev.includes(id)) {
        return prev.filter((selectedId) => selectedId !== id);
      } else {
        return [...prev, id];
      }
    });
  };

  // âœ… Select all
  const handleSelectAll = () => {
    setSelectedIds(users.map((user) => user.id));
  };

  // âœ… Deselect all
  const handleDeselectAll = () => {
    setSelectedIds([]);
  };

  // âœ… Delete selected
  const handleDeleteSelected = () => {
    if (window.confirm(`Delete ${selectedIds.length} users?`)) {
      setUsers((prev) => prev.filter((user) => !selectedIds.includes(user.id)));
      setSelectedIds([]);
    }
  };

  // âœ… Mark selected as active
  const handleMarkActive = () => {
    setUsers((prev) =>
      prev.map((user) =>
        selectedIds.includes(user.id) ? { ...user, isActive: true } : user,
      ),
    );
    setSelectedIds([]);
  };

  // âœ… Mark selected as inactive
  const handleMarkInactive = () => {
    setUsers((prev) =>
      prev.map((user) =>
        selectedIds.includes(user.id) ? { ...user, isActive: false } : user,
      ),
    );
    setSelectedIds([]);
  };

  return (
    <div
      style={{
        maxWidth: '800px',
        margin: '0 auto',
        padding: '20px',
        fontFamily: 'system-ui',
      }}
    >
      <h1>ğŸ‘¥ User Management</h1>

      <SelectionControls
        totalUsers={users.length}
        selectedCount={selectedIds.length}
        onSelectAll={handleSelectAll}
        onDeselectAll={handleDeselectAll}
      />

      <BulkActions
        selectedCount={selectedIds.length}
        onDelete={handleDeleteSelected}
        onMarkActive={handleMarkActive}
        onMarkInactive={handleMarkInactive}
      />

      <UserList
        users={users}
        selectedIds={selectedIds}
        onToggleSelect={handleToggleSelect}
      />

      {users.length === 0 && (
        <p style={{ textAlign: 'center', color: '#666', padding: '40px' }}>
          No users available
        </p>
      )}

      {/* Debug */}
      <details style={{ marginTop: '30px' }}>
        <summary>ğŸ” Debug Info</summary>
        <div style={{ fontSize: '0.9em' }}>
          <p>
            <strong>Total Users:</strong> {users.length}
          </p>
          <p>
            <strong>Selected IDs:</strong> [{selectedIds.join(', ')}]
          </p>
          <pre
            style={{ background: '#f5f5f5', padding: '10px', overflow: 'auto' }}
          >
            {JSON.stringify(users, null, 2)}
          </pre>
        </div>
      </details>
    </div>
  );
}
```

**Key Patterns:**

1. **Selection state lifted to parent:** `selectedIds` array
2. **Toggle logic in parent:** Add/remove from selectedIds
3. **Bulk operations:** Filter/map users based on selectedIds
4. **Clear selection after action:** Good UX
5. **Confirmation for destructive actions:** Delete prompt

</details>

---

### â­â­â­â­ Exercise 4: Accordion with Controlled Expansion (60 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Implement accordion vá»›i controlled expansion state
 * â±ï¸ Thá»i gian: 60 phÃºt
 *
 * ğŸ—ï¸ PHASE 1: Research & Design (20 phÃºt)
 *
 * Requirements:
 * - Accordion vá»›i multiple panels
 * - Modes: single (only 1 open) vs multiple (many open)
 * - Expand/collapse animations (CSS transition)
 * - Expand All / Collapse All buttons
 * - Keyboard navigation (Enter to toggle)
 *
 * Design Questions:
 * 1. State structure: array of open IDs vs object?
 * 2. Where to track mode (single vs multiple)?
 * 3. How to prevent multiple open in single mode?
 * 4. How to handle Expand All in single mode?
 *
 * ğŸ’» PHASE 2: Implementation (30 phÃºt)
 * ğŸ§ª PHASE 3: Testing (10 phÃºt)
 */

const FAQ_DATA = [
  {
    id: 1,
    question: 'What is lifting state up?',
    answer:
      'Lifting state up means moving state to the closest common ancestor when multiple components need to share that state.',
  },
  {
    id: 2,
    question: 'When should I lift state?',
    answer:
      'Lift state when two or more sibling components need to access or modify the same data.',
  },
  {
    id: 3,
    question: 'What are the trade-offs?',
    answer:
      'Lifting state can cause more components to re-render, but it enables proper data sharing and maintains a single source of truth.',
  },
];

// Implement AccordionPanel and Accordion components!
```

<details>
<summary>ğŸ’¡ Hint & Starter Code</summary>

```jsx
/**
 * State Design Recommendation:
 * - openIds: array of panel IDs that are currently open
 * - mode: 'single' or 'multiple'
 *
 * Single mode: openIds.length <= 1 (enforce in toggle logic)
 * Multiple mode: openIds can have any length
 */

function AccordionPanel({ id, question, answer, isOpen, onToggle }) {
  // TODO: Implement panel with expand/collapse
}

function Accordion() {
  // TODO: State for openIds and mode
  // TODO: Handlers for toggle, expandAll, collapseAll
  // TODO: Render panels
}
```

</details>

---

### â­â­â­â­â­ Exercise 5: Kanban Board (90 phÃºt)

```jsx
/**
 * ğŸ¯ Má»¥c tiÃªu: Production-ready Kanban board vá»›i drag simulation
 * â±ï¸ Thá»i gian: 90 phÃºt
 *
 * ğŸ“‹ Feature Specification:
 * - 3 columns: Todo, In Progress, Done
 * - Add task to any column
 * - Move tasks between columns (buttons - no actual drag & drop)
 * - Delete tasks
 * - Task count per column
 * - Filter: show all columns or single column
 *
 * ğŸ—ï¸ Technical Design:
 * 1. Tasks array vá»›i column property
 * 2. Columns config (id, title, color)
 * 3. Move task = update column property
 * 4. All operations through parent
 *
 * Components:
 * - Task: Single task card vá»›i move buttons
 * - Column: Task container vá»›i add form
 * - Board: Parent orchestrator
 * - Stats: Summary statistics
 *
 * âœ… Production Checklist:
 * - [ ] State structure documented
 * - [ ] Immutable updates
 * - [ ] Proper error handling (empty task text)
 * - [ ] Keyboard shortcuts (optional)
 * - [ ] Responsive layout
 */

const COLUMNS = [
  { id: 'todo', title: 'To Do', color: '#6c757d' },
  { id: 'inprogress', title: 'In Progress', color: '#ffc107' },
  { id: 'done', title: 'Done', color: '#28a745' },
];

// Implement the Kanban board!
```

---

## ğŸ“Š PHáº¦N 4: SO SÃNH PATTERNS (30 phÃºt)

### Báº£ng So SÃ¡nh Trade-offs

| Pattern                     | Pros âœ…                                                                        | Cons âŒ                                                                              | When to Use ğŸ¯                                                              |
| --------------------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------ | --------------------------------------------------------------------------- |
| **Lift to Parent**          | â€¢ Share state giá»¯a siblings<br/>â€¢ Single source of truth<br/>â€¢ Easier to debug | â€¢ More props passing<br/>â€¢ Parent re-renders when state changes<br/>â€¢ Props drilling | â€¢ Siblings cáº§n share data<br/>â€¢ **Default approach**                        |
| **Keep State Local**        | â€¢ Simpler code<br/>â€¢ Fewer re-renders<br/>â€¢ Better performance                 | â€¢ KhÃ´ng share Ä‘Æ°á»£c<br/>â€¢ Duplicate logic possible                                    | â€¢ Component-specific state<br/>â€¢ No sharing needed<br/>â€¢ Form input buffers |
| **Callbacks Up, Data Down** | â€¢ Clear data flow<br/>â€¢ Predictable<br/>â€¢ Easy to trace                        | â€¢ Verbose with many callbacks<br/>â€¢ Props drilling                                   | â€¢ **Standard React pattern**<br/>â€¢ Always use for updates                   |
| **Derived State**           | â€¢ Always in sync<br/>â€¢ No duplication<br/>â€¢ Less bugs                          | â€¢ Re-compute every render<br/>â€¢ Can be expensive                                     | â€¢ Filtered lists<br/>â€¢ Computed values<br/>â€¢ **Prefer over storing**        |
| **Lift to Grandparent**     | â€¢ Share across more components                                                 | â€¢ Deep props drilling<br/>â€¢ Many intermediate components<br/>â€¢ Hard to maintain      | â€¢ âŒ Avoid if possible<br/>â€¢ Use Context instead (sáº½ há»c sau)               |

---

### Decision Tree

```
Q1: CÃ³ component nÃ o khÃ¡c cáº§n data nÃ y khÃ´ng?
â”œâ”€ NO â†’ Keep state local trong component
â””â”€ YES â†’ Continue to Q2

Q2: Components cÃ³ cÃ¹ng parent khÃ´ng?
â”œâ”€ YES â†’ Lift to immediate parent
â””â”€ NO â†’ Continue to Q3

Q3: CÃ³ closest common ancestor gáº§n khÃ´ng?
â”œâ”€ YES â†’ Lift to closest common ancestor
â””â”€ NO â†’ Consider Context API (NgÃ y 29) hoáº·c global state (NgÃ y 10+)

Q4: Data cÃ³ derive Ä‘Æ°á»£c tá»« state khÃ¡c khÃ´ng?
â”œâ”€ YES â†’ DON'T store it! Compute nÃ³
â””â”€ NO â†’ Store in state

Q5: Props drilling quÃ¡ sÃ¢u (>3 levels)?
â”œâ”€ YES â†’ Consider:
â”‚        - Component composition
â”‚        - Context API
â”‚        - State management library
â””â”€ NO â†’ Props drilling OK (acceptable)

GOLDEN RULES:
âœ… State cÃ ng gáº§n nÆ¡i dÃ¹ng cÃ ng tá»‘t
âœ… Lift CHá»ˆ khi cáº§n share
âœ… Derived > Stored
âœ… Callbacks for updates, props for data
```

---

## ğŸ§ª PHáº¦N 5: DEBUG LAB (20 phÃºt)

### Bug 1: State Not Sharing â­

```jsx
// ğŸ› BUG: ComponentB khÃ´ng nháº­n Ä‘Æ°á»£c data tá»« ComponentA
function ComponentA() {
  const [data, setData] = useState('Hello');

  return (
    <div>
      <p>Component A: {data}</p>
      <button onClick={() => setData('Updated!')}>Update</button>
    </div>
  );
}

function ComponentB() {
  return (
    <div>
      <p>Component B: ??? {/* Muá»‘n hiá»ƒn thá»‹ data tá»« A */}</p>
    </div>
  );
}

function App() {
  return (
    <div>
      <ComponentA />
      <ComponentB />
    </div>
  );
}

/**
 * ğŸ” DEBUG QUESTIONS:
 * 1. Táº¡i sao ComponentB khÃ´ng tháº¥y data?
 * 2. State nÃªn di chuyá»ƒn Ä‘áº¿n Ä‘Ã¢u?
 * 3. Fix nhÆ° tháº¿ nÃ o?
 */
```

<details>
<summary>ğŸ’¡ Solution</summary>

**Váº¥n Ä‘á»:**

- State trong ComponentA â†’ chá»‰ ComponentA access Ä‘Æ°á»£c
- ComponentB lÃ  sibling â†’ khÃ´ng thá»ƒ access state cá»§a ComponentA
- Cáº§n **lift state up** to parent (App)

**Fix:**

```jsx
// âœ… Lift state to parent
function App() {
  const [data, setData] = useState('Hello');

  return (
    <div>
      <ComponentA
        data={data}
        onUpdate={setData}
      />
      <ComponentB data={data} />
    </div>
  );
}

function ComponentA({ data, onUpdate }) {
  return (
    <div>
      <p>Component A: {data}</p>
      <button onClick={() => onUpdate('Updated!')}>Update</button>
    </div>
  );
}

function ComponentB({ data }) {
  return (
    <div>
      <p>Component B: {data}</p>
    </div>
  );
}
```

**Lesson:** Siblings can't share state directly. Lift to common parent!

</details>

---

### Bug 2: Child Can't Update Parent â­â­

```jsx
// ğŸ› BUG: Counter update khÃ´ng work
function Counter({ count }) {
  // BUG: Child trying to update parent state directly
  const increment = () => {
    count = count + 1; // âŒ Won't work!
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+1</button>
    </div>
  );
}

function App() {
  const [count, setCount] = useState(0);

  return <Counter count={count} />;
}

/**
 * ğŸ” DEBUG QUESTIONS:
 * 1. Táº¡i sao button click khÃ´ng update count?
 * 2. `count = count + 1` cÃ³ váº¥n Ä‘á» gÃ¬?
 * 3. Child cáº§n gÃ¬ tá»« parent?
 */
```

<details>
<summary>ğŸ’¡ Solution</summary>

**Váº¥n Ä‘á»:**

1. `count` lÃ  prop (read-only)
2. Reassigning prop khÃ´ng trigger re-render
3. Child khÃ´ng thá»ƒ directly update parent state
4. Cáº§n callback tá»« parent!

**Fix:**

```jsx
// âœ… Parent provides callback
function App() {
  const [count, setCount] = useState(0);

  return (
    <Counter
      count={count}
      onIncrement={() => setCount((prev) => prev + 1)} // âœ… Callback!
    />
  );
}

// âœ… Child calls callback
function Counter({ count, onIncrement }) {
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={onIncrement}>+1</button>
    </div>
  );
}
```

**Lesson:** Props down, callbacks up! Child communicates via callbacks.

</details>

---

### Bug 3: Lifted Too High â­â­â­

```jsx
// ğŸ› PERFORMANCE ISSUE: Everything re-renders unnecessarily
function App() {
  const [searchTerm, setSearchTerm] = useState('');
  const [users, setUsers] = useState([
    /* 1000 users */
  ]);

  const filteredUsers = users.filter((u) =>
    u.name.toLowerCase().includes(searchTerm.toLowerCase()),
  );

  return (
    <div>
      <Header /> {/* Re-renders on every keystroke! */}
      <Sidebar /> {/* Re-renders on every keystroke! */}
      <SearchBar
        searchTerm={searchTerm}
        onChange={setSearchTerm}
      />
      <UserList users={filteredUsers} />
      <Footer /> {/* Re-renders on every keystroke! */}
    </div>
  );
}

/**
 * ğŸ” DEBUG QUESTIONS:
 * 1. Táº¡i sao Header/Sidebar/Footer re-render khi gÃµ search?
 * 2. Component nÃ o thá»±c sá»± cáº§n searchTerm?
 * 3. LÃ m tháº¿ nÃ o optimize?
 */
```

<details>
<summary>ğŸ’¡ Solution</summary>

**Váº¥n Ä‘á»:**

- `searchTerm` state in App
- Má»—i keystroke â†’ App re-render â†’ ALL children re-render
- Header/Sidebar/Footer khÃ´ng cáº§n searchTerm â†’ unnecessary re-renders

**Fix 1: Move state down**

```jsx
// âœ… Create SearchSection component
function SearchSection() {
  const [searchTerm, setSearchTerm] = useState('');
  const [users] = useState([
    /* users */
  ]);

  const filteredUsers = users.filter((u) =>
    u.name.toLowerCase().includes(searchTerm.toLowerCase()),
  );

  return (
    <>
      <SearchBar
        searchTerm={searchTerm}
        onChange={setSearchTerm}
      />
      <UserList users={filteredUsers} />
    </>
  );
}

function App() {
  return (
    <div>
      <Header /> {/* âœ… Doesn't re-render */}
      <Sidebar /> {/* âœ… Doesn't re-render */}
      <SearchSection />
      <Footer /> {/* âœ… Doesn't re-render */}
    </div>
  );
}
```

**Fix 2: Use React.memo (will learn in NgÃ y 23)**

```jsx
// Prevent unnecessary re-renders
const Header = React.memo(() => <header>Header</header>);
```

**Lesson:**

- Only lift as high as NEEDED
- Lower state = fewer re-renders = better performance
- State placement affects performance!

</details>

---

## âœ… PHáº¦N 6: Tá»° ÄÃNH GIÃ (15 phÃºt)

### Knowledge Check

- [ ] TÃ´i hiá»ƒu khi nÃ o cáº§n lift state up
- [ ] TÃ´i biáº¿t cÃ¡ch identify closest common ancestor
- [ ] TÃ´i cÃ³ thá»ƒ implement inverse data flow (callbacks)
- [ ] TÃ´i hiá»ƒu "props down, callbacks up" pattern
- [ ] TÃ´i nháº­n biáº¿t Ä‘Æ°á»£c props drilling
- [ ] TÃ´i biáº¿t khi nÃ o state nÃªn local vs lifted
- [ ] TÃ´i cÃ³ thá»ƒ refactor isolated state thÃ nh shared state
- [ ] TÃ´i hiá»ƒu trade-offs cá»§a lifting state
- [ ] TÃ´i biáº¿t cÃ¡ch avoid lifting quÃ¡ cao
- [ ] TÃ´i cÃ³ thá»ƒ design component hierarchy vá»›i state placement tá»‘i Æ°u

### Code Review Checklist

Khi review code vá» state management:

**State Placement:**

- [ ] State á»Ÿ level tháº¥p nháº¥t cÃ³ thá»ƒ
- [ ] Chá»‰ lift khi Cáº¦N share
- [ ] KhÃ´ng lift quÃ¡ cao (performance)
- [ ] Local state cho component-specific data

**Data Flow:**

- [ ] Data flows down via props
- [ ] Events flow up via callbacks
- [ ] Single source of truth
- [ ] No duplicate state

**Component Design:**

- [ ] Parent owns shared state
- [ ] Children are controlled components
- [ ] Clear props interface
- [ ] Derived state computed, not stored

**Performance:**

- [ ] Minimal re-renders
- [ ] State not higher than needed
- [ ] Consider memoization if many re-renders

---

## ğŸ  BÃ€I Táº¬P Vá»€ NHÃ€

### Báº¯t buá»™c (30 phÃºt)

**Exercise: Refactor Isolated State**

Cho code vá»›i state isolated. Refactor thÃ nh shared state:

```jsx
// Start: Each component has its own count
function CounterA() {
  const [count, setCount] = useState(0);
  return (
    <div>
      A: {count} <button onClick={() => setCount((c) => c + 1)}>+</button>
    </div>
  );
}

function CounterB() {
  const [count, setCount] = useState(0);
  return (
    <div>
      B: {count} <button onClick={() => setCount((c) => c + 1)}>+</button>
    </div>
  );
}

// Goal: Share count between A and B, show total
```

### NÃ¢ng cao (60 phÃºt)

**Exercise: Movie Watchlist Manager**

Táº¡o app quáº£n lÃ½ watchlist vá»›i:

**Features:**

- Movie list vá»›i buttons "Add to Watchlist" / "Mark as Watched"
- Separate tabs: All Movies / Watchlist / Watched
- Statistics: Total movies, watchlist count, watched count
- Filter by genre
- Search by title

**Components:**

- MovieCard
- MovieList
- Tabs
- SearchBar
- GenreFilter
- Stats
- MovieApp (parent)

**Requirements:**

- âœ… Proper state lifting
- âœ… All operations through parent
- âœ… Derived state for filtered lists
- âœ… No duplicate state

---

## ğŸ“š TÃ€I LIá»†U THAM KHáº¢O

### Báº¯t buá»™c Ä‘á»c

1. **React Docs - Sharing State Between Components**
   - https://react.dev/learn/sharing-state-between-components
   - ChÃ­nh thá»©c tá»« React team

2. **React Docs - Passing Data Deeply with Context**
   - https://react.dev/learn/passing-data-deeply-with-context
   - Preview alternative to props drilling (sáº½ há»c NgÃ y 29)

### Äá»c thÃªm

3. **Thinking in React**
   - https://react.dev/learn/thinking-in-react
   - How to design component hierarchy

4. **Component Composition vs Inheritance**
   - https://react.dev/learn/passing-props-to-a-component

---

## ğŸ”— Káº¾T Ná»I KIáº¾N THá»¨C

### Kiáº¿n thá»©c ná»n (Ä‘Ã£ há»c)

- **NgÃ y 13**: Forms vá»›i State - Controlled components
- **NgÃ y 12**: useState Patterns - Immutability, functional updates
- **NgÃ y 4**: Props - Data flow parent â†’ child

### HÆ°á»›ng tá»›i (sáº½ há»c)

- **NgÃ y 15**: Project 2 - Todo App (apply lifting state)
- **NgÃ y 29**: Context API - Solution cho deep props drilling
- **NgÃ y 30**: useReducer - Complex state logic alternative

---

## ğŸ’¡ SENIOR INSIGHTS

### CÃ¢n Nháº¯c Production

**When to Lift vs Context:**

```jsx
// âœ… Lift state: 1-2 levels
Parent â†’ Child â†’ Grandchild (OK)

// âš ï¸ Props drilling: 3+ levels
Parent â†’ A â†’ B â†’ C â†’ D (Consider Context)

// Rule of Thumb:
// - Lift for shallow trees
// - Context for deep trees
// - State management for global state
```

**Performance Considerations:**

```jsx
// âš ï¸ Expensive re-renders
function App() {
  const [search, setSearch] = useState('');

  return (
    <>
      <ExpensiveComponent /> {/* Re-renders on search change! */}
      <SearchBar
        search={search}
        onChange={setSearch}
      />
    </>
  );
}

// âœ… Optimize vá»›i composition
function App() {
  return (
    <>
      <ExpensiveComponent /> {/* Doesn't re-render */}
      <SearchSection /> {/* search state local here */}
    </>
  );
}
```

### CÃ¢u Há»i Phá»ng Váº¥n

**Junior:**
Q: "Lifting state up lÃ  gÃ¬?"
A: Di chuyá»ƒn state tá»« child lÃªn parent khi nhiá»u components cáº§n share state Ä‘Ã³. Parent pass state down via props vÃ  nháº­n updates qua callbacks.

**Mid:**
Q: "Khi nÃ o nÃªn lift state vÃ  khi nÃ o khÃ´ng?"
A: Lift khi: (1) Siblings cáº§n share data, (2) Parent cáº§n control child state. KhÃ´ng lift khi: (1) Chá»‰ 1 component dÃ¹ng, (2) Component-specific UI state (hover, focus).

**Senior:**
Q: "Design state architecture cho feature X. Justify placement decisions."
A: Pháº£i analyze:

- Component hierarchy (siblings? parent-child?)
- Data flow requirements (who reads? who writes?)
- Re-render impact (will lifting cause unnecessary renders?)
- Scalability (will this grow?)
- Document: State location + rationale + trade-offs

### War Stories

**Story 1: The Props Drilling Nightmare**

> Má»™t project lift state lÃªn App component cho "easier sharing". Káº¿t quáº£: 8 levels props drilling, má»—i component pass 10+ props. Refactoring nightmare! Lesson: Chá»‰ lift Ä‘áº¿n closest common ancestor, khÃ´ng cao hÆ¡n. Consider Context náº¿u > 3 levels.

**Story 2: The Performance Bug**

> Form input lag 200ms má»—i keystroke. Root cause: Form state lifted to App, app cÃ³ 50 child components khÃ´ng liÃªn quan nhÆ°ng re-render má»—i keystroke. Fix: Move form state down to FormSection component. Performance tá»« 200ms â†’ <1ms. Lesson: State placement = performance!

**Story 3: The Duplicate State Sync Issue**

> Bug: Filtered list vÃ  stats khÃ´ng sync. Code store cáº£ filteredData vÃ  stats in state, manually sync. Miss 1 chá»— update = out of sync. Fix: Chá»‰ store raw data + filters, derive filtered list vÃ  stats. LuÃ´n sync vÃ¬ computed. Lesson: Derived state > Duplicate state!

---

## ğŸ¯ PREVIEW NGÃ€Y MAI

**NgÃ y 15: Project 2 - Interactive Todo App**

HÃ´m nay Ä‘Ã£ master state sharing. NgÃ y mai sáº½ Ã¡p dá»¥ng vÃ o full project:

- Todo app vá»›i multiple components
- Lift state up trong thá»±c táº¿
- Filter, search, stats - all derived
- Production-ready architecture
- Review code vá»›i senior mindset

HÃ´m nay: Theory + Patterns âœ…  
NgÃ y mai: Real project application ğŸ¯

---

**ğŸŠ CHÃšC Má»ªNG! Báº¡n Ä‘Ã£ hoÃ n thÃ nh NgÃ y 14!**

HÃ´m nay báº¡n Ä‘Ã£ master:

1. âœ… Lifting State Up concept
2. âœ… Props down, Callbacks up pattern
3. âœ… Closest common ancestor principle
4. âœ… State placement decisions
5. âœ… Avoiding props drilling
6. âœ… Performance implications

**Lifting State Up lÃ  foundation cá»§a React architecture!**

Má»i app phá»©c táº¡p Ä‘á»u dá»±a trÃªn principle nÃ y. Master nÃ³ = master React data flow!

ğŸ’ª Tomorrow: Put it all together in a real project!
