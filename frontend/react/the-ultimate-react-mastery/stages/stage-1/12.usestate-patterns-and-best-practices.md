# üìÖ NG√ÄY 12: useState - Patterns & Best Practices

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:

- [ ] **Hi·ªÉu v√† √°p d·ª•ng functional updates** ƒë·ªÉ tr√°nh stale closure bugs
- [ ] **S·ª≠ d·ª•ng lazy initialization** ƒë·ªÉ optimize performance
- [ ] **Thi·∫øt k·∫ø state structure** h·ª£p l√Ω (flat vs nested, single vs multiple)
- [ ] **√Åp d·ª•ng immutability patterns** khi update objects/arrays
- [ ] **Nh·∫≠n bi·∫øt v√† tr√°nh derived state anti-pattern**

---

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

Tr·∫£ l·ªùi 3 c√¢u h·ªèi sau ƒë·ªÉ k√≠ch ho·∫°t ki·∫øn th·ª©c t·ª´ Ng√†y 11:

1. **C√¢u 1**: Code n√†y s·∫Ω hi·ªÉn th·ªã g√¨ sau khi click 3 l·∫ßn?

```jsx
const [count, setCount] = useState(0);

const handleClick = () => {
  setCount(count + 1);
  setCount(count + 1);
  setCount(count + 1);
};
```

2. **C√¢u 2**: State v√† Props kh√°c nhau th·∫ø n√†o? ƒêi·ªÅu g√¨ x·∫£y ra khi state thay ƒë·ªïi?

3. **C√¢u 3**: T·∫°i sao code n√†y c√≥ v·∫•n ƒë·ªÅ?

```jsx
const [user, setUser] = useState({ name: 'Alice', age: 25 });
user.age = 26; // Mutating directly
```

<details>
<summary>üí° Xem ƒë√°p √°n</summary>

1. Hi·ªÉn th·ªã `1` (kh√¥ng ph·∫£i 3!) - ƒê√¢y ch√≠nh l√† v·∫•n ƒë·ªÅ m√† functional updates s·∫Ω gi·∫£i quy·∫øt
2. Props: read-only, t·ª´ parent; State: mutable, internal. Khi state thay ƒë·ªïi ‚Üí component re-render
3. Vi ph·∫°m immutability - React kh√¥ng detect ƒë∆∞·ª£c thay ƒë·ªïi ‚Üí kh√¥ng re-render

</details>

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

H√¥m qua (Ng√†y 11) ch√∫ng ta ƒë√£ h·ªçc useState c∆° b·∫£n v·ªõi c√∫ ph√°p:

```jsx
const [count, setCount] = useState(0);
setCount(5); // Direct update
```

Nh∆∞ng h√£y xem t√¨nh hu·ªëng n√†y trong real app:

```jsx
// ‚ùå BUG ·∫®N TRONG CODE N√ÄY!
function LikeButton() {
  const [likes, setLikes] = useState(0);

  const handleTripleClick = () => {
    setLikes(likes + 1);
    setLikes(likes + 1);
    setLikes(likes + 1);
  };

  return <button onClick={handleTripleClick}>‚ù§Ô∏è {likes}</button>;
}
```

**K·ª≥ v·ªçng**: Click 1 l·∫ßn ‚Üí tƒÉng 3 likes  
**Th·ª±c t·∫ø**: Click 1 l·∫ßn ‚Üí ch·ªâ tƒÉng 1 like üò±

**T·∫°i sao?** ƒê√¢y l√† **stale closure** - m·ªôt trong nh·ªØng bugs ph·ªï bi·∫øn nh·∫•t trong React!

---

### 1.2 Gi·∫£i Ph√°p

H√¥m nay ch√∫ng ta h·ªçc 5 patterns n√¢ng cao c·ªßa useState:

1. **Functional Updates** - Fix stale closure
2. **Lazy Initialization** - Optimize expensive computations
3. **State Structure** - Design state hi·ªáu qu·∫£
4. **Immutability Patterns** - Update objects/arrays ƒë√∫ng c√°ch
5. **Derived State** - Tr√°nh duplicate state

### 1.3 Mental Model

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          useState ADVANCED PATTERNS             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
‚îÇ  ‚îÇ Functional      ‚îÇ  setCount(prev => prev+1)  ‚îÇ
‚îÇ  ‚îÇ Updates         ‚îÇ  ‚úÖ Always latest state    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
‚îÇ  ‚îÇ Lazy            ‚îÇ  useState(() => heavy())   ‚îÇ
‚îÇ  ‚îÇ Initialization  ‚îÇ  ‚úÖ Run once on mount      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
‚îÇ  ‚îÇ State           ‚îÇ  Multiple small vs         ‚îÇ
‚îÇ  ‚îÇ Structure       ‚îÇ  One big object?           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
‚îÇ  ‚îÇ Immutability    ‚îÇ  {...obj, age: 26}         ‚îÇ
‚îÇ  ‚îÇ Patterns        ‚îÇ  [...arr, newItem]         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îÇ
‚îÇ  ‚îÇ Derived         ‚îÇ  fullName = first + last   ‚îÇ
‚îÇ  ‚îÇ State           ‚îÇ  ‚úÖ Calculate, don't store ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Analogy d·ªÖ hi·ªÉu**:

- **Functional updates** = G·ª≠i th∆∞ v·ªõi "tƒÉng l∆∞∆°ng th√™m 10%" thay v√¨ "l∆∞∆°ng = 5 tri·ªáu" (v√¨ c√≥ th·ªÉ ƒë√£ tƒÉng r·ªìi)
- **Lazy initialization** = N·∫•u c∆°m electric cooker m·ªôt l·∫ßn, kh√¥ng ph·∫£i n·∫•u l·∫°i m·ªói l·∫ßn ƒÉn
- **Immutability** = Vi·∫øt draft email m·ªõi thay v√¨ s·ª≠a email ƒë√£ g·ª≠i

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

‚ùå **Myth 1**: "setCount(count + 1) lu√¥n ƒë√∫ng"  
‚úÖ **Truth**: Sai khi c√≥ multiple updates ho·∫∑c async operations

‚ùå **Myth 2**: "useState ch·∫≠m v√¨ heavy computation"  
‚úÖ **Truth**: Ch·ªâ ch·∫≠m n·∫øu kh√¥ng d√πng lazy initialization

‚ùå **Myth 3**: "Store m·ªçi th·ª© in state"  
‚úÖ **Truth**: Derived values n√™n calculate, kh√¥ng store

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Functional Updates - Pattern C∆° B·∫£n ‚≠ê

#### ‚ùå C√ÅCH SAI: Direct Updates (Stale Closure)

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  // ‚ùå V·∫§N ƒê·ªÄ: T·∫•t c·∫£ 3 l·∫ßn ƒë·ªÅu ƒë·ªçc count = 0
  const increment3Times = () => {
    setCount(count + 1); // count = 0, set to 1
    setCount(count + 1); // count v·∫´n = 0, set to 1
    setCount(count + 1); // count v·∫´n = 0, set to 1
    // K·∫øt qu·∫£: count = 1 (kh√¥ng ph·∫£i 3!)
  };

  // ‚ùå V·∫§N ƒê·ªÄ: setTimeout capture stale value
  const incrementAsync = () => {
    setTimeout(() => {
      setCount(count + 1); // count l√† gi√° tr·ªã l√∫c click, kh√¥ng ph·∫£i l√∫c timeout
    }, 1000);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment3Times}>+3 (BUG!)</button>
      <button onClick={incrementAsync}>+1 sau 1s (BUG!)</button>
    </div>
  );
}
```

**T·∫°i sao sai?**

- `count` l√† constant trong m·ªói render
- Closure capture gi√° tr·ªã t·∫°i th·ªùi ƒëi·ªÉm t·∫°o function
- Multiple updates ƒë·ªçc c√πng 1 gi√° tr·ªã c≈©

---

#### ‚úÖ C√ÅCH ƒê√öNG: Functional Updates

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  // ‚úÖ ƒê√öNG: M·ªói l·∫ßn d√πng gi√° tr·ªã m·ªõi nh·∫•t
  const increment3Times = () => {
    setCount((prev) => prev + 1); // prev = 0, return 1
    setCount((prev) => prev + 1); // prev = 1, return 2
    setCount((prev) => prev + 1); // prev = 2, return 3
    // K·∫øt qu·∫£: count = 3 ‚úÖ
  };

  // ‚úÖ ƒê√öNG: Lu√¥n l·∫•y gi√° tr·ªã m·ªõi nh·∫•t khi timeout ch·∫°y
  const incrementAsync = () => {
    setTimeout(() => {
      setCount((prev) => prev + 1); // prev l√† gi√° tr·ªã m·ªõi nh·∫•t
    }, 1000);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment3Times}>+3 ‚úÖ</button>
      <button onClick={incrementAsync}>+1 sau 1s ‚úÖ</button>
    </div>
  );
}
```

**T·∫°i sao ƒë√∫ng?**

- `prev` lu√¥n l√† latest state value
- React queue updates v√† ch·∫°y tu·∫ßn t·ª±
- Kh√¥ng b·ªã stale closure

---

### Demo 2: Lazy Initialization - K·ªãch B·∫£n Th·ª±c T·∫ø ‚≠ê‚≠ê

#### ‚ùå C√ÅCH SAI: Expensive Computation Ch·∫°y M·ªói Render

```jsx
// H√†m t√≠nh to√°n n·∫∑ng (v√≠ d·ª•: ƒë·ªçc t·ª´ localStorage)
function getInitialTodos() {
  console.log('üî• Running expensive computation...');

  // Gi·∫£ l·∫≠p heavy computation
  const start = Date.now();
  while (Date.now() - start < 100) {
    // Block 100ms
  }

  // ƒê·ªçc t·ª´ localStorage
  const saved = localStorage.getItem('todos');
  return saved ? JSON.parse(saved) : [];
}

// ‚ùå V·∫§N ƒê·ªÄ: getInitialTodos() ch·∫°y M·ªñI RENDER!
function TodoApp() {
  const [todos, setTodos] = useState(getInitialTodos()); // üî• Ch·∫°y m·ªói render!
  const [input, setInput] = useState('');

  // M·ªói l·∫ßn g√µ input ‚Üí component re-render ‚Üí getInitialTodos() ch·∫°y l·∫°i!
  // D√π ch·ªâ c·∫ßn gi√° tr·ªã initial 1 l·∫ßn

  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
      />
      {/* UI... */}
    </div>
  );
}
```

**V·∫•n ƒë·ªÅ:**

- `getInitialTodos()` ch·∫°y m·ªói render (ngay c·∫£ khi ƒëang g√µ input!)
- Waste performance
- Console log spam

---

#### ‚úÖ C√ÅCH ƒê√öNG: Lazy Initialization

```jsx
function getInitialTodos() {
  console.log('‚úÖ Running ONCE on mount...');

  const start = Date.now();
  while (Date.now() - start < 100) {}

  const saved = localStorage.getItem('todos');
  return saved ? JSON.parse(saved) : [];
}

// ‚úÖ ƒê√öNG: Pass function, React ch·ªâ g·ªçi 1 l·∫ßn khi mount
function TodoApp() {
  const [todos, setTodos] = useState(() => getInitialTodos()); // ‚úÖ Function!
  const [input, setInput] = useState('');

  // G√µ input ‚Üí re-render ‚Üí getInitialTodos() KH√îNG ch·∫°y l·∫°i

  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
      />
      <p>Todos: {todos.length}</p>
      {/* Console ch·ªâ log 1 l·∫ßn! */}
    </div>
  );
}
```

**Quy t·∫Øc v√†ng:**

```jsx
// ‚ùå SAI: Function call
useState(expensiveFunction());

// ‚úÖ ƒê√öNG: Function reference
useState(() => expensiveFunction());

// ‚ö†Ô∏è CH√ö √ù: Ch·ªâ d√πng khi initial value th·ª±c s·ª± expensive
useState(0); // OK - simple value
useState(() => 0); // Overkill - kh√¥ng c·∫ßn thi·∫øt
useState(() => readFromDB()); // GOOD - expensive operation
```

---

### Demo 3: State Structure & Immutability - Edge Cases ‚≠ê‚≠ê‚≠ê

#### ‚ùå C√ÅCH SAI: Nhi·ªÅu State Kh√¥ng Li√™n Quan

```jsx
// ‚ùå V·∫§N ƒê·ªÄ: State kh√¥ng ƒë∆∞·ª£c group logic
function UserProfile() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [address, setAddress] = useState('');
  const [city, setCity] = useState('');
  const [country, setCountry] = useState('');

  // Reset form c·∫ßn 7 d√≤ng code!
  const handleReset = () => {
    setFirstName('');
    setLastName('');
    setEmail('');
    setAge(0);
    setAddress('');
    setCity('');
    setCountry('');
  };

  // Update ph·ª©c t·∫°p, d·ªÖ miss fields
}
```

---

#### ‚úÖ C√ÅCH ƒê√öNG: Group Related State

```jsx
// ‚úÖ ƒê√öNG: Group state c√≥ li√™n quan
function UserProfile() {
  const [user, setUser] = useState({
    firstName: '',
    lastName: '',
    email: '',
    age: 0,
    address: {
      street: '',
      city: '',
      country: '',
    },
  });

  // Reset ƒë∆°n gi·∫£n h∆°n
  const handleReset = () => {
    setUser({
      firstName: '',
      lastName: '',
      email: '',
      age: 0,
      address: { street: '', city: '', country: '' },
    });
  };

  // Update v·ªõi immutability
  const updateField = (field, value) => {
    setUser((prev) => ({
      ...prev, // Spread old values
      [field]: value, // Override field
    }));
  };

  // Update nested object
  const updateAddress = (field, value) => {
    setUser((prev) => ({
      ...prev,
      address: {
        ...prev.address, // Spread old address
        [field]: value, // Override address field
      },
    }));
  };

  return (
    <div>
      <input
        value={user.firstName}
        onChange={(e) => updateField('firstName', e.target.value)}
      />
      <input
        value={user.address.city}
        onChange={(e) => updateAddress('city', e.target.value)}
      />
    </div>
  );
}
```

---

#### üî• Immutability Patterns Deep Dive

```jsx
function DataManager() {
  const [items, setItems] = useState([
    { id: 1, name: 'Item 1', completed: false },
    { id: 2, name: 'Item 2', completed: true },
  ]);

  // ‚úÖ PATTERN 1: Add item
  const addItem = (name) => {
    const newItem = {
      id: Date.now(),
      name,
      completed: false,
    };

    setItems((prev) => [...prev, newItem]); // Spread + add
  };

  // ‚úÖ PATTERN 2: Remove item
  const removeItem = (id) => {
    setItems((prev) => prev.filter((item) => item.id !== id));
  };

  // ‚úÖ PATTERN 3: Update item
  const toggleItem = (id) => {
    setItems((prev) =>
      prev.map(
        (item) =>
          item.id === id
            ? { ...item, completed: !item.completed } // Create new object
            : item, // Keep old reference
      ),
    );
  };

  // ‚úÖ PATTERN 4: Update nested property
  const updateItemName = (id, newName) => {
    setItems((prev) =>
      prev.map((item) => (item.id === id ? { ...item, name: newName } : item)),
    );
  };

  // ‚úÖ PATTERN 5: Replace entire array
  const replaceItems = (newItems) => {
    setItems(newItems); // Direct replacement OK
  };

  // ‚ùå NEVER DO THIS:
  const wrongUpdate = (id) => {
    const item = items.find((i) => i.id === id);
    item.completed = true; // üö´ Mutation!
    setItems(items); // üö´ Same reference!
  };
}
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Exercise 1: Fix Stale Closure Bug (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: S·ª≠a bug stale closure trong code d∆∞·ªõi ƒë√¢y
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: useEffect, useRef
 *
 * Requirements:
 * 1. Fix bug trong handleDoubleClick (ph·∫£i tƒÉng 2 l·∫ßn)
 * 2. Fix bug trong handleDelayedIncrement (ph·∫£i d√πng latest value)
 * 3. Gi·∫£i th√≠ch T·∫†I SAO functional updates fix ƒë∆∞·ª£c bugs
 *
 * üí° G·ª£i √Ω: Thay direct updates b·∫±ng functional updates
 */

// ‚ùå CODE C√ì BUG:
function BuggyCounter() {
  const [count, setCount] = useState(0);

  // BUG: Ch·ªâ tƒÉng 1 l·∫ßn d√π g·ªçi 2 l·∫ßn
  const handleDoubleClick = () => {
    setCount(count + 1);
    setCount(count + 1);
  };

  // BUG: N·∫øu click nhi·ªÅu l·∫ßn nhanh, gi√° tr·ªã sai
  const handleDelayedIncrement = () => {
    setTimeout(() => {
      setCount(count + 1);
    }, 1000);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleDoubleClick}>+2 (BUG!)</button>
      <button onClick={handleDelayedIncrement}>+1 sau 1s (BUG!)</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

// ‚úÖ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
// TODO: Fix handleDoubleClick
// TODO: Fix handleDelayedIncrement
// TODO: Gi·∫£i th√≠ch t·∫°i sao fix n√†y work
```

<details>
<summary>üí° Solution</summary>

```jsx
function FixedCounter() {
  const [count, setCount] = useState(0);

  // ‚úÖ FIX: Functional updates
  const handleDoubleClick = () => {
    setCount((prev) => prev + 1); // prev = current value
    setCount((prev) => prev + 1); // prev = after first update
  };

  // ‚úÖ FIX: Functional updates v·ªõi async
  const handleDelayedIncrement = () => {
    setTimeout(() => {
      setCount((prev) => prev + 1); // prev = latest value khi timeout
    }, 1000);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleDoubleClick}>+2 ‚úÖ</button>
      <button onClick={handleDelayedIncrement}>+1 sau 1s ‚úÖ</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

/**
 * GI·∫¢I TH√çCH:
 *
 * Direct updates (count + 1):
 * - count l√† constant trong m·ªói render
 * - Closure capture gi√° tr·ªã t·∫°i th·ªùi ƒëi·ªÉm function ƒë∆∞·ª£c t·∫°o
 * - Multiple updates ƒë·ªçc c√πng 1 gi√° tr·ªã
 *
 * Functional updates (prev => prev + 1):
 * - prev lu√¥n l√† latest state value
 * - React queue c√°c updates
 * - M·ªói update nh·∫≠n output c·ªßa update tr∆∞·ªõc
 * - Kh√¥ng b·ªã stale closure v√¨ kh√¥ng depend on outer variable
 */
```

</details>

---

### ‚≠ê‚≠ê Exercise 2: Lazy Initialization Pattern (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Optimize expensive initialization
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Shopping cart app ƒë·ªçc t·ª´ localStorage
 *
 * ü§î PH√ÇN T√çCH:
 * Approach A: Direct initialization - useState(getCartFromStorage())
 * Pros: Code ng·∫Øn g·ªçn
 * Cons: Ch·∫°y m·ªói render, waste performance
 *
 * Approach B: Lazy initialization - useState(() => getCartFromStorage())
 * Pros: Ch·ªâ ch·∫°y 1 l·∫ßn on mount
 * Cons: Syntax h∆°i d√†i h∆°n (nh∆∞ng ƒë√°ng gi√°!)
 *
 * üí≠ B·∫†N CH·ªåN G√å V√Ä T·∫†I SAO?
 * Document quy·∫øt ƒë·ªãnh c·ªßa b·∫°n, sau ƒë√≥ implement.
 */

// Helper function (ƒë√£ c√≥ s·∫µn)
function getCartFromStorage() {
  console.log('üîç Reading from localStorage...');

  // Simulate expensive operation
  const start = Date.now();
  while (Date.now() - start < 50) {} // Block 50ms

  const saved = localStorage.getItem('cart');
  return saved ? JSON.parse(saved) : [];
}

// ‚ùå CODE C√ì PERFORMANCE ISSUE:
function ShoppingCart() {
  const [cart, setCart] = useState(getCartFromStorage()); // Ch·∫°y m·ªói render!
  const [searchTerm, setSearchTerm] = useState('');

  // M·ªói l·∫ßn g√µ search ‚Üí re-render ‚Üí getCartFromStorage() ch·∫°y l·∫°i!

  const addToCart = (product) => {
    setCart((prev) => [...prev, product]);
  };

  return (
    <div>
      <input
        placeholder='Search products...'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      <p>Cart: {cart.length} items</p>
      {/* M·ªói keystroke = 1 l·∫ßn ƒë·ªçc localStorage üò± */}
    </div>
  );
}

// ‚úÖ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
// TODO: Vi·∫øt version optimized v·ªõi lazy initialization
// TODO: Test b·∫±ng c√°ch g√µ v√†o search input
// TODO: Check console - getCartFromStorage() ch·ªâ log 1 l·∫ßn
// TODO: Document decision: Khi n√†o n√™n d√πng lazy init?
```

<details>
<summary>üí° Solution</summary>

```jsx
// ‚úÖ OPTIMIZED VERSION:
function ShoppingCartOptimized() {
  const [cart, setCart] = useState(() => getCartFromStorage()); // Function!
  const [searchTerm, setSearchTerm] = useState('');

  const addToCart = (product) => {
    setCart((prev) => {
      const newCart = [...prev, product];
      localStorage.setItem('cart', JSON.stringify(newCart));
      return newCart;
    });
  };

  return (
    <div>
      <input
        placeholder='Search products...'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      <p>Cart: {cart.length} items</p>
      <button onClick={() => addToCart({ id: Date.now(), name: 'Product' })}>
        Add Item
      </button>
    </div>
  );
}

/**
 * üìã DECISION DOCUMENT:
 *
 * Approach chosen: Lazy Initialization
 *
 * Rationale:
 * - getCartFromStorage() l√† expensive (I/O operation + JSON parse)
 * - Ch·ªâ c·∫ßn initial value 1 l·∫ßn
 * - Component re-render nhi·ªÅu l·∫ßn (search input changes)
 * - Performance gain ƒë√°ng k·ªÉ (50ms x N renders)
 *
 * When to use Lazy Initialization:
 * ‚úÖ Reading from localStorage/sessionStorage
 * ‚úÖ Complex calculations
 * ‚úÖ Reading from DOM
 * ‚úÖ Parsing large data structures
 *
 * When NOT needed:
 * ‚ùå Simple values (0, '', [], {})
 * ‚ùå Fast computations
 * ‚ùå Values already in memory
 */
```

</details>

---

### ‚≠ê‚≠ê‚≠ê Exercise 3: User Profile Form (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Qu·∫£n l√Ω complex form state v·ªõi immutability
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën edit profile v·ªõi th√¥ng tin personal v√† address"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Form c√≥ fields: firstName, lastName, email, phone
 * - [ ] Nested address: street, city, country
 * - [ ] Update fields kh√¥ng mutate state
 * - [ ] Reset button clear to√†n b·ªô form
 * - [ ] Display full name (derived from first + last)
 *
 * üé® Technical Constraints:
 * - D√πng 1 state object cho to√†n b·ªô form
 * - Immutable updates cho c·∫£ top-level v√† nested fields
 * - Kh√¥ng duplicate data (fullName ph·∫£i derived)
 *
 * üö® Edge Cases c·∫ßn handle:
 * - Empty string inputs
 * - Update nested fields kh√¥ng ·∫£nh h∆∞·ªüng top-level
 * - Reset ph·∫£i clear c·∫£ nested objects
 */

// ‚úÖ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:

// TODO 1: Design state structure
const INITIAL_STATE = {
  // TODO: Define structure
};

function UserProfileForm() {
  const [profile, setProfile] = useState(INITIAL_STATE);

  // TODO 2: Implement updateField (for top-level fields)
  const updateField = (field, value) => {
    // TODO: Immutable update
  };

  // TODO 3: Implement updateAddress (for nested fields)
  const updateAddress = (field, value) => {
    // TODO: Immutable nested update
  };

  // TODO 4: Implement handleReset
  const handleReset = () => {
    // TODO: Reset to initial state
  };

  // TODO 5: Compute derived state (fullName)
  const fullName = ''; // TODO: Derive from firstName + lastName

  return (
    <div>
      <h2>Edit Profile</h2>

      {/* TODO 6: Implement form fields */}
      <input placeholder='First Name' />
      <input placeholder='Last Name' />
      <input placeholder='Email' />
      <input placeholder='Phone' />

      <h3>Address</h3>
      <input placeholder='Street' />
      <input placeholder='City' />
      <input placeholder='Country' />

      <div>
        <p>Full Name: {fullName}</p>
        <button onClick={handleReset}>Reset</button>
      </div>

      {/* Debug view */}
      <pre>{JSON.stringify(profile, null, 2)}</pre>
    </div>
  );
}

// üìù Implementation Checklist:
// - [ ] State structure designed
// - [ ] updateField works for top-level
// - [ ] updateAddress works for nested
// - [ ] Reset clears everything
// - [ ] fullName derives correctly
// - [ ] No mutations anywhere
```

<details>
<summary>üí° Solution</summary>

```jsx
const INITIAL_STATE = {
  firstName: '',
  lastName: '',
  email: '',
  phone: '',
  address: {
    street: '',
    city: '',
    country: '',
  },
};

function UserProfileForm() {
  const [profile, setProfile] = useState(INITIAL_STATE);

  // ‚úÖ Update top-level field
  const updateField = (field, value) => {
    setProfile((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // ‚úÖ Update nested address field
  const updateAddress = (field, value) => {
    setProfile((prev) => ({
      ...prev,
      address: {
        ...prev.address,
        [field]: value,
      },
    }));
  };

  // ‚úÖ Reset to initial state
  const handleReset = () => {
    setProfile(INITIAL_STATE);
  };

  // ‚úÖ Derived state (computed, not stored)
  const fullName =
    `${profile.firstName} ${profile.lastName}`.trim() || '(Not set)';

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h2>Edit Profile</h2>

      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          gap: '10px',
          maxWidth: '400px',
        }}
      >
        <input
          placeholder='First Name'
          value={profile.firstName}
          onChange={(e) => updateField('firstName', e.target.value)}
        />
        <input
          placeholder='Last Name'
          value={profile.lastName}
          onChange={(e) => updateField('lastName', e.target.value)}
        />
        <input
          placeholder='Email'
          value={profile.email}
          onChange={(e) => updateField('email', e.target.value)}
        />
        <input
          placeholder='Phone'
          value={profile.phone}
          onChange={(e) => updateField('phone', e.target.value)}
        />

        <h3>Address</h3>
        <input
          placeholder='Street'
          value={profile.address.street}
          onChange={(e) => updateAddress('street', e.target.value)}
        />
        <input
          placeholder='City'
          value={profile.address.city}
          onChange={(e) => updateAddress('city', e.target.value)}
        />
        <input
          placeholder='Country'
          value={profile.address.country}
          onChange={(e) => updateAddress('country', e.target.value)}
        />

        <div
          style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
        >
          <p>
            <strong>Full Name:</strong> {fullName}
          </p>
          <button onClick={handleReset}>Reset Form</button>
        </div>

        <details>
          <summary>Debug: State</summary>
          <pre style={{ background: '#000', color: '#0f0', padding: '10px' }}>
            {JSON.stringify(profile, null, 2)}
          </pre>
        </details>
      </div>
    </div>
  );
}

/**
 * KEY LEARNINGS:
 *
 * 1. State Structure:
 *    - Group related data (personal info vs address)
 *    - Nested objects for logical grouping
 *
 * 2. Immutability:
 *    - Top-level: {...prev, field: value}
 *    - Nested: {...prev, nested: {...prev.nested, field: value}}
 *
 * 3. Derived State:
 *    - fullName computed from firstName + lastName
 *    - Kh√¥ng store ri√™ng ‚Üí lu√¥n sync
 *
 * 4. Reusable Patterns:
 *    - updateField: generic top-level updater
 *    - updateAddress: specific nested updater
 *    - Reset: restore to initial constant
 */
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê Exercise 4: Shopping Cart with Quantities (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Architectural decisions cho shopping cart
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * So s√°nh 3 approaches:
 *
 * A) Array of objects: [{id, name, price, quantity}, ...]
 * B) Object with IDs as keys: {[id]: {name, price, quantity}, ...}
 * C) Separate arrays: products[] + quantities[]
 *
 * Document pros/cons m·ªói approach, sau ƒë√≥ ch·ªçn 1.
 *
 * ADR Template:
 * - Context: Shopping cart c·∫ßn add/remove/update quantity
 * - Decision: Approach [A/B/C]
 * - Rationale: T·∫°i sao?
 * - Consequences: Trade-offs accepted
 * - Alternatives Considered: T·∫°i sao kh√¥ng ch·ªçn approach kh√°c?
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 *
 * Requirements:
 * - Add product to cart
 * - Remove product from cart
 * - Increase/decrease quantity
 * - Calculate total price (derived state)
 * - Clear cart
 *
 * üß™ PHASE 3: Testing (10 ph√∫t)
 * Manual testing checklist:
 * - [ ] Add same product twice ‚Üí quantity increases
 * - [ ] Decrease quantity to 0 ‚Üí remove from cart
 * - [ ] Total price updates correctly
 */

// Sample products
const PRODUCTS = [
  { id: 1, name: 'Laptop', price: 1000 },
  { id: 2, name: 'Mouse', price: 20 },
  { id: 3, name: 'Keyboard', price: 50 },
];

// ‚úÖ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:

// PHASE 1: Vi·∫øt ADR (Architecture Decision Record)
/**
 * ADR: Shopping Cart State Structure
 *
 * Context:
 * [TODO: M√¥ t·∫£ v·∫•n ƒë·ªÅ]
 *
 * Decision:
 * [TODO: Approach ƒë√£ ch·ªçn]
 *
 * Rationale:
 * [TODO: T·∫°i sao ch·ªçn approach n√†y]
 *
 * Consequences:
 * [TODO: Trade-offs accepted]
 *
 * Alternatives Considered:
 * [TODO: C√°c options kh√°c v√† t·∫°i sao kh√¥ng ch·ªçn]
 */

// PHASE 2: Implementation
function ShoppingCart() {
  const [cart, setCart] =
    useState(/* TODO: Initial state based on your decision */);

  const addToCart = (product) => {
    // TODO: Add product or increment quantity if exists
  };

  const removeFromCart = (productId) => {
    // TODO: Remove product
  };

  const increaseQuantity = (productId) => {
    // TODO: +1 quantity
  };

  const decreaseQuantity = (productId) => {
    // TODO: -1 quantity, remove if reaches 0
  };

  const clearCart = () => {
    // TODO: Clear all items
  };

  // TODO: Calculate total (derived state)
  const total = 0;

  return <div>{/* TODO: Implement UI */}</div>;
}

// PHASE 3: Write test cases
/**
 * Manual Test Cases:
 * 1. [TODO: Test scenario 1]
 * 2. [TODO: Test scenario 2]
 * 3. [TODO: Test scenario 3]
 */
```

<details>
<summary>üí° Solution v·ªõi ADR</summary>

```jsx
/**
 * ADR: Shopping Cart State Structure
 *
 * Context:
 * - C·∫ßn store products v·ªõi quantities
 * - Frequent operations: add, remove, update quantity
 * - Derive total price
 * - Check if product exists in cart
 *
 * Decision: Approach B - Object with product IDs as keys
 * {
 *   [productId]: { product, quantity }
 * }
 *
 * Rationale:
 * - O(1) lookup by ID (vs O(n) with array)
 * - Easy to check existence: cart[id]
 * - Easy to update quantity: {...cart, [id]: {}}
 * - Convert to array khi render: Object.values(cart)
 *
 * Consequences (Accepted Trade-offs):
 * - C·∫ßn Object.values() ƒë·ªÉ iterate
 * - Kh√¥ng c√≥ natural ordering (OK for cart)
 *
 * Alternatives Considered:
 * - Array approach (A): O(n) lookups, need .find() everywhere
 * - Separate arrays (C): Hard to keep in sync, complex updates
 */

const PRODUCTS = [
  { id: 1, name: 'Laptop', price: 1000 },
  { id: 2, name: 'Mouse', price: 20 },
  { id: 3, name: 'Keyboard', price: 50 },
];

function ShoppingCart() {
  // State: { [productId]: { product, quantity } }
  const [cart, setCart] = useState({});

  // Add or increment
  const addToCart = (product) => {
    setCart((prev) => {
      const existing = prev[product.id];

      if (existing) {
        // Product exists ‚Üí increment quantity
        return {
          ...prev,
          [product.id]: {
            ...existing,
            quantity: existing.quantity + 1,
          },
        };
      } else {
        // New product ‚Üí add with quantity 1
        return {
          ...prev,
          [product.id]: {
            product,
            quantity: 1,
          },
        };
      }
    });
  };

  // Remove product
  const removeFromCart = (productId) => {
    setCart((prev) => {
      const newCart = { ...prev };
      delete newCart[productId];
      return newCart;
    });
  };

  // Increase quantity
  const increaseQuantity = (productId) => {
    setCart((prev) => ({
      ...prev,
      [productId]: {
        ...prev[productId],
        quantity: prev[productId].quantity + 1,
      },
    }));
  };

  // Decrease quantity (remove if 0)
  const decreaseQuantity = (productId) => {
    setCart((prev) => {
      const item = prev[productId];

      if (item.quantity === 1) {
        // Remove if quantity becomes 0
        const newCart = { ...prev };
        delete newCart[productId];
        return newCart;
      } else {
        // Decrease quantity
        return {
          ...prev,
          [productId]: {
            ...item,
            quantity: item.quantity - 1,
          },
        };
      }
    });
  };

  // Clear cart
  const clearCart = () => {
    setCart({});
  };

  // ‚úÖ Derived state: total price
  const total = Object.values(cart).reduce(
    (sum, item) => sum + item.product.price * item.quantity,
    0,
  );

  // Convert to array for rendering
  const cartItems = Object.values(cart);

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h2>Shopping Cart</h2>

      {/* Product List */}
      <div style={{ marginBottom: '20px' }}>
        <h3>Products</h3>
        {PRODUCTS.map((product) => (
          <div
            key={product.id}
            style={{ marginBottom: '10px' }}
          >
            <span>
              {product.name} - ${product.price}
            </span>
            <button onClick={() => addToCart(product)}>Add to Cart</button>
          </div>
        ))}
      </div>

      {/* Cart Items */}
      <div>
        <h3>Cart ({cartItems.length} items)</h3>
        {cartItems.length === 0 ? (
          <p>Cart is empty</p>
        ) : (
          <>
            {cartItems.map((item) => (
              <div
                key={item.product.id}
                style={{
                  display: 'flex',
                  gap: '10px',
                  alignItems: 'center',
                  marginBottom: '10px',
                }}
              >
                <span>{item.product.name}</span>
                <button onClick={() => decreaseQuantity(item.product.id)}>
                  -
                </button>
                <span>{item.quantity}</span>
                <button onClick={() => increaseQuantity(item.product.id)}>
                  +
                </button>
                <span>${item.product.price * item.quantity}</span>
                <button onClick={() => removeFromCart(item.product.id)}>
                  Remove
                </button>
              </div>
            ))}

            <div
              style={{
                marginTop: '20px',
                padding: '10px',
                background: '#f0f0f0',
              }}
            >
              <strong>Total: ${total}</strong>
              <button
                onClick={clearCart}
                style={{ marginLeft: '10px' }}
              >
                Clear Cart
              </button>
            </div>
          </>
        )}
      </div>

      {/* Debug */}
      <details style={{ marginTop: '20px' }}>
        <summary>Debug: Cart State</summary>
        <pre style={{ background: '#000', color: '#0f0', padding: '10px' }}>
          {JSON.stringify(cart, null, 2)}
        </pre>
      </details>
    </div>
  );
}

/**
 * Manual Test Cases:
 *
 * ‚úÖ Test 1: Add same product twice
 * - Click "Add to Cart" 2 l·∫ßn cho Laptop
 * - Expect: Quantity = 2, Total = $2000
 *
 * ‚úÖ Test 2: Decrease to zero removes item
 * - Add Mouse, click "-" button
 * - Expect: Mouse removed from cart
 *
 * ‚úÖ Test 3: Total updates correctly
 * - Add Laptop (1000), Mouse (20), Keyboard (50)
 * - Increase Laptop quantity to 2
 * - Expect: Total = 2000 + 20 + 50 = $2070
 *
 * ‚úÖ Test 4: Clear cart works
 * - Add multiple items
 * - Click "Clear Cart"
 * - Expect: Cart empty, Total = $0
 */
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Exercise 5: Advanced Todo App with Categories (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Production-ready todo app
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 * - Add/Edit/Delete todos
 * - Mark as complete/incomplete
 * - Assign category to each todo
 * - Filter by category
 * - Filter by status (all/active/completed)
 * - Persist to localStorage
 * - Show statistics (total, active, completed per category)
 *
 * üèóÔ∏è Technical Design Doc:
 * 1. Component Architecture: Single component (Ng√†y 12 ch∆∞a h·ªçc composition)
 * 2. State Management: useState v·ªõi proper structure
 * 3. Data Structure: Array vs Object trade-offs
 * 4. Performance: Lazy initialization cho localStorage
 * 5. Derived State: Statistics computed, not stored
 *
 * ‚úÖ Production Checklist:
 * - [ ] Proper state structure (justify your choice)
 * - [ ] Immutable updates throughout
 * - [ ] Lazy initialization for localStorage
 * - [ ] Derived state for statistics
 * - [ ] No duplicate state
 * - [ ] Input validation (empty strings)
 * - [ ] Edge cases handled (delete last todo, etc.)
 * - [ ] Clear variable names
 * - [ ] Comments explaining complex logic
 *
 * üìù Documentation:
 * - Write ADR cho state structure decision
 * - Comment complex immutability patterns
 * - Document filter logic
 */

const CATEGORIES = ['Work', 'Personal', 'Shopping'];

// Starter code
function AdvancedTodoApp() {
  // TODO: Design state structure
  // Consider:
  // - How to store todos?
  // - How to store current filters?
  // - What should be in state vs derived?

  const [todos, setTodos] = useState(() => {
    // TODO: Lazy initialization from localStorage
  });

  const [filter, setFilter] = useState(/* TODO */);
  const [categoryFilter, setCategoryFilter] = useState(/* TODO */);

  // TODO: Implement CRUD operations
  const addTodo = (text, category) => {};
  const toggleTodo = (id) => {};
  const deleteTodo = (id) => {};
  const editTodo = (id, newText) => {};

  // TODO: Derive filtered todos
  const filteredTodos = todos; // Replace with actual filter logic

  // TODO: Derive statistics
  const stats = {
    total: 0,
    active: 0,
    completed: 0,
    byCategory: {},
  };

  // TODO: Persist to localStorage when todos change
  // (Hint: You'll learn useEffect tomorrow, for now just add comment)

  return <div>{/* TODO: Implement UI */}</div>;
}
```

<details>
<summary>üí° Full Solution</summary>

```jsx
/**
 * ADR: Advanced Todo App State Structure
 *
 * Decision: Array of todo objects + separate filter states
 *
 * State shape:
 * {
 *   todos: [{ id, text, category, completed, createdAt }, ...],
 *   statusFilter: 'all' | 'active' | 'completed',
 *   categoryFilter: 'all' | 'Work' | 'Personal' | 'Shopping'
 * }
 *
 * Rationale:
 * - Array natural for ordered list
 * - Filters in separate state ‚Üí easy to reset independently
 * - Statistics derived ‚Üí always in sync
 * - Compatible v·ªõi localStorage (JSON.stringify/parse)
 *
 * Trade-offs Accepted:
 * - O(n) operations (acceptable for todo lists)
 * - Need .find() for lookups (not frequent)
 */

const CATEGORIES = ['Work', 'Personal', 'Shopping'];

function AdvancedTodoApp() {
  // ‚úÖ Lazy initialization from localStorage
  const [todos, setTodos] = useState(() => {
    const saved = localStorage.getItem('advanced-todos');
    return saved ? JSON.parse(saved) : [];
  });

  const [statusFilter, setStatusFilter] = useState('all');
  const [categoryFilter, setCategoryFilter] = useState('all');
  const [inputText, setInputText] = useState('');
  const [inputCategory, setInputCategory] = useState(CATEGORIES[0]);
  const [editingId, setEditingId] = useState(null);

  // ‚úÖ Add todo v·ªõi validation
  const addTodo = () => {
    const trimmed = inputText.trim();
    if (!trimmed) return; // Validate

    const newTodo = {
      id: Date.now(),
      text: trimmed,
      category: inputCategory,
      completed: false,
      createdAt: new Date().toISOString(),
    };

    setTodos((prev) => {
      const updated = [...prev, newTodo];
      localStorage.setItem('advanced-todos', JSON.stringify(updated));
      return updated;
    });

    setInputText(''); // Clear input
  };

  // ‚úÖ Toggle complete status
  const toggleTodo = (id) => {
    setTodos((prev) => {
      const updated = prev.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo,
      );
      localStorage.setItem('advanced-todos', JSON.stringify(updated));
      return updated;
    });
  };

  // ‚úÖ Delete todo
  const deleteTodo = (id) => {
    setTodos((prev) => {
      const updated = prev.filter((todo) => todo.id !== id);
      localStorage.setItem('advanced-todos', JSON.stringify(updated));
      return updated;
    });
  };

  // ‚úÖ Edit todo
  const startEdit = (id) => {
    const todo = todos.find((t) => t.id === id);
    setEditingId(id);
    setInputText(todo.text);
  };

  const saveEdit = () => {
    const trimmed = inputText.trim();
    if (!trimmed) return;

    setTodos((prev) => {
      const updated = prev.map((todo) =>
        todo.id === editingId ? { ...todo, text: trimmed } : todo,
      );
      localStorage.setItem('advanced-todos', JSON.stringify(updated));
      return updated;
    });

    setEditingId(null);
    setInputText('');
  };

  // ‚úÖ Derived: Filtered todos
  const filteredTodos = todos.filter((todo) => {
    // Status filter
    if (statusFilter === 'active' && todo.completed) return false;
    if (statusFilter === 'completed' && !todo.completed) return false;

    // Category filter
    if (categoryFilter !== 'all' && todo.category !== categoryFilter)
      return false;

    return true;
  });

  // ‚úÖ Derived: Statistics
  const stats = todos.reduce(
    (acc, todo) => {
      acc.total++;
      if (todo.completed) {
        acc.completed++;
      } else {
        acc.active++;
      }

      // By category
      if (!acc.byCategory[todo.category]) {
        acc.byCategory[todo.category] = { total: 0, active: 0, completed: 0 };
      }
      acc.byCategory[todo.category].total++;
      if (todo.completed) {
        acc.byCategory[todo.category].completed++;
      } else {
        acc.byCategory[todo.category].active++;
      }

      return acc;
    },
    {
      total: 0,
      active: 0,
      completed: 0,
      byCategory: {},
    },
  );

  return (
    <div
      style={{
        padding: '20px',
        fontFamily: 'system-ui',
        maxWidth: '800px',
        margin: '0 auto',
      }}
    >
      <h1>üìù Advanced Todo App</h1>

      {/* Add/Edit Form */}
      <div
        style={{
          marginBottom: '20px',
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
        }}
      >
        <input
          type='text'
          value={inputText}
          onChange={(e) => setInputText(e.target.value)}
          onKeyPress={(e) =>
            e.key === 'Enter' && (editingId ? saveEdit() : addTodo())
          }
          placeholder='Enter todo...'
          style={{ padding: '8px', width: '300px', marginRight: '10px' }}
        />

        {!editingId && (
          <select
            value={inputCategory}
            onChange={(e) => setInputCategory(e.target.value)}
            style={{ padding: '8px', marginRight: '10px' }}
          >
            {CATEGORIES.map((cat) => (
              <option
                key={cat}
                value={cat}
              >
                {cat}
              </option>
            ))}
          </select>
        )}

        {editingId ? (
          <>
            <button onClick={saveEdit}>Save</button>
            <button
              onClick={() => {
                setEditingId(null);
                setInputText('');
              }}
            >
              Cancel
            </button>
          </>
        ) : (
          <button onClick={addTodo}>Add Todo</button>
        )}
      </div>

      {/* Filters */}
      <div style={{ marginBottom: '20px', display: 'flex', gap: '20px' }}>
        <div>
          <strong>Status:</strong>{' '}
          {['all', 'active', 'completed'].map((status) => (
            <button
              key={status}
              onClick={() => setStatusFilter(status)}
              style={{
                marginLeft: '5px',
                fontWeight: statusFilter === status ? 'bold' : 'normal',
              }}
            >
              {status}
            </button>
          ))}
        </div>

        <div>
          <strong>Category:</strong>{' '}
          <button
            onClick={() => setCategoryFilter('all')}
            style={{ fontWeight: categoryFilter === 'all' ? 'bold' : 'normal' }}
          >
            All
          </button>
          {CATEGORIES.map((cat) => (
            <button
              key={cat}
              onClick={() => setCategoryFilter(cat)}
              style={{
                marginLeft: '5px',
                fontWeight: categoryFilter === cat ? 'bold' : 'normal',
              }}
            >
              {cat}
            </button>
          ))}
        </div>
      </div>

      {/* Statistics */}
      <div
        style={{
          marginBottom: '20px',
          padding: '15px',
          background: '#e3f2fd',
          borderRadius: '8px',
        }}
      >
        <h3>üìä Statistics</h3>
        <p>
          Total: {stats.total} | Active: {stats.active} | Completed:{' '}
          {stats.completed}
        </p>
        <div style={{ display: 'flex', gap: '20px', marginTop: '10px' }}>
          {CATEGORIES.map((cat) => {
            const catStats = stats.byCategory[cat] || {
              total: 0,
              active: 0,
              completed: 0,
            };
            return (
              <div
                key={cat}
                style={{
                  padding: '10px',
                  background: 'white',
                  borderRadius: '4px',
                }}
              >
                <strong>{cat}</strong>
                <div style={{ fontSize: '0.9em', marginTop: '5px' }}>
                  Total: {catStats.total} | Active: {catStats.active} | Done:{' '}
                  {catStats.completed}
                </div>
              </div>
            );
          })}
        </div>
      </div>

      {/* Todo List */}
      <div>
        <h3>Todos ({filteredTodos.length})</h3>
        {filteredTodos.length === 0 ? (
          <p style={{ color: '#999' }}>No todos match current filters</p>
        ) : (
          filteredTodos.map((todo) => (
            <div
              key={todo.id}
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: '10px',
                padding: '10px',
                marginBottom: '8px',
                background: todo.completed ? '#f0f0f0' : 'white',
                border: '1px solid #ddd',
                borderRadius: '4px',
              }}
            >
              <input
                type='checkbox'
                checked={todo.completed}
                onChange={() => toggleTodo(todo.id)}
              />
              <span
                style={{
                  flex: 1,
                  textDecoration: todo.completed ? 'line-through' : 'none',
                  color: todo.completed ? '#999' : '#000',
                }}
              >
                {todo.text}
              </span>
              <span
                style={{
                  padding: '2px 8px',
                  background: '#e0e0e0',
                  borderRadius: '12px',
                  fontSize: '0.85em',
                }}
              >
                {todo.category}
              </span>
              <button onClick={() => startEdit(todo.id)}>Edit</button>
              <button onClick={() => deleteTodo(todo.id)}>Delete</button>
            </div>
          ))
        )}
      </div>

      {/* Debug */}
      <details style={{ marginTop: '30px' }}>
        <summary>üîç Debug: Raw State</summary>
        <pre
          style={{
            background: '#000',
            color: '#0f0',
            padding: '15px',
            overflow: 'auto',
          }}
        >
          {JSON.stringify({ todos, statusFilter, categoryFilter }, null, 2)}
        </pre>
      </details>
    </div>
  );
}

/**
 * C√ÅC PATTERN CHU·∫®N D√ôNG TRONG PRODUCTION:
 *
 * 1. ‚úÖ Kh·ªüi t·∫°o Lazy (Lazy Initialization):
 *    - Ch·ªâ ƒë·ªçc localStorage m·ªôt l·∫ßn khi mount
 *    - T√°c v·ª• t·ªën k√©m kh√¥ng ch·∫°y l·∫°i m·ªói l·∫ßn render
 *
 * 2. ‚úÖ B·∫•t bi·∫øn (Immutability):
 *    - map() ƒë·ªÉ c·∫≠p nh·∫≠t
 *    - filter() ƒë·ªÉ xo√°
 *    - spread ƒë·ªÉ th√™m
 *
 * 3. ‚úÖ State t·ª± suy (Derived State):
 *    - filteredTodos ƒë∆∞·ª£c t√≠nh t·ª´ todos + filters
 *    - stats ƒë∆∞·ª£c t√≠nh t·ª´ todos
 *    - Kh√¥ng duplicate ‚Üí lu√¥n ƒë·ªìng b·ªô
 *
 * 4. ‚úÖ X√°c th·ª±c h·ª£p l·ªá (Validation):
 *    - .trim() chu·ªói r·ªóng
 *    - Return s·ªõm (early return)
 *
 * 5. ‚úÖ T√≠nh L∆∞u tr·ªØ (Persistence):
 *    - localStorage.setItem sau m·ªói l·∫ßn thay ƒë·ªïi
 *    - (Ghi ch√∫: d√πng useEffect s·∫Ω g·ªçn h∆°n!)
 *
 * 6. ‚úÖ Ho√†n thi·ªán UX:
 *    - Xo√° input sau khi th√™m
 *    - Nh·∫•n Enter ƒë·ªÉ submit
 *    - Ch·∫ø ƒë·ªô edit c√≥ hu·ª∑ (cancel)
 *    - Ph·∫£n h·ªìi tr·ª±c quan (g·∫°ch ngang, m√†u s·∫Øc)
 */
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh Trade-offs

| Pattern                                                 | Pros ‚úÖ                                                                     | Cons ‚ùå                                                                        | When to Use üéØ                                                                          |
| ------------------------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- |
| **Direct Updates**<br/>`setCount(count + 1)`            | ‚Ä¢ ƒê∆°n gi·∫£n, d·ªÖ ƒë·ªçc<br/>‚Ä¢ √çt code h∆°n                                        | ‚Ä¢ Stale closure bugs<br/>‚Ä¢ Kh√¥ng work v·ªõi async<br/>‚Ä¢ Sai v·ªõi multiple updates | ‚Ä¢ Single update ƒë∆°n gi·∫£n<br/>‚Ä¢ Kh√¥ng c√≥ async/events                                    |
| **Functional Updates**<br/>`setCount(prev => prev + 1)` | ‚Ä¢ Lu√¥n c√≥ latest value<br/>‚Ä¢ Work v·ªõi async<br/>‚Ä¢ Safe v·ªõi multiple updates | ‚Ä¢ H∆°i verbose h∆°n<br/>‚Ä¢ C·∫ßn hi·ªÉu closure                                       | ‚Ä¢ Async operations<br/>‚Ä¢ Multiple updates<br/>‚Ä¢ Event handlers<br/>‚Ä¢ **DEFAULT CHOICE** |
| **Lazy Initialization**<br/>`useState(() => fn())`      | ‚Ä¢ Ch·ªâ ch·∫°y 1 l·∫ßn<br/>‚Ä¢ Optimize performance                                 | ‚Ä¢ Th√™m boilerplate<br/>‚Ä¢ Ph·ª©c t·∫°p h∆°n cho simple values                        | ‚Ä¢ Reading localStorage<br/>‚Ä¢ Expensive computation<br/>‚Ä¢ Heavy parsing                  |
| **Multiple States**<br/>`[a, setA], [b, setB]`          | ‚Ä¢ Clear separation<br/>‚Ä¢ Easy to understand                                 | ‚Ä¢ Many setter functions<br/>‚Ä¢ Hard to reset together<br/>‚Ä¢ Prop drilling       | ‚Ä¢ Unrelated values<br/>‚Ä¢ Different update patterns                                      |
| **Single Object State**<br/>`{a, b, c}`                 | ‚Ä¢ Group related data<br/>‚Ä¢ Easy to reset<br/>‚Ä¢ Pass to children             | ‚Ä¢ Complex updates<br/>‚Ä¢ Easy to mutate accidentally<br/>‚Ä¢ Spread overhead      | ‚Ä¢ Form data<br/>‚Ä¢ User profile<br/>‚Ä¢ Related values                                     |

---

### Decision Tree

```
Q1: ƒê√¢y c√≥ ph·∫£i l√† gi√° tr·ªã kh·ªüi t·∫°o t·ªën k√©m ƒë·ªÉ t√≠nh to√°n kh√¥ng?
‚îú‚îÄ C√ì  ‚Üí D√πng kh·ªüi t·∫°o l∆∞·ªùi (lazy initialization): useState(() => fn())
‚îî‚îÄ KH√îNG ‚Üí Ti·∫øp t·ª•c Q2

Q2: State c√≥ ƒë∆∞·ª£c c·∫≠p nh·∫≠t d·ª±a tr√™n gi√° tr·ªã tr∆∞·ªõc ƒë√≥ kh√¥ng?
‚îú‚îÄ C√ì  ‚Üí D√πng c·∫≠p nh·∫≠t d·∫°ng h√†m (functional updates): setState(prev => ...)
‚îÇ        (ƒë·∫∑c bi·ªát trong async/s·ª± ki·ªán)
‚îî‚îÄ KH√îNG ‚Üí Ti·∫øp t·ª•c Q3

Q3: C√°c gi√° tr·ªã n√†y c√≥ li√™n quan/c·∫≠p nh·∫≠t c√πng nhau kh√¥ng?
‚îú‚îÄ C√ì  ‚Üí D√πng m·ªôt state object duy nh·∫•t: useState({a, b, c})
‚îî‚îÄ KH√îNG ‚Üí D√πng c√°c state ri√™ng bi·ªát: useState(a), useState(b)

Q4: B·∫°n c√≥ ƒëang c·∫≠p nh·∫≠t object ho·∫∑c array kh√¥ng?
‚îî‚îÄ LU√îN LU√îN ‚Üí D√πng c√°c m·∫´u b·∫•t bi·∫øn (immutability):
           ‚Ä¢ Object: {...prev, key: value}
           ‚Ä¢ Array: [...prev, item] ho·∫∑c .map()/.filter()

Q5: Gi√° tr·ªã n√†y c√≥ th·ªÉ ƒë∆∞·ª£c t√≠nh t·ª´ state kh√°c kh√¥ng?
‚îî‚îÄ C√ì  ‚Üí ƒê·ª™NG l∆∞u n√≥! H√£y suy ra:
         const fullName = firstName + lastName
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Stale Closure trong Event Handler ‚≠ê

```jsx
// üêõ BUG: Counter kh√¥ng tƒÉng ƒë√∫ng khi click nhanh
function BuggyCounter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setTimeout(() => {
      setCount(count + 1); // BUG HERE
    }, 100);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Click me fast!</button>
    </div>
  );
}

/**
 * üîç DEBUG QUESTIONS:
 * 1. Click button 5 l·∫ßn nhanh. Count s·∫Ω l√† bao nhi√™u? T·∫°i sao?
 * 2. V·∫•n ƒë·ªÅ n·∫±m ·ªü ƒë√¢u?
 * 3. L√†m th·∫ø n√†o ƒë·ªÉ fix?
 */
```

<details>
<summary>üí° Solution</summary>

**V·∫•n ƒë·ªÅ:**

- M·ªói click t·∫°o 1 setTimeout v·ªõi closure capture `count` t·∫°i th·ªùi ƒëi·ªÉm click
- T·∫•t c·∫£ 5 setTimeout ƒë·ªÅu ƒë·ªçc `count = 0`
- Khi ch·∫°y, t·∫•t c·∫£ ƒë·ªÅu set `count = 1`
- K·∫øt qu·∫£: `count = 1` (kh√¥ng ph·∫£i 5!)

**Fix:**

```jsx
const handleClick = () => {
  setTimeout(() => {
    setCount((prev) => prev + 1); // ‚úÖ Use latest value
  }, 100);
};
```

**Lesson:** Lu√¥n d√πng functional updates trong async operations!

</details>

---

### Bug 2: Mutating State Object ‚≠ê‚≠ê

```jsx
// üêõ BUG: Form kh√¥ng update khi g√µ
function BuggyForm() {
  const [user, setUser] = useState({ name: '', email: '' });

  const handleChange = (field, value) => {
    user[field] = value; // BUG: Mutating!
    setUser(user); // BUG: Same reference!
  };

  return (
    <div>
      <input
        value={user.name}
        onChange={(e) => handleChange('name', e.target.value)}
      />
      <pre>{JSON.stringify(user)}</pre>
    </div>
  );
}

/**
 * üîç DEBUG QUESTIONS:
 * 1. T·∫°i sao input kh√¥ng hi·ªÉn th·ªã text khi g√µ?
 * 2. JSON.stringify c√≥ update kh√¥ng? T·∫°i sao?
 * 3. L√†m th·∫ø n√†o ƒë·ªÉ fix?
 */
```

<details>
<summary>üí° Solution</summary>

**V·∫•n ƒë·ªÅ:**

- Line 5: Mutating object directly (vi ph·∫°m immutability)
- Line 6: `setUser(user)` - same reference, React kh√¥ng detect change
- React so s√°nh references (===), kh√¥ng deep compare
- V√¨ reference gi·ªëng nhau ‚Üí kh√¥ng re-render

**Fix:**

```jsx
const handleChange = (field, value) => {
  setUser((prev) => ({
    ...prev, // Create new object
    [field]: value,
  }));
};
```

**Lesson:** Never mutate state! Always create new objects/arrays.

</details>

---

### Bug 3: Kh√¥ng C·∫ßn Thi·∫øt Store Derived State ‚≠ê‚≠ê‚≠ê

```jsx
// üêõ BUG: fullName out of sync
function BuggyProfile() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState(''); // BUG: Duplicate state

  const updateFirstName = (value) => {
    setFirstName(value);
    setFullName(value + ' ' + lastName); // BUG: Can forget to update
  };

  const updateLastName = (value) => {
    setLastName(value);
    // BUG: Forgot to update fullName!
  };

  return (
    <div>
      <input
        value={firstName}
        onChange={(e) => updateFirstName(e.target.value)}
      />
      <input
        value={lastName}
        onChange={(e) => updateLastName(e.target.value)}
      />
      <p>Full Name: {fullName}</p>
    </div>
  );
}

/**
 * üîç DEBUG QUESTIONS:
 * 1. G√µ v√†o firstName ‚Üí fullName update. G√µ lastName ‚Üí fullName c√≥ update kh√¥ng?
 * 2. V·∫•n ƒë·ªÅ g√¨ v·ªõi c√°ch store fullName in state?
 * 3. Solution t·ªët h∆°n l√† g√¨?
 */
```

<details>
<summary>üí° Solution</summary>

**V·∫•n ƒë·ªÅ:**

- fullName l√† **derived state** - c√≥ th·ªÉ t√≠nh t·ª´ firstName + lastName
- Store ri√™ng ‚Üí ph·∫£i manually sync ‚Üí d·ªÖ qu√™n ‚Üí bug!
- Line 14: Qu√™n update fullName khi lastName thay ƒë·ªïi

**Fix:**

```jsx
function FixedProfile() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // ‚úÖ Derive, don't store
  const fullName = `${firstName} ${lastName}`.trim();

  return (
    <div>
      <input
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
      />
      <input
        value={lastName}
        onChange={(e) => setLastName(e.target.value)}
      />
      <p>Full Name: {fullName}</p>
    </div>
  );
}
```

**Lesson:** Don't duplicate state! If it can be computed, compute it.

**Rule of Thumb:**

```jsx
// ‚ùå BAD: Storing derived value
const [items, setItems] = useState([]);
const [itemCount, setItemCount] = useState(0); // Duplicate!

// ‚úÖ GOOD: Computing derived value
const [items, setItems] = useState([]);
const itemCount = items.length; // Compute!
```

</details>

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

ƒê√°nh d·∫•u nh·ªØng g√¨ b·∫°n ƒë√£ hi·ªÉu:

- [ ] T√¥i hi·ªÉu stale closure l√† g√¨ v√† t·∫°i sao x·∫£y ra
- [ ] T√¥i bi·∫øt khi n√†o d√πng functional updates vs direct updates
- [ ] T√¥i c√≥ th·ªÉ gi·∫£i th√≠ch lazy initialization v√† khi n√†o d√πng
- [ ] T√¥i bi·∫øt c√°ch update objects immutably v·ªõi spread
- [ ] T√¥i bi·∫øt c√°ch update arrays immutably v·ªõi map/filter/concat
- [ ] T√¥i bi·∫øt khi n√†o n√™n group state vs split state
- [ ] T√¥i hi·ªÉu derived state v√† tr√°nh duplicate state
- [ ] T√¥i c√≥ th·ªÉ debug stale closure bugs
- [ ] T√¥i c√≥ th·ªÉ debug mutation bugs
- [ ] T√¥i hi·ªÉu trade-offs c·ªßa m·ªói pattern

### Code Review Checklist

Khi review code useState, check:

**Functional Updates:**

- [ ] D√πng `prev => ...` khi update d·ª±a tr√™n previous value
- [ ] D√πng functional updates trong async operations
- [ ] D√πng functional updates trong event handlers

**Lazy Initialization:**

- [ ] D√πng `() => fn()` cho expensive initial values
- [ ] KH√îNG d√πng lazy init cho simple values

**Immutability:**

- [ ] Objects: `{...prev, key: value}` (kh√¥ng mutate)
- [ ] Arrays: `[...prev]`, `.map()`, `.filter()` (kh√¥ng mutate)
- [ ] Nested: Spread ·ªü m·ªçi level

**State Structure:**

- [ ] Related values grouped together
- [ ] Unrelated values separated
- [ ] No derived state duplication

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**Exercise: Fix Production Bugs**

```
BuggyApp/
‚îú‚îÄ CounterBug.jsx       // Stale closure
‚îú‚îÄ FormBug.jsx          // Mutation
‚îú‚îÄ ProfileBug.jsx       // Derived state
‚îî‚îÄ CartBug.jsx          // Lazy init missing
```

Nhi·ªám v·ª•:

1. T√¨m v√† fix bug trong m·ªói file
2. Gi·∫£i th√≠ch t·∫°i sao bug x·∫£y ra
3. Vi·∫øt test case ƒë·ªÉ verify fix

#### CounterBug.jsx

```jsx
import { useState } from 'react';

function CounterBug() {
  const [count, setCount] = useState(0);

  const handleBurst = () => {
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        setCount(count + 1);
      }, i * 100);
    }
  };

  return (
    <div>
      <h3>Count: {count}</h3>
      <button onClick={handleBurst}>Burst +5 (sai)</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

export default CounterBug;
```

<details>
<summary>üí° Xem ƒë√°p √°n</summary>

```jsx
import { useState } from 'react';

/**
 * CounterBug - Fixed version
 * V·∫•n ƒë·ªÅ g·ªëc: stale closure trong setTimeout + burst click
 * M·ªói l·∫ßn click t·∫°o nhi·ªÅu setTimeout, t·∫•t c·∫£ ƒë·ªÅu capture c√πng gi√° tr·ªã count c≈©
 */
function CounterBugFixed() {
  const [count, setCount] = useState(0);

  const handleBurst = () => {
    for (let i = 0; i < 5; i++) {
      setTimeout(() => {
        // ‚ùå Sai: setCount(count + 1) ‚Üí t·∫•t c·∫£ ƒë·ªÅu d√πng count l√∫c click
        // ‚úÖ ƒê√∫ng: d√πng functional update ‚Üí lu√¥n l·∫•y gi√° tr·ªã m·ªõi nh·∫•t
        setCount((prevCount) => prevCount + 1);

        // Optional: log ƒë·ªÉ debug
        // console.log(`Timeout ${i} running, count became: ${prevCount + 1}`);
      }, i * 100);
    }
  };

  return (
    <div>
      <h3>Count: {count}</h3>
      <button onClick={handleBurst}>Burst +5 (ƒë√∫ng)</button>
      <button onClick={() => setCount(0)}>Reset</button>

      {/* Gi·∫£i th√≠ch ng·∫Øn g·ªçn cho ng∆∞·ªùi ƒë·ªçc code */}
      <small style={{ color: '#666', display: 'block', marginTop: 12 }}>
        Click nhi·ªÅu l·∫ßn nhanh ‚Üí m·ªói timeout s·∫Ω tƒÉng count ch√≠nh x√°c (kh√¥ng b·ªã
        stale)
      </small>
    </div>
  );
}

export default CounterBugFixed;
```

**Test case g·ª£i √Ω:**

- Click "Burst +5" 1 l·∫ßn ‚Üí count tƒÉng ƒë√∫ng 5
- Click li√™n t·ª•c 3 l·∫ßn nhanh ‚Üí count tƒÉng ~15 (c√≥ th·ªÉ l·ªách nh·∫π do timing, nh∆∞ng kh√¥ng b·ªã k·∫πt ·ªü +5)
</details>

---

#### FormBug.jsx

```jsx
import { useState } from 'react';

function FormBug() {
  const [form, setForm] = useState({
    name: '',
    email: '',
    address: { city: 'HCMC', district: '' },
  });

  const handleChange = (path, value) => {
    const parts = path.split('.');
    let current = form;

    if (parts.length === 2) {
      current[parts[0]][parts[1]] = value; // mutation
    } else {
      current[parts[0]] = value;
    }

    setForm(form); // same reference ‚Üí kh√¥ng re-render
  };

  return (
    <div>
      <input
        value={form.name}
        onChange={(e) => handleChange('name', e.target.value)}
        placeholder='Name'
      />
      <input
        value={form.email}
        onChange={(e) => handleChange('email', e.target.value)}
        placeholder='Email'
      />
      <input
        value={form.address.district}
        onChange={(e) => handleChange('address.district', e.target.value)}
        placeholder='District'
      />
      <pre>{JSON.stringify(form, null, 2)}</pre>
    </div>
  );
}

export default FormBug;
```

<details>
<summary>üí° Xem ƒë√°p √°n</summary>

```jsx
import { useState } from 'react';

/**
 * FormBug - Fixed version
 * V·∫•n ƒë·ªÅ g·ªëc:
 * 1. Mutate object tr·ª±c ti·∫øp ‚Üí vi ph·∫°m immutability
 * 2. setForm(form) ‚Üí truy·ªÅn c√πng reference ‚Üí React kh√¥ng re-render
 */
function FormBugFixed() {
  const [form, setForm] = useState({
    name: '',
    email: '',
    address: { city: 'HCMC', district: '' },
  });

  const handleChange = (path, value) => {
    const parts = path.split('.');

    setForm((prev) => {
      // T·∫°o b·∫£n sao m·ªõi
      if (parts.length === 1) {
        // C·∫≠p nh·∫≠t top-level
        return {
          ...prev,
          [parts[0]]: value,
        };
      }

      // C·∫≠p nh·∫≠t nested (address.district)
      if (parts.length === 2 && parts[0] === 'address') {
        return {
          ...prev,
          address: {
            ...prev.address,
            [parts[1]]: value,
          },
        };
      }

      // Tr∆∞·ªùng h·ª£p kh√°c (n·∫øu m·ªü r·ªông sau n√†y)
      return prev;
    });
  };

  return (
    <div>
      <input
        value={form.name}
        onChange={(e) => handleChange('name', e.target.value)}
        placeholder='Name'
      />
      <input
        value={form.email}
        onChange={(e) => handleChange('email', e.target.value)}
        placeholder='Email'
      />
      <input
        value={form.address.district}
        onChange={(e) => handleChange('address.district', e.target.value)}
        placeholder='District'
      />

      <pre style={{ fontSize: '0.9em', background: '#f8f8f8', padding: 12 }}>
        {JSON.stringify(form, null, 2)}
      </pre>

      <small style={{ color: '#555' }}>
        B√¢y gi·ªù g√µ v√†o b·∫•t k·ª≥ field n√†o c≈©ng s·∫Ω c·∫≠p nh·∫≠t v√† re-render ƒë√∫ng
      </small>
    </div>
  );
}

export default FormBugFixed;
```

**Test case g·ª£i √Ω:**

- G√µ v√†o Name ‚Üí th·∫•y state v√† UI c·∫≠p nh·∫≠t ngay
- G√µ v√†o District ‚Üí address.district thay ƒë·ªïi, kh√¥ng b·ªã m·∫•t d·ªØ li·ªáu kh√°c
</details>

---

#### ProfileBug.jsx

```jsx
import { useState } from 'react';

function ProfileBug() {
  const [user, setUser] = useState({ first: '', last: '' });
  const [fullName, setFullName] = useState(''); // duplicate derived state

  const update = (field, value) => {
    setUser((prev) => ({ ...prev, [field]: value }));

    // Manual sync ‚Äì d·ªÖ qu√™n
    if (field === 'first') {
      setFullName(value + ' ' + user.last);
    } else if (field === 'last') {
      setFullName(user.first + ' ' + value);
    }
  };

  return (
    <div>
      <input
        value={user.first}
        onChange={(e) => update('first', e.target.value)}
        placeholder='First name'
      />
      <input
        value={user.last}
        onChange={(e) => update('last', e.target.value)}
        placeholder='Last name'
      />
      <p>Full name: {fullName || '(ch∆∞a ƒë·ªìng b·ªô)'}</p>
    </div>
  );
}

export default ProfileBug;
```

<details>
<summary>üí° Xem ƒë√°p √°n</summary>

```jsx
import { useState } from 'react';

/**
 * ProfileBug - Fixed version
 * V·∫•n ƒë·ªÅ g·ªëc:
 *   L∆∞u fullName ri√™ng ‚Üí d·ªÖ b·ªã l·ªách (out of sync)
 *   Ph·∫£i manual sync ·ªü m·ªçi n∆°i ‚Üí d·ªÖ qu√™n
 *
 * C√°ch fix t·ªët nh·∫•t: **derived state** (t√≠nh to√°n t·ª´ first + last)
 */
function ProfileBugFixed() {
  const [user, setUser] = useState({ first: '', last: '' });

  // ‚úÖ Derived value - lu√¥n ƒë√∫ng, kh√¥ng c·∫ßn l∆∞u ri√™ng
  const fullName =
    [user.first, user.last].filter(Boolean).join(' ').trim() || '(ch∆∞a nh·∫≠p)';

  const update = (field, value) => {
    setUser((prev) => ({
      ...prev,
      [field]: value,
    }));
    // KH√îNG C·∫¶N setFullName n·ªØa ‚Üí tr√°nh bug qu√™n sync
  };

  return (
    <div>
      <input
        value={user.first}
        onChange={(e) => update('first', e.target.value)}
        placeholder='First name'
      />
      <input
        value={user.last}
        onChange={(e) => update('last', e.target.value)}
        placeholder='Last name'
      />
      <p>
        Full name: <strong>{fullName}</strong>
      </p>

      <small style={{ color: '#666' }}>
        Full name lu√¥n ƒë·ªìng b·ªô m√† kh√¥ng c·∫ßn l∆∞u state ri√™ng
      </small>
    </div>
  );
}

export default ProfileBugFixed;
```

**Test case g·ª£i √Ω:**

- G√µ First name ‚Üí full name c·∫≠p nh·∫≠t ngay
- G√µ Last name ‚Üí full name v·∫´n ƒë√∫ng (kh√¥ng b·ªã thi·∫øu ph·∫ßn tr∆∞·ªõc)
- X√≥a c·∫£ hai ‚Üí hi·ªÉn th·ªã "(ch∆∞a nh·∫≠p)"
</details>

---

#### CartBug.jsx

```jsx
import { useState } from 'react';

function getCart() {
  console.log('üî• ƒê·ªçc localStorage + parse JSON n·∫∑ng...');
  const start = Date.now();
  while (Date.now() - start < 100) {} // gi·∫£ l·∫≠p n·∫∑ng

  const data = localStorage.getItem('cart');
  return data ? JSON.parse(data) : [];
}

function CartBug() {
  const [cart, setCart] = useState(getCart()); // ch·∫°y m·ªói render!
  const [search, setSearch] = useState('');

  const addItem = () => {
    const newCart = [...cart, { id: Date.now(), name: 'Item m·ªõi' }];
    localStorage.setItem('cart', JSON.stringify(newCart));
    setCart(newCart);
  };

  const filtered = cart.filter((item) =>
    item.name.toLowerCase().includes(search.toLowerCase()),
  );

  return (
    <div>
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder='T√¨m trong gi·ªè...'
      />
      <button onClick={addItem}>Th√™m item</button>
      <p>
        Gi·ªè: {cart.length} | L·ªçc ƒë∆∞·ª£c: {filtered.length}
      </p>
      <small>(M·ªü console ‚Üí th·∫•y log spam khi g√µ search)</small>
    </div>
  );
}

export default CartBug;
```

<details>
<summary>üí° Xem ƒë√°p √°n</summary>

```jsx
import { useState } from 'react';

function getCart() {
  console.log('üî• ƒê·ªçc localStorage + parse JSON n·∫∑ng...');
  const start = Date.now();
  while (Date.now() - start < 100) {} // gi·∫£ l·∫≠p n·∫∑ng

  const data = localStorage.getItem('cart');
  return data ? JSON.parse(data) : [];
}

/**
 * CartBug - Fixed version (s·ª≠ d·ª•ng lazy initialization)
 * V·∫•n ƒë·ªÅ g·ªëc: getCart() ch·∫°y M·ªñI render ‚Üí r·∫•t t·ªën khi g√µ search
 */
function CartBugFixed() {
  // ‚úÖ Lazy initialization: ch·ªâ ch·∫°y 1 l·∫ßn khi mount
  const [cart, setCart] = useState(() => getCart());

  const [search, setSearch] = useState('');

  const addItem = () => {
    setCart((prev) => {
      const newCart = [...prev, { id: Date.now(), name: 'Item m·ªõi' }];
      localStorage.setItem('cart', JSON.stringify(newCart));
      return newCart;
    });
  };

  // L·ªçc t·ª´ cart (ƒë√£ c√≥ s·∫µn trong state)
  const filtered = cart.filter((item) =>
    item.name.toLowerCase().includes(search.toLowerCase()),
  );

  return (
    <div>
      <input
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        placeholder='T√¨m trong gi·ªè...'
      />
      <button onClick={addItem}>Th√™m item</button>
      <p>
        Gi·ªè: <strong>{cart.length}</strong> | L·ªçc ƒë∆∞·ª£c:{' '}
        <strong>{filtered.length}</strong>
      </p>

      <small style={{ color: '#555', display: 'block', marginTop: 12 }}>
        M·ªü console ‚Üí gi·ªù ch·ªâ th·∫•y log ƒê·ªåC localStorage 1 l·∫ßn duy nh·∫•t khi mount
      </small>
    </div>
  );
}

export default CartBugFixed;
```

**Test case g·ª£i √Ω:**

- M·ªü console ‚Üí mount component ‚Üí th·∫•y log "ƒê·ªçc localStorage" **ch·ªâ 1 l·∫ßn**
- G√µ nhi·ªÅu k√Ω t·ª± v√†o √¥ search ‚Üí **kh√¥ng** th·∫•y log l·∫∑p l·∫°i
- Th√™m item ‚Üí gi·ªè c·∫≠p nh·∫≠t, localStorage ƒë∆∞·ª£c l∆∞u
</details>

---

### N√¢ng cao (60 ph√∫t)

**Exercise: Expense Tracker**

T·∫°o app qu·∫£n l√Ω chi ti√™u v·ªõi:

- Add/Edit/Delete expenses
- Categories (Food, Transport, Entertainment, etc.)
- Date filtering (This Month, Last Month, Custom Range)
- Statistics: Total by category, Average per day
- Persist to localStorage

Y√™u c·∫ßu:

- ‚úÖ Functional updates everywhere
- ‚úÖ Lazy initialization cho localStorage
- ‚úÖ Immutable updates
- ‚úÖ Derived statistics (don't store!)
- ‚úÖ Decision document cho state structure

---

<details>
<summary>üí° Xem ƒë√°p √°n </summary>

```jsx
/**
 * Expense Tracker - Production-ready version
 *
 * Features:
 * - Add / Edit / Delete expenses
 * - Categories
 * - Date filtering: This Month / Last Month / Custom Range
 * - Statistics: Total by category, Average per day
 * - Persist to localStorage (s·ª≠ d·ª•ng lazy init + save sau m·ªói thay ƒë·ªïi)
 *
 * Best Practices √°p d·ª•ng:
 * - Functional updates ·ªü m·ªçi n∆°i
 * - Lazy initialization cho localStorage
 * - Immutable updates (spread + map/filter)
 * - Derived state cho statistics & filtered list
 * - Kh√¥ng duplicate state
 */

/* ==================== Architecture Decision Record (ADR) ==================== */
/*
ADR: State Structure cho Expense Tracker

Context:
- C·∫ßn l∆∞u danh s√°ch chi ti√™u v·ªõi c√°c thu·ªôc t√≠nh: id, amount, category, date, description
- C·∫ßn filter theo th·ªùi gian (this month, last month, custom range)
- C·∫ßn t√≠nh to√°n th·ªëng k√™ theo category v√† average per day
- Ph·∫£i persist v√†o localStorage
- Update th∆∞·ªùng xuy√™n (add/edit/delete)

Decision: S·ª≠ d·ª•ng m·ªôt m·∫£ng objects + c√°c state filter ri√™ng bi·ªát

State shape:
{
  expenses: [
    { id: string, amount: number, category: string, date: string (ISO), description: string },
    ...
  ],
  filter: {
    mode: 'this-month' | 'last-month' | 'custom',
    startDate?: string,   // YYYY-MM-DD
    endDate?: string
  }
}

Rationale:
- Array ph√π h·ª£p v·ªõi danh s√°ch c√≥ th·ª© t·ª± th·ªùi gian
- D·ªÖ filter v√† sort theo date
- D·ªÖ persist tr·ª±c ti·∫øp b·∫±ng JSON
- C√°c filter l√† transient ‚Üí t√°ch ri√™ng kh·ªèi data ch√≠nh
- Statistics ho√†n to√†n derived ‚Üí kh√¥ng l∆∞u d∆∞ th·ª´a

Consequences (Trade-offs accepted):
- O(n) khi filter ‚Üí ch·∫•p nh·∫≠n ƒë∆∞·ª£c v·ªõi s·ªë l∆∞·ª£ng chi ti√™u c√° nh√¢n (<1000)
- C·∫ßn parse date nhi·ªÅu l·∫ßn khi filter ‚Üí c√≥ th·ªÉ optimize sau b·∫±ng useMemo (ng√†y sau)

Alternatives Considered:
- Object v·ªõi id l√†m key ‚Üí kh√≥ sort theo th·ªùi gian, ph·ª©c t·∫°p h∆°n khi filter date
- Redux / Zustand ‚Üí overkill cho single component
- T√°ch expenses & summary ‚Üí vi ph·∫°m "don't store derived state"
*/

/* ==================== Constants & Helpers ==================== */
const CATEGORIES = [
  'ƒÇn u·ªëng',
  'Di chuy·ªÉn',
  'Nh√† c·ª≠a & Ti·ªán √≠ch',
  'Gi·∫£i tr√≠',
  'Mua s·∫Øm',
  'S·ª©c kh·ªèe',
  'H·ªçc t·∫≠p',
  'Kh√°c',
];

const STORAGE_KEY = 'expense-tracker-2025';

/**
 * Load expenses t·ª´ localStorage (ch·ªâ ch·∫°y 1 l·∫ßn khi mount)
 */
function loadExpenses() {
  try {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (!saved) return [];
    const parsed = JSON.parse(saved);
    return parsed.map((item) => ({
      ...item,
      date: new Date(item.date).toISOString().split('T')[0], // ƒë·∫£m b·∫£o ƒë·ªãnh d·∫°ng
    }));
  } catch (err) {
    console.error('L·ªói ƒë·ªçc localStorage:', err);
    return [];
  }
}

/* ==================== Main Component ==================== */
function ExpenseTracker() {
  // Lazy init: ch·ªâ ƒë·ªçc localStorage 1 l·∫ßn
  const [expenses, setExpenses] = useState(() => loadExpenses());

  // Filter controls
  const [filterMode, setFilterMode] = useState('this-month');
  const [customStart, setCustomStart] = useState('');
  const [customEnd, setCustomEnd] = useState('');

  // Form add/edit
  const [form, setForm] = useState({
    amount: '',
    category: CATEGORIES[0],
    date: new Date().toISOString().split('T')[0],
    description: '',
  });
  const [editingId, setEditingId] = useState(null);

  // ‚îÄ‚îÄ T√≠nh filtered expenses (derived, t√≠nh m·ªói render) ‚îÄ‚îÄ
  const getFilteredExpenses = () => {
    let startDate, endDate;

    const now = new Date();
    const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const thisMonthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0);

    if (filterMode === 'this-month') {
      startDate = thisMonthStart;
      endDate = thisMonthEnd;
    } else if (filterMode === 'last-month') {
      startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
      endDate = new Date(now.getFullYear(), now.getMonth(), 0);
    } else if (filterMode === 'custom' && customStart && customEnd) {
      startDate = new Date(customStart);
      endDate = new Date(customEnd);
      endDate.setHours(23, 59, 59, 999); // bao g·ªìm c·∫£ ng√†y cu·ªëi
    } else {
      return [...expenses].sort((a, b) => new Date(b.date) - new Date(a.date));
    }

    return expenses
      .filter((exp) => {
        const d = new Date(exp.date);
        return d >= startDate && d <= endDate;
      })
      .sort((a, b) => new Date(b.date) - new Date(a.date)); // m·ªõi nh·∫•t l√™n ƒë·∫ßu
  };

  const filteredExpenses = getFilteredExpenses();

  // ‚îÄ‚îÄ T√≠nh statistics (derived, t√≠nh m·ªói render) ‚îÄ‚îÄ
  const getStats = () => {
    if (filteredExpenses.length === 0) {
      return { total: 0, byCategory: {}, averagePerDay: 0 };
    }

    const byCategory = {};
    let total = 0;

    filteredExpenses.forEach((exp) => {
      const amt = Number(exp.amount);
      total += amt;
      byCategory[exp.category] = (byCategory[exp.category] || 0) + amt;
    });

    // T√≠nh s·ªë ng√†y trong kho·∫£ng
    // 1000 ms * 60 gi√¢y * 60 ph√∫t * 24 gi·ªù = 86_400_000 (ms / ng√†y)
    let days = 1;
    if (filteredExpenses.length > 0) {
      const first = new Date(filteredExpenses[0].date); // ng√†y ƒë·∫ßu trong m·∫£ng (ƒë∆°n v·ªã ms)
      const last = new Date(filteredExpenses.at(-1).date); // ng√†y cu·ªëi trong m·∫£ng (ƒë∆°n v·ªã ms)

      // + 1 ƒê·ªÉ t√≠nh c·∫£ ng√†y ƒë·∫ßu v√† ng√†y cu·ªëi
      // T·ª´ 1/1 ƒë·∫øn 1/1 ‚Üí Hi·ªáu th·ªùi gian = 0 ng√†y, nh∆∞ng th·ª±c t·∫ø l√† 1 ng√†y ‚Üí c·∫ßn +1
      days = Math.max(1, (first - last) / (1000 * 60 * 60 * 24) + 1);
    }
    if (filterMode === 'custom' && customStart && customEnd) {
      days = Math.max(
        1,
        (new Date(customEnd) - new Date(customStart)) / (1000 * 60 * 60 * 24) +
          1,
      );
    }

    return {
      total,
      byCategory,
      averagePerDay: total / days,
    };
  };

  const stats = getStats();

  // ‚îÄ‚îÄ CRUD Handlers ‚îÄ‚îÄ
  const saveExpense = () => {
    const amountNum = Number(form.amount);
    if (!form.amount || isNaN(amountNum) || amountNum <= 0) {
      alert('Vui l√≤ng nh·∫≠p s·ªë ti·ªÅn h·ª£p l·ªá (l·ªõn h∆°n 0)');
      return;
    }

    setExpenses((prev) => {
      let nextExpenses;

      if (editingId) {
        // Edit
        nextExpenses = prev.map((exp) =>
          exp.id === editingId ? { ...exp, ...form, amount: amountNum } : exp,
        );
      } else {
        // Add
        nextExpenses = [
          ...prev,
          {
            id: Date.now().toString(),
            ...form,
            amount: amountNum,
          },
        ];
      }

      // L∆∞u localStorage
      localStorage.setItem(STORAGE_KEY, JSON.stringify(nextExpenses));
      return nextExpenses;
    });

    // Reset form
    setForm({
      amount: '',
      category: CATEGORIES[0],
      date: new Date().toISOString().split('T')[0],
      description: '',
    });
    setEditingId(null);
  };

  const startEdit = (exp) => {
    setForm({
      amount: exp.amount.toString(),
      category: exp.category,
      date: exp.date,
      description: exp.description || '',
    });
    setEditingId(exp.id);
  };

  const deleteExpense = (id) => {
    if (!window.confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a kho·∫£n chi n√†y?')) return;

    setExpenses((prev) => {
      const next = prev.filter((exp) => exp.id !== id);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(next));
      return next;
    });
  };

  const cancelEdit = () => {
    setEditingId(null);
    setForm({
      amount: '',
      category: CATEGORIES[0],
      date: new Date().toISOString().split('T')[0],
      description: '',
    });
  };

  return (
    <div
      style={{
        maxWidth: 900,
        margin: '0 auto',
        padding: 20,
        fontFamily: 'system-ui',
      }}
    >
      <h1>üí∏ Qu·∫£n l√Ω chi ti√™u</h1>

      {/* FORM */}
      <section
        style={{
          background: '#f8f9fa',
          padding: 20,
          borderRadius: 8,
          marginBottom: 24,
        }}
      >
        <h3>{editingId ? 'S·ª≠a chi ti√™u' : 'Th√™m kho·∫£n chi m·ªõi'}</h3>

        <div
          style={{
            display: 'grid',
            gap: 16,
            gridTemplateColumns: 'repeat(auto-fit, minmax(220px, 1fr))',
          }}
        >
          <div>
            <label>S·ªë ti·ªÅn (‚Ç´)</label>
            <br />
            <input
              type='number'
              value={form.amount}
              onChange={(e) =>
                setForm((p) => ({ ...p, amount: e.target.value }))
              }
              placeholder='VD: 120000'
              style={{ width: '100%', padding: 8 }}
            />
          </div>

          <div>
            <label>Danh m·ª•c</label>
            <br />
            <select
              value={form.category}
              onChange={(e) =>
                setForm((p) => ({ ...p, category: e.target.value }))
              }
              style={{ width: '100%', padding: 8 }}
            >
              {CATEGORIES.map((c) => (
                <option
                  key={c}
                  value={c}
                >
                  {c}
                </option>
              ))}
            </select>
          </div>

          <div>
            <label>Ng√†y</label>
            <br />
            <input
              type='date'
              value={form.date}
              onChange={(e) => setForm((p) => ({ ...p, date: e.target.value }))}
              style={{ width: '100%', padding: 8 }}
            />
          </div>

          <div style={{ gridColumn: '1 / -1' }}>
            <label>Ghi ch√∫</label>
            <br />
            <input
              type='text'
              value={form.description}
              onChange={(e) =>
                setForm((p) => ({ ...p, description: e.target.value }))
              }
              placeholder='VD: ƒÇn t·ªëi v·ªõi b·∫°n b√®'
              style={{ width: '100%', padding: 8 }}
            />
          </div>
        </div>

        <div style={{ marginTop: 16 }}>
          <button
            onClick={saveExpense}
            style={{ padding: '10px 20px', marginRight: 12 }}
          >
            {editingId ? 'L∆∞u thay ƒë·ªïi' : 'Th√™m'}
          </button>
          {editingId && (
            <button
              onClick={cancelEdit}
              style={{
                padding: '10px 20px',
                background: '#6c757d',
                color: 'white',
              }}
            >
              H·ªßy
            </button>
          )}
        </div>
      </section>

      {/* FILTER */}
      <section style={{ marginBottom: 24 }}>
        <h3>L·ªçc theo kho·∫£ng th·ªùi gian</h3>
        <div style={{ display: 'flex', flexWrap: 'wrap', gap: 12 }}>
          <button
            onClick={() => setFilterMode('this-month')}
            style={{
              fontWeight: filterMode === 'this-month' ? 'bold' : 'normal',
            }}
          >
            Th√°ng n√†y
          </button>
          <button
            onClick={() => setFilterMode('last-month')}
            style={{
              fontWeight: filterMode === 'last-month' ? 'bold' : 'normal',
            }}
          >
            Th√°ng tr∆∞·ªõc
          </button>
          <button
            onClick={() => setFilterMode('custom')}
            style={{ fontWeight: filterMode === 'custom' ? 'bold' : 'normal' }}
          >
            T√πy ch·ªçn
          </button>

          {filterMode === 'custom' && (
            <>
              <input
                type='date'
                value={customStart}
                onChange={(e) => setCustomStart(e.target.value)}
              />
              <input
                type='date'
                value={customEnd}
                onChange={(e) => setCustomEnd(e.target.value)}
              />
            </>
          )}
        </div>
      </section>

      {/* STATS */}
      <section
        style={{
          background: '#e6f4ff',
          padding: 16,
          borderRadius: 8,
          marginBottom: 24,
        }}
      >
        <h3>Th·ªëng k√™</h3>
        <p style={{ fontSize: '1.3em' }}>
          T·ªïng chi: <strong>{stats.total.toLocaleString('vi-VN')} ‚Ç´</strong>
        </p>
        <p>
          Trung b√¨nh/ng√†y:{' '}
          <strong>
            {Math.round(stats.averagePerDay).toLocaleString('vi-VN')} ‚Ç´
          </strong>
        </p>

        <h4>Chi ti·∫øt theo danh m·ª•c:</h4>
        <ul style={{ paddingLeft: 20 }}>
          {Object.entries(stats.byCategory).map(([cat, value]) => (
            <li key={cat}>
              {cat}: <strong>{value.toLocaleString('vi-VN')} ‚Ç´</strong>
            </li>
          ))}
        </ul>
      </section>

      {/* LIST */}
      <section>
        <h3>Danh s√°ch ({filteredExpenses.length} kho·∫£n)</h3>

        {filteredExpenses.length === 0 ? (
          <p style={{ color: '#6c757d' }}>
            Ch∆∞a c√≥ kho·∫£n chi n√†o trong kho·∫£ng th·ªùi gian n√†y.
          </p>
        ) : (
          filteredExpenses.map((exp) => (
            <div
              key={exp.id}
              style={{
                padding: 12,
                marginBottom: 12,
                border: '1px solid #dee2e6',
                borderRadius: 6,
                background: '#fff',
              }}
            >
              <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                <div>
                  <strong>{exp.amount.toLocaleString('vi-VN')} ‚Ç´</strong>
                  <span style={{ marginLeft: 12, color: '#555' }}>
                    {exp.description || '(kh√¥ng ghi ch√∫)'}
                  </span>
                </div>
                <div>
                  <button
                    onClick={() => startEdit(exp)}
                    style={{ marginRight: 8 }}
                  >
                    S·ª≠a
                  </button>
                  <button
                    onClick={() => deleteExpense(exp.id)}
                    style={{ background: '#dc3545', color: 'white' }}
                  >
                    X√≥a
                  </button>
                </div>
              </div>
              <div
                style={{ marginTop: 6, color: '#6c757d', fontSize: '0.9em' }}
              >
                {new Date(exp.date).toLocaleDateString('vi-VN')} ‚Ä¢{' '}
                {exp.category}
              </div>
            </div>
          ))
        )}
      </section>
    </div>
  );
}

export default ExpenseTracker;
```

</details>

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - useState**
   - https://react.dev/reference/react/useState
   - ƒê·ªçc sections: "Updating based on previous state", "Avoiding recreating initial state"

2. **React Docs - Choosing State Structure**
   - https://react.dev/learn/choosing-the-state-structure
   - ƒê·∫∑c bi·ªát ch√∫ √Ω: "Avoid duplication in state", "Group related state"

### ƒê·ªçc th√™m

3. **A Complete Guide to useEffect** by Dan Abramov
   - https://overreacted.io/a-complete-guide-to-useeffect/
   - Section v·ªÅ closures (chu·∫©n b·ªã cho useEffect ng√†y mai)

4. **Immutability in React and Redux**
   - https://daveceddia.com/react-redux-immutability-guide/

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (ƒë√£ h·ªçc)

- **Ng√†y 11**: useState basics - `const [state, setState] = useState(initial)`
- **Ng√†y 10**: Component composition
- **Ng√†y 9**: Forms concept (controlled inputs)

### H∆∞·ªõng t·ªõi (s·∫Ω h·ªçc)

- **Ng√†y 13**: Forms v·ªõi State - √Åp d·ª•ng patterns h√¥m nay v√†o real forms
- **Ng√†y 14**: Lifting State Up - Share state gi·ªØa components
- **Ng√†y 17**: useEffect - Side effects v√† cleanup (closure issues ·ªü ƒë√¢y!)

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**Performance:**

```jsx
// ‚ö†Ô∏è Expensive re-computation m·ªói render
function Dashboard() {
  const [data, setData] = useState([
    /* 10000 items */
  ]);

  // ‚ùå BAD: Filter ch·∫°y m·ªói render
  const filtered = data.filter(/* complex logic */);

  // ‚úÖ BETTER: S·∫Ω h·ªçc useMemo ·ªü Ng√†y 23
  // B√¢y gi·ªù: C√¢n nh·∫Øc n·∫øu filter th·ª±c s·ª± expensive
}
```

**Memory Leaks:**

```jsx
// ‚ö†Ô∏è Potential memory leak
function Timer() {
  const [count, setCount] = useState(0);

  // ‚ùå PROBLEM: setTimeout kh√¥ng ƒë∆∞·ª£c clear
  const start = () => {
    setTimeout(() => {
      setCount((prev) => prev + 1);
      start(); // Infinite recursion!
    }, 1000);
  };

  // ‚úÖ Solution: S·∫Ω h·ªçc useEffect cleanup ·ªü Ng√†y 17
}
```

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior Level:**

Q: "T·∫°i sao code n√†y ch·ªâ tƒÉng 1 l·∫ßn d√π g·ªçi setState 3 l·∫ßn?"

```jsx
setCount(count + 1);
setCount(count + 1);
setCount(count + 1);
```

> A: V√¨ `count` l√† constant trong render, c·∫£ 3 l·∫ßn ƒë·ªÅu ƒë·ªçc c√πng gi√° tr·ªã. Fix: d√πng functional updates `setCount(prev => prev + 1)`

**Mid Level:**

Q: "Khi n√†o n√™n d√πng lazy initialization?"

> A: Khi initial value expensive (localStorage read, heavy computation, DOM read). React ch·ªâ g·ªçi function 1 l·∫ßn on mount thay v√¨ m·ªói render.

**Senior Level:**

Q: "Thi·∫øt k·∫ø state structure cho feature X. Justify your choice."

> A: Ph·∫£i analyze:
>
> - Related data? ‚Üí Group into object
> - Frequent updates? ‚Üí Consider split
> - Derived values? ‚Üí Compute, don't store
> - Update patterns? ‚Üí Object vs Array
> - Document trade-offs

### War Stories

**Story 1: The Stale Closure Bug**

> M·ªôt l·∫ßn t√¥i debug bug "random" trong production: click button c√≥ khi work, c√≥ khi kh√¥ng. Sau 2 gi·ªù m·ªõi ph√°t hi·ªán l√† stale closure trong setTimeout. User click nhanh ‚Üí multiple timeouts v·ªõi stale values. Fix: ƒë·ªïi sang functional updates. Lesson: Lu√¥n d√πng functional updates trong async!

**Story 2: The Performance Nightmare**

> App ch·∫≠m d·∫ßn sau v√†i ph√∫t s·ª≠ d·ª•ng. Root cause: ƒë·ªçc t·ª´ localStorage trong useState KH√îNG lazy. M·ªói keystroke = 1 l·∫ßn parse JSON c·ªßa 10MB data! Fix: lazy initialization. Performance t·ª´ 200ms ‚Üí <1ms. Lesson: Profile before optimize, nh∆∞ng lazy init l√† low-hanging fruit.

**Story 3: The Out-of-Sync Bug**

> Bug production: statistics kh√¥ng update khi user edit item. Code store count, total, average in separate states. Developer qu√™n update average khi edit. Fix: Derive t·∫•t c·∫£ statistics. Kh√¥ng bao gi·ªù store derived state! Trade-off: Re-compute m·ªói render, nh∆∞ng always correct.

---

## üéØ PREVIEW NG√ÄY MAI

**Ng√†y 13: Forms v·ªõi State**

H√¥m nay ƒë√£ h·ªçc useState patterns. Ng√†y mai s·∫Ω √°p d·ª•ng v√†o:

- Controlled vs Uncontrolled components
- Form validation v·ªõi state
- Multiple inputs handling
- Custom hooks cho forms (gi·ªõi thi·ªáu concept)

H√¥m nay: Master patterns ‚úÖ  
Ng√†y mai: Apply to real forms üéØ

---

**üéä CH√öC M·ª™NG! B·∫°n ƒë√£ ho√†n th√†nh Ng√†y 12!**

H√¥m nay b·∫°n ƒë√£ master 5 patterns quan tr·ªçng nh·∫•t c·ªßa useState:

1. ‚úÖ Functional Updates - Fix stale closure
2. ‚úÖ Lazy Initialization - Optimize performance
3. ‚úÖ State Structure - Design decisions
4. ‚úÖ Immutability - Update safely
5. ‚úÖ Derived State - Avoid duplication

Nh·ªØng patterns n√†y s·∫Ω theo b·∫°n su·ªët career React. Practice ch√∫ng cho ƒë·∫øn khi th√†nh second nature!

üí™ Keep coding! Tomorrow: Forms mastery!
