# üìÖ NG√ÄY 12: useState - Patterns & Best Practices

## üéØ M·ª•c ti√™u h·ªçc t·∫≠p (5 ph√∫t)

Sau b√†i h·ªçc n√†y, b·∫°n s·∫Ω:

- [ ] **Hi·ªÉu v√† √°p d·ª•ng functional updates** ƒë·ªÉ tr√°nh stale closure bugs
- [ ] **S·ª≠ d·ª•ng lazy initialization** ƒë·ªÉ optimize performance
- [ ] **Thi·∫øt k·∫ø state structure** h·ª£p l√Ω (flat vs nested, single vs multiple)
- [ ] **√Åp d·ª•ng immutability patterns** khi update objects/arrays
- [ ] **Nh·∫≠n bi·∫øt v√† tr√°nh derived state anti-pattern**

---

## ü§î Ki·ªÉm tra ƒë·∫ßu v√†o (5 ph√∫t)

Tr·∫£ l·ªùi 3 c√¢u h·ªèi sau ƒë·ªÉ k√≠ch ho·∫°t ki·∫øn th·ª©c t·ª´ Ng√†y 11:

1. **C√¢u 1**: Code n√†y s·∫Ω hi·ªÉn th·ªã g√¨ sau khi click 3 l·∫ßn?

```jsx
const [count, setCount] = useState(0);

const handleClick = () => {
  setCount(count + 1);
  setCount(count + 1);
  setCount(count + 1);
};
```

2. **C√¢u 2**: State v√† Props kh√°c nhau th·∫ø n√†o? ƒêi·ªÅu g√¨ x·∫£y ra khi state thay ƒë·ªïi?

3. **C√¢u 3**: T·∫°i sao code n√†y c√≥ v·∫•n ƒë·ªÅ?

```jsx
const [user, setUser] = useState({ name: 'Alice', age: 25 });
user.age = 26; // Mutating directly
```

<details>
<summary>üí° Xem ƒë√°p √°n</summary>

1. Hi·ªÉn th·ªã `1` (kh√¥ng ph·∫£i 3!) - ƒê√¢y ch√≠nh l√† v·∫•n ƒë·ªÅ m√† functional updates s·∫Ω gi·∫£i quy·∫øt
2. Props: read-only, t·ª´ parent; State: mutable, internal. Khi state thay ƒë·ªïi ‚Üí component re-render
3. Vi ph·∫°m immutability - React kh√¥ng detect ƒë∆∞·ª£c thay ƒë·ªïi ‚Üí kh√¥ng re-render

</details>

---

## üìñ PH·∫¶N 1: GI·ªöI THI·ªÜU KH√ÅI NI·ªÜM (30 ph√∫t)

### 1.1 V·∫•n ƒê·ªÅ Th·ª±c T·∫ø

H√¥m qua (Ng√†y 11) ch√∫ng ta ƒë√£ h·ªçc useState c∆° b·∫£n v·ªõi c√∫ ph√°p:

```jsx
const [count, setCount] = useState(0);
setCount(5); // Direct update
```

Nh∆∞ng h√£y xem t√¨nh hu·ªëng n√†y trong real app:

```jsx
// ‚ùå BUG ·∫®N TRONG CODE N√ÄY!
function LikeButton() {
  const [likes, setLikes] = useState(0);

  const handleTripleClick = () => {
    setLikes(likes + 1);
    setLikes(likes + 1);
    setLikes(likes + 1);
  };

  return <button onClick={handleTripleClick}>‚ù§Ô∏è {likes}</button>;
}
```

**K·ª≥ v·ªçng**: Click 1 l·∫ßn ‚Üí tƒÉng 3 likes  
**Th·ª±c t·∫ø**: Click 1 l·∫ßn ‚Üí ch·ªâ tƒÉng 1 like üò±

**T·∫°i sao?** ƒê√¢y l√† **stale closure** - m·ªôt trong nh·ªØng bugs ph·ªï bi·∫øn nh·∫•t trong React!

---

### 1.2 Gi·∫£i Ph√°p

H√¥m nay ch√∫ng ta h·ªçc 5 patterns n√¢ng cao c·ªßa useState:

1. **Functional Updates** - Fix stale closure
2. **Lazy Initialization** - Optimize expensive computations
3. **State Structure** - Design state hi·ªáu qu·∫£
4. **Immutability Patterns** - Update objects/arrays ƒë√∫ng c√°ch
5. **Derived State** - Tr√°nh duplicate state

### 1.3 Mental Model

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          useState ADVANCED PATTERNS             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îÇ
‚îÇ  ‚îÇ Functional      ‚îÇ  setCount(prev => prev+1) ‚îÇ
‚îÇ  ‚îÇ Updates         ‚îÇ  ‚úÖ Always latest state   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îÇ
‚îÇ  ‚îÇ Lazy            ‚îÇ  useState(() => heavy())  ‚îÇ
‚îÇ  ‚îÇ Initialization  ‚îÇ  ‚úÖ Run once on mount     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îÇ
‚îÇ  ‚îÇ State           ‚îÇ  Multiple small vs        ‚îÇ
‚îÇ  ‚îÇ Structure       ‚îÇ  One big object?          ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îÇ
‚îÇ  ‚îÇ Immutability    ‚îÇ  {...obj, age: 26}        ‚îÇ
‚îÇ  ‚îÇ Patterns        ‚îÇ  [...arr, newItem]        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îÇ
‚îÇ  ‚îÇ Derived         ‚îÇ  fullName = first + last  ‚îÇ
‚îÇ  ‚îÇ State           ‚îÇ  ‚úÖ Calculate, don't store‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Analogy d·ªÖ hi·ªÉu**:

- **Functional updates** = G·ª≠i th∆∞ v·ªõi "tƒÉng l∆∞∆°ng th√™m 10%" thay v√¨ "l∆∞∆°ng = 5 tri·ªáu" (v√¨ c√≥ th·ªÉ ƒë√£ tƒÉng r·ªìi)
- **Lazy initialization** = N·∫•u c∆°m electric cooker m·ªôt l·∫ßn, kh√¥ng ph·∫£i n·∫•u l·∫°i m·ªói l·∫ßn ƒÉn
- **Immutability** = Vi·∫øt draft email m·ªõi thay v√¨ s·ª≠a email ƒë√£ g·ª≠i

### 1.4 Hi·ªÉu L·∫ßm Ph·ªï Bi·∫øn

‚ùå **Myth 1**: "setCount(count + 1) lu√¥n ƒë√∫ng"  
‚úÖ **Truth**: Sai khi c√≥ multiple updates ho·∫∑c async operations

‚ùå **Myth 2**: "useState ch·∫≠m v√¨ heavy computation"  
‚úÖ **Truth**: Ch·ªâ ch·∫≠m n·∫øu kh√¥ng d√πng lazy initialization

‚ùå **Myth 3**: "Store m·ªçi th·ª© in state"  
‚úÖ **Truth**: Derived values n√™n calculate, kh√¥ng store

---

## üíª PH·∫¶N 2: LIVE CODING (45 ph√∫t)

### Demo 1: Functional Updates - Pattern C∆° B·∫£n ‚≠ê

#### ‚ùå C√ÅCH SAI: Direct Updates (Stale Closure)

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  // ‚ùå V·∫§N ƒê·ªÄ: T·∫•t c·∫£ 3 l·∫ßn ƒë·ªÅu ƒë·ªçc count = 0
  const increment3Times = () => {
    setCount(count + 1); // count = 0, set to 1
    setCount(count + 1); // count v·∫´n = 0, set to 1
    setCount(count + 1); // count v·∫´n = 0, set to 1
    // K·∫øt qu·∫£: count = 1 (kh√¥ng ph·∫£i 3!)
  };

  // ‚ùå V·∫§N ƒê·ªÄ: setTimeout capture stale value
  const incrementAsync = () => {
    setTimeout(() => {
      setCount(count + 1); // count l√† gi√° tr·ªã l√∫c click, kh√¥ng ph·∫£i l√∫c timeout
    }, 1000);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment3Times}>+3 (BUG!)</button>
      <button onClick={incrementAsync}>+1 sau 1s (BUG!)</button>
    </div>
  );
}
```

**T·∫°i sao sai?**

- `count` l√† constant trong m·ªói render
- Closure capture gi√° tr·ªã t·∫°i th·ªùi ƒëi·ªÉm t·∫°o function
- Multiple updates ƒë·ªçc c√πng 1 gi√° tr·ªã c≈©

---

#### ‚úÖ C√ÅCH ƒê√öNG: Functional Updates

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  // ‚úÖ ƒê√öNG: M·ªói l·∫ßn d√πng gi√° tr·ªã m·ªõi nh·∫•t
  const increment3Times = () => {
    setCount((prev) => prev + 1); // prev = 0, return 1
    setCount((prev) => prev + 1); // prev = 1, return 2
    setCount((prev) => prev + 1); // prev = 2, return 3
    // K·∫øt qu·∫£: count = 3 ‚úÖ
  };

  // ‚úÖ ƒê√öNG: Lu√¥n l·∫•y gi√° tr·ªã m·ªõi nh·∫•t khi timeout ch·∫°y
  const incrementAsync = () => {
    setTimeout(() => {
      setCount((prev) => prev + 1); // prev l√† gi√° tr·ªã m·ªõi nh·∫•t
    }, 1000);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment3Times}>+3 ‚úÖ</button>
      <button onClick={incrementAsync}>+1 sau 1s ‚úÖ</button>
    </div>
  );
}
```

**T·∫°i sao ƒë√∫ng?**

- `prev` lu√¥n l√† latest state value
- React queue updates v√† ch·∫°y tu·∫ßn t·ª±
- Kh√¥ng b·ªã stale closure

---

### Demo 2: Lazy Initialization - K·ªãch B·∫£n Th·ª±c T·∫ø ‚≠ê‚≠ê

#### ‚ùå C√ÅCH SAI: Expensive Computation Ch·∫°y M·ªói Render

```jsx
// H√†m t√≠nh to√°n n·∫∑ng (v√≠ d·ª•: ƒë·ªçc t·ª´ localStorage)
function getInitialTodos() {
  console.log('üî• Running expensive computation...');

  // Gi·∫£ l·∫≠p heavy computation
  const start = Date.now();
  while (Date.now() - start < 100) {
    // Block 100ms
  }

  // ƒê·ªçc t·ª´ localStorage
  const saved = localStorage.getItem('todos');
  return saved ? JSON.parse(saved) : [];
}

// ‚ùå V·∫§N ƒê·ªÄ: getInitialTodos() ch·∫°y M·ªñI RENDER!
function TodoApp() {
  const [todos, setTodos] = useState(getInitialTodos()); // üî• Ch·∫°y m·ªói render!
  const [input, setInput] = useState('');

  // M·ªói l·∫ßn g√µ input ‚Üí component re-render ‚Üí getInitialTodos() ch·∫°y l·∫°i!
  // D√π ch·ªâ c·∫ßn gi√° tr·ªã initial 1 l·∫ßn

  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
      />
      {/* UI... */}
    </div>
  );
}
```

**V·∫•n ƒë·ªÅ:**

- `getInitialTodos()` ch·∫°y m·ªói render (ngay c·∫£ khi ƒëang g√µ input!)
- Waste performance
- Console log spam

---

#### ‚úÖ C√ÅCH ƒê√öNG: Lazy Initialization

```jsx
function getInitialTodos() {
  console.log('‚úÖ Running ONCE on mount...');

  const start = Date.now();
  while (Date.now() - start < 100) {}

  const saved = localStorage.getItem('todos');
  return saved ? JSON.parse(saved) : [];
}

// ‚úÖ ƒê√öNG: Pass function, React ch·ªâ g·ªçi 1 l·∫ßn khi mount
function TodoApp() {
  const [todos, setTodos] = useState(() => getInitialTodos()); // ‚úÖ Function!
  const [input, setInput] = useState('');

  // G√µ input ‚Üí re-render ‚Üí getInitialTodos() KH√îNG ch·∫°y l·∫°i

  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
      />
      <p>Todos: {todos.length}</p>
      {/* Console ch·ªâ log 1 l·∫ßn! */}
    </div>
  );
}
```

**Quy t·∫Øc v√†ng:**

```jsx
// ‚ùå SAI: Function call
useState(expensiveFunction());

// ‚úÖ ƒê√öNG: Function reference
useState(() => expensiveFunction());

// ‚ö†Ô∏è CH√ö √ù: Ch·ªâ d√πng khi initial value th·ª±c s·ª± expensive
useState(0); // OK - simple value
useState(() => 0); // Overkill - kh√¥ng c·∫ßn thi·∫øt
useState(() => readFromDB()); // GOOD - expensive operation
```

---

### Demo 3: State Structure & Immutability - Edge Cases ‚≠ê‚≠ê‚≠ê

#### ‚ùå C√ÅCH SAI: Nhi·ªÅu State Kh√¥ng Li√™n Quan

```jsx
// ‚ùå V·∫§N ƒê·ªÄ: State kh√¥ng ƒë∆∞·ª£c group logic
function UserProfile() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState(0);
  const [address, setAddress] = useState('');
  const [city, setCity] = useState('');
  const [country, setCountry] = useState('');

  // Reset form c·∫ßn 7 d√≤ng code!
  const handleReset = () => {
    setFirstName('');
    setLastName('');
    setEmail('');
    setAge(0);
    setAddress('');
    setCity('');
    setCountry('');
  };

  // Update ph·ª©c t·∫°p, d·ªÖ miss fields
}
```

---

#### ‚úÖ C√ÅCH ƒê√öNG: Group Related State

```jsx
// ‚úÖ ƒê√öNG: Group state c√≥ li√™n quan
function UserProfile() {
  const [user, setUser] = useState({
    firstName: '',
    lastName: '',
    email: '',
    age: 0,
    address: {
      street: '',
      city: '',
      country: '',
    },
  });

  // Reset ƒë∆°n gi·∫£n h∆°n
  const handleReset = () => {
    setUser({
      firstName: '',
      lastName: '',
      email: '',
      age: 0,
      address: { street: '', city: '', country: '' },
    });
  };

  // Update v·ªõi immutability
  const updateField = (field, value) => {
    setUser((prev) => ({
      ...prev, // Spread old values
      [field]: value, // Override field
    }));
  };

  // Update nested object
  const updateAddress = (field, value) => {
    setUser((prev) => ({
      ...prev,
      address: {
        ...prev.address, // Spread old address
        [field]: value, // Override address field
      },
    }));
  };

  return (
    <div>
      <input
        value={user.firstName}
        onChange={(e) => updateField('firstName', e.target.value)}
      />
      <input
        value={user.address.city}
        onChange={(e) => updateAddress('city', e.target.value)}
      />
    </div>
  );
}
```

---

#### üî• Immutability Patterns Deep Dive

```jsx
function DataManager() {
  const [items, setItems] = useState([
    { id: 1, name: 'Item 1', completed: false },
    { id: 2, name: 'Item 2', completed: true },
  ]);

  // ‚úÖ PATTERN 1: Add item
  const addItem = (name) => {
    const newItem = {
      id: Date.now(),
      name,
      completed: false,
    };

    setItems((prev) => [...prev, newItem]); // Spread + add
  };

  // ‚úÖ PATTERN 2: Remove item
  const removeItem = (id) => {
    setItems((prev) => prev.filter((item) => item.id !== id));
  };

  // ‚úÖ PATTERN 3: Update item
  const toggleItem = (id) => {
    setItems((prev) =>
      prev.map(
        (item) =>
          item.id === id
            ? { ...item, completed: !item.completed } // Create new object
            : item, // Keep old reference
      ),
    );
  };

  // ‚úÖ PATTERN 4: Update nested property
  const updateItemName = (id, newName) => {
    setItems((prev) =>
      prev.map((item) => (item.id === id ? { ...item, name: newName } : item)),
    );
  };

  // ‚úÖ PATTERN 5: Replace entire array
  const replaceItems = (newItems) => {
    setItems(newItems); // Direct replacement OK
  };

  // ‚ùå NEVER DO THIS:
  const wrongUpdate = (id) => {
    const item = items.find((i) => i.id === id);
    item.completed = true; // üö´ Mutation!
    setItems(items); // üö´ Same reference!
  };
}
```

---

## üî® PH·∫¶N 3: B√ÄI T·∫¨P TH·ª∞C H√ÄNH (60 ph√∫t)

### ‚≠ê Exercise 1: Fix Stale Closure Bug (15 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: S·ª≠a bug stale closure trong code d∆∞·ªõi ƒë√¢y
 * ‚è±Ô∏è Th·ªùi gian: 15 ph√∫t
 * üö´ KH√îNG d√πng: useEffect, useRef
 *
 * Requirements:
 * 1. Fix bug trong handleDoubleClick (ph·∫£i tƒÉng 2 l·∫ßn)
 * 2. Fix bug trong handleDelayedIncrement (ph·∫£i d√πng latest value)
 * 3. Gi·∫£i th√≠ch T·∫†I SAO functional updates fix ƒë∆∞·ª£c bugs
 *
 * üí° G·ª£i √Ω: Thay direct updates b·∫±ng functional updates
 */

// ‚ùå CODE C√ì BUG:
function BuggyCounter() {
  const [count, setCount] = useState(0);

  // BUG: Ch·ªâ tƒÉng 1 l·∫ßn d√π g·ªçi 2 l·∫ßn
  const handleDoubleClick = () => {
    setCount(count + 1);
    setCount(count + 1);
  };

  // BUG: N·∫øu click nhi·ªÅu l·∫ßn nhanh, gi√° tr·ªã sai
  const handleDelayedIncrement = () => {
    setTimeout(() => {
      setCount(count + 1);
    }, 1000);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleDoubleClick}>+2 (BUG!)</button>
      <button onClick={handleDelayedIncrement}>+1 sau 1s (BUG!)</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

// ‚úÖ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
// TODO: Fix handleDoubleClick
// TODO: Fix handleDelayedIncrement
// TODO: Gi·∫£i th√≠ch t·∫°i sao fix n√†y work
```

<details>
<summary>üí° Solution</summary>

```jsx
function FixedCounter() {
  const [count, setCount] = useState(0);

  // ‚úÖ FIX: Functional updates
  const handleDoubleClick = () => {
    setCount((prev) => prev + 1); // prev = current value
    setCount((prev) => prev + 1); // prev = after first update
  };

  // ‚úÖ FIX: Functional updates v·ªõi async
  const handleDelayedIncrement = () => {
    setTimeout(() => {
      setCount((prev) => prev + 1); // prev = latest value khi timeout
    }, 1000);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleDoubleClick}>+2 ‚úÖ</button>
      <button onClick={handleDelayedIncrement}>+1 sau 1s ‚úÖ</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}

/**
 * GI·∫¢I TH√çCH:
 *
 * Direct updates (count + 1):
 * - count l√† constant trong m·ªói render
 * - Closure capture gi√° tr·ªã t·∫°i th·ªùi ƒëi·ªÉm function ƒë∆∞·ª£c t·∫°o
 * - Multiple updates ƒë·ªçc c√πng 1 gi√° tr·ªã
 *
 * Functional updates (prev => prev + 1):
 * - prev lu√¥n l√† latest state value
 * - React queue c√°c updates
 * - M·ªói update nh·∫≠n output c·ªßa update tr∆∞·ªõc
 * - Kh√¥ng b·ªã stale closure v√¨ kh√¥ng depend on outer variable
 */
```

</details>

---

### ‚≠ê‚≠ê Exercise 2: Lazy Initialization Pattern (25 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Optimize expensive initialization
 * ‚è±Ô∏è Th·ªùi gian: 25 ph√∫t
 *
 * Scenario: Shopping cart app ƒë·ªçc t·ª´ localStorage
 *
 * ü§î PH√ÇN T√çCH:
 * Approach A: Direct initialization - useState(getCartFromStorage())
 * Pros: Code ng·∫Øn g·ªçn
 * Cons: Ch·∫°y m·ªói render, waste performance
 *
 * Approach B: Lazy initialization - useState(() => getCartFromStorage())
 * Pros: Ch·ªâ ch·∫°y 1 l·∫ßn on mount
 * Cons: Syntax h∆°i d√†i h∆°n (nh∆∞ng ƒë√°ng gi√°!)
 *
 * üí≠ B·∫†N CH·ªåN G√å V√Ä T·∫†I SAO?
 * Document quy·∫øt ƒë·ªãnh c·ªßa b·∫°n, sau ƒë√≥ implement.
 */

// Helper function (ƒë√£ c√≥ s·∫µn)
function getCartFromStorage() {
  console.log('üîç Reading from localStorage...');

  // Simulate expensive operation
  const start = Date.now();
  while (Date.now() - start < 50) {} // Block 50ms

  const saved = localStorage.getItem('cart');
  return saved ? JSON.parse(saved) : [];
}

// ‚ùå CODE C√ì PERFORMANCE ISSUE:
function ShoppingCart() {
  const [cart, setCart] = useState(getCartFromStorage()); // Ch·∫°y m·ªói render!
  const [searchTerm, setSearchTerm] = useState('');

  // M·ªói l·∫ßn g√µ search ‚Üí re-render ‚Üí getCartFromStorage() ch·∫°y l·∫°i!

  const addToCart = (product) => {
    setCart((prev) => [...prev, product]);
  };

  return (
    <div>
      <input
        placeholder='Search products...'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      <p>Cart: {cart.length} items</p>
      {/* M·ªói keystroke = 1 l·∫ßn ƒë·ªçc localStorage üò± */}
    </div>
  );
}

// ‚úÖ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:
// TODO: Vi·∫øt version optimized v·ªõi lazy initialization
// TODO: Test b·∫±ng c√°ch g√µ v√†o search input
// TODO: Check console - getCartFromStorage() ch·ªâ log 1 l·∫ßn
// TODO: Document decision: Khi n√†o n√™n d√πng lazy init?
```

<details>
<summary>üí° Solution</summary>

```jsx
// ‚úÖ OPTIMIZED VERSION:
function ShoppingCartOptimized() {
  const [cart, setCart] = useState(() => getCartFromStorage()); // Function!
  const [searchTerm, setSearchTerm] = useState('');

  const addToCart = (product) => {
    setCart((prev) => {
      const newCart = [...prev, product];
      localStorage.setItem('cart', JSON.stringify(newCart));
      return newCart;
    });
  };

  return (
    <div>
      <input
        placeholder='Search products...'
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
      />
      <p>Cart: {cart.length} items</p>
      <button onClick={() => addToCart({ id: Date.now(), name: 'Product' })}>
        Add Item
      </button>
    </div>
  );
}

/**
 * üìã DECISION DOCUMENT:
 *
 * Approach chosen: Lazy Initialization
 *
 * Rationale:
 * - getCartFromStorage() l√† expensive (I/O operation + JSON parse)
 * - Ch·ªâ c·∫ßn initial value 1 l·∫ßn
 * - Component re-render nhi·ªÅu l·∫ßn (search input changes)
 * - Performance gain ƒë√°ng k·ªÉ (50ms x N renders)
 *
 * When to use Lazy Initialization:
 * ‚úÖ Reading from localStorage/sessionStorage
 * ‚úÖ Complex calculations
 * ‚úÖ Reading from DOM
 * ‚úÖ Parsing large data structures
 *
 * When NOT needed:
 * ‚ùå Simple values (0, '', [], {})
 * ‚ùå Fast computations
 * ‚ùå Values already in memory
 */
```

</details>

---

### ‚≠ê‚≠ê‚≠ê Exercise 3: User Profile Form (40 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Qu·∫£n l√Ω complex form state v·ªõi immutability
 * ‚è±Ô∏è Th·ªùi gian: 40 ph√∫t
 *
 * üìã Product Requirements:
 * User Story: "L√† user, t√¥i mu·ªën edit profile v·ªõi th√¥ng tin personal v√† address"
 *
 * ‚úÖ Acceptance Criteria:
 * - [ ] Form c√≥ fields: firstName, lastName, email, phone
 * - [ ] Nested address: street, city, country
 * - [ ] Update fields kh√¥ng mutate state
 * - [ ] Reset button clear to√†n b·ªô form
 * - [ ] Display full name (derived from first + last)
 *
 * üé® Technical Constraints:
 * - D√πng 1 state object cho to√†n b·ªô form
 * - Immutable updates cho c·∫£ top-level v√† nested fields
 * - Kh√¥ng duplicate data (fullName ph·∫£i derived)
 *
 * üö® Edge Cases c·∫ßn handle:
 * - Empty string inputs
 * - Update nested fields kh√¥ng ·∫£nh h∆∞·ªüng top-level
 * - Reset ph·∫£i clear c·∫£ nested objects
 */

// ‚úÖ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:

// TODO 1: Design state structure
const INITIAL_STATE = {
  // TODO: Define structure
};

function UserProfileForm() {
  const [profile, setProfile] = useState(INITIAL_STATE);

  // TODO 2: Implement updateField (for top-level fields)
  const updateField = (field, value) => {
    // TODO: Immutable update
  };

  // TODO 3: Implement updateAddress (for nested fields)
  const updateAddress = (field, value) => {
    // TODO: Immutable nested update
  };

  // TODO 4: Implement handleReset
  const handleReset = () => {
    // TODO: Reset to initial state
  };

  // TODO 5: Compute derived state (fullName)
  const fullName = ''; // TODO: Derive from firstName + lastName

  return (
    <div>
      <h2>Edit Profile</h2>

      {/* TODO 6: Implement form fields */}
      <input placeholder='First Name' />
      <input placeholder='Last Name' />
      <input placeholder='Email' />
      <input placeholder='Phone' />

      <h3>Address</h3>
      <input placeholder='Street' />
      <input placeholder='City' />
      <input placeholder='Country' />

      <div>
        <p>Full Name: {fullName}</p>
        <button onClick={handleReset}>Reset</button>
      </div>

      {/* Debug view */}
      <pre>{JSON.stringify(profile, null, 2)}</pre>
    </div>
  );
}

// üìù Implementation Checklist:
// - [ ] State structure designed
// - [ ] updateField works for top-level
// - [ ] updateAddress works for nested
// - [ ] Reset clears everything
// - [ ] fullName derives correctly
// - [ ] No mutations anywhere
```

<details>
<summary>üí° Solution</summary>

```jsx
const INITIAL_STATE = {
  firstName: '',
  lastName: '',
  email: '',
  phone: '',
  address: {
    street: '',
    city: '',
    country: '',
  },
};

function UserProfileForm() {
  const [profile, setProfile] = useState(INITIAL_STATE);

  // ‚úÖ Update top-level field
  const updateField = (field, value) => {
    setProfile((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  // ‚úÖ Update nested address field
  const updateAddress = (field, value) => {
    setProfile((prev) => ({
      ...prev,
      address: {
        ...prev.address,
        [field]: value,
      },
    }));
  };

  // ‚úÖ Reset to initial state
  const handleReset = () => {
    setProfile(INITIAL_STATE);
  };

  // ‚úÖ Derived state (computed, not stored)
  const fullName =
    `${profile.firstName} ${profile.lastName}`.trim() || '(Not set)';

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h2>Edit Profile</h2>

      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          gap: '10px',
          maxWidth: '400px',
        }}
      >
        <input
          placeholder='First Name'
          value={profile.firstName}
          onChange={(e) => updateField('firstName', e.target.value)}
        />
        <input
          placeholder='Last Name'
          value={profile.lastName}
          onChange={(e) => updateField('lastName', e.target.value)}
        />
        <input
          placeholder='Email'
          value={profile.email}
          onChange={(e) => updateField('email', e.target.value)}
        />
        <input
          placeholder='Phone'
          value={profile.phone}
          onChange={(e) => updateField('phone', e.target.value)}
        />

        <h3>Address</h3>
        <input
          placeholder='Street'
          value={profile.address.street}
          onChange={(e) => updateAddress('street', e.target.value)}
        />
        <input
          placeholder='City'
          value={profile.address.city}
          onChange={(e) => updateAddress('city', e.target.value)}
        />
        <input
          placeholder='Country'
          value={profile.address.country}
          onChange={(e) => updateAddress('country', e.target.value)}
        />

        <div
          style={{ marginTop: '20px', padding: '10px', background: '#f0f0f0' }}
        >
          <p>
            <strong>Full Name:</strong> {fullName}
          </p>
          <button onClick={handleReset}>Reset Form</button>
        </div>

        <details>
          <summary>Debug: State</summary>
          <pre style={{ background: '#000', color: '#0f0', padding: '10px' }}>
            {JSON.stringify(profile, null, 2)}
          </pre>
        </details>
      </div>
    </div>
  );
}

/**
 * KEY LEARNINGS:
 *
 * 1. State Structure:
 *    - Group related data (personal info vs address)
 *    - Nested objects for logical grouping
 *
 * 2. Immutability:
 *    - Top-level: {...prev, field: value}
 *    - Nested: {...prev, nested: {...prev.nested, field: value}}
 *
 * 3. Derived State:
 *    - fullName computed from firstName + lastName
 *    - Kh√¥ng store ri√™ng ‚Üí lu√¥n sync
 *
 * 4. Reusable Patterns:
 *    - updateField: generic top-level updater
 *    - updateAddress: specific nested updater
 *    - Reset: restore to initial constant
 */
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê Exercise 4: Shopping Cart with Quantities (60 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Architectural decisions cho shopping cart
 * ‚è±Ô∏è Th·ªùi gian: 60 ph√∫t
 *
 * üèóÔ∏è PHASE 1: Research & Design (20 ph√∫t)
 *
 * So s√°nh 3 approaches:
 *
 * A) Array of objects: [{id, name, price, quantity}, ...]
 * B) Object with IDs as keys: {[id]: {name, price, quantity}, ...}
 * C) Separate arrays: products[] + quantities[]
 *
 * Document pros/cons m·ªói approach, sau ƒë√≥ ch·ªçn 1.
 *
 * ADR Template:
 * - Context: Shopping cart c·∫ßn add/remove/update quantity
 * - Decision: Approach [A/B/C]
 * - Rationale: T·∫°i sao?
 * - Consequences: Trade-offs accepted
 * - Alternatives Considered: T·∫°i sao kh√¥ng ch·ªçn approach kh√°c?
 *
 * üíª PHASE 2: Implementation (30 ph√∫t)
 *
 * Requirements:
 * - Add product to cart
 * - Remove product from cart
 * - Increase/decrease quantity
 * - Calculate total price (derived state)
 * - Clear cart
 *
 * üß™ PHASE 3: Testing (10 ph√∫t)
 * Manual testing checklist:
 * - [ ] Add same product twice ‚Üí quantity increases
 * - [ ] Decrease quantity to 0 ‚Üí remove from cart
 * - [ ] Total price updates correctly
 */

// Sample products
const PRODUCTS = [
  { id: 1, name: 'Laptop', price: 1000 },
  { id: 2, name: 'Mouse', price: 20 },
  { id: 3, name: 'Keyboard', price: 50 },
];

// ‚úÖ NHI·ªÜM V·ª§ C·ª¶A B·∫†N:

// PHASE 1: Vi·∫øt ADR (Architecture Decision Record)
/**
 * ADR: Shopping Cart State Structure
 *
 * Context:
 * [TODO: M√¥ t·∫£ v·∫•n ƒë·ªÅ]
 *
 * Decision:
 * [TODO: Approach ƒë√£ ch·ªçn]
 *
 * Rationale:
 * [TODO: T·∫°i sao ch·ªçn approach n√†y]
 *
 * Consequences:
 * [TODO: Trade-offs accepted]
 *
 * Alternatives Considered:
 * [TODO: C√°c options kh√°c v√† t·∫°i sao kh√¥ng ch·ªçn]
 */

// PHASE 2: Implementation
function ShoppingCart() {
  const [cart, setCart] =
    useState(/* TODO: Initial state based on your decision */);

  const addToCart = (product) => {
    // TODO: Add product or increment quantity if exists
  };

  const removeFromCart = (productId) => {
    // TODO: Remove product
  };

  const increaseQuantity = (productId) => {
    // TODO: +1 quantity
  };

  const decreaseQuantity = (productId) => {
    // TODO: -1 quantity, remove if reaches 0
  };

  const clearCart = () => {
    // TODO: Clear all items
  };

  // TODO: Calculate total (derived state)
  const total = 0;

  return <div>{/* TODO: Implement UI */}</div>;
}

// PHASE 3: Write test cases
/**
 * Manual Test Cases:
 * 1. [TODO: Test scenario 1]
 * 2. [TODO: Test scenario 2]
 * 3. [TODO: Test scenario 3]
 */
```

<details>
<summary>üí° Solution v·ªõi ADR</summary>

```jsx
/**
 * ADR: Shopping Cart State Structure
 *
 * Context:
 * - C·∫ßn store products v·ªõi quantities
 * - Frequent operations: add, remove, update quantity
 * - Derive total price
 * - Check if product exists in cart
 *
 * Decision: Approach B - Object with product IDs as keys
 * {
 *   [productId]: { product, quantity }
 * }
 *
 * Rationale:
 * - O(1) lookup by ID (vs O(n) with array)
 * - Easy to check existence: cart[id]
 * - Easy to update quantity: {...cart, [id]: {}}
 * - Convert to array khi render: Object.values(cart)
 *
 * Consequences (Accepted Trade-offs):
 * - C·∫ßn Object.values() ƒë·ªÉ iterate
 * - Kh√¥ng c√≥ natural ordering (OK for cart)
 *
 * Alternatives Considered:
 * - Array approach (A): O(n) lookups, need .find() everywhere
 * - Separate arrays (C): Hard to keep in sync, complex updates
 */

const PRODUCTS = [
  { id: 1, name: 'Laptop', price: 1000 },
  { id: 2, name: 'Mouse', price: 20 },
  { id: 3, name: 'Keyboard', price: 50 },
];

function ShoppingCart() {
  // State: { [productId]: { product, quantity } }
  const [cart, setCart] = useState({});

  // Add or increment
  const addToCart = (product) => {
    setCart((prev) => {
      const existing = prev[product.id];

      if (existing) {
        // Product exists ‚Üí increment quantity
        return {
          ...prev,
          [product.id]: {
            ...existing,
            quantity: existing.quantity + 1,
          },
        };
      } else {
        // New product ‚Üí add with quantity 1
        return {
          ...prev,
          [product.id]: {
            product,
            quantity: 1,
          },
        };
      }
    });
  };

  // Remove product
  const removeFromCart = (productId) => {
    setCart((prev) => {
      const newCart = { ...prev };
      delete newCart[productId];
      return newCart;
    });
  };

  // Increase quantity
  const increaseQuantity = (productId) => {
    setCart((prev) => ({
      ...prev,
      [productId]: {
        ...prev[productId],
        quantity: prev[productId].quantity + 1,
      },
    }));
  };

  // Decrease quantity (remove if 0)
  const decreaseQuantity = (productId) => {
    setCart((prev) => {
      const item = prev[productId];

      if (item.quantity === 1) {
        // Remove if quantity becomes 0
        const newCart = { ...prev };
        delete newCart[productId];
        return newCart;
      } else {
        // Decrease quantity
        return {
          ...prev,
          [productId]: {
            ...item,
            quantity: item.quantity - 1,
          },
        };
      }
    });
  };

  // Clear cart
  const clearCart = () => {
    setCart({});
  };

  // ‚úÖ Derived state: total price
  const total = Object.values(cart).reduce(
    (sum, item) => sum + item.product.price * item.quantity,
    0,
  );

  // Convert to array for rendering
  const cartItems = Object.values(cart);

  return (
    <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
      <h2>Shopping Cart</h2>

      {/* Product List */}
      <div style={{ marginBottom: '20px' }}>
        <h3>Products</h3>
        {PRODUCTS.map((product) => (
          <div
            key={product.id}
            style={{ marginBottom: '10px' }}
          >
            <span>
              {product.name} - ${product.price}
            </span>
            <button onClick={() => addToCart(product)}>Add to Cart</button>
          </div>
        ))}
      </div>

      {/* Cart Items */}
      <div>
        <h3>Cart ({cartItems.length} items)</h3>
        {cartItems.length === 0 ? (
          <p>Cart is empty</p>
        ) : (
          <>
            {cartItems.map((item) => (
              <div
                key={item.product.id}
                style={{
                  display: 'flex',
                  gap: '10px',
                  alignItems: 'center',
                  marginBottom: '10px',
                }}
              >
                <span>{item.product.name}</span>
                <button onClick={() => decreaseQuantity(item.product.id)}>
                  -
                </button>
                <span>{item.quantity}</span>
                <button onClick={() => increaseQuantity(item.product.id)}>
                  +
                </button>
                <span>${item.product.price * item.quantity}</span>
                <button onClick={() => removeFromCart(item.product.id)}>
                  Remove
                </button>
              </div>
            ))}

            <div
              style={{
                marginTop: '20px',
                padding: '10px',
                background: '#f0f0f0',
              }}
            >
              <strong>Total: ${total}</strong>
              <button
                onClick={clearCart}
                style={{ marginLeft: '10px' }}
              >
                Clear Cart
              </button>
            </div>
          </>
        )}
      </div>

      {/* Debug */}
      <details style={{ marginTop: '20px' }}>
        <summary>Debug: Cart State</summary>
        <pre style={{ background: '#000', color: '#0f0', padding: '10px' }}>
          {JSON.stringify(cart, null, 2)}
        </pre>
      </details>
    </div>
  );
}

/**
 * Manual Test Cases:
 *
 * ‚úÖ Test 1: Add same product twice
 * - Click "Add to Cart" 2 l·∫ßn cho Laptop
 * - Expect: Quantity = 2, Total = $2000
 *
 * ‚úÖ Test 2: Decrease to zero removes item
 * - Add Mouse, click "-" button
 * - Expect: Mouse removed from cart
 *
 * ‚úÖ Test 3: Total updates correctly
 * - Add Laptop (1000), Mouse (20), Keyboard (50)
 * - Increase Laptop quantity to 2
 * - Expect: Total = 2000 + 20 + 50 = $2070
 *
 * ‚úÖ Test 4: Clear cart works
 * - Add multiple items
 * - Click "Clear Cart"
 * - Expect: Cart empty, Total = $0
 */
```

</details>

---

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Exercise 5: Advanced Todo App with Categories (90 ph√∫t)

```jsx
/**
 * üéØ M·ª•c ti√™u: Production-ready todo app
 * ‚è±Ô∏è Th·ªùi gian: 90 ph√∫t
 *
 * üìã Feature Specification:
 * - Add/Edit/Delete todos
 * - Mark as complete/incomplete
 * - Assign category to each todo
 * - Filter by category
 * - Filter by status (all/active/completed)
 * - Persist to localStorage
 * - Show statistics (total, active, completed per category)
 *
 * üèóÔ∏è Technical Design Doc:
 * 1. Component Architecture: Single component (Ng√†y 12 ch∆∞a h·ªçc composition)
 * 2. State Management: useState v·ªõi proper structure
 * 3. Data Structure: Array vs Object trade-offs
 * 4. Performance: Lazy initialization cho localStorage
 * 5. Derived State: Statistics computed, not stored
 *
 * ‚úÖ Production Checklist:
 * - [ ] Proper state structure (justify your choice)
 * - [ ] Immutable updates throughout
 * - [ ] Lazy initialization for localStorage
 * - [ ] Derived state for statistics
 * - [ ] No duplicate state
 * - [ ] Input validation (empty strings)
 * - [ ] Edge cases handled (delete last todo, etc.)
 * - [ ] Clear variable names
 * - [ ] Comments explaining complex logic
 *
 * üìù Documentation:
 * - Write ADR cho state structure decision
 * - Comment complex immutability patterns
 * - Document filter logic
 */

const CATEGORIES = ['Work', 'Personal', 'Shopping'];

// Starter code
function AdvancedTodoApp() {
  // TODO: Design state structure
  // Consider:
  // - How to store todos?
  // - How to store current filters?
  // - What should be in state vs derived?

  const [todos, setTodos] = useState(() => {
    // TODO: Lazy initialization from localStorage
  });

  const [filter, setFilter] = useState(/* TODO */);
  const [categoryFilter, setCategoryFilter] = useState(/* TODO */);

  // TODO: Implement CRUD operations
  const addTodo = (text, category) => {};
  const toggleTodo = (id) => {};
  const deleteTodo = (id) => {};
  const editTodo = (id, newText) => {};

  // TODO: Derive filtered todos
  const filteredTodos = todos; // Replace with actual filter logic

  // TODO: Derive statistics
  const stats = {
    total: 0,
    active: 0,
    completed: 0,
    byCategory: {},
  };

  // TODO: Persist to localStorage when todos change
  // (Hint: You'll learn useEffect tomorrow, for now just add comment)

  return <div>{/* TODO: Implement UI */}</div>;
}
```

<details>
<summary>üí° Full Solution</summary>

```jsx
/**
 * ADR: Advanced Todo App State Structure
 *
 * Decision: Array of todo objects + separate filter states
 *
 * State shape:
 * {
 *   todos: [{ id, text, category, completed, createdAt }, ...],
 *   statusFilter: 'all' | 'active' | 'completed',
 *   categoryFilter: 'all' | 'Work' | 'Personal' | 'Shopping'
 * }
 *
 * Rationale:
 * - Array natural for ordered list
 * - Filters in separate state ‚Üí easy to reset independently
 * - Statistics derived ‚Üí always in sync
 * - Compatible v·ªõi localStorage (JSON.stringify/parse)
 *
 * Trade-offs Accepted:
 * - O(n) operations (acceptable for todo lists)
 * - Need .find() for lookups (not frequent)
 */

const CATEGORIES = ['Work', 'Personal', 'Shopping'];

function AdvancedTodoApp() {
  // ‚úÖ Lazy initialization from localStorage
  const [todos, setTodos] = useState(() => {
    const saved = localStorage.getItem('advanced-todos');
    return saved ? JSON.parse(saved) : [];
  });

  const [statusFilter, setStatusFilter] = useState('all');
  const [categoryFilter, setCategoryFilter] = useState('all');
  const [inputText, setInputText] = useState('');
  const [inputCategory, setInputCategory] = useState(CATEGORIES[0]);
  const [editingId, setEditingId] = useState(null);

  // ‚úÖ Add todo v·ªõi validation
  const addTodo = () => {
    const trimmed = inputText.trim();
    if (!trimmed) return; // Validate

    const newTodo = {
      id: Date.now(),
      text: trimmed,
      category: inputCategory,
      completed: false,
      createdAt: new Date().toISOString(),
    };

    setTodos((prev) => {
      const updated = [...prev, newTodo];
      localStorage.setItem('advanced-todos', JSON.stringify(updated));
      return updated;
    });

    setInputText(''); // Clear input
  };

  // ‚úÖ Toggle complete status
  const toggleTodo = (id) => {
    setTodos((prev) => {
      const updated = prev.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo,
      );
      localStorage.setItem('advanced-todos', JSON.stringify(updated));
      return updated;
    });
  };

  // ‚úÖ Delete todo
  const deleteTodo = (id) => {
    setTodos((prev) => {
      const updated = prev.filter((todo) => todo.id !== id);
      localStorage.setItem('advanced-todos', JSON.stringify(updated));
      return updated;
    });
  };

  // ‚úÖ Edit todo
  const startEdit = (id) => {
    const todo = todos.find((t) => t.id === id);
    setEditingId(id);
    setInputText(todo.text);
  };

  const saveEdit = () => {
    const trimmed = inputText.trim();
    if (!trimmed) return;

    setTodos((prev) => {
      const updated = prev.map((todo) =>
        todo.id === editingId ? { ...todo, text: trimmed } : todo,
      );
      localStorage.setItem('advanced-todos', JSON.stringify(updated));
      return updated;
    });

    setEditingId(null);
    setInputText('');
  };

  // ‚úÖ Derived: Filtered todos
  const filteredTodos = todos.filter((todo) => {
    // Status filter
    if (statusFilter === 'active' && todo.completed) return false;
    if (statusFilter === 'completed' && !todo.completed) return false;

    // Category filter
    if (categoryFilter !== 'all' && todo.category !== categoryFilter)
      return false;

    return true;
  });

  // ‚úÖ Derived: Statistics
  const stats = todos.reduce(
    (acc, todo) => {
      acc.total++;
      if (todo.completed) {
        acc.completed++;
      } else {
        acc.active++;
      }

      // By category
      if (!acc.byCategory[todo.category]) {
        acc.byCategory[todo.category] = { total: 0, active: 0, completed: 0 };
      }
      acc.byCategory[todo.category].total++;
      if (todo.completed) {
        acc.byCategory[todo.category].completed++;
      } else {
        acc.byCategory[todo.category].active++;
      }

      return acc;
    },
    {
      total: 0,
      active: 0,
      completed: 0,
      byCategory: {},
    },
  );

  return (
    <div
      style={{
        padding: '20px',
        fontFamily: 'system-ui',
        maxWidth: '800px',
        margin: '0 auto',
      }}
    >
      <h1>üìù Advanced Todo App</h1>

      {/* Add/Edit Form */}
      <div
        style={{
          marginBottom: '20px',
          padding: '15px',
          background: '#f5f5f5',
          borderRadius: '8px',
        }}
      >
        <input
          type='text'
          value={inputText}
          onChange={(e) => setInputText(e.target.value)}
          onKeyPress={(e) =>
            e.key === 'Enter' && (editingId ? saveEdit() : addTodo())
          }
          placeholder='Enter todo...'
          style={{ padding: '8px', width: '300px', marginRight: '10px' }}
        />

        {!editingId && (
          <select
            value={inputCategory}
            onChange={(e) => setInputCategory(e.target.value)}
            style={{ padding: '8px', marginRight: '10px' }}
          >
            {CATEGORIES.map((cat) => (
              <option
                key={cat}
                value={cat}
              >
                {cat}
              </option>
            ))}
          </select>
        )}

        {editingId ? (
          <>
            <button onClick={saveEdit}>Save</button>
            <button
              onClick={() => {
                setEditingId(null);
                setInputText('');
              }}
            >
              Cancel
            </button>
          </>
        ) : (
          <button onClick={addTodo}>Add Todo</button>
        )}
      </div>

      {/* Filters */}
      <div style={{ marginBottom: '20px', display: 'flex', gap: '20px' }}>
        <div>
          <strong>Status:</strong>{' '}
          {['all', 'active', 'completed'].map((status) => (
            <button
              key={status}
              onClick={() => setStatusFilter(status)}
              style={{
                marginLeft: '5px',
                fontWeight: statusFilter === status ? 'bold' : 'normal',
              }}
            >
              {status}
            </button>
          ))}
        </div>

        <div>
          <strong>Category:</strong>{' '}
          <button
            onClick={() => setCategoryFilter('all')}
            style={{ fontWeight: categoryFilter === 'all' ? 'bold' : 'normal' }}
          >
            All
          </button>
          {CATEGORIES.map((cat) => (
            <button
              key={cat}
              onClick={() => setCategoryFilter(cat)}
              style={{
                marginLeft: '5px',
                fontWeight: categoryFilter === cat ? 'bold' : 'normal',
              }}
            >
              {cat}
            </button>
          ))}
        </div>
      </div>

      {/* Statistics */}
      <div
        style={{
          marginBottom: '20px',
          padding: '15px',
          background: '#e3f2fd',
          borderRadius: '8px',
        }}
      >
        <h3>üìä Statistics</h3>
        <p>
          Total: {stats.total} | Active: {stats.active} | Completed:{' '}
          {stats.completed}
        </p>
        <div style={{ display: 'flex', gap: '20px', marginTop: '10px' }}>
          {CATEGORIES.map((cat) => {
            const catStats = stats.byCategory[cat] || {
              total: 0,
              active: 0,
              completed: 0,
            };
            return (
              <div
                key={cat}
                style={{
                  padding: '10px',
                  background: 'white',
                  borderRadius: '4px',
                }}
              >
                <strong>{cat}</strong>
                <div style={{ fontSize: '0.9em', marginTop: '5px' }}>
                  Total: {catStats.total} | Active: {catStats.active} | Done:{' '}
                  {catStats.completed}
                </div>
              </div>
            );
          })}
        </div>
      </div>

      {/* Todo List */}
      <div>
        <h3>Todos ({filteredTodos.length})</h3>
        {filteredTodos.length === 0 ? (
          <p style={{ color: '#999' }}>No todos match current filters</p>
        ) : (
          filteredTodos.map((todo) => (
            <div
              key={todo.id}
              style={{
                display: 'flex',
                alignItems: 'center',
                gap: '10px',
                padding: '10px',
                marginBottom: '8px',
                background: todo.completed ? '#f0f0f0' : 'white',
                border: '1px solid #ddd',
                borderRadius: '4px',
              }}
            >
              <input
                type='checkbox'
                checked={todo.completed}
                onChange={() => toggleTodo(todo.id)}
              />
              <span
                style={{
                  flex: 1,
                  textDecoration: todo.completed ? 'line-through' : 'none',
                  color: todo.completed ? '#999' : '#000',
                }}
              >
                {todo.text}
              </span>
              <span
                style={{
                  padding: '2px 8px',
                  background: '#e0e0e0',
                  borderRadius: '12px',
                  fontSize: '0.85em',
                }}
              >
                {todo.category}
              </span>
              <button onClick={() => startEdit(todo.id)}>Edit</button>
              <button onClick={() => deleteTodo(todo.id)}>Delete</button>
            </div>
          ))
        )}
      </div>

      {/* Debug */}
      <details style={{ marginTop: '30px' }}>
        <summary>üîç Debug: Raw State</summary>
        <pre
          style={{
            background: '#000',
            color: '#0f0',
            padding: '15px',
            overflow: 'auto',
          }}
        >
          {JSON.stringify({ todos, statusFilter, categoryFilter }, null, 2)}
        </pre>
      </details>
    </div>
  );
}

/**
 * KEY PRODUCTION PATTERNS:
 *
 * 1. ‚úÖ Lazy Initialization:
 *    - localStorage read only once on mount
 *    - Expensive operation kh√¥ng ch·∫°y m·ªói render
 *
 * 2. ‚úÖ Immutability Throughout:
 *    - map() for updates
 *    - filter() for deletes
 *    - spread for adds
 *
 * 3. ‚úÖ Derived State:
 *    - filteredTodos computed from todos + filters
 *    - stats computed from todos
 *    - Kh√¥ng duplicate ‚Üí always in sync
 *
 * 4. ‚úÖ Validation:
 *    - .trim() empty strings
 *    - Early returns
 *
 * 5. ‚úÖ Persistence:
 *    - localStorage.setItem after every mutation
 *    - (Note: useEffect will make this cleaner tomorrow!)
 *
 * 6. ‚úÖ UX Polish:
 *    - Clear input after add
 *    - Enter key to submit
 *    - Edit mode v·ªõi cancel
 *    - Visual feedback (strikethrough, colors)
 */
```

</details>

---

## üìä PH·∫¶N 4: SO S√ÅNH PATTERNS (30 ph√∫t)

### B·∫£ng So S√°nh Trade-offs

| Pattern                                                 | Pros ‚úÖ                                                                     | Cons ‚ùå                                                                        | When to Use üéØ                                                                          |
| ------------------------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- |
| **Direct Updates**<br/>`setCount(count + 1)`            | ‚Ä¢ ƒê∆°n gi·∫£n, d·ªÖ ƒë·ªçc<br/>‚Ä¢ √çt code h∆°n                                        | ‚Ä¢ Stale closure bugs<br/>‚Ä¢ Kh√¥ng work v·ªõi async<br/>‚Ä¢ Sai v·ªõi multiple updates | ‚Ä¢ Single update ƒë∆°n gi·∫£n<br/>‚Ä¢ Kh√¥ng c√≥ async/events                                    |
| **Functional Updates**<br/>`setCount(prev => prev + 1)` | ‚Ä¢ Lu√¥n c√≥ latest value<br/>‚Ä¢ Work v·ªõi async<br/>‚Ä¢ Safe v·ªõi multiple updates | ‚Ä¢ H∆°i verbose h∆°n<br/>‚Ä¢ C·∫ßn hi·ªÉu closure                                       | ‚Ä¢ Async operations<br/>‚Ä¢ Multiple updates<br/>‚Ä¢ Event handlers<br/>‚Ä¢ **DEFAULT CHOICE** |
| **Lazy Initialization**<br/>`useState(() => fn())`      | ‚Ä¢ Ch·ªâ ch·∫°y 1 l·∫ßn<br/>‚Ä¢ Optimize performance                                 | ‚Ä¢ Th√™m boilerplate<br/>‚Ä¢ Ph·ª©c t·∫°p h∆°n cho simple values                        | ‚Ä¢ Reading localStorage<br/>‚Ä¢ Expensive computation<br/>‚Ä¢ Heavy parsing                  |
| **Multiple States**<br/>`[a, setA], [b, setB]`          | ‚Ä¢ Clear separation<br/>‚Ä¢ Easy to understand                                 | ‚Ä¢ Many setter functions<br/>‚Ä¢ Hard to reset together<br/>‚Ä¢ Prop drilling       | ‚Ä¢ Unrelated values<br/>‚Ä¢ Different update patterns                                      |
| **Single Object State**<br/>`{a, b, c}`                 | ‚Ä¢ Group related data<br/>‚Ä¢ Easy to reset<br/>‚Ä¢ Pass to children             | ‚Ä¢ Complex updates<br/>‚Ä¢ Easy to mutate accidentally<br/>‚Ä¢ Spread overhead      | ‚Ä¢ Form data<br/>‚Ä¢ User profile<br/>‚Ä¢ Related values                                     |

---

### Decision Tree

```
Q1: Is this an initial value that's expensive to compute?
‚îú‚îÄ YES ‚Üí Use lazy initialization: useState(() => fn())
‚îî‚îÄ NO  ‚Üí Continue to Q2

Q2: Will state be updated based on previous value?
‚îú‚îÄ YES ‚Üí Use functional updates: setState(prev => ...)
‚îÇ        (especially in async/events)
‚îî‚îÄ NO  ‚Üí Continue to Q3

Q3: Are these values related/updated together?
‚îú‚îÄ YES ‚Üí Use single object state: useState({a, b, c})
‚îî‚îÄ NO  ‚Üí Use separate states: useState(a), useState(b)

Q4: Are you updating an object or array?
‚îî‚îÄ ALWAYS ‚Üí Use immutability patterns:
           ‚Ä¢ Objects: {...prev, key: value}
           ‚Ä¢ Arrays: [...prev, item] or .map()/.filter()

Q5: Can this value be computed from other state?
‚îî‚îÄ YES ‚Üí DON'T store it! Derive it:
         const fullName = firstName + lastName
```

---

## üß™ PH·∫¶N 5: DEBUG LAB (20 ph√∫t)

### Bug 1: Stale Closure trong Event Handler ‚≠ê

```jsx
// üêõ BUG: Counter kh√¥ng tƒÉng ƒë√∫ng khi click nhanh
function BuggyCounter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setTimeout(() => {
      setCount(count + 1); // BUG HERE
    }, 100);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Click me fast!</button>
    </div>
  );
}

/**
 * üîç DEBUG QUESTIONS:
 * 1. Click button 5 l·∫ßn nhanh. Count s·∫Ω l√† bao nhi√™u? T·∫°i sao?
 * 2. V·∫•n ƒë·ªÅ n·∫±m ·ªü ƒë√¢u?
 * 3. L√†m th·∫ø n√†o ƒë·ªÉ fix?
 */
```

<details>
<summary>üí° Solution</summary>

**V·∫•n ƒë·ªÅ:**

- M·ªói click t·∫°o 1 setTimeout v·ªõi closure capture `count` t·∫°i th·ªùi ƒëi·ªÉm click
- T·∫•t c·∫£ 5 setTimeout ƒë·ªÅu ƒë·ªçc `count = 0`
- Khi ch·∫°y, t·∫•t c·∫£ ƒë·ªÅu set `count = 1`
- K·∫øt qu·∫£: `count = 1` (kh√¥ng ph·∫£i 5!)

**Fix:**

```jsx
const handleClick = () => {
  setTimeout(() => {
    setCount((prev) => prev + 1); // ‚úÖ Use latest value
  }, 100);
};
```

**Lesson:** Lu√¥n d√πng functional updates trong async operations!

</details>

---

### Bug 2: Mutating State Object ‚≠ê‚≠ê

```jsx
// üêõ BUG: Form kh√¥ng update khi g√µ
function BuggyForm() {
  const [user, setUser] = useState({ name: '', email: '' });

  const handleChange = (field, value) => {
    user[field] = value; // BUG: Mutating!
    setUser(user); // BUG: Same reference!
  };

  return (
    <div>
      <input
        value={user.name}
        onChange={(e) => handleChange('name', e.target.value)}
      />
      <pre>{JSON.stringify(user)}</pre>
    </div>
  );
}

/**
 * üîç DEBUG QUESTIONS:
 * 1. T·∫°i sao input kh√¥ng hi·ªÉn th·ªã text khi g√µ?
 * 2. JSON.stringify c√≥ update kh√¥ng? T·∫°i sao?
 * 3. L√†m th·∫ø n√†o ƒë·ªÉ fix?
 */
```

<details>
<summary>üí° Solution</summary>

**V·∫•n ƒë·ªÅ:**

- Line 5: Mutating object directly (vi ph·∫°m immutability)
- Line 6: `setUser(user)` - same reference, React kh√¥ng detect change
- React so s√°nh references (===), kh√¥ng deep compare
- V√¨ reference gi·ªëng nhau ‚Üí kh√¥ng re-render

**Fix:**

```jsx
const handleChange = (field, value) => {
  setUser((prev) => ({
    ...prev, // Create new object
    [field]: value,
  }));
};
```

**Lesson:** Never mutate state! Always create new objects/arrays.

</details>

---

### Bug 3: Kh√¥ng C·∫ßn Thi·∫øt Store Derived State ‚≠ê‚≠ê‚≠ê

```jsx
// üêõ BUG: fullName out of sync
function BuggyProfile() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState(''); // BUG: Duplicate state

  const updateFirstName = (value) => {
    setFirstName(value);
    setFullName(value + ' ' + lastName); // BUG: Can forget to update
  };

  const updateLastName = (value) => {
    setLastName(value);
    // BUG: Forgot to update fullName!
  };

  return (
    <div>
      <input
        value={firstName}
        onChange={(e) => updateFirstName(e.target.value)}
      />
      <input
        value={lastName}
        onChange={(e) => updateLastName(e.target.value)}
      />
      <p>Full Name: {fullName}</p>
    </div>
  );
}

/**
 * üîç DEBUG QUESTIONS:
 * 1. G√µ v√†o firstName ‚Üí fullName update. G√µ lastName ‚Üí fullName c√≥ update kh√¥ng?
 * 2. V·∫•n ƒë·ªÅ g√¨ v·ªõi c√°ch store fullName in state?
 * 3. Solution t·ªët h∆°n l√† g√¨?
 */
```

<details>
<summary>üí° Solution</summary>

**V·∫•n ƒë·ªÅ:**

- fullName l√† **derived state** - c√≥ th·ªÉ t√≠nh t·ª´ firstName + lastName
- Store ri√™ng ‚Üí ph·∫£i manually sync ‚Üí d·ªÖ qu√™n ‚Üí bug!
- Line 14: Qu√™n update fullName khi lastName thay ƒë·ªïi

**Fix:**

```jsx
function FixedProfile() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // ‚úÖ Derive, don't store
  const fullName = `${firstName} ${lastName}`.trim();

  return (
    <div>
      <input
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
      />
      <input
        value={lastName}
        onChange={(e) => setLastName(e.target.value)}
      />
      <p>Full Name: {fullName}</p>
    </div>
  );
}
```

**Lesson:** Don't duplicate state! If it can be computed, compute it.

**Rule of Thumb:**

```jsx
// ‚ùå BAD: Storing derived value
const [items, setItems] = useState([]);
const [itemCount, setItemCount] = useState(0); // Duplicate!

// ‚úÖ GOOD: Computing derived value
const [items, setItems] = useState([]);
const itemCount = items.length; // Compute!
```

</details>

---

## ‚úÖ PH·∫¶N 6: T·ª∞ ƒê√ÅNH GI√Å (15 ph√∫t)

### Knowledge Check

ƒê√°nh d·∫•u nh·ªØng g√¨ b·∫°n ƒë√£ hi·ªÉu:

- [ ] T√¥i hi·ªÉu stale closure l√† g√¨ v√† t·∫°i sao x·∫£y ra
- [ ] T√¥i bi·∫øt khi n√†o d√πng functional updates vs direct updates
- [ ] T√¥i c√≥ th·ªÉ gi·∫£i th√≠ch lazy initialization v√† khi n√†o d√πng
- [ ] T√¥i bi·∫øt c√°ch update objects immutably v·ªõi spread
- [ ] T√¥i bi·∫øt c√°ch update arrays immutably v·ªõi map/filter/concat
- [ ] T√¥i bi·∫øt khi n√†o n√™n group state vs split state
- [ ] T√¥i hi·ªÉu derived state v√† tr√°nh duplicate state
- [ ] T√¥i c√≥ th·ªÉ debug stale closure bugs
- [ ] T√¥i c√≥ th·ªÉ debug mutation bugs
- [ ] T√¥i hi·ªÉu trade-offs c·ªßa m·ªói pattern

### Code Review Checklist

Khi review code useState, check:

**Functional Updates:**

- [ ] D√πng `prev => ...` khi update d·ª±a tr√™n previous value
- [ ] D√πng functional updates trong async operations
- [ ] D√πng functional updates trong event handlers

**Lazy Initialization:**

- [ ] D√πng `() => fn()` cho expensive initial values
- [ ] KH√îNG d√πng lazy init cho simple values

**Immutability:**

- [ ] Objects: `{...prev, key: value}` (kh√¥ng mutate)
- [ ] Arrays: `[...prev]`, `.map()`, `.filter()` (kh√¥ng mutate)
- [ ] Nested: Spread ·ªü m·ªçi level

**State Structure:**

- [ ] Related values grouped together
- [ ] Unrelated values separated
- [ ] No derived state duplication

---

## üè† B√ÄI T·∫¨P V·ªÄ NH√Ä

### B·∫Øt bu·ªôc (30 ph√∫t)

**Exercise: Fix Production Bugs**

Clone repo n√†y (mental simulation):

```
BuggyApp/
‚îú‚îÄ CounterBug.jsx       // Stale closure
‚îú‚îÄ FormBug.jsx          // Mutation
‚îú‚îÄ ProfileBug.jsx       // Derived state
‚îî‚îÄ CartBug.jsx          // Lazy init missing
```

Nhi·ªám v·ª•:

1. T√¨m v√† fix bug trong m·ªói file
2. Gi·∫£i th√≠ch t·∫°i sao bug x·∫£y ra
3. Vi·∫øt test case ƒë·ªÉ verify fix

### N√¢ng cao (60 ph√∫t)

**Exercise: Expense Tracker**

T·∫°o app qu·∫£n l√Ω chi ti√™u v·ªõi:

- Add/Edit/Delete expenses
- Categories (Food, Transport, Entertainment, etc.)
- Date filtering (This Month, Last Month, Custom Range)
- Statistics: Total by category, Average per day
- Persist to localStorage

Y√™u c·∫ßu:

- ‚úÖ Functional updates everywhere
- ‚úÖ Lazy initialization cho localStorage
- ‚úÖ Immutable updates
- ‚úÖ Derived statistics (don't store!)
- ‚úÖ Decision document cho state structure

---

## üìö T√ÄI LI·ªÜU THAM KH·∫¢O

### B·∫Øt bu·ªôc ƒë·ªçc

1. **React Docs - useState**
   - https://react.dev/reference/react/useState
   - ƒê·ªçc sections: "Updating based on previous state", "Avoiding recreating initial state"

2. **React Docs - Choosing State Structure**
   - https://react.dev/learn/choosing-the-state-structure
   - ƒê·∫∑c bi·ªát ch√∫ √Ω: "Avoid duplication in state", "Group related state"

### ƒê·ªçc th√™m

3. **A Complete Guide to useEffect** by Dan Abramov
   - https://overreacted.io/a-complete-guide-to-useeffect/
   - Section v·ªÅ closures (chu·∫©n b·ªã cho useEffect ng√†y mai)

4. **Immutability in React and Redux**
   - https://daveceddia.com/react-redux-immutability-guide/

---

## üîó K·∫æT N·ªêI KI·∫æN TH·ª®C

### Ki·∫øn th·ª©c n·ªÅn (ƒë√£ h·ªçc)

- **Ng√†y 11**: useState basics - `const [state, setState] = useState(initial)`
- **Ng√†y 10**: Component composition
- **Ng√†y 9**: Forms concept (controlled inputs)

### H∆∞·ªõng t·ªõi (s·∫Ω h·ªçc)

- **Ng√†y 13**: Forms v·ªõi State - √Åp d·ª•ng patterns h√¥m nay v√†o real forms
- **Ng√†y 14**: Lifting State Up - Share state gi·ªØa components
- **Ng√†y 17**: useEffect - Side effects v√† cleanup (closure issues ·ªü ƒë√¢y!)

---

## üí° SENIOR INSIGHTS

### C√¢n Nh·∫Øc Production

**Performance:**

```jsx
// ‚ö†Ô∏è Expensive re-computation m·ªói render
function Dashboard() {
  const [data, setData] = useState([
    /* 10000 items */
  ]);

  // ‚ùå BAD: Filter ch·∫°y m·ªói render
  const filtered = data.filter(/* complex logic */);

  // ‚úÖ BETTER: S·∫Ω h·ªçc useMemo ·ªü Ng√†y 23
  // B√¢y gi·ªù: C√¢n nh·∫Øc n·∫øu filter th·ª±c s·ª± expensive
}
```

**Memory Leaks:**

```jsx
// ‚ö†Ô∏è Potential memory leak
function Timer() {
  const [count, setCount] = useState(0);

  // ‚ùå PROBLEM: setTimeout kh√¥ng ƒë∆∞·ª£c clear
  const start = () => {
    setTimeout(() => {
      setCount((prev) => prev + 1);
      start(); // Infinite recursion!
    }, 1000);
  };

  // ‚úÖ Solution: S·∫Ω h·ªçc useEffect cleanup ·ªü Ng√†y 17
}
```

### C√¢u H·ªèi Ph·ªèng V·∫•n

**Junior Level:**
Q: "T·∫°i sao code n√†y ch·ªâ tƒÉng 1 l·∫ßn d√π g·ªçi setState 3 l·∫ßn?"

```jsx
setCount(count + 1);
setCount(count + 1);
setCount(count + 1);
```

A: V√¨ `count` l√† constant trong render, c·∫£ 3 l·∫ßn ƒë·ªÅu ƒë·ªçc c√πng gi√° tr·ªã. Fix: d√πng functional updates `setCount(prev => prev + 1)`

**Mid Level:**
Q: "Khi n√†o n√™n d√πng lazy initialization?"
A: Khi initial value expensive (localStorage read, heavy computation, DOM read). React ch·ªâ g·ªçi function 1 l·∫ßn on mount thay v√¨ m·ªói render.

**Senior Level:**
Q: "Thi·∫øt k·∫ø state structure cho feature X. Justify your choice."
A: Ph·∫£i analyze:

- Related data? ‚Üí Group into object
- Frequent updates? ‚Üí Consider split
- Derived values? ‚Üí Compute, don't store
- Update patterns? ‚Üí Object vs Array
- Document trade-offs

### War Stories

**Story 1: The Stale Closure Bug**

> M·ªôt l·∫ßn t√¥i debug bug "random" trong production: click button c√≥ khi work, c√≥ khi kh√¥ng. Sau 2 gi·ªù m·ªõi ph√°t hi·ªán l√† stale closure trong setTimeout. User click nhanh ‚Üí multiple timeouts v·ªõi stale values. Fix: ƒë·ªïi sang functional updates. Lesson: Lu√¥n d√πng functional updates trong async!

**Story 2: The Performance Nightmare**

> App ch·∫≠m d·∫ßn sau v√†i ph√∫t s·ª≠ d·ª•ng. Root cause: ƒë·ªçc t·ª´ localStorage trong useState KH√îNG lazy. M·ªói keystroke = 1 l·∫ßn parse JSON c·ªßa 10MB data! Fix: lazy initialization. Performance t·ª´ 200ms ‚Üí <1ms. Lesson: Profile before optimize, nh∆∞ng lazy init l√† low-hanging fruit.

**Story 3: The Out-of-Sync Bug**

> Bug production: statistics kh√¥ng update khi user edit item. Code store count, total, average in separate states. Developer qu√™n update average khi edit. Fix: Derive t·∫•t c·∫£ statistics. Kh√¥ng bao gi·ªù store derived state! Trade-off: Re-compute m·ªói render, nh∆∞ng always correct.

---

## üéØ PREVIEW NG√ÄY MAI

**Ng√†y 13: Forms v·ªõi State**

H√¥m nay ƒë√£ h·ªçc useState patterns. Ng√†y mai s·∫Ω √°p d·ª•ng v√†o:

- Controlled vs Uncontrolled components
- Form validation v·ªõi state
- Multiple inputs handling
- Custom hooks cho forms (gi·ªõi thi·ªáu concept)

H√¥m nay: Master patterns ‚úÖ  
Ng√†y mai: Apply to real forms üéØ

---

**üéä CH√öC M·ª™NG! B·∫°n ƒë√£ ho√†n th√†nh Ng√†y 12!**

H√¥m nay b·∫°n ƒë√£ master 5 patterns quan tr·ªçng nh·∫•t c·ªßa useState:

1. ‚úÖ Functional Updates - Fix stale closure
2. ‚úÖ Lazy Initialization - Optimize performance
3. ‚úÖ State Structure - Design decisions
4. ‚úÖ Immutability - Update safely
5. ‚úÖ Derived State - Avoid duplication

Nh·ªØng patterns n√†y s·∫Ω theo b·∫°n su·ªët career React. Practice ch√∫ng cho ƒë·∫øn khi th√†nh second nature!

üí™ Keep coding! Tomorrow: Forms mastery!
