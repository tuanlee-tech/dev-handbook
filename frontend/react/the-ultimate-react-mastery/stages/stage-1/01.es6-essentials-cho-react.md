# ğŸ“š NGÃ€Y 1: ES6+ Essentials cho React

## ğŸ“ Phase 1, Week 1, Day 1 of 169

## I. KNOWLEDGE CHECK-IN

### âœ… Kiáº¿n thá»©c tá»« trÆ°á»›c:

- JavaScript cÆ¡ báº£n (variables, functions, loops)
- HTML/CSS fundamentals
- CÃ¡ch browser cháº¡y JavaScript

### ğŸ¯ HÃ´m nay sáº½ há»c:

1. `let`/`const` vÃ  block scope
2. Arrow functions vÃ  `this` binding
3. Template literals
4. Destructuring (objects & arrays)
5. Spread/Rest operators
6. Array methods: `map`, `filter`, `reduce`

### ğŸ”— NgÃ y mai sáº½ dÃ¹ng Ä‘á»ƒ:

- Promises & async/await
- ES6 modules (import/export)
- Advanced array operations

## II. MENTAL MODELS (15 phÃºt)

### ğŸ§  Big Picture: Táº¡i sao ES6+ quan trá»ng cho React?

```
Old JavaScript (ES5)          Modern JavaScript (ES6+)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var everywhere               let/const vá»›i block scope
function() {}                () => {} concise syntax
string + concatenation       `template ${literals}`
Manual object picking        { destructuring }
.apply(), .call()            Spread ... operators
Loops everywhere             .map(), .filter(), .reduce()

                    â†“
            React Components sá»­ dá»¥ng 90% ES6+
```

### ğŸ¯ Learning Path Today:

```
1. Variables (let/const)
   â””â”€â†’ Understanding scope lÃ  ná»n táº£ng

2. Arrow Functions
   â””â”€â†’ 90% functions trong React

3. Template Literals
   â””â”€â†’ Dynamic JSX content

4. Destructuring
   â””â”€â†’ Props handling trong React

5. Spread/Rest
   â””â”€â†’ Immutable state updates

6. Array Methods
   â””â”€â†’ Rendering lists trong React
```

---

## III. CONTENT DEEP DIVE

## ğŸ“Œ 1. LET/CONST & BLOCK SCOPE (30 phÃºt)

### Mental Model:

```
var: Function-scoped (old, avoid)
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  function() {   â”‚
  â”‚    var x = 1    â”‚ â† Accessible anywhere in function
  â”‚    if (true) {  â”‚
  â”‚      var x = 2  â”‚ â† Same variable!
  â”‚    }            â”‚
  â”‚  }              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

let/const: Block-scoped (modern)
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  function() {   â”‚
  â”‚    let x = 1    â”‚ â† Outer scope
  â”‚    if (true) {  â”‚
  â”‚      let x = 2  â”‚ â† Different variable (block scope)
  â”‚    }            â”‚
  â”‚    console(x)   â”‚ â† Still 1
  â”‚  }              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Using var (confusing scope)
function processUsers() {
  var user = "John";
  if (true) {
    var user = "Jane"; // Overwrites outer user!
  }
  console.log(user); // 'Jane' - unexpected!
}

// âŒ WRONG: Mutating const primitive
const age = 25;
age = 26; // TypeError: Assignment to constant variable

// âŒ WRONG: Using let when value never changes
let API_URL = "https://api.example.com";
// Should be const - signals immutability

// âŒ WRONG: Reassigning when you want mutation
const config = { theme: "dark" };
config = { theme: "light" }; // Error!
// Should: config.theme = 'light'
```

### âœ… Best Practices:

```javascript
// âœ… RIGHT: Use const by default
const MAX_RETRIES = 3;
const API_URL = "https://api.example.com";

// âœ… RIGHT: Use let only when reassignment needed
let currentIndex = 0;
for (let i = 0; i < items.length; i++) {
  currentIndex = i;
}

// âœ… RIGHT: Block scope prevents accidents
function processData() {
  const result = [];

  if (data.length > 0) {
    const firstItem = data[0]; // Only exists in this block
    result.push(firstItem);
  }

  // firstItem not accessible here - good!
  return result;
}

// âœ… RIGHT: const with objects (reference is constant)
const user = { name: "John", age: 25 };
user.age = 26; // OK - mutating object
user.email = "john@example.com"; // OK - adding property
// user = {}; // Error - can't reassign
```

### ğŸ¯ Decision Framework:

```
Should I use const or let?
â”‚
â”œâ”€ Will the variable be reassigned?
â”‚  â”‚
â”‚  â”œâ”€ YES â†’ Use let
â”‚  â”‚       Examples: loop counters, accumulators
â”‚  â”‚
â”‚  â””â”€ NO â†’ Use const
â”‚          Examples: API URLs, functions, objects
â”‚
â””â”€ When in doubt â†’ Start with const
                    Change to let only if needed
```

---

## ğŸ“Œ 2. ARROW FUNCTIONS (30 phÃºt)

### Mental Model:

```
Regular Function              Arrow Function
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function add(a, b) {         const add = (a, b) => {
  return a + b;                return a + b;
}                            }

                             // Shorter with implicit return:
                             const add = (a, b) => a + b;

Key Difference: `this` binding
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Regular: `this` depends on HOW function is called
Arrow:   `this` is LEXICALLY bound (from surrounding scope)
```

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Arrow function as method (loses this)
const person = {
  name: "John",
  greet: () => {
    console.log(`Hi, I'm ${this.name}`); // this.name is undefined!
  },
};

// âŒ WRONG: Unnecessary braces with single expression
const double = (x) => {
  return x * 2; // Remove braces and return
};

// âŒ WRONG: Parentheses for single parameter
const square = (x) => x * x; // Remove parentheses

// âŒ WRONG: Using arrow function when you need arguments object
const sum = () => {
  return Array.from(arguments).reduce((a, b) => a + b); // Error!
};

// âŒ WRONG: Implicit return of object without parentheses
const makeUser = (name) => {
  name: name;
}; // Returns undefined!
```

### âœ… Best Practices:

```javascript
// âœ… RIGHT: Single parameter, no parentheses
const square = (x) => x * x;

// âœ… RIGHT: Multiple parameters, use parentheses
const add = (a, b) => a + b;

// âœ… RIGHT: No parameters, use empty parentheses
const getRandom = () => Math.random();

// âœ… RIGHT: Implicit return for single expression
const isEven = (num) => num % 2 === 0;

// âœ… RIGHT: Explicit return for multiple statements
const processUser = (user) => {
  const name = user.name.toUpperCase();
  const age = user.age + 1;
  return { name, age };
};

// âœ… RIGHT: Return object with parentheses
const makeUser = (name) => ({ name: name, active: true });

// âœ… RIGHT: Use regular function for methods
const person = {
  name: "John",
  greet: function () {
    // or greet() { ... }
    console.log(`Hi, I'm ${this.name}`);
  },
};

// âœ… RIGHT: Arrow functions for callbacks (preserves this)
class Timer {
  constructor() {
    this.seconds = 0;
  }

  start() {
    setInterval(() => {
      this.seconds++; // Arrow function preserves `this`
      console.log(this.seconds);
    }, 1000);
  }
}
```

### ğŸ¯ When to Use What:

```
Use Arrow Functions:
âœ“ Callbacks (array methods, event handlers)
âœ“ Short utility functions
âœ“ When you need lexical `this`
âœ“ Function expressions

Use Regular Functions:
âœ“ Object methods
âœ“ When you need `arguments` object
âœ“ Constructor functions
âœ“ When you want dynamic `this`
```

---

## ğŸ“Œ 3. TEMPLATE LITERALS (20 phÃºt)

### Mental Model:

```
Old Way (Concatenation)       Modern Way (Template Literals)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
'Hello ' + name + '!'        `Hello ${name}!`

'Line 1\n' +                 `Line 1
'Line 2\n' +                  Line 2
'Line 3'                      Line 3`

'Value: ' + (x * 2)          `Value: ${x * 2}`
```

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Using concatenation for simple strings
const greeting = "Hello " + user.name + ", welcome back!";

// âŒ WRONG: Ugly multi-line string concatenation
const html =
  '<div class="card">' +
  "<h2>" +
  title +
  "</h2>" +
  "<p>" +
  description +
  "</p>" +
  "</div>";

// âŒ WRONG: Not using expression power
const price = "Total: $" + (quantity * unitPrice).toFixed(2);

// âŒ WRONG: Nested concatenation
const message =
  "User " + user.name + " (" + user.role + ") logged in at " + timestamp;
```

### âœ… Best Practices:

```javascript
// âœ… RIGHT: Clean interpolation
const greeting = `Hello ${user.name}, welcome back!`;

// âœ… RIGHT: Multi-line strings
const html = `
  <div class="card">
    <h2>${title}</h2>
    <p>${description}</p>
  </div>
`;

// âœ… RIGHT: Expressions in templates
const price = `Total: $${(quantity * unitPrice).toFixed(2)}`;

// âœ… RIGHT: Nested templates for readability
const message = `User ${user.name} (${user.role}) logged in at ${timestamp}`;

// âœ… RIGHT: Function calls in templates
const status = `Status: ${isActive ? "Active" : "Inactive"}`;

// âœ… RIGHT: Complex expressions
const summary = `
  Order #${orderId}
  Items: ${items.length}
  Total: $${items.reduce((sum, item) => sum + item.price, 0)}
`;

// âœ… RIGHT: Tagged templates (advanced)
function highlight(strings, ...values) {
  return strings.reduce((result, str, i) => {
    return result + str + (values[i] ? `<mark>${values[i]}</mark>` : "");
  }, "");
}

const name = "John";
const age = 25;
const bio = highlight`Name: ${name}, Age: ${age}`;
// "Name: <mark>John</mark>, Age: <mark>25</mark>"
```

---

## ğŸ“Œ 4. DESTRUCTURING (45 phÃºt)

### Mental Model - Object Destructuring:

```
Traditional Way              Destructuring Way
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const name = user.name;     const { name, age, email } = user;
const age = user.age;
const email = user.email;

                            // Like unpacking a box:
                            // Box (object) â†’ Individual items (variables)
```

### Mental Model - Array Destructuring:

```
Traditional Way              Destructuring Way
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const first = arr[0];       const [first, second, third] = arr;
const second = arr[1];
const third = arr[2];

                            // Like taking items from a line:
                            // Position matters!
```

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Manually extracting object properties
function displayUser(user) {
  const name = user.name;
  const age = user.age;
  const email = user.email;
  console.log(name, age, email);
}

// âŒ WRONG: Accessing nested properties multiple times
function getCity(user) {
  if (user.address && user.address.city) {
    return user.address.city.toUpperCase();
  }
}

// âŒ WRONG: Not using default values
function greet(user) {
  const name = user.name; // Could be undefined!
  console.log(`Hello ${name}`); // "Hello undefined"
}

// âŒ WRONG: Ignoring array items without placeholder
const colors = ["red", "green", "blue"];
const red = colors[0];
const blue = colors[2]; // Skip green manually
```

### âœ… Best Practices - Objects:

```javascript
// âœ… RIGHT: Basic object destructuring
const user = { name: "John", age: 25, email: "john@example.com" };
const { name, age, email } = user;

// âœ… RIGHT: Rename variables
const { name: userName, age: userAge } = user;
console.log(userName); // 'John'

// âœ… RIGHT: Default values
const { name, role = "user" } = user;
console.log(role); // 'user' (if not in object)

// âœ… RIGHT: Nested destructuring
const user = {
  name: "John",
  address: {
    city: "New York",
    zip: "10001",
  },
};
const {
  address: { city, zip },
} = user;

// âœ… RIGHT: Function parameters
function displayUser({ name, age, email = "N/A" }) {
  console.log(`${name}, ${age}, ${email}`);
}
displayUser(user);

// âœ… RIGHT: Destructuring with rest
const { name, ...otherProps } = user;
console.log(otherProps); // { age: 25, email: '...' }

// âœ… RIGHT: Computed property names
const key = "name";
const { [key]: value } = user;
console.log(value); // 'John'
```

### âœ… Best Practices - Arrays:

```javascript
// âœ… RIGHT: Basic array destructuring
const colors = ["red", "green", "blue"];
const [first, second, third] = colors;

// âœ… RIGHT: Skipping items
const [red, , blue] = colors; // Skip green

// âœ… RIGHT: Default values
const [a, b, c = "yellow"] = ["red", "green"];
console.log(c); // 'yellow'

// âœ… RIGHT: Rest elements
const [first, ...rest] = colors;
console.log(rest); // ['green', 'blue']

// âœ… RIGHT: Swapping variables
let a = 1,
  b = 2;
[a, b] = [b, a]; // Swap without temp variable

// âœ… RIGHT: Function return values
function getCoordinates() {
  return [10, 20];
}
const [x, y] = getCoordinates();

// âœ… RIGHT: Nested array destructuring
const matrix = [
  [1, 2],
  [3, 4],
];
const [[a, b], [c, d]] = matrix;
```

### ğŸ¯ Real-world Example:

```javascript
// API response handling
const apiResponse = {
  data: {
    user: {
      id: 1,
      profile: {
        name: "John Doe",
        email: "john@example.com",
      },
      settings: {
        theme: "dark",
        notifications: true,
      },
    },
  },
  status: 200,
};

// âœ… Extract exactly what you need
const {
  data: {
    user: {
      profile: { name, email },
      settings: { theme = "light" },
    },
  },
  status,
} = apiResponse;

console.log(name, email, theme, status);
// 'John Doe', 'john@example.com', 'dark', 200
```

---

## ğŸ“Œ 5. SPREAD/REST OPERATORS (45 phÃºt)

### Mental Model:

```
Spread (...)                  Rest (...)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"Explode" array/object       "Collect" into array

const arr = [1, 2, 3];       function sum(...numbers) {
console.log(...arr);           // numbers is [1, 2, 3]
// Same as: 1, 2, 3            return numbers.reduce(...)
                             }
[...arr1, ...arr2]           sum(1, 2, 3)

{...obj1, ...obj2}           const [first, ...rest] = arr
```

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Manual array copying (mutates original)
const original = [1, 2, 3];
const copy = original; // Same reference!
copy.push(4); // Mutates original too

// âŒ WRONG: Verbose array concatenation
const combined = arr1.concat(arr2).concat(arr3);

// âŒ WRONG: Object.assign when spread is cleaner
const merged = Object.assign({}, obj1, obj2, obj3);

// âŒ WRONG: Manually building new object
const updated = {
  name: user.name,
  age: user.age,
  email: user.email,
  verified: true,
};

// âŒ WRONG: Using arguments object
function sum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}
```

### âœ… Best Practices - Spread:

```javascript
// âœ… RIGHT: Array copying
const original = [1, 2, 3];
const copy = [...original]; // New array
copy.push(4); // Original unchanged

// âœ… RIGHT: Array concatenation
const combined = [...arr1, ...arr2, ...arr3];

// âœ… RIGHT: Add items to array
const numbers = [2, 3, 4];
const moreNumbers = [1, ...numbers, 5]; // [1, 2, 3, 4, 5]

// âœ… RIGHT: Object copying and merging
const user = { name: "John", age: 25 };
const updatedUser = { ...user, age: 26 };
// { name: 'John', age: 26 }

// âœ… RIGHT: Merge multiple objects (right to left priority)
const defaults = { theme: "light", lang: "en" };
const userPrefs = { theme: "dark" };
const settings = { ...defaults, ...userPrefs };
// { theme: 'dark', lang: 'en' }

// âœ… RIGHT: Function arguments
const numbers = [1, 2, 3, 4, 5];
Math.max(...numbers); // 5 (instead of Math.max(1,2,3,4,5))

// âœ… RIGHT: Conditional properties
const user = {
  name: "John",
  ...(isAdmin && { role: "admin" }),
  ...(hasEmail && { email: "john@example.com" }),
};
```

### âœ… Best Practices - Rest:

```javascript
// âœ… RIGHT: Function with variable arguments
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}
sum(1, 2, 3, 4); // 10

// âœ… RIGHT: Separate first argument from rest
function log(level, ...messages) {
  console.log(`[${level}]`, ...messages);
}
log("ERROR", "Something", "went", "wrong");

// âœ… RIGHT: Destructuring with rest
const { name, age, ...otherProps } = user;
// name='John', age=25, otherProps={email:'...', role:'...'}

// âœ… RIGHT: Array destructuring with rest
const [first, second, ...remaining] = [1, 2, 3, 4, 5];
// first=1, second=2, remaining=[3,4,5]

// âœ… RIGHT: Ignore some properties
const { password, ...safeUser } = user;
// Remove password, keep everything else
```

### ğŸ¯ React-Relevant Pattern:

```javascript
// Immutable state updates (CRITICAL for React)

// âœ… Add item to array
const addItem = (items, newItem) => [...items, newItem];

// âœ… Remove item from array
const removeItem = (items, index) => [
  ...items.slice(0, index),
  ...items.slice(index + 1),
];

// âœ… Update item in array
const updateItem = (items, index, updates) => [
  ...items.slice(0, index),
  { ...items[index], ...updates },
  ...items.slice(index + 1),
];

// âœ… Update nested object
const user = {
  name: "John",
  address: {
    city: "New York",
    zip: "10001",
  },
};

const updatedUser = {
  ...user,
  address: {
    ...user.address,
    city: "Boston",
  },
};
```

---

## ğŸ“Œ 6. ARRAY METHODS (60 phÃºt)

### Mental Model:

```
Traditional Loop              Modern Array Methods
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for (let i...) {             .map()    - Transform each item
  // transform                .filter() - Keep items that pass test
}                            .reduce() - Combine into single value

                             .find()   - First item that matches
                             .some()   - Any item matches?
                             .every()  - All items match?
```

### ğŸ¯ Method Comparison:

| Method      | Returns                  | Original Array | Use Case            |
| ----------- | ------------------------ | -------------- | ------------------- |
| `map`       | New array (same length)  | Unchanged      | Transform each item |
| `filter`    | New array (â‰¤ length)     | Unchanged      | Keep matching items |
| `reduce`    | Single value             | Unchanged      | Combine/aggregate   |
| `find`      | Single item or undefined | Unchanged      | First match         |
| `findIndex` | Index or -1              | Unchanged      | Position of match   |
| `some`      | Boolean                  | Unchanged      | Any match?          |
| `every`     | Boolean                  | Unchanged      | All match?          |
| `forEach`   | undefined                | Unchanged      | Side effects only   |

### âŒ Anti-patterns:

```javascript
// âŒ WRONG: Using forEach when map is appropriate
const doubled = [];
numbers.forEach((num) => {
  doubled.push(num * 2);
});
// Should use map!

// âŒ WRONG: Using map for side effects
users.map((user) => {
  console.log(user.name); // Side effect, not transformation
});
// Should use forEach!

// âŒ WRONG: Chaining map multiple times
const result = numbers
  .map((x) => x * 2)
  .map((x) => x + 1)
  .map((x) => x.toString());
// Should combine into single map!

// âŒ WRONG: Using reduce when simple method works
const hasAdmin = users.reduce((found, user) => {
  return found || user.role === "admin";
}, false);
// Should use .some()!

// âŒ WRONG: Mutating during map
const updated = users.map((user) => {
  user.lastSeen = Date.now(); // MUTATION!
  return user;
});
```

### âœ… MAP - Transform Each Item:

```javascript
// âœ… Basic transformation
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);
// [2, 4, 6, 8, 10]

// âœ… Extract properties
const users = [
  { name: "John", age: 25 },
  { name: "Jane", age: 30 },
];
const names = users.map((user) => user.name);
// ['John', 'Jane']

// âœ… Transform objects
const usersWithIds = users.map((user, index) => ({
  id: index + 1,
  ...user,
}));
// [{ id: 1, name: 'John', age: 25 }, ...]

// âœ… Format for display
const formatted = users.map((user) => `${user.name} (${user.age} years old)`);

// âœ… Complex transformation
const products = [
  { name: "Laptop", price: 1000, tax: 0.1 },
  { name: "Mouse", price: 50, tax: 0.1 },
];
const withTotal = products.map((product) => ({
  ...product,
  total: product.price * (1 + product.tax),
}));
```

### âœ… FILTER - Keep Items That Match:

```javascript
// âœ… Basic filtering
const numbers = [1, 2, 3, 4, 5, 6];
const evens = numbers.filter((num) => num % 2 === 0);
// [2, 4, 6]

// âœ… Filter by property
const users = [
  { name: "John", age: 25, active: true },
  { name: "Jane", age: 30, active: false },
  { name: "Bob", age: 35, active: true },
];
const activeUsers = users.filter((user) => user.active);

// âœ… Multiple conditions
const youngActiveUsers = users.filter((user) => user.active && user.age < 30);

// âœ… Remove falsy values
const items = [1, 0, "hello", "", null, "world", undefined];
const truthy = items.filter(Boolean);
// [1, 'hello', 'world']

// âœ… Remove duplicates (with index check)
const numbers = [1, 2, 2, 3, 3, 4];
const unique = numbers.filter((num, index, arr) => arr.indexOf(num) === index);
// [1, 2, 3, 4]

// âœ… Complex filtering
const products = [
  { name: "Laptop", price: 1000, inStock: true },
  { name: "Mouse", price: 50, inStock: false },
  { name: "Keyboard", price: 100, inStock: true },
];
const affordable = products.filter((p) => p.price < 500 && p.inStock);
```

### âœ… REDUCE - Combine Into Single Value:

```javascript
// âœ… Sum numbers
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((total, num) => total + num, 0);
// 15

// âœ… Find maximum
const max = numbers.reduce((max, num) => (num > max ? num : max), numbers[0]);

// âœ… Count occurrences
const fruits = ["apple", "banana", "apple", "orange", "banana"];
const count = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});
// { apple: 2, banana: 2, orange: 1 }

// âœ… Group by property
const users = [
  { name: "John", role: "admin" },
  { name: "Jane", role: "user" },
  { name: "Bob", role: "admin" },
];
const byRole = users.reduce((groups, user) => {
  const role = user.role;
  groups[role] = groups[role] || [];
  groups[role].push(user);
  return groups;
}, {});
// { admin: [{...}, {...}], user: [{...}] }

// âœ… Transform array to object
const users = [
  { id: 1, name: "John" },
  { id: 2, name: "Jane" },
];
const usersById = users.reduce((acc, user) => {
  acc[user.id] = user;
  return acc;
}, {});
// { 1: {...}, 2: {...} }

// âœ… Flatten nested arrays
const nested = [[1, 2], [3, 4], [5]];
const flat = nested.reduce((acc, arr) => acc.concat(arr), []);
// [1, 2, 3, 4, 5]

// âœ… Calculate total price
const cart = [
  { name: "Laptop", price: 1000, quantity: 1 },
  { name: "Mouse", price: 50, quantity: 2 },
];
const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
// 1100
```

### âœ… OTHER USEFUL METHODS:

```javascript
// âœ… FIND - First matching item
const users = [
  { id: 1, name: "John" },
  { id: 2, name: "Jane" },
];
const user = users.find((u) => u.id === 2);
// { id: 2, name: 'Jane' }

// âœ… SOME - Any item matches?
const numbers = [1, 2, 3, 4, 5];
const hasEven = numbers.some((num) => num % 2 === 0);
// true

// âœ… EVERY - All items match?
const allEven = numbers.every((num) => num % 2 === 0);
// false

// âœ… INCLUDES - Array contains value?
const hasThree = numbers.includes(3);
// true

// âœ… Chaining methods
const result = users
  .filter((user) => user.active)
  .map((user) => user.name)
  .sort();
```

### ğŸ¯ React-Relevant Patterns:

```javascript
// âœ… Render list of components (map)
const UserList = ({ users }) => (
  <div>
    {users.map((user) => (
      <UserCard key={user.id} user={user} />
    ))}
  </div>
);

// âœ… Filter then render
const ActiveUsers = ({ users }) => (
  <div>
    {users
      .filter((user) => user.active)
      .map((user) => (
        <UserCard key={user.id} user={user} />
      ))}
  </div>
);

// âœ… Calculate derived state
const total = items.reduce((sum, item) => sum + item.price, 0);
const average = total / items.length;

// âœ… Transform API data
const apiUsers = await fetch("/api/users").then((r) => r.json());
const formattedUsers = apiUsers.map((user) => ({
  id: user.user_id,
  name: `${user.first_name} ${user.last_name}`,
  email: user.email_address,
}));
```

---

## IV. LIVE CODING DEMOS (45 phÃºt)

### ğŸ¯ Demo 1: User Profile Card (â­)

```javascript
// Requirement: Transform user data and display formatted info

const rawUser = {
  first_name: "John",
  last_name: "Doe",
  email: "john.doe@example.com",
  age: 25,
  address: {
    street: "123 Main St",
    city: "New York",
    state: "NY",
    zip: "10001",
  },
  preferences: {
    theme: "dark",
    notifications: true,
    language: "en",
  },
};

// âŒ Old way
function formatUserOld(user) {
  const firstName = user.first_name;
  const lastName = user.last_name;
  const email = user.email;
  const city = user.address.city;
  const state = user.address.state;
  const theme = user.preferences.theme;

  return (
    "Name: " +
    firstName +
    " " +
    lastName +
    "\n" +
    "Email: " +
    email +
    "\n" +
    "Location: " +
    city +
    ", " +
    state +
    "\n" +
    "Theme: " +
    theme
  );
}

// âœ… Modern way
const formatUser = (user) => {
  const {
    first_name: firstName,
    last_name: lastName,
    email,
    address: { city, state },
    preferences: { theme = "light" },
  } = user;

  return `Name: ${firstName} ${lastName}
Email: ${email}
Location: ${city}, ${state}
Theme: ${theme}`;
};

console.log(formatUser(rawUser));

// âœ… Even better: Return object for flexibility
const transformUser = ({
  first_name,
  last_name,
  email,
  age,
  address: { city, state, ...restAddress },
  preferences,
}) => ({
  fullName: `${first_name} ${last_name}`,
  email,
  age,
  location: `${city}, ${state}`,
  address: restAddress,
  ...preferences,
});

const user = transformUser(rawUser);
console.log(user);
// {
//   fullName: 'John Doe',
//   email: 'john.doe@example.com',
//   age: 25,
//   location: 'New York, NY',
//   address: { street: '123 Main St', zip: '10001' },
//   theme: 'dark',
//   notifications: true,
//   language: 'en'
// }
```

### ğŸ¯ Demo 2: Shopping Cart Manager (â­â­)

```javascript
// Requirement: Manage shopping cart with modern JS

const products = [
  { id: 1, name: "Laptop", price: 1000, category: "electronics" },
  { id: 2, name: "Mouse", price: 50, category: "electronics" },
  { id: 3, name: "Keyboard", price: 100, category: "electronics" },
  { id: 4, name: "Desk", price: 300, category: "furniture" },
  { id: 5, name: "Chair", price: 200, category: "furniture" },
];

const cart = [
  { productId: 1, quantity: 1 },
  { productId: 2, quantity: 2 },
  { productId: 5, quantity: 1 },
];

// âœ… Calculate cart total
const calculateTotal = (cart, products) => {
  return cart.reduce((total, item) => {
    const product = products.find((p) => p.id === item.productId);
    return total + product.price * item.quantity;
  }, 0);
};

console.log(`Total: $${calculateTotal(cart, products)}`);
// Total: $1300

// âœ… Get cart items with full details
const getCartDetails = (cart, products) => {
  return cart.map((item) => {
    const product = products.find((p) => p.id === item.productId);
    return {
      ...product,
      quantity: item.quantity,
      subtotal: product.price * item.quantity,
    };
  });
};

const cartDetails = getCartDetails(cart, products);
console.log(cartDetails);

// âœ… Group cart by category
const groupByCategory = (cartDetails) => {
  return cartDetails.reduce((groups, item) => {
    const category = item.category;
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(item);
    return groups;
  }, {});
};

const grouped = groupByCategory(cartDetails);
console.log(grouped);
// {
//   electronics: [{...}, {...}],
//   furniture: [{...}]
// }

// âœ… Add item to cart (immutably)
const addToCart = (cart, productId, quantity = 1) => {
  const existingIndex = cart.findIndex((item) => item.productId === productId);

  if (existingIndex !== -1) {
    // Update existing item
    return cart.map((item, index) =>
      index === existingIndex
        ? { ...item, quantity: item.quantity + quantity }
        : item
    );
  }

  // Add new item
  return [...cart, { productId, quantity }];
};

const newCart = addToCart(cart, 3, 1); // Add Keyboard
console.log(newCart);

// âœ… Remove item from cart (immutably)
const removeFromCart = (cart, productId) => {
  return cart.filter((item) => item.productId !== productId);
};

// âœ… Update quantity (immutably)
const updateQuantity = (cart, productId, quantity) => {
  if (quantity <= 0) {
    return removeFromCart(cart, productId);
  }

  return cart.map((item) =>
    item.productId === productId ? { ...item, quantity } : item
  );
};

// âœ… Apply discount
const applyDiscount = (total, discountPercent) => {
  return total * (1 - discountPercent / 100);
};

const finalTotal = applyDiscount(calculateTotal(cart, products), 10);
console.log(`Final Total (10% off): $${finalTotal}`);
// Final Total (10% off): $1170
```

### ğŸ¯ Demo 3: Data Processing Pipeline (â­â­â­)

```javascript
// Requirement: Process and analyze user activity data

const activities = [
  { userId: 1, action: "login", timestamp: "2025-01-01T10:00:00", duration: 0 },
  {
    userId: 1,
    action: "view",
    timestamp: "2025-01-01T10:05:00",
    duration: 300,
  },
  { userId: 2, action: "login", timestamp: "2025-01-01T10:10:00", duration: 0 },
  {
    userId: 1,
    action: "purchase",
    timestamp: "2025-01-01T10:15:00",
    duration: 120,
    amount: 100,
  },
  {
    userId: 2,
    action: "view",
    timestamp: "2025-01-01T10:20:00",
    duration: 180,
  },
  { userId: 3, action: "login", timestamp: "2025-01-01T10:25:00", duration: 0 },
  {
    userId: 2,
    action: "purchase",
    timestamp: "2025-01-01T10:30:00",
    duration: 90,
    amount: 50,
  },
  {
    userId: 1,
    action: "logout",
    timestamp: "2025-01-01T10:35:00",
    duration: 0,
  },
];

// âœ… Group activities by user
const byUser = activities.reduce((groups, activity) => {
  const { userId, ...rest } = activity;
  groups[userId] = groups[userId] || [];
  groups[userId].push(rest);
  return groups;
}, {});

console.log(byUser);

// âœ… Calculate user statistics
const getUserStats = (activities) => {
  // Group by user first
  const byUser = activities.reduce((acc, activity) => {
    const { userId } = activity;
    acc[userId] = acc[userId] || [];
    acc[userId].push(activity);
    return acc;
  }, {});

  // Calculate stats for each user
  return Object.entries(byUser).map(([userId, userActivities]) => {
    const purchases = userActivities.filter((a) => a.action === "purchase");
    const totalSpent = purchases.reduce((sum, p) => sum + (p.amount || 0), 0);
    const totalTime = userActivities.reduce((sum, a) => sum + a.duration, 0);

    return {
      userId: parseInt(userId),
      totalActivities: userActivities.length,
      totalPurchases: purchases.length,
      totalSpent,
      totalTime,
      averageSessionTime: totalTime / userActivities.length,
    };
  });
};

const stats = getUserStats(activities);
console.log(stats);
// [
//   { userId: 1, totalActivities: 4, totalPurchases: 1, totalSpent: 100, ... },
//   { userId: 2, totalActivities: 3, totalPurchases: 1, totalSpent: 50, ... },
//   { userId: 3, totalActivities: 1, totalPurchases: 0, totalSpent: 0, ... }
// ]

// âœ… Find top spenders
const getTopSpenders = (stats, limit = 3) => {
  return stats
    .filter((user) => user.totalSpent > 0)
    .sort((a, b) => b.totalSpent - a.totalSpent)
    .slice(0, limit)
    .map(({ userId, totalSpent, totalPurchases }) => ({
      userId,
      totalSpent,
      totalPurchases,
      averageOrderValue: totalSpent / totalPurchases,
    }));
};

const topSpenders = getTopSpenders(stats);
console.log("Top Spenders:", topSpenders);

// âœ… Activity timeline
const getTimeline = (activities) => {
  return activities
    .map(({ timestamp, action, userId, amount }) => ({
      time: new Date(timestamp).toLocaleTimeString(),
      event: `User ${userId}: ${action}${amount ? ` ($${amount})` : ""}`,
    }))
    .sort((a, b) => a.time.localeCompare(b.time));
};

const timeline = getTimeline(activities);
console.log("Timeline:");
timeline.forEach(({ time, event }) => {
  console.log(`${time} - ${event}`);
});

// âœ… Purchase analysis
const analyzePurchases = (activities) => {
  const purchases = activities.filter((a) => a.action === "purchase");

  if (purchases.length === 0) {
    return { count: 0, total: 0, average: 0, max: 0, min: 0 };
  }

  const amounts = purchases.map((p) => p.amount);
  const total = amounts.reduce((sum, amount) => sum + amount, 0);

  return {
    count: purchases.length,
    total,
    average: total / purchases.length,
    max: Math.max(...amounts),
    min: Math.min(...amounts),
  };
};

const purchaseAnalysis = analyzePurchases(activities);
console.log("Purchase Analysis:", purchaseAnalysis);
// {
//   count: 2,
//   total: 150,
//   average: 75,
//   max: 100,
//   min: 50
// }
```

---

## V. EXERCISES (90 phÃºt)

### ğŸ’ª Exercise 1: Variable Practice (â­) - 15 phÃºt

**Requirement**: Refactor code sá»­ dá»¥ng `let`/`const` Ä‘Ãºng cÃ¡ch.

```javascript
// Starter Code (BAD - using var):
var name = "John Doe";
var age = 25;
var email = "john@example.com";

if (age >= 18) {
  var status = "adult";
  var canVote = true;
}

console.log(name, age, email, status, canVote);

for (var i = 0; i < 3; i++) {
  var message = "Iteration " + i;
  console.log(message);
}

console.log(i); // What value? Why?
```

**Your Task**:

1. Replace `var` vá»›i `let` hoáº·c `const` appropriately
2. Fix scope issues
3. Add comments giáº£i thÃ­ch choices

**Expected Output**: Code cháº¡y giá»‘ng nhau nhÆ°ng safer.

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Solution:
const name = "John Doe"; // Never changes
const age = 25; // Never changes
const email = "john@example.com"; // Never changes

let status; // Declared outside to be accessible
let canVote; // Declared outside to be accessible

if (age >= 18) {
  status = "adult"; // Assigned in block
  canVote = true; // Assigned in block
}

console.log(name, age, email, status, canVote);

for (let i = 0; i < 3; i++) {
  // let i is block-scoped to loop
  const message = `Iteration ${i}`; // const in each iteration
  console.log(message);
}

// console.log(i); // ReferenceError - i is not defined (good!)
```

**Key Points**:

- `const` for values that never change
- `let` for values that will be reassigned
- Block scope prevents accidental variable leaks
</details>

---

### ğŸ’ª Exercise 2: Arrow Functions & Destructuring (â­â­) - 25 phÃºt

**Requirement**: Modernize function syntax vÃ  data extraction.

```javascript
// Starter Code (OLD STYLE):
const users = [
  {
    id: 1,
    name: "John Doe",
    email: "john@example.com",
    address: { city: "New York", country: "USA" },
    age: 25,
  },
  {
    id: 2,
    name: "Jane Smith",
    email: "jane@example.com",
    address: { city: "London", country: "UK" },
    age: 30,
  },
  {
    id: 3,
    name: "Bob Johnson",
    email: "bob@example.com",
    address: { city: "Paris", country: "France" },
    age: 28,
  },
];

// Old way
function getUserInfo(user) {
  const name = user.name;
  const email = user.email;
  const city = user.address.city;
  const country = user.address.country;

  return (
    "Name: " +
    name +
    "\n" +
    "Email: " +
    email +
    "\n" +
    "Location: " +
    city +
    ", " +
    country
  );
}

function filterByAge(users, minAge) {
  const result = [];
  for (let i = 0; i < users.length; i++) {
    if (users[i].age >= minAge) {
      result.push(users[i]);
    }
  }
  return result;
}

function getEmails(users) {
  const emails = [];
  for (let i = 0; i < users.length; i++) {
    emails.push(users[i].email);
  }
  return emails;
}
```

**Your Task**:

1. Convert all functions to arrow functions
2. Use destructuring trong parameters
3. Use template literals
4. Replace loops vá»›i array methods
5. Make code concise vÃ  readable

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Solution:

// 1. getUserInfo with destructuring & template literal
const getUserInfo = ({ name, email, address: { city, country } }) =>
  `Name: ${name}
Email: ${email}
Location: ${city}, ${country}`;

// Test
console.log(getUserInfo(users[0]));

// 2. filterByAge with arrow function & filter
const filterByAge = (users, minAge) =>
  users.filter((user) => user.age >= minAge);

// Or with destructuring:
const filterByAge = (users, minAge) => users.filter(({ age }) => age >= minAge);

// Test
console.log(filterByAge(users, 28));

// 3. getEmails with map
const getEmails = (users) => users.map((user) => user.email);

// Or with destructuring:
const getEmails = (users) => users.map(({ email }) => email);

// Test
console.log(getEmails(users));

// BONUS: Combine everything
const getUserSummaries = (users, minAge) =>
  users
    .filter(({ age }) => age >= minAge)
    .map(({ name, email, address: { city } }) => ({
      name,
      email,
      city,
    }));

console.log(getUserSummaries(users, 28));
```

</details>

---

### ğŸ’ª Exercise 3: Shopping Cart System (â­â­â­) - 40 phÃºt

**Requirement**: Build complete shopping cart vá»›i modern JS.

```javascript
// Products database
const products = [
  { id: 1, name: "Laptop", price: 1200, category: "electronics", stock: 5 },
  { id: 2, name: "Mouse", price: 25, category: "electronics", stock: 50 },
  { id: 3, name: "Keyboard", price: 75, category: "electronics", stock: 30 },
  { id: 4, name: "Monitor", price: 300, category: "electronics", stock: 15 },
  { id: 5, name: "Desk", price: 450, category: "furniture", stock: 8 },
  { id: 6, name: "Chair", price: 250, category: "furniture", stock: 12 },
];

// Starter cart
let cart = [];
```

**Your Task**: Implement cÃ¡c functions sau sá»­ dá»¥ng ES6+:

1. `addItem(cart, productId, quantity)` - Add/update item
2. `removeItem(cart, productId)` - Remove item
3. `updateQuantity(cart, productId, quantity)` - Update quantity
4. `calculateSubtotal(cart, products)` - Total before tax
5. `calculateTax(subtotal, taxRate)` - Calculate tax
6. `calculateTotal(cart, products, taxRate)` - Final total
7. `getCartSummary(cart, products)` - Detailed summary
8. `applyDiscount(total, discountCode)` - Apply discount codes
9. `checkStock(cart, products)` - Verify availability
10. `suggestRelated(cart, products)` - Suggest items

**Rules**:

- âŒ NO mutation of original arrays/objects
- âœ… Use spread operator for immutable updates
- âœ… Use array methods (map, filter, reduce)
- âœ… Use destructuring where appropriate
- âœ… Use arrow functions
- âœ… Handle edge cases

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Complete Solution:

// 1. Add or update item in cart (immutably)
const addItem = (cart, productId, quantity = 1) => {
  const existingIndex = cart.findIndex((item) => item.productId === productId);

  if (existingIndex !== -1) {
    // Update existing item
    return cart.map((item, index) =>
      index === existingIndex
        ? { ...item, quantity: item.quantity + quantity }
        : item
    );
  }

  // Add new item
  return [...cart, { productId, quantity }];
};

// 2. Remove item from cart
const removeItem = (cart, productId) =>
  cart.filter((item) => item.productId !== productId);

// 3. Update quantity (remove if 0 or negative)
const updateQuantity = (cart, productId, quantity) => {
  if (quantity <= 0) {
    return removeItem(cart, productId);
  }

  return cart.map((item) =>
    item.productId === productId ? { ...item, quantity } : item
  );
};

// 4. Calculate subtotal
const calculateSubtotal = (cart, products) =>
  cart.reduce((total, item) => {
    const product = products.find((p) => p.id === item.productId);
    return total + (product ? product.price * item.quantity : 0);
  }, 0);

// 5. Calculate tax
const calculateTax = (subtotal, taxRate = 0.1) => subtotal * taxRate;

// 6. Calculate final total
const calculateTotal = (cart, products, taxRate = 0.1) => {
  const subtotal = calculateSubtotal(cart, products);
  const tax = calculateTax(subtotal, taxRate);
  return subtotal + tax;
};

// 7. Get detailed cart summary
const getCartSummary = (cart, products) => {
  const items = cart.map(({ productId, quantity }) => {
    const product = products.find((p) => p.id === productId);
    return {
      ...product,
      quantity,
      subtotal: product.price * quantity,
    };
  });

  const subtotal = items.reduce((sum, item) => sum + item.subtotal, 0);
  const tax = calculateTax(subtotal);
  const total = subtotal + tax;

  return {
    items,
    itemCount: cart.reduce((sum, item) => sum + item.quantity, 0),
    subtotal,
    tax,
    total,
  };
};

// 8. Apply discount codes
const discountCodes = {
  SAVE10: 0.1,
  SAVE20: 0.2,
  SUMMER: 0.15,
};

const applyDiscount = (total, code) => {
  const discount = discountCodes[code.toUpperCase()];
  if (!discount) {
    return { total, discount: 0, message: "Invalid code" };
  }

  const discountAmount = total * discount;
  return {
    total: total - discountAmount,
    discount: discountAmount,
    message: `${discount * 100}% discount applied`,
  };
};

// 9. Check stock availability
const checkStock = (cart, products) => {
  const outOfStock = cart
    .map(({ productId, quantity }) => {
      const product = products.find((p) => p.id === productId);
      return {
        productId,
        productName: product.name,
        requested: quantity,
        available: product.stock,
        sufficient: product.stock >= quantity,
      };
    })
    .filter((item) => !item.sufficient);

  return {
    allAvailable: outOfStock.length === 0,
    outOfStock,
  };
};

// 10. Suggest related items (same category, not in cart)
const suggestRelated = (cart, products, limit = 3) => {
  const cartProductIds = cart.map((item) => item.productId);
  const cartCategories = cart
    .map(({ productId }) => products.find((p) => p.id === productId)?.category)
    .filter(
      (category, index, self) => category && self.indexOf(category) === index
    );

  return products
    .filter(
      (product) =>
        !cartProductIds.includes(product.id) &&
        cartCategories.includes(product.category)
    )
    .slice(0, limit);
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TESTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Build a cart
let myCart = [];
myCart = addItem(myCart, 1, 1); // Laptop
myCart = addItem(myCart, 2, 2); // 2x Mouse
myCart = addItem(myCart, 5, 1); // Desk

console.log("Cart:", myCart);

// Get summary
const summary = getCartSummary(myCart, products);
console.log("Summary:", summary);

// Check stock
const stockCheck = checkStock(myCart, products);
console.log("Stock Check:", stockCheck);

// Calculate total with discount
const total = calculateTotal(myCart, products, 0.1);
const withDiscount = applyDiscount(total, "SAVE20");
console.log("Total:", total);
console.log("With Discount:", withDiscount);

// Get suggestions
const suggestions = suggestRelated(myCart, products);
console.log("Suggested Products:", suggestions);

// Update quantity
myCart = updateQuantity(myCart, 2, 5); // Update mouse to 5
console.log("Updated Cart:", myCart);

// Remove item
myCart = removeItem(myCart, 5); // Remove desk
console.log("After Removal:", myCart);
```

**Testing Checklist**:

- [ ] Adding items works
- [ ] Updating quantity works
- [ ] Removing items works
- [ ] Subtotal calculates correctly
- [ ] Tax calculates correctly
- [ ] Discount codes work
- [ ] Stock checking works
- [ ] Suggestions show related items
- [ ] No mutations happen
</details>

---

### ğŸ’ª Exercise 4: Data Analytics Pipeline (â­â­â­â­) - 60 phÃºt

**Requirement**: Process vÃ  analyze e-commerce data.

```javascript
// Sales data from API
const salesData = [
  {
    orderId: 1001,
    customerId: "C001",
    date: "2025-01-01",
    items: [
      {
        productId: "P001",
        name: "Laptop",
        price: 1200,
        quantity: 1,
        category: "electronics",
      },
      {
        productId: "P002",
        name: "Mouse",
        price: 25,
        quantity: 2,
        category: "electronics",
      },
    ],
    status: "completed",
    shippingCost: 15,
  },
  {
    orderId: 1002,
    customerId: "C002",
    date: "2025-01-01",
    items: [
      {
        productId: "P003",
        name: "Desk",
        price: 450,
        quantity: 1,
        category: "furniture",
      },
    ],
    status: "completed",
    shippingCost: 50,
  },
  {
    orderId: 1003,
    customerId: "C001",
    date: "2025-01-02",
    items: [
      {
        productId: "P004",
        name: "Chair",
        price: 250,
        quantity: 2,
        category: "furniture",
      },
      {
        productId: "P002",
        name: "Mouse",
        price: 25,
        quantity: 1,
        category: "electronics",
      },
    ],
    status: "pending",
    shippingCost: 40,
  },
  {
    orderId: 1004,
    customerId: "C003",
    date: "2025-01-02",
    items: [
      {
        productId: "P001",
        name: "Laptop",
        price: 1200,
        quantity: 1,
        category: "electronics",
      },
      {
        productId: "P005",
        name: "Monitor",
        price: 300,
        quantity: 1,
        category: "electronics",
      },
    ],
    status: "completed",
    shippingCost: 20,
  },
  {
    orderId: 1005,
    customerId: "C002",
    date: "2025-01-03",
    items: [
      {
        productId: "P003",
        name: "Desk",
        price: 450,
        quantity: 1,
        category: "furniture",
      },
      {
        productId: "P004",
        name: "Chair",
        price: 250,
        quantity: 1,
        category: "furniture",
      },
    ],
    status: "completed",
    shippingCost: 60,
  },
];
```

**Your Task**: Implement analytics functions:

1. `getTotalRevenue(data)` - Total from all completed orders
2. `getRevenueByDate(data)` - Revenue grouped by date
3. `getRevenueByCategory(data)` - Revenue by product category
4. `getTopProducts(data, limit)` - Best selling products
5. `getCustomerStats(data)` - Customer purchase statistics
6. `getAverageOrderValue(data)` - AOV for completed orders
7. `getProductPerformance(data)` - Detailed product metrics
8. `getDailySummary(data)` - Complete daily breakdown
9. `getCustomerSegments(data)` - Segment customers by spend
10. `getProfitMargins(data, costs)` - Calculate profit margins

**Advanced Requirements**:

- Handle incomplete data gracefully
- Support filtering by date range
- Support filtering by status
- Calculate percentage changes
- Format currency properly

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Complete Analytics Solution:

// Helper: Calculate order total
const getOrderTotal = ({ items, shippingCost = 0 }) =>
  items.reduce((sum, item) => sum + (item.price * item.quantity), 0) + shippingCost;

// 1. Total revenue from completed orders
const getTotalRevenue = (data) =>
  data
    .filter(order => order.status === 'completed')
    .reduce((total, order) => total + getOrderTotal(order), 0);

console.log(`Total Revenue: $${getTotalRevenue(salesData)}`);

// 2. Revenue grouped by date
const getRevenueByDate = (data) => {
  const completed = data.filter(order => order.status === 'completed');

  return completed.reduce((acc, order) => {
    const { date } = order;
    const total = getOrderTotal(order);

    acc[date] = (acc[date] || 0) + total;
    return acc;
  }, {});
};

console.log('Revenue by Date:', getRevenueByDate(salesData));

// 3. Revenue by category
const getRevenueByCategory = (data) => {
  const completed = data.filter(order => order.status === 'completed');

  return completed.reduce((acc, order) => {
    order.items.forEach(({ category, price, quantity }) => {
      acc[category] = (acc[category] || 0) + (price * quantity);
    });
    return acc;
  }, {});
};

console.log('Revenue by Category:', getRevenueByCategory(salesData));

// 4. Top selling products
const getTopProducts = (data, limit = 5) => {
  const completed = data.filter(order => order.status === 'completed');

  // Aggregate product sales
  const productSales = completed.reduce((acc, order) => {
    order.items.forEach(({ productId, name, price, quantity, category }) => {
      if (!acc[productId]) {
        acc[productId] = { productId, name, category, totalQuantity: 0, totalRevenue: 0 };
      }
      acc[productId].totalQuantity += quantity;
      acc[productId].totalRevenue += price * quantity;
    });
    return acc;
  }, {});

  // Sort and limit
  return Object.values(productSales)
    .sort((a, b) => b.totalRevenue - a.totalRevenue)
    .slice(0, limit)
    .map((product, index) => ({
      rank: index + 1,
      ...product
    }));
};

console.log('Top Products:', getTopProducts(salesData, 3));

// 5. Customer statistics
const getCustomerStats = (data) => {
  const byCustomer = data.reduce((acc, order) => {
    const { customerId, status } = order;
    const total = getOrderTotal(order);

    if (!acc[customerId]) {
      acc[customerId] = {
        customerId,
        totalOrders: 0,
        completedOrders: 0,
        pendingOrders: 0,
        totalSpent: 0
      };
    }

    acc[customerId].totalOrders++;
    if (status === 'completed') {
      acc[customerId].completedOrders++;
      acc[customerId].totalSpent += total;
    } else if (status === 'pending') {
      acc[customerId].pendingOrders++;
    }

    return acc;
  }, {});

  return Object.values(byCustomer).map(customer => ({
    ...customer,
    averageOrderValue: customer.completedOrders > 0
      ? customer.totalSpent / customer.completedOrders
      : 0
  }));
};

console.log('Customer Stats:', getCustomerStats(salesData));

// 6. Average Order Value
const getAverageOrderValue = (data) => {
  const completed = data.filter(order => order.status === 'completed');
  if (completed.length === 0) return 0;

  const total = completed.reduce((sum, order) => sum + getOrderTotal(order), 0);
  return total / completed.length;
};

console.log(`Average Order Value: $${getAverageOrderValue(salesData).toFixed(2)}`);

// 7. Product performance metrics
const getProductPerformance = (data) => {
  const completed = data.filter(order => order.status === 'completed');

  const performance = completed.reduce((acc, order) => {
    order.items.forEach(({ productId, name, price, quantity, category }) => {
      if (!acc[productId]) {
        acc[productId] = {
          productId,
          name,
          category,
          unitsSold: 0,
          revenue: 0,
          orderCount: 0
        };
      }

      acc[productId].unitsSold += quantity;
      acc[productId].revenue += price * quantity;
      acc[productId].orderCount++;
    });
    return acc;
  }, {});

  return Object.values(performance).map(product => ({
    ...product,
    averageUnitsPerOrder: product.unitsSold / product.orderCount,
    averageRevenue PerOrder: product.revenue / product.orderCount
  }));
};

console.log('Product Performance:', getProductPerformance(salesData));

// 8. Daily summary
const getDailySummary = (data) => {
  const byDate = data.reduce((acc, order) => {
    const { date, status } = order;

    if (!acc[date]) {
      acc[date] = {
        date,
        totalOrders: 0,
        completedOrders: 0,
        pendingOrders: 0,
        revenue: 0,
        items: []
      };
    }

    acc[date].totalOrders++;
    if (status === 'completed') {
      acc[date].completedOrders++;
      acc[date].revenue += getOrderTotal(order);
    } else if (status === 'pending') {
      acc[date].pendingOrders++;
    }

    acc[date].items.push(...order.items.map(item => item.productId));

    return acc;
  }, {});

  return Object.values(byDate).map(day => ({
    ...day,
    uniqueProducts: [...new Set(day.items)].length,
    averageOrderValue: day.completedOrders > 0
      ? day.revenue / day.completedOrders
      : 0,
    items: undefined // Remove items array
  }));
};

console.log('Daily Summary:', getDailySummary(salesData));

// 9. Customer segments
const getCustomerSegments = (data) => {
  const stats = getCustomerStats(data);

  const segments = {
    high: { customers: [], threshold: 1000, totalSpent: 0 },
    medium: { customers: [], threshold: 500, totalSpent: 0 },
    low: { customers: [], totalSpent: 0 }
  };

  stats.forEach(customer => {
    const { totalSpent } = customer;

    if (totalSpent >= segments.high.threshold) {
      segments.high.customers.push(customer);
      segments.high.totalSpent += totalSpent;
    } else if (totalSpent >= segments.medium.threshold) {
      segments.medium.customers.push(customer);
      segments.medium.totalSpent += totalSpent;
    } else {
      segments.low.customers.push(customer);
      segments.low.totalSpent += totalSpent;
    }
  });

  return {
    high: {
      count: segments.high.customers.length,
      totalRevenue: segments.high.totalSpent,
      averageSpend: segments.high.customers.length > 0
        ? segments.high.totalSpent / segments.high.customers.length
        : 0
    },
    medium: {
      count: segments.medium.customers.length,
      totalRevenue: segments.medium.totalSpent,
      averageSpend: segments.medium.customers.length > 0
        ? segments.medium.totalSpent / segments.medium.customers.length
        : 0
    },
    low: {
      count: segments.low.customers.length,
      totalRevenue: segments.low.totalSpent,
      averageSpend: segments.low.customers.length > 0
        ? segments.low.totalSpent / segments.low.customers.length
        : 0
    }
  };
};

console.log('Customer Segments:', getCustomerSegments(salesData));

// 10. Profit margins (assuming cost data)
const productCosts = {
  'P001': 800,  // Laptop
  'P002': 15,   // Mouse
  'P003': 300,  // Desk
  'P004': 150,  // Chair
  'P005': 200   // Monitor
};

const getProfitMargins = (data, costs) => {
  const performance = getProductPerformance(data);

  return performance.map(product => {
    const cost = costs[product.productId] || 0;
    const totalCost = cost * product.unitsSold;
    const profit = product.revenue - totalCost;
    const marginPercent = product.revenue > 0
      ? (profit / product.revenue) * 100
      : 0;

    return {
      ...product,
      totalCost,
      profit,
      marginPercent: marginPercent.toFixed(2) + '%'
    };
  }).sort((a, b) => parseFloat(b.marginPercent) - parseFloat(a.marginPercent));
};

console.log('Profit Margins:', getProfitMargins(salesData, productCosts));
```

**Complete Dashboard Output:**

```javascript
const generateDashboard = (data) => {
  const revenue = getTotalRevenue(data);
  const aov = getAverageOrderValue(data);
  const topProducts = getTopProducts(data, 3);
  const segments = getCustomerSegments(data);
  const daily = getDailySummary(data);

  return {
    overview: {
      totalRevenue: `$${revenue.toFixed(2)}`,
      averageOrderValue: `$${aov.toFixed(2)}`,
      totalOrders: data.filter((o) => o.status === "completed").length,
    },
    topProducts,
    customerSegments: segments,
    dailyBreakdown: daily,
  };
};

console.log("=== DASHBOARD ===");
console.log(JSON.stringify(generateDashboard(salesData), null, 2));
```

</details>

---

### ğŸ’ª Exercise 5: Production-Ready Utility Library (â­â­â­â­â­) - 90 phÃºt

**Requirement**: Build reusable utility library vá»›i modern JS.

**Your Task**: Create `utils.js` library vá»›i:

**Array Utilities:**

1. `chunk(array, size)` - Split array into chunks
2. `unique(array)` - Remove duplicates
3. `groupBy(array, key)` - Group by property
4. `sortBy(array, key)` - Sort by property
5. `pluck(array, key)` - Extract property values

**Object Utilities:** 6. `pick(object, keys)` - Pick specific keys 7. `omit(object, keys)` - Omit specific keys 8. `merge(objects...)` - Deep merge objects 9. `flatten(object)` - Flatten nested object 10. `invert(object)` - Swap keys and values

**Function Utilities:** 11. `pipe(...fns)` - Compose functions left-to-right 12. `compose(...fns)` - Compose functions right-to-left 13. `debounce(fn, delay)` - Debounce function 14. `throttle(fn, delay)` - Throttle function 15. `memoize(fn)` - Cache function results

**Requirements**:

- All functions must be pure (no side effects)
- Handle edge cases
- Add JSDoc comments
- Include usage examples
- Write test cases

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Production-Ready Utility Library

/**
 * utils.js - Modern JavaScript Utility Library
 * All functions are pure and immutable
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARRAY UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Split array into chunks of specified size
 * @param {Array} array - Input array
 * @param {number} size - Chunk size
 * @returns {Array} Array of chunks
 */
const chunk = (array, size) => {
  if (!Array.isArray(array) || size <= 0) return [];

  return array.reduce((chunks, item, index) => {
    const chunkIndex = Math.floor(index / size);
    chunks[chunkIndex] = chunks[chunkIndex] || [];
    chunks[chunkIndex].push(item);
    return chunks;
  }, []);
};

// Usage
console.log(chunk([1, 2, 3, 4, 5, 6, 7], 3));
// [[1, 2, 3], [4, 5, 6], [7]]

/**
 * Remove duplicate values from array
 * @param {Array} array - Input array
 * @returns {Array} Array with unique values
 */
const unique = (array) => {
  if (!Array.isArray(array)) return [];
  return [...new Set(array)];
};

// Usage
console.log(unique([1, 2, 2, 3, 3, 3, 4]));
// [1, 2, 3, 4]

/**
 * Group array items by key
 * @param {Array} array - Input array
 * @param {string|Function} key - Property name or function
 * @returns {Object} Grouped object
 */
const groupBy = (array, key) => {
  if (!Array.isArray(array)) return {};

  return array.reduce((groups, item) => {
    const groupKey = typeof key === "function" ? key(item) : item[key];
    groups[groupKey] = groups[groupKey] || [];
    groups[groupKey].push(item);
    return groups;
  }, {});
};

// Usage
const users = [
  { name: "John", role: "admin" },
  { name: "Jane", role: "user" },
  { name: "Bob", role: "admin" },
];
console.log(groupBy(users, "role"));
// { admin: [...], user: [...] }

/**
 * Sort array by key
 * @param {Array} array - Input array
 * @param {string|Function} key - Property or comparator
 * @param {string} order - 'asc' or 'desc'
 * @returns {Array} Sorted array (new copy)
 */
const sortBy = (array, key, order = "asc") => {
  if (!Array.isArray(array)) return [];

  const sorted = [...array].sort((a, b) => {
    const aVal = typeof key === "function" ? key(a) : a[key];
    const bVal = typeof key === "function" ? key(b) : b[key];

    if (aVal < bVal) return order === "asc" ? -1 : 1;
    if (aVal > bVal) return order === "asc" ? 1 : -1;
    return 0;
  });

  return sorted;
};

// Usage
console.log(sortBy(users, "name", "asc"));

/**
 * Extract property values from array of objects
 * @param {Array} array - Input array
 * @param {string} key - Property name
 * @returns {Array} Array of values
 */
const pluck = (array, key) => {
  if (!Array.isArray(array)) return [];
  return array.map((item) => item?.[key]);
};

// Usage
console.log(pluck(users, "name"));
// ['John', 'Jane', 'Bob']

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OBJECT UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Pick specific keys from object
 * @param {Object} object - Input object
 * @param {Array<string>} keys - Keys to pick
 * @returns {Object} New object with picked keys
 */
const pick = (object, keys) => {
  if (!object || typeof object !== "object") return {};

  return keys.reduce((result, key) => {
    if (key in object) {
      result[key] = object[key];
    }
    return result;
  }, {});
};

// Usage
const user = {
  name: "John",
  age: 25,
  email: "john@example.com",
  password: "secret",
};
console.log(pick(user, ["name", "email"]));
// { name: 'John', email: 'john@example.com' }

/**
 * Omit specific keys from object
 * @param {Object} object - Input object
 * @param {Array<string>} keys - Keys to omit
 * @returns {Object} New object without omitted keys
 */
const omit = (object, keys) => {
  if (!object || typeof object !== "object") return {};

  return Object.keys(object).reduce((result, key) => {
    if (!keys.includes(key)) {
      result[key] = object[key];
    }
    return result;
  }, {});
};

// Usage
console.log(omit(user, ["password"]));
// { name: 'John', age: 25, email: 'john@example.com' }

/**
 * Deep merge objects
 * @param {...Object} objects - Objects to merge
 * @returns {Object} Merged object
 */
const merge = (...objects) => {
  const isObject = (obj) =>
    obj && typeof obj === "object" && !Array.isArray(obj);

  return objects.reduce((result, obj) => {
    Object.keys(obj).forEach((key) => {
      if (isObject(obj[key]) && isObject(result[key])) {
        result[key] = merge(result[key], obj[key]);
      } else {
        result[key] = obj[key];
      }
    });
    return result;
  }, {});
};

// Usage
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { b: { d: 3 }, e: 4 };
console.log(merge(obj1, obj2));
// { a: 1, b: { c: 2, d: 3 }, e: 4 }

/**
 * Flatten nested object
 * @param {Object} object - Input object
 * @param {string} separator - Key separator
 * @returns {Object} Flattened object
 */
const flatten = (object, separator = ".") => {
  const isObject = (obj) =>
    obj && typeof obj === "object" && !Array.isArray(obj);

  const flatten = (obj, prefix = "") => {
    return Object.keys(obj).reduce((acc, key) => {
      const newKey = prefix ? `${prefix}${separator}${key}` : key;

      if (isObject(obj[key])) {
        Object.assign(acc, flatten(obj[key], newKey));
      } else {
        acc[newKey] = obj[key];
      }

      return acc;
    }, {});
  };

  return flatten(object);
};

// Usage
const nested = { a: 1, b: { c: 2, d: { e: 3 } } };
console.log(flatten(nested));
// { 'a': 1, 'b.c': 2, 'b.d.e': 3 }

/**
 * Invert object (swap keys and values)
 * @param {Object} object - Input object
 * @returns {Object} Inverted object
 */
const invert = (object) => {
  if (!object || typeof object !== "object") return {};

  return Object.keys(object).reduce((result, key) => {
    result[object[key]] = key;
    return result;
  }, {});
};

// Usage
console.log(invert({ a: "1", b: "2", c: "3" }));
// { '1': 'a', '2': 'b', '3': 'c' }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNCTION UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Compose functions left-to-right
 * @param {...Function} fns - Functions to compose
 * @returns {Function} Composed function
 */
const pipe =
  (...fns) =>
  (value) =>
    fns.reduce((acc, fn) => fn(acc), value);

// Usage
const add5 = (x) => x + 5;
const multiply3 = (x) => x * 3;
const subtract2 = (x) => x - 2;

const calculate = pipe(add5, multiply3, subtract2);
console.log(calculate(10)); // ((10 + 5) * 3) - 2 = 43

/**
 * Compose functions right-to-left
 * @param {...Function} fns - Functions to compose
 * @returns {Function} Composed function
 */
const compose =
  (...fns) =>
  (value) =>
    fns.reduceRight((acc, fn) => fn(acc), value);

// Usage
const calculate2 = compose(subtract2, multiply3, add5);
console.log(calculate2(10)); // Same as pipe

/**
 * Debounce function (call after delay of inactivity)
 * @param {Function} fn - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} Debounced function
 */
const debounce = (fn, delay) => {
  let timeoutId;

  return (...args) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
};

// Usage
const searchAPI = debounce((query) => {
  console.log("Searching for:", query);
}, 500);

// Only calls after 500ms of no input
searchAPI("hello");
searchAPI("hello world"); // Only this one executes

/**
 * Throttle function (call at most once per delay)
 * @param {Function} fn - Function to throttle
 * @param {number} delay - Minimum delay between calls
 * @returns {Function} Throttled function
 */
const throttle = (fn, delay) => {
  let lastCall = 0;

  return (...args) => {
    const now = Date.now();

    if (now - lastCall >= delay) {
      lastCall = now;
      fn(...args);
    }
  };
};

// Usage
const logScroll = throttle(() => {
  console.log("Scrolled!");
}, 1000);

// Calls at most once per second
window.addEventListener("scroll", logScroll);

/**
 * Memoize function (cache results)
 * @param {Function} fn - Function to memoize
 * @returns {Function} Memoized function
 */
const memoize = (fn) => {
  const cache = new Map();

  return (...args) => {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      console.log("Cache hit!");
      return cache.get(key);
    }

    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
};

// Usage
const expensiveCalculation = (n) => {
  console.log("Calculating...");
  return n * n;
};

const memoized = memoize(expensiveCalculation);
console.log(memoized(5)); // Calculating... 25
console.log(memoized(5)); // Cache hit! 25 (instant)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT (for use in other files)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export {
  // Array
  chunk,
  unique,
  groupBy,
  sortBy,
  pluck,
  // Object
  pick,
  omit,
  merge,
  flatten,
  invert,
  // Function
  pipe,
  compose,
  debounce,
  throttle,
  memoize,
};
```

**Test Suite:**

```javascript
// utils.test.js
console.log("Running tests...\n");

// Test chunk
console.assert(
  JSON.stringify(chunk([1, 2, 3, 4, 5], 2)) ===
    JSON.stringify([[1, 2], [3, 4], [5]]),
  "chunk failed"
);

// Test unique
console.assert(
  JSON.stringify(unique([1, 1, 2, 2, 3])) === JSON.stringify([1, 2, 3]),
  "unique failed"
);

// Test groupBy
const items = [
  { type: "a", val: 1 },
  { type: "b", val: 2 },
  { type: "a", val: 3 },
];
const grouped = groupBy(items, "type");
console.assert(grouped.a.length === 2, "groupBy failed");

// Test pick
const obj = { a: 1, b: 2, c: 3 };
console.assert(
  JSON.stringify(pick(obj, ["a", "c"])) === JSON.stringify({ a: 1, c: 3 }),
  "pick failed"
);

// Test pipe
const result = pipe(
  (x) => x + 1,
  (x) => x * 2
)(5);
console.assert(result === 12, "pipe failed");

console.log("All tests passed! âœ“");
```

</details>

---

## VI. DEBUG LAB (20 phÃºt)

### ğŸ› Bug 1: Scope Issue

```javascript
// This code has a scope bug. Find and fix it.

function createCounters() {
  var counters = [];

  for (var i = 0; i < 3; i++) {
    counters.push(function () {
      console.log(i);
    });
  }

  return counters;
}

const counters = createCounters();
counters[0](); // Expected: 0, Actual: 3
counters[1](); // Expected: 1, Actual: 3
counters[2](); // Expected: 2, Actual: 3
```

<details>
<summary>ğŸ’¡ Solution & Explanation</summary>

```javascript
// Problem: `var` is function-scoped, so all functions share the same `i`
// When functions execute, i is already 3 (end of loop)

// âœ… Solution 1: Use `let` (block-scoped)
function createCounters() {
  const counters = [];

  for (let i = 0; i < 3; i++) {
    // let creates new binding each iteration
    counters.push(function () {
      console.log(i);
    });
  }

  return counters;
}

// âœ… Solution 2: Use closure (if you must use var)
function createCounters() {
  var counters = [];

  for (var i = 0; i < 3; i++) {
    counters.push(
      (function (j) {
        return function () {
          console.log(j);
        };
      })(i)
    ); // IIFE captures current i value
  }

  return counters;
}

// âœ… Solution 3: Modern approach with map
function createCounters() {
  return [0, 1, 2].map((i) => () => console.log(i));
}
```

</details>

---

### ğŸ› Bug 2: `this` Binding Issue

```javascript
// This code loses context. Find and fix it.

const user = {
  name: "John",
  friends: ["Jane", "Bob", "Alice"],

  greetFriends: function () {
    this.friends.forEach(function (friend) {
      console.log(this.name + " says hi to " + friend);
      // TypeError: Cannot read property 'name' of undefined
    });
  },
};

user.greetFriends();
```

<details>
<summary>ğŸ’¡ Solution & Explanation</summary>

```javascript
// Problem: Regular function in forEach loses `this` context

// âœ… Solution 1: Arrow function (preserves this)
const user = {
  name: "John",
  friends: ["Jane", "Bob", "Alice"],

  greetFriends: function () {
    this.friends.forEach((friend) => {
      // Arrow function!
      console.log(`${this.name} says hi to ${friend}`);
    });
  },
};

// âœ… Solution 2: Bind this
const user = {
  name: "John",
  friends: ["Jane", "Bob", "Alice"],

  greetFriends: function () {
    this.friends.forEach(
      function (friend) {
        console.log(`${this.name} says hi to ${friend}`);
      }.bind(this)
    ); // Bind this explicitly
  },
};

// âœ… Solution 3: Save this reference
const user = {
  name: "John",
  friends: ["Jane", "Bob", "Alice"],

  greetFriends: function () {
    const self = this; // Save reference
    this.friends.forEach(function (friend) {
      console.log(`${self.name} says hi to ${friend}`);
    });
  },
};
```

</details>

---

### ğŸ› Bug 3: Mutation Bug

```javascript
// This code mutates original data. Find and fix it.

const originalUsers = [
  { id: 1, name: "John", active: false },
  { id: 2, name: "Jane", active: false },
];

function activateUsers(users) {
  return users.map((user) => {
    user.active = true; // BUG: Mutating original!
    return user;
  });
}

const activeUsers = activateUsers(originalUsers);
console.log(originalUsers[0].active); // true (should be false!)
```

<details>
<summary>ğŸ’¡ Solution & Explanation</summary>

```javascript
// Problem: map returns new array but objects inside are same references

// âœ… Solution: Create new objects
function activateUsers(users) {
  return users.map((user) => ({
    ...user, // Spread creates new object
    active: true,
  }));
}

// Now originalUsers is unchanged
const activeUsers = activateUsers(originalUsers);
console.log(originalUsers[0].active); // false âœ“
console.log(activeUsers[0].active); // true âœ“

// âš ï¸ Note: Spread is shallow!
// For nested objects, need deep copy:
const deepCopy = (users) =>
  users.map((user) => ({
    ...user,
    address: { ...user.address }, // If user has nested address
  }));
```

</details>

---

## VII. INTERVIEW PREP (15 phÃºt)

### ğŸ’¼ Junior Level Questions

**Q1**: What's the difference between `let`, `const`, and `var`?

<details>
<summary>Expected Answer</summary>

- **`var`**: Function-scoped, can be redeclared, hoisted
- **`let`**: Block-scoped, cannot be redeclared, hoisted but not initialized
- **`const`**: Block-scoped, cannot be reassigned (but objects/arrays can be mutated)

```javascript
// var: function-scoped
function test() {
  if (true) {
    var x = 1;
  }
  console.log(x); // 1 (accessible outside block)
}

// let: block-scoped
function test() {
  if (true) {
    let x = 1;
  }
  console.log(x); // ReferenceError
}

// const: cannot reassign
const x = 1;
x = 2; // Error

const user = { name: "John" };
user.name = "Jane"; // OK (mutation)
user = {}; // Error (reassignment)
```

</details>

**Q2**: Explain arrow functions and when NOT to use them.

<details>
<summary>Expected Answer</summary>

Arrow functions:

- Shorter syntax
- Lexical `this` binding (inherit from surrounding scope)
- Cannot be used as constructors
- No `arguments` object

Don't use arrow functions for:

- Object methods (loses `this`)
- Event handlers that need `this`
- Functions that need `arguments`

```javascript
// âœ… Good uses:
const numbers = [1, 2, 3];
const doubled = numbers.map((x) => x * 2);

setTimeout(() => console.log("Hello"), 1000);

// âŒ Bad uses:
const person = {
  name: "John",
  greet: () => console.log(this.name), // undefined!
};

button.addEventListener("click", () => {
  this.classList.toggle("active"); // this is not the button!
});
```

</details>

---

### ğŸ’¼ Mid Level Questions

**Q3**: Explain the difference between `map`, `filter`, and `reduce`. When would you use each?

<details>
<summary>Expected Answer</summary>

- **`map`**: Transform each item, returns new array (same length)
- **`filter`**: Keep items that pass test, returns new array (â‰¤ length)
- **`reduce`**: Combine into single value

Use map when: Transforming data (API responses, formatting)
Use filter when: Removing items (search, validation)
Use reduce when: Aggregating (sums, grouping, flattening)

```javascript
const numbers = [1, 2, 3, 4, 5];

// map: transform each
const doubled = numbers.map((x) => x * 2);
// [2, 4, 6, 8, 10]

// filter: keep some
const evens = numbers.filter((x) => x % 2 === 0);
// [2, 4]

// reduce: combine
const sum = numbers.reduce((acc, x) => acc + x, 0);
// 15

// Real use: Transform API response
const apiUsers = response.data.map((user) => ({
  id: user.user_id,
  name: `${user.first} ${user.last}`,
  email: user.email_address,
}));
```

</details>

---

### ğŸ’¼ Senior Level Questions

**Q4**: Implement a `groupBy` function that groups array items by a key, then explain how `reduce` works internally.

<details>
<summary>Expected Answer</summary>

```javascript
// Implementation
const groupBy = (array, key) => {
  return array.reduce((groups, item) => {
    // Get the grouping key
    const groupKey = typeof key === "function" ? key(item) : item[key];

    // Initialize group if it doesn't exist
    if (!groups[groupKey]) {
      groups[groupKey] = [];
    }

    // Add item to group
    groups[groupKey].push(item);

    return groups;
  }, {});
};

// Usage
const users = [
  { name: "John", role: "admin", age: 25 },
  { name: "Jane", role: "user", age: 30 },
  { name: "Bob", role: "admin", age: 35 },
];

const byRole = groupBy(users, "role");
// { admin: [{...}, {...}], user: [{...}] }

const byAgeGroup = groupBy(users, (user) =>
  user.age < 30 ? "young" : "senior"
);
// { young: [{...}], senior: [{...}, {...}] }
```

**How reduce works internally**:

1. Takes accumulator (initial value) and current item
2. Executes reducer function
3. Returns new accumulator value
4. Passes to next iteration
5. Final accumulator is the result

**Key points**:

- Accumulator can be any type (object, array, number, etc.)
- Always return accumulator in each iteration
- Initial value is crucial - wrong type causes bugs
- Most powerful array method - can implement map/filter with reduce

```javascript
// Implementing map with reduce
const map = (array, fn) =>
  array.reduce((result, item) => {
    result.push(fn(item));
    return result;
  }, []);

// Implementing filter with reduce
const filter = (array, predicate) =>
  array.reduce((result, item) => {
    if (predicate(item)) {
      result.push(item);
    }
    return result;
  }, []);
```

</details>

---

**Q5**: What are the performance implications of using spread operator vs `Object.assign` vs manual property assignment for object copying?

<details>
<summary>Expected Answer</summary>

**Performance hierarchy** (fastest â†’ slowest):

1. Manual assignment (fastest)
2. `Object.assign`
3. Spread operator (slowest)

```javascript
// Benchmark example (conceptual)
const obj = { a: 1, b: 2, c: 3, d: 4, e: 5 };

// 1. Manual (fastest) ~1.0x
const manual = {
  a: obj.a,
  b: obj.b,
  c: obj.c,
  d: obj.d,
  e: obj.e,
  f: 6,
};

// 2. Object.assign (fast) ~1.2x
const assigned = Object.assign({}, obj, { f: 6 });

// 3. Spread (slower) ~1.5x
const spread = { ...obj, f: 6 };
```

**Trade-offs**:

| Method        | Performance | Readability | Maintainability | Use Case                  |
| ------------- | ----------- | ----------- | --------------- | ------------------------- |
| Manual        | â­â­â­      | â­          | â­              | Performance-critical code |
| Object.assign | â­â­        | â­â­        | â­â­            | Multiple source objects   |
| Spread        | â­          | â­â­â­      | â­â­â­          | Modern React code         |

**Real-world implications**:

- For <100 objects/sec: Use spread (readability wins)
- For >1000 objects/sec: Consider Object.assign
- For >10000 objects/sec: Profile and optimize

**React context**:

```javascript
// State updates - spread is fine
setState((prevState) => ({
  ...prevState,
  count: prevState.count + 1,
}));

// Hot path rendering - might need optimization
// (But optimize only after profiling!)
```

**Memory considerations**:

- All methods create new object (same memory cost)
- Spread has slight overhead from transpilation
- For large objects (>50 properties), consider immutability libraries
</details>

---

**Q6**: Design a data transformation pipeline using composition. Explain currying and partial application.

<details>
<summary>Expected Answer</summary>

**Composition Pattern**:

```javascript
// Individual transformations
const normalize = (str) => str.toLowerCase().trim();
const removeSpaces = (str) => str.replace(/\s+/g, "-");
const addPrefix = (prefix) => (str) => `${prefix}-${str}`;
const addSuffix = (suffix) => (str) => `${str}-${suffix}`;

// Compose (right to left)
const compose =
  (...fns) =>
  (value) =>
    fns.reduceRight((acc, fn) => fn(acc), value);

// Pipe (left to right) - more intuitive
const pipe =
  (...fns) =>
  (value) =>
    fns.reduce((acc, fn) => fn(acc), value);

// Build transformation pipeline
const createSlug = pipe(
  normalize, // "Hello World" â†’ "hello world"
  removeSpaces, // "hello world" â†’ "hello-world"
  addPrefix("post"), // "hello-world" â†’ "post-hello-world"
  addSuffix("2025") // "post-hello-world" â†’ "post-hello-world-2025"
);

console.log(createSlug("  Hello World  "));
// "post-hello-world-2025"
```

**Currying**:

```javascript
// Regular function
const add = (a, b, c) => a + b + c;
add(1, 2, 3); // 6

// Curried version
const addCurried = (a) => (b) => (c) => a + b + c;
addCurried(1)(2)(3); // 6

// Practical use: Create specialized functions
const add1 = addCurried(1);
const add1and2 = add1(2);
console.log(add1and2(3)); // 6

// Real-world example: Logger
const log = (level) => (message) => (timestamp) =>
  `[${timestamp}] ${level}: ${message}`;

const logError = log("ERROR");
const logErrorNow = logError("Something went wrong");
console.log(logErrorNow(new Date().toISOString()));
```

**Partial Application**:

```javascript
// Partial application helper
const partial =
  (fn, ...presetArgs) =>
  (...laterArgs) =>
    fn(...presetArgs, ...laterArgs);

// Example: fetch wrapper
const fetchJSON = (method, url, data) =>
  fetch(url, {
    method,
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(data),
  }).then((r) => r.json());

// Create specialized versions
const get = partial(fetchJSON, "GET");
const post = partial(fetchJSON, "POST");
const put = partial(fetchJSON, "PUT");

// Use them
get("/api/users");
post("/api/users", { name: "John" });
```

**Real-world Pipeline Example**:

```javascript
// Data transformation pipeline for API response
const transformUsers = pipe(
  // 1. Extract data array
  (response) => response.data,

  // 2. Filter active users
  (users) => users.filter((u) => u.active),

  // 3. Transform shape
  (users) =>
    users.map((u) => ({
      id: u.user_id,
      name: `${u.first_name} ${u.last_name}`,
      email: u.email_address,
    })),

  // 4. Sort by name
  (users) => users.sort((a, b) => a.name.localeCompare(b.name)),

  // 5. Add index
  (users) =>
    users.map((user, index) => ({
      ...user,
      displayOrder: index + 1,
    }))
);

// Use it
fetch("/api/users")
  .then((r) => r.json())
  .then(transformUsers)
  .then((users) => console.log(users));
```

**Key Benefits**:

- Testable (each function is pure)
- Reusable (compose in different ways)
- Readable (declarative pipeline)
- Maintainable (easy to add/remove steps)
</details>

---

## VIII. CODE REVIEW CHECKLIST (15 phÃºt)

### ğŸ“‹ ES6+ Code Review Guide

Khi review code sá»­ dá»¥ng ES6+, check cÃ¡c Ä‘iá»ƒm sau:

#### âœ… Variables & Scope

```javascript
// âŒ BAD
var count = 0;
if (true) {
  var count = 1; // Overwrites outer count
}

// âœ… GOOD
let count = 0;
if (true) {
  let count = 1; // Separate scope
}

// âœ… BETTER
const count = 0; // Use const when no reassignment needed
```

**Checklist**:

- [ ] No `var` usage
- [ ] `const` used for values that don't change
- [ ] `let` only when reassignment is needed
- [ ] No variable shadowing (unless intentional)
- [ ] Block scope used correctly

---

#### âœ… Functions

```javascript
// âŒ BAD
const user = {
  name: "John",
  greet: () => {
    // Arrow function loses this
    console.log(this.name);
  },
};

// âœ… GOOD
const user = {
  name: "John",
  greet() {
    // Shorthand method
    console.log(this.name);
  },
};

// âŒ BAD
const double = (x) => {
  return x * 2;
}; // Unnecessary braces

// âœ… GOOD
const double = (x) => x * 2; // Concise
```

**Checklist**:

- [ ] Arrow functions used for callbacks
- [ ] Regular functions used for methods
- [ ] Implicit return used when possible
- [ ] No unnecessary parentheses for single parameter
- [ ] No unnecessary braces for single expression

---

#### âœ… Destructuring

```javascript
// âŒ BAD
function displayUser(user) {
  const name = user.name;
  const email = user.email;
  const age = user.age;
}

// âœ… GOOD
function displayUser({ name, email, age }) {
  // Direct access to properties
}

// âŒ BAD
const first = arr[0];
const second = arr[1];

// âœ… GOOD
const [first, second] = arr;
```

**Checklist**:

- [ ] Object destructuring used in function parameters
- [ ] Nested destructuring used appropriately (not too deep)
- [ ] Default values provided when needed
- [ ] Rest operator used to collect remaining properties
- [ ] Array destructuring used for multiple return values

---

#### âœ… Immutability

```javascript
// âŒ BAD
function addItem(cart, item) {
  cart.push(item); // Mutation!
  return cart;
}

// âœ… GOOD
function addItem(cart, item) {
  return [...cart, item]; // New array
}

// âŒ BAD
function updateUser(user, updates) {
  user.name = updates.name; // Mutation!
  return user;
}

// âœ… GOOD
function updateUser(user, updates) {
  return { ...user, ...updates }; // New object
}
```

**Checklist**:

- [ ] No direct array mutations (push, splice, etc.)
- [ ] No direct object mutations
- [ ] Spread operator used for copying
- [ ] Array methods (map, filter, reduce) used instead of loops
- [ ] New arrays/objects returned from functions

---

#### âœ… Array Methods

```javascript
// âŒ BAD
const doubled = [];
for (let i = 0; i < numbers.length; i++) {
  doubled.push(numbers[i] * 2);
}

// âœ… GOOD
const doubled = numbers.map((n) => n * 2);

// âŒ BAD
numbers.forEach((n) => {
  console.log(n); // Side effect without transformation
});

// âœ… GOOD
// forEach is fine for side effects
// But don't return anything from forEach

// âŒ BAD
const result = numbers
  .map((n) => n * 2)
  .map((n) => n + 1)
  .map((n) => n.toString());

// âœ… GOOD
const result = numbers.map((n) => (n * 2 + 1).toString());
```

**Checklist**:

- [ ] `map` used for transformations
- [ ] `filter` used for keeping items
- [ ] `reduce` used for aggregations
- [ ] No `forEach` when `map`/`filter` would work
- [ ] Multiple maps combined when possible
- [ ] Array methods chained appropriately

---

#### âœ… Template Literals

```javascript
// âŒ BAD
const message = "Hello " + name + ", you are " + age + " years old";

// âœ… GOOD
const message = `Hello ${name}, you are ${age} years old`;

// âŒ BAD
const html =
  '<div class="' +
  className +
  '">' +
  "<h1>" +
  title +
  "</h1>" +
  "<p>" +
  content +
  "</p>" +
  "</div>";

// âœ… GOOD
const html = `
  <div class="${className}">
    <h1>${title}</h1>
    <p>${content}</p>
  </div>
`;
```

**Checklist**:

- [ ] Template literals used instead of concatenation
- [ ] Multi-line strings use template literals
- [ ] Complex expressions extracted to variables (for readability)
- [ ] No unnecessary template literals for static strings

---

### ğŸ¯ Complete Review Example

```javascript
// âŒ BEFORE (nhiá»u issues)
var users = [];

function processUsers(data) {
  for (var i = 0; i < data.length; i++) {
    var user = data[i];
    if (user.active == true) {
      var processed = {
        id: user.id,
        name: user.first_name + " " + user.last_name,
        email: user.email,
      };
      users.push(processed);
    }
  }
  return users;
}

// âœ… AFTER (fixed all issues)
const processUsers = (data) => {
  return data
    .filter((user) => user.active === true) // Explicit comparison
    .map(({ id, first_name, last_name, email }) => ({
      id,
      name: `${first_name} ${last_name}`,
      email,
    }));
};

// Even better: Extract transformation
const transformUser = ({ id, first_name, last_name, email }) => ({
  id,
  name: `${first_name} ${last_name}`,
  email,
});

const processUsers = (data) =>
  data.filter((user) => user.active).map(transformUser);
```

**Issues Fixed**:

1. âœ… `var` â†’ `const`
2. âœ… Manual loop â†’ `filter` + `map`
3. âœ… String concatenation â†’ Template literal
4. âœ… Loose equality â†’ Strict equality
5. âœ… Function expression â†’ Arrow function
6. âœ… Mutation â†’ Pure function (no external state)
7. âœ… Manual property picking â†’ Destructuring

---

## IX. COMMON PITFALLS & SOLUTIONS (20 phÃºt)

### ğŸš¨ Pitfall 1: Const Confusion

**Problem**:

```javascript
const user = { name: "John" };
user = { name: "Jane" }; // âŒ Error: Assignment to constant

const colors = ["red", "green"];
colors = ["blue"]; // âŒ Error: Assignment to constant
```

**Solution**:

```javascript
// âœ… const prevents REASSIGNMENT, not MUTATION
const user = { name: "John" };
user.name = "Jane"; // âœ… OK - mutating object

const colors = ["red", "green"];
colors.push("blue"); // âœ… OK - mutating array

// But for immutability, create new objects/arrays:
const updatedUser = { ...user, name: "Jane" };
const updatedColors = [...colors, "blue"];
```

---

### ğŸš¨ Pitfall 2: Arrow Function Returns

**Problem**:

```javascript
// âŒ Returns undefined!
const getUser = () => {
  id: 1,
  name: 'John'
};

// JavaScript thinks it's a code block, not an object!
```

**Solution**:

```javascript
// âœ… Wrap object in parentheses
const getUser = () => ({
  id: 1,
  name: "John",
});

// Or use explicit return
const getUser = () => {
  return {
    id: 1,
    name: "John",
  };
};
```

---

### ğŸš¨ Pitfall 3: Destructuring Default Values

**Problem**:

```javascript
const user = { name: "John" };

// âŒ Age is undefined, not 25!
const { name, age = 25 } = user;
// age is undefined (not 25) because user.age exists and is undefined
```

**Solution**:

```javascript
// âœ… Default values only work if property doesn't exist
const user = { name: "John" }; // No age property
const { name, age = 25 } = user; // age is 25 âœ“

// For undefined values, use nullish coalescing:
const user = { name: "John", age: undefined };
const age = user.age ?? 25; // 25
```

---

### ğŸš¨ Pitfall 4: Spread Operator is Shallow

**Problem**:

```javascript
const user = {
  name: "John",
  address: {
    city: "New York",
  },
};

const clone = { ...user };
clone.address.city = "Boston"; // âŒ Mutates original!

console.log(user.address.city); // 'Boston' (unexpected!)
```

**Solution**:

```javascript
// âœ… Manually spread nested objects
const clone = {
  ...user,
  address: { ...user.address },
};

// âœ… Or use a deep clone utility
const deepClone = JSON.parse(JSON.stringify(user));
// (Simple but has limitations: loses functions, dates, etc.)

// âœ… Or use a library (for production)
import { cloneDeep } from "lodash";
const clone = cloneDeep(user);
```

---

### ğŸš¨ Pitfall 5: Map Returns Undefined

**Problem**:

```javascript
const numbers = [1, 2, 3];

// âŒ Returns [undefined, undefined, undefined]
const doubled = numbers.map((n) => {
  n * 2; // No return statement!
});
```

**Solution**:

```javascript
// âœ… Implicit return (no braces)
const doubled = numbers.map((n) => n * 2);

// âœ… Explicit return (with braces)
const doubled = numbers.map((n) => {
  return n * 2;
});
```

---

### ğŸš¨ Pitfall 6: Reduce Without Initial Value

**Problem**:

```javascript
const numbers = [1, 2, 3, 4];

// âŒ Works for numbers but dangerous pattern
const sum = numbers.reduce((acc, n) => acc + n);

// âŒ Fails for empty array!
const empty = [];
const sum = empty.reduce((acc, n) => acc + n); // TypeError!
```

**Solution**:

```javascript
// âœ… Always provide initial value
const sum = numbers.reduce((acc, n) => acc + n, 0);

// âœ… Safe for empty arrays
const sum = [].reduce((acc, n) => acc + n, 0); // 0

// âœ… Use correct initial value for the data type
const grouped = items.reduce((acc, item) => {
  // ...
}, {}); // Object initial value

const flattened = nested.reduce((acc, arr) => {
  // ...
}, []); // Array initial value
```

---

## X. PERFORMANCE TIPS (15 phÃºt)

### âš¡ Tip 1: Avoid Unnecessary Array Iterations

```javascript
// âŒ BAD: Multiple iterations
const result = data
  .filter((item) => item.active)
  .map((item) => item.value)
  .filter((value) => value > 10);

// âœ… GOOD: Single iteration with reduce
const result = data.reduce((acc, item) => {
  if (item.active && item.value > 10) {
    acc.push(item.value);
  }
  return acc;
}, []);

// ğŸ¯ BEST: Only optimize if profiling shows it's a bottleneck!
// Readability usually wins over micro-optimizations
```

---

### âš¡ Tip 2: Memoize Expensive Operations

```javascript
// âŒ BAD: Recalculates every time
function processData(data) {
  const sorted = data.sort((a, b) => b.value - a.value);
  const top10 = sorted.slice(0, 10);
  return top10;
}

// âœ… GOOD: Memoize result
const memoize = (fn) => {
  const cache = new Map();
  return (...args) => {
    const key = JSON.stringify(args);
    if (cache.has(key)) return cache.get(key);
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
};

const processData = memoize((data) => {
  const sorted = [...data].sort((a, b) => b.value - a.value);
  return sorted.slice(0, 10);
});
```

---

### âš¡ Tip 3: Use Object Lookup Instead of Array.find

```javascript
// âŒ SLOW: O(n) for each lookup
const users = [
  /* large array */
];
const user1 = users.find((u) => u.id === 1);
const user2 = users.find((u) => u.id === 2);

// âœ… FAST: O(1) for each lookup
const usersById = users.reduce((acc, user) => {
  acc[user.id] = user;
  return acc;
}, {});

const user1 = usersById[1];
const user2 = usersById[2];
```

---

## XI. DAILY RECAP & NEXT STEPS (10 phÃºt)

### ğŸ¯ HÃ´m nay Ä‘Ã£ há»c:

#### Core Concepts:

- âœ… `let`/`const` vÃ  block scope
- âœ… Arrow functions vÃ  `this` binding
- âœ… Template literals
- âœ… Destructuring (objects & arrays)
- âœ… Spread/Rest operators
- âœ… Array methods (`map`, `filter`, `reduce`)

#### Key Takeaways:

1. **Always use `const`** by default, only `let` when reassignment needed
2. **Arrow functions** for callbacks, regular functions for methods
3. **Destructuring** makes code cleaner and more readable
4. **Spread operator** for immutable updates (critical for React)
5. **Array methods** replace loops for better readability

---

### ğŸ“ Self-Assessment Questions:

Tá»± tráº£ lá»i cÃ¡c cÃ¢u há»i sau (khÃ´ng cáº§n code):

1. Khi nÃ o dÃ¹ng `let` vs `const`?
2. Táº¡i sao arrow function khÃ´ng phÃ¹ há»£p lÃ m object method?
3. Spread operator shallow hay deep copy?
4. Khi nÃ o dÃ¹ng `map` vs `forEach` vs `reduce`?
5. LÃ m sao trÃ¡nh mutation khi update object trong array?

<details>
<summary>ğŸ’¡ Answers</summary>

1. **let vs const**: DÃ¹ng `const` cho values khÃ´ng reassign. DÃ¹ng `let` chá»‰ khi cáº§n reassignment (loops, counters). Const khÃ´ng prevent mutation (object/array methods váº«n hoáº¡t Ä‘á»™ng).

2. **Arrow functions as methods**: Arrow functions cÃ³ lexical `this` (inherit tá»« surrounding scope), khÃ´ng pháº£i dynamic `this`. Object methods cáº§n dynamic `this` Ä‘á»ƒ reference object itself.

3. **Spread shallow/deep**: Spread operator lÃ  **shallow copy**. Chá»‰ copy level Ä‘áº§u tiÃªn. Nested objects/arrays váº«n lÃ  references. Cáº§n spread manually hoáº·c dÃ¹ng deep clone utility.

4. **map vs forEach vs reduce**:

   - `map`: Transform má»—i item, return new array
   - `forEach`: Side effects only, return undefined
   - `reduce`: Aggregate thÃ nh single value (hoáº·c build complex result)

5. **Avoid mutation**: DÃ¹ng `map` Ä‘á»ƒ create new array vá»›i updated objects: `items.map((item, i) => i === index ? { ...item, ...updates } : item)`
</details>

---

### ğŸ”— NgÃ y mai sáº½ há»c:

#### ES6+ Advanced (Day 2):

- **Promises & async/await** - Asynchronous operations
- **Modules** - import/export code organization
- **Optional chaining** - Safe property access
- **Nullish coalescing** - Default value handling
- **Advanced array methods** - flatMap, find, some, every

#### Preparation:

- [ ] Review hÃ´m nay's exercises
- [ ] Complete any unfinished challenges
- [ ] Read about Promises (optional)
- [ ] Install Node.js (if not yet installed)

---

### ğŸ“š Additional Resources:

#### Official Docs:

- [MDN: JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
- [MDN: Array Methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)

#### Practice:

- [JavaScript30](https://javascript30.com/) - 30 coding challenges
- [Exercism JavaScript Track](https://exercism.org/tracks/javascript) - Practice with mentoring

#### Deep Dives:

- [JavaScript Info](https://javascript.info/) - Comprehensive tutorial
- [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) - Book series

---

## XII. HOMEWORK & PRACTICE (Optional)

### ğŸ  Tonight's Practice:

#### 1. Refactor Old Code (30 phÃºt)

TÃ¬m old JavaScript code cá»§a báº¡n (hoáº·c code online) vÃ  refactor sá»­ dá»¥ng ES6+:

- Replace `var` vá»›i `let`/`const`
- Convert functions sang arrow functions
- Add destructuring
- Replace loops vá»›i array methods

#### 2. Build Mini Project (60 phÃºt)

**Todo List Manager** (Pure JavaScript, NO React yet):

```javascript
// Requirements:
// - Add/remove/update todos
// - Filter by status (all/active/completed)
// - Sort by date/priority
// - Calculate statistics
// - All using ES6+ features
```

#### 3. Code Challenge (45 phÃºt)

Implement these utilities from scratch:

- `flatten(array, depth)` - Flatten nested arrays
- `difference(arr1, arr2)` - Items in arr1 not in arr2
- `intersection(arr1, arr2)` - Items in both arrays
- `union(arr1, arr2)` - All unique items
- `partition(array, predicate)` - Split by condition

---

## ğŸ‰ CONGRATULATIONS!

Báº¡n Ä‘Ã£ hoÃ n thÃ nh **NgÃ y 1: ES6+ Essentials cho React**!

### ğŸ“Š Progress Tracker:

```
PHASE 1: React Fundamentals (Week 1-4)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Week 1: Modern JavaScript (Days 1-5)
â”œâ”€ [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘] 20% Complete
â”‚  â””â”€ Day 1: ES6+ Essentials âœ…
â”‚  â””â”€ Day 2: ES6+ Advanced
â”‚  â””â”€ Day 3: React Basics & JSX
â”‚  â””â”€ Day 4: Components & Props
â”‚  â””â”€ Day 5: Events & Conditional Rendering
```

**You're on track!** ğŸš€

---

### ğŸ’¬ Final Tips:

1. **Practice Daily** - Code má»—i ngÃ y, dÃ¹ chá»‰ 30 phÃºt
2. **Build Real Things** - Apply concepts vÃ o projects thá»±c táº¿
3. **Debug Actively** - Má»—i bug lÃ  cÆ¡ há»™i há»c
4. **Ask Questions** - KhÃ´ng cÃ³ cÃ¢u há»i ngu, chá»‰ cÃ³ ngÆ°á»i khÃ´ng há»i
5. **Review Often** - Quay láº¡i material nÃ y khi cáº§n

---

### â“ Questions Before Next Lesson?

Review checklist:

- [ ] Hiá»ƒu khÃ¡c biá»‡t let/const/var
- [ ] Thoáº£i mÃ¡i vá»›i arrow functions
- [ ] Biáº¿t khi nÃ o dÃ¹ng destructuring
- [ ] Hiá»ƒu spread operator vÃ  immutability
- [ ] ThÃ nh tháº¡o map/filter/reduce

Náº¿u cÃ²n unclear á»Ÿ báº¥t ká»³ pháº§n nÃ o, hÃ£y review láº¡i section Ä‘Ã³ trÆ°á»›c khi chuyá»ƒn sang Day 2!

---

**See you tomorrow for Day 2: ES6+ Advanced!** ğŸ‘‹
