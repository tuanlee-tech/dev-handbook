# ğŸ“š NGÃ€Y 1: ES6+ Essentials cho React

## ğŸ“ Phase 1, Week 1, Day 1 of 169

## I. KNOWLEDGE CHECK-IN

### âœ… Kiáº¿n thá»©c tá»« trÆ°á»›c:

-   JavaScript cÆ¡ báº£n (variables, functions, loops)
-   HTML/CSS fundamentals
-   CÃ¡ch browser cháº¡y JavaScript

### ğŸ¯ HÃ´m nay sáº½ há»c:

1. `let`/`const` vÃ  block scope
2. Arrow functions vÃ  `this` binding
3. Template literals
4. Destructuring (objects & arrays)
5. Spread/Rest operators
6. Array methods: `map`, `filter`, `reduce`

### ğŸ”— NgÃ y mai sáº½ dÃ¹ng Ä‘á»ƒ:

-   Promises & async/await
-   ES6 modules (import/export)
-   Advanced array operations

## II. MENTAL MODELS (15 phÃºt)

### ğŸ§  Big Picture: Táº¡i sao ES6+ quan trá»ng cho React?

```
Old JavaScript (ES5)          Modern JavaScript (ES6+)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var everywhere               let/const vá»›i block scope
function() {}                () => {} concise syntax
string + concatenation       `template ${literals}`
Manual object picking        { destructuring }
.apply(), .call()            Spread ... operators
Loops everywhere             .map(), .filter(), .reduce()

                    â†“
            React Components sá»­ dá»¥ng 90% ES6+
```

### ğŸ¯ Learning Path Today:

```
1. Variables (let/const)
   â””â”€â†’ Understanding scope lÃ  ná»n táº£ng

2. Arrow Functions
   â””â”€â†’ 90% functions trong React

3. Template Literals
   â””â”€â†’ Dynamic JSX content

4. Destructuring
   â””â”€â†’ Props handling trong React

5. Spread/Rest
   â””â”€â†’ Immutable state updates

6. Array Methods
   â””â”€â†’ Rendering lists trong React
```

---

## III. CONTENT DEEP DIVE

## ğŸ“Œ 1. LET/CONST & BLOCK SCOPE (30 phÃºt)

### Mental Model:

```
var: Pháº¡m vi theo function (cÅ©, nÃªn trÃ¡nh)
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  function() {   â”‚
  â”‚    var x = 1    â”‚ â† Truy cáº­p Ä‘Æ°á»£c á»Ÿ báº¥t cá»© Ä‘Ã¢u trong function
  â”‚    if (true) {  â”‚
  â”‚      var x = 2  â”‚ â† CÃ¹ng má»™t biáº¿n!
  â”‚    }            â”‚
  â”‚  }              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

let/const: Pháº¡m vi theo block (hiá»‡n Ä‘áº¡i)
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  function() {   â”‚
  â”‚    let x = 1    â”‚ â† Pháº¡m vi bÃªn ngoÃ i
  â”‚    if (true) {  â”‚
  â”‚      let x = 2  â”‚ â† Biáº¿n khÃ¡c (pháº¡m vi block)
  â”‚    }            â”‚
  â”‚    console(x)   â”‚ â† Váº«n lÃ  1
  â”‚  }              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### âŒ Anti-patterns:

```javascript
// âŒ SAI: Sá»­ dá»¥ng var (pháº¡m vi dá»… gÃ¢y nháº§m láº«n)
function processUsers() {
    var user = 'John';
    if (true) {
        var user = 'Jane'; // Ghi Ä‘Ã¨ user bÃªn ngoÃ i!
    }
    console.log(user); // 'Jane' - khÃ´ng mong muá»‘n!
}

// âŒ SAI: Thay Ä‘á»•i giÃ¡ trá»‹ const primitive
const age = 25;
age = 26; // TypeError: Assignment to constant variable

// âŒ SAI: Sá»­ dá»¥ng let khi giÃ¡ trá»‹ khÃ´ng thay Ä‘á»•i
let API_URL = 'https://api.example.com';
// NÃªn dÃ¹ng const - biá»ƒu thá»‹ tÃ­nh báº¥t biáº¿n

// âŒ SAI: GÃ¡n láº¡i khi muá»‘n mutation
const config = { theme: 'dark' };
config = { theme: 'light' }; // Lá»—i!
// ÄÃºng ra: config.theme = 'light'
```

### âœ… Best Practices:

```javascript
// âœ… ÄÃšNG: Máº·c Ä‘á»‹nh dÃ¹ng const
const MAX_RETRIES = 3;
const API_URL = 'https://api.example.com';

// âœ… ÄÃšNG: DÃ¹ng let chá»‰ khi cáº§n gÃ¡n láº¡i
let currentIndex = 0;
for (let i = 0; i < items.length; i++) {
    currentIndex = i;
}

// âœ… ÄÃšNG: Pháº¡m vi block ngÄƒn ngá»«a lá»—i khÃ´ng mong muá»‘n
function processData() {
    const result = [];

    if (data.length > 0) {
        const firstItem = data[0]; // Chá»‰ tá»“n táº¡i trong block nÃ y
        result.push(firstItem);
    }

    // firstItem khÃ´ng truy cáº­p Ä‘Æ°á»£c á»Ÿ Ä‘Ã¢y - tá»‘t!
    return result;
}

// âœ… ÄÃšNG: const vá»›i object (tham chiáº¿u khÃ´ng Ä‘á»•i)
const user = { name: 'John', age: 25 };
user.age = 26; // OK - thay Ä‘á»•i object
user.email = 'john@example.com'; // OK - thÃªm thuá»™c tÃ­nh
// user = {}; // TypeError: Assignment to constant variable
```

### ğŸ¯ Decision Framework:

```
NÃªn dÃ¹ng const hay let?
â”‚
â”œâ”€ Biáº¿n nÃ y cÃ³ bá»‹ gÃ¡n láº¡i khÃ´ng?
â”‚  â”‚
â”‚  â”œâ”€ CÃ“ â†’ DÃ¹ng let
â”‚  â”‚       VÃ­ dá»¥: bá»™ Ä‘áº¿m vÃ²ng láº·p, biáº¿n tÃ­ch lÅ©y
â”‚  â”‚
â”‚  â””â”€ KHÃ”NG â†’ DÃ¹ng const
â”‚          VÃ­ dá»¥: API URLs, functions, objects
â”‚
â””â”€ Khi nghi ngá» â†’ Báº¯t Ä‘áº§u vá»›i const
                    Chá»‰ Ä‘á»•i sang let khi cáº§n
```

---

## ğŸ“Œ 2. ARROW FUNCTIONS (30 phÃºt)

### Mental Model:

```
Regular Function              Arrow Function
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function add(a, b) {         const add = (a, b) => {
  return a + b;                return a + b;
}                            }

                             // Ngáº¯n gá»n hÆ¡n vá»›i implicit return:
                             const add = (a, b) => a + b;

Äiá»ƒm khÃ¡c biá»‡t chÃ­nh: binding cá»§a `this`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Regular: `this` phá»¥ thuá»™c vÃ o CÃCH function Ä‘Æ°á»£c gá»i
Arrow:   `this` Ä‘Æ°á»£c binding THEO LEXICAL (tá»« pháº¡m vi bao quanh)
```

### âŒ Anti-patterns (CÃ¡c anti-pattern):

```javascript
// âŒ WRONG: Arrow function lÃ m method (máº¥t this)
const person = {
    name: 'John',
    greet: () => {
        console.log(`Hi, I'm ${this.name}`); // this.name is undefined! (khÃ´ng xÃ¡c Ä‘á»‹nh)
    },
};

// âŒ WRONG: DÃ¹ng braces khÃ´ng cáº§n thiáº¿t vá»›i single expression
const double = (x) => {
    return x * 2; // Remove braces and return (bá» braces vÃ  return)
};

// âŒ WRONG: DÃ¹ng parentheses cho single parameter
const square = (x) => x * x; // Remove parentheses (bá» parentheses)

// âŒ WRONG: DÃ¹ng arrow function khi cáº§n arguments object
const sum = () => {
    return Array.from(arguments).reduce((a, b) => a + b); // Error! (lá»—i)
};

// âŒ WRONG: Implicit return object nhÆ°ng thiáº¿u parentheses
const makeUser = (name) => {
    name: name;
}; // Returns undefined! (tráº£ vá» khÃ´ng xÃ¡c Ä‘á»‹nh)
```

### âœ… Best Practices (Thá»±c hÃ nh tá»‘t nháº¥t):

```javascript
// âœ… RIGHT: Single parameter, khÃ´ng cáº§n parentheses
const square = (x) => x * x;

// âœ… RIGHT: Multiple parameters, dÃ¹ng parentheses
const add = (a, b) => a + b;

// âœ… RIGHT: KhÃ´ng cÃ³ parameters, dÃ¹ng empty parentheses
const getRandom = () => Math.random();

// âœ… RIGHT: Implicit return cho single expression
const isEven = (num) => num % 2 === 0;

// âœ… RIGHT: Explicit return cho nhiá»u statements
const processUser = (user) => {
    const name = user.name.toUpperCase();
    const age = user.age + 1;
    return { name, age };
};

// âœ… RIGHT: Return object vá»›i parentheses
const makeUser = (name) => ({ name: name, active: true });

// âœ… RIGHT: DÃ¹ng regular function cho methods
const person = {
    name: 'John',
    greet: function () {
        // hoáº·c greet() { ... }
        console.log(`Hi, I'm ${this.name}`);
    },
};

// âœ… RIGHT: Arrow functions cho callbacks (giá»¯ nguyÃªn this)
class Timer {
    constructor() {
        this.seconds = 0;
    }

    start() {
        setInterval(() => {
            this.seconds++; // Arrow function giá»¯ nguyÃªn `this`
            console.log(this.seconds);
        }, 1000);
    }
}
```

### ğŸ¯ When to Use What (Khi nÃ o dÃ¹ng cÃ¡i nÃ o):

```
Use Arrow Functions:
âœ“ Callbacks (array methods, event handlers)
âœ“ Short utility functions
âœ“ Khi cáº§n lexical `this`
âœ“ Function expressions

Use Regular Functions:
âœ“ Object methods
âœ“ Khi cáº§n `arguments` object
âœ“ Constructor functions
âœ“ Khi muá»‘n `this` Ä‘á»™ng
```

---

## ğŸ“Œ 3. TEMPLATE LITERALS (20 phÃºt)

### Mental Model (MÃ´ hÃ¬nh tÆ° duy):

```
Old Way (Concatenation)       Modern Way (Template Literals)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
'Hello ' + name + '!'        `Hello ${name}!`

'Line 1\n' +                 `Line 1
'Line 2\n' +                  Line 2
'Line 3'                      Line 3`

'Value: ' + (x * 2)          `Value: ${x * 2}`
```

### âŒ Anti-patterns (CÃ¡c anti-pattern):

```javascript
// âŒ WRONG: DÃ¹ng concatenation cho chuá»—i Ä‘Æ¡n giáº£n
const greeting = 'Hello ' + user.name + ', welcome back!';

// âŒ WRONG: Ná»‘i chuá»—i nhiá»u dÃ²ng xáº¥u, khÃ³ Ä‘á»c
const html =
    '<div class="card">' +
    '<h2>' +
    title +
    '</h2>' +
    '<p>' +
    description +
    '</p>' +
    '</div>';

// âŒ WRONG: KhÃ´ng táº­n dá»¥ng sá»©c máº¡nh expression
const price = 'Total: $' + (quantity * unitPrice).toFixed(2);

// âŒ WRONG: Nested concatenation (ná»‘i chuá»—i lá»“ng nhau)
const message =
    'User ' + user.name + ' (' + user.role + ') logged in at ' + timestamp;
```

### âœ… Best Practices (Thá»±c hÃ nh tá»‘t nháº¥t):

```javascript
// âœ… RIGHT: Clean interpolation (ná»™i suy chuá»—i rÃµ rÃ ng, sáº¡ch sáº½)
const greeting = `Hello ${user.name}, welcome back!`;

// âœ… RIGHT: Multi-line strings (chuá»—i nhiá»u dÃ²ng)
const html = `
  <div class="card">
    <h2>${title}</h2>
    <p>${description}</p>
  </div>
`;

// âœ… RIGHT: Expressions in templates (dÃ¹ng biá»ƒu thá»©c trong template)
const price = `Total: $${(quantity * unitPrice).toFixed(2)}`;

// âœ… RIGHT: Nested templates for readability (template lá»“ng nhau, dá»… Ä‘á»c)
const message = `User ${user.name} (${user.role}) logged in at ${timestamp}`;

// âœ… RIGHT: Function calls in templates (gá»i hÃ m trong template)
const status = `Status: ${isActive ? 'Active' : 'Inactive'}`;

// âœ… RIGHT: Complex expressions (biá»ƒu thá»©c phá»©c táº¡p)
const summary = `
  Order #${orderId}
  Items: ${items.length}
  Total: $${items.reduce((sum, item) => sum + item.price, 0)}
`;

// âœ… RIGHT: Tagged templates (advanced) (tagged template â€“ nÃ¢ng cao)
function highlight(strings, ...values) {
    return strings.reduce((result, str, i) => {
        return result + str + (values[i] ? `<mark>${values[i]}</mark>` : '');
    }, '');
}

const name = 'John';
const age = 25;
const bio = highlight`Name: ${name}, Age: ${age}`;
// "Name: <mark>John</mark>, Age: <mark>25</mark>"
```

---

## ğŸ“Œ 4. DESTRUCTURING (45 phÃºt)

### Mental Model - Object Destructuring (MÃ´ hÃ¬nh tÆ° duy â€“ Object Destructuring):

```
Traditional Way              Destructuring Way
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const name = user.name;     const { name, age, email } = user;
const age = user.age;
const email = user.email;

                            // Like unpacking a box:
                            // Box (object) â†’ Individual items (variables)
                            // Giá»‘ng nhÆ° má»Ÿ má»™t cÃ¡i há»™p:
                            // Há»™p (object) â†’ CÃ¡c mÃ³n riÃªng láº» (biáº¿n)
```

### Mental Model - Array Destructuring (MÃ´ hÃ¬nh tÆ° duy â€“ Array Destructuring):

```
Traditional Way              Destructuring Way
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const first = arr[0];       const [first, second, third] = arr;
const second = arr[1];
const third = arr[2];

                            // Like taking items from a line:
                            // Position matters!
                            // Giá»‘ng nhÆ° láº¥y Ä‘á»“ theo hÃ ng:
                            // Vá»‹ trÃ­ ráº¥t quan trá»ng!
```

### âŒ Anti-patterns (CÃ¡c anti-pattern):

```javascript
// âŒ WRONG: TÃ¡ch object properties thá»§ cÃ´ng
function displayUser(user) {
    const name = user.name;
    const age = user.age;
    const email = user.email;
    console.log(name, age, email);
}

// âŒ WRONG: Truy cáº­p nested properties nhiá»u láº§n
function getCity(user) {
    if (user.address && user.address.city) {
        return user.address.city.toUpperCase();
    }
}

// âŒ WRONG: KhÃ´ng dÃ¹ng default values
function greet(user) {
    const name = user.name; // Could be undefined! (cÃ³ thá»ƒ khÃ´ng xÃ¡c Ä‘á»‹nh)
    console.log(`Hello ${name}`); // "Hello undefined"
}

// âŒ WRONG: Bá» qua array items mÃ  khÃ´ng dÃ¹ng placeholder
const colors = ['red', 'green', 'blue'];
const red = colors[0];
const blue = colors[2]; // Skip green manually (bá» green thá»§ cÃ´ng)
```

### âœ… Best Practices - Objects (Thá»±c hÃ nh tá»‘t nháº¥t â€“ Objects):

```javascript
// âœ… RIGHT: Basic object destructuring
const user = { name: 'John', age: 25, email: 'john@example.com' };
const { name, age, email } = user;

// âœ… RIGHT: Rename variables (Ä‘á»•i tÃªn biáº¿n)
const { name: userName, age: userAge } = user;
console.log(userName); // 'John'

// âœ… RIGHT: Default values (giÃ¡ trá»‹ máº·c Ä‘á»‹nh)
const { name, role = 'user' } = user;
console.log(role); // 'user' (if not in object) (náº¿u khÃ´ng cÃ³ trong object)

// âœ… RIGHT: Nested destructuring (destructuring lá»“ng nhau)
const user = {
    name: 'John',
    address: {
        city: 'New York',
        zip: '10001',
    },
};
const {
    address: { city, zip },
} = user;

// âœ… RIGHT: Function parameters (tham sá»‘ hÃ m)
function displayUser({ name, age, email = 'N/A' }) {
    console.log(`${name}, ${age}, ${email}`);
}
displayUser(user);

// âœ… RIGHT: Destructuring with rest (káº¿t há»£p rest)
const { name, ...otherProps } = user;
console.log(otherProps); // { age: 25, email: '...' }

// âœ… RIGHT: Computed property names (tÃªn thuá»™c tÃ­nh Ä‘á»™ng)
const key = 'name';
const { [key]: value } = user;
console.log(value); // 'John'
```

### âœ… Best Practices - Arrays (Thá»±c hÃ nh tá»‘t nháº¥t â€“ Arrays):

```javascript
// âœ… RIGHT: Basic array destructuring
const colors = ['red', 'green', 'blue'];
const [first, second, third] = colors;

// âœ… RIGHT: Skipping items (bá» qua pháº§n tá»­)
const [red, , blue] = colors; // Skip green (bá» green)

// âœ… RIGHT: Default values (giÃ¡ trá»‹ máº·c Ä‘á»‹nh)
const [a, b, c = 'yellow'] = ['red', 'green'];
console.log(c); // 'yellow'

// âœ… RIGHT: Rest elements (pháº§n tá»­ rest)
const [first, ...rest] = colors;
console.log(rest); // ['green', 'blue']

// âœ… RIGHT: Swapping variables (hoÃ¡n Ä‘á»•i biáº¿n)
let a = 1,
    b = 2;
[a, b] = [b, a]; // Swap without temp variable (hoÃ¡n Ä‘á»•i khÃ´ng cáº§n biáº¿n táº¡m)

// âœ… RIGHT: Function return values (giÃ¡ trá»‹ tráº£ vá» tá»« hÃ m)
function getCoordinates() {
    return [10, 20];
}
const [x, y] = getCoordinates();

// âœ… RIGHT: Nested array destructuring (destructuring máº£ng lá»“ng nhau)
const matrix = [
    [1, 2],
    [3, 4],
];
const [[a, b], [c, d]] = matrix;
```

### ğŸ¯ Real-world Example (VÃ­ dá»¥ thá»±c táº¿):

```javascript
// API response handling (xá»­ lÃ½ pháº£n há»“i API)
const apiResponse = {
    data: {
        user: {
            id: 1,
            profile: {
                name: 'John Doe',
                email: 'john@example.com',
            },
            settings: {
                theme: 'dark',
                notifications: true,
            },
        },
    },
    status: 200,
};

// âœ… Extract exactly what you need (chá»‰ trÃ­ch xuáº¥t Ä‘Ãºng thá»© cáº§n dÃ¹ng)
const {
    data: {
        user: {
            profile: { name, email },
            settings: { theme = 'light' },
        },
    },
    status,
} = apiResponse;

console.log(name, email, theme, status);
// 'John Doe', 'john@example.com', 'dark', 200
```

---

## ğŸ“Œ 5. SPREAD/REST OPERATORS (45 phÃºt)

### Mental Model (MÃ´ hÃ¬nh tÆ° duy):

```
Spread (...)                  Rest (...)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"Explode" array/object       "Collect" into array
(lÃ m bung máº£ng/object)       (gom láº¡i thÃ nh máº£ng)

const arr = [1, 2, 3];       function sum(...numbers) {
console.log(...arr);           // numbers is [1, 2, 3] (numbers lÃ  [1, 2, 3])
// Same as: 1, 2, 3            return numbers.reduce(...)
                             }
[...arr1, ...arr2]           sum(1, 2, 3)

{...obj1, ...obj2}           const [first, ...rest] = arr
```

### âŒ Anti-patterns (CÃ¡c anti-pattern):

```javascript
// âŒ WRONG: Manual array copying (mutates original)
// copy máº£ng thá»§ cÃ´ng (lÃ m thay Ä‘á»•i máº£ng gá»‘c)
const original = [1, 2, 3];
const copy = original; // Same reference! (cÃ¹ng tham chiáº¿u)
copy.push(4); // Mutates original too (lÃ m thay Ä‘á»•i cáº£ máº£ng gá»‘c)

// âŒ WRONG: Verbose array concatenation
// ná»‘i máº£ng dÃ i dÃ²ng
const combined = arr1.concat(arr2).concat(arr3);

// âŒ WRONG: Object.assign when spread is cleaner
// dÃ¹ng Object.assign khi spread gá»n hÆ¡n
const merged = Object.assign({}, obj1, obj2, obj3);

// âŒ WRONG: Manually building new object
// táº¡o object má»›i thá»§ cÃ´ng, dÃ i dÃ²ng
const updated = {
    name: user.name,
    age: user.age,
    email: user.email,
    verified: true,
};

// âŒ WRONG: Using arguments object
// dÃ¹ng arguments object
function sum() {
    let total = 0;
    for (let i = 0; i < arguments.length; i++) {
        total += arguments[i];
    }
    return total;
}
```

### âœ… Best Practices - Spread (Thá»±c hÃ nh tá»‘t nháº¥t â€“ Spread):

```javascript
// âœ… RIGHT: Array copying (sao chÃ©p máº£ng)
const original = [1, 2, 3];
const copy = [...original]; // New array (máº£ng má»›i)
copy.push(4); // Original unchanged (máº£ng gá»‘c khÃ´ng Ä‘á»•i)

// âœ… RIGHT: Array concatenation (ná»‘i máº£ng)
const combined = [...arr1, ...arr2, ...arr3];

// âœ… RIGHT: Add items to array (thÃªm pháº§n tá»­ vÃ o máº£ng)
const numbers = [2, 3, 4];
const moreNumbers = [1, ...numbers, 5]; // [1, 2, 3, 4, 5]

// âœ… RIGHT: Object copying and merging (sao chÃ©p vÃ  gá»™p object)
const user = { name: 'John', age: 25 };
const updatedUser = { ...user, age: 26 };
// { name: 'John', age: 26 }

// âœ… RIGHT: Merge multiple objects (right to left priority)
// gá»™p nhiá»u object (Æ°u tiÃªn tá»« pháº£i sang trÃ¡i)
const defaults = { theme: 'light', lang: 'en' };
const userPrefs = { theme: 'dark' };
const settings = { ...defaults, ...userPrefs };
// { theme: 'dark', lang: 'en' }

// âœ… RIGHT: Function arguments (truyá»n tham sá»‘ hÃ m)
const numbers = [1, 2, 3, 4, 5];
Math.max(...numbers); // 5 (thay cho Math.max(1,2,3,4,5))

// âœ… RIGHT: Conditional properties (thuá»™c tÃ­nh cÃ³ Ä‘iá»u kiá»‡n)
const user = {
    name: 'John',
    ...(isAdmin && { role: 'admin' }),
    ...(hasEmail && { email: 'john@example.com' }),
};
```

### âœ… Best Practices - Rest (Thá»±c hÃ nh tá»‘t nháº¥t â€“ Rest):

```javascript
// âœ… RIGHT: Function with variable arguments (hÃ m vá»›i sá»‘ lÆ°á»£ng tham sá»‘ linh hoáº¡t)
function sum(...numbers) {
    return numbers.reduce((total, num) => total + num, 0);
}
sum(1, 2, 3, 4); // 10

// âœ… RIGHT: Separate first argument from rest (tÃ¡ch tham sá»‘ Ä‘áº§u vÃ  pháº§n cÃ²n láº¡i)
function log(level, ...messages) {
    console.log(`[${level}]`, ...messages);
}
log('ERROR', 'Something', 'went', 'wrong');

// âœ… RIGHT: Destructuring with rest (destructuring káº¿t há»£p rest)
const { name, age, ...otherProps } = user;
// name='John', age=25, otherProps={email:'...', role:'...'}

// âœ… RIGHT: Array destructuring with rest (destructuring máº£ng vá»›i rest)
const [first, second, ...remaining] = [1, 2, 3, 4, 5];
// first=1, second=2, remaining=[3,4,5]

// âœ… RIGHT: Ignore some properties (bá» qua má»™t sá»‘ thuá»™c tÃ­nh)
const { password, ...safeUser } = user;
// Remove password, keep everything else (loáº¡i bá» password, giá»¯ pháº§n cÃ²n láº¡i)
```

### ğŸ¯ React-Relevant Pattern:

```javascript
// Immutable state updates (CRITICAL for React)

// âœ… Add item to array
const addItem = (items, newItem) => [...items, newItem];

// âœ… Remove item from array
const removeItem = (items, index) => [
    ...items.slice(0, index),
    ...items.slice(index + 1),
];

// âœ… Update item in array
const updateItem = (items, index, updates) => [
    ...items.slice(0, index),
    { ...items[index], ...updates },
    ...items.slice(index + 1),
];

// âœ… Update nested object
const user = {
    name: 'John',
    address: {
        city: 'New York',
        zip: '10001',
    },
};

const updatedUser = {
    ...user,
    address: {
        ...user.address,
        city: 'Boston',
    },
};
```

---

## ğŸ“Œ 6. ARRAY METHODS (60 phÃºt)

### Mental Model (MÃ´ hÃ¬nh tÆ° duy):

```
Traditional Loop              Modern Array Methods
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for (let i...) {             .map()    - Transform each item (biáº¿n Ä‘á»•i tá»«ng pháº§n tá»­)
  // transform                .filter() - Keep items that pass test (giá»¯ pháº§n tá»­ thá»a Ä‘iá»u kiá»‡n)
}                            .reduce() - Combine into single value (gá»™p thÃ nh má»™t giÃ¡ trá»‹)

                             .find()   - First item that matches (pháº§n tá»­ khá»›p Ä‘áº§u tiÃªn)
                             .some()   - Any item matches? (cÃ³ pháº§n tá»­ nÃ o khá»›p khÃ´ng?)
                             .every()  - All items match? (táº¥t cáº£ pháº§n tá»­ cÃ³ khá»›p khÃ´ng?)
```

### ğŸ¯ Method Comparison (So sÃ¡nh cÃ¡c method):

| Method      | Returns (GiÃ¡ trá»‹ tráº£ vá») | Original Array | Use Case (TrÆ°á»ng há»£p dÃ¹ng)                    |
| ----------- | ------------------------ | -------------- | --------------------------------------------- |
| `map`       | New array (same length)  | Unchanged      | Transform each item (biáº¿n Ä‘á»•i tá»«ng pháº§n tá»­)   |
| `filter`    | New array (â‰¤ length)     | Unchanged      | Keep matching items (giá»¯ pháº§n tá»­ phÃ¹ há»£p)     |
| `reduce`    | Single value             | Unchanged      | Combine/aggregate (gá»™p / tá»•ng há»£p)            |
| `find`      | Single item or undefined | Unchanged      | First match (khá»›p Ä‘áº§u tiÃªn)                   |
| `findIndex` | Index or -1              | Unchanged      | Position of match (vá»‹ trÃ­ pháº§n tá»­ khá»›p)       |
| `some`      | Boolean                  | Unchanged      | Any match? (cÃ³ pháº§n tá»­ nÃ o khá»›p?)             |
| `every`     | Boolean                  | Unchanged      | All match? (táº¥t cáº£ Ä‘á»u khá»›p?)                 |
| `forEach`   | undefined                | Unchanged      | Side effects only (chá»‰ dÃ¹ng cho side effects) |

### âŒ Anti-patterns (CÃ¡c anti-pattern):

```javascript
// âŒ WRONG: DÃ¹ng forEach khi map phÃ¹ há»£p hÆ¡n
const doubled = [];
numbers.forEach((num) => {
    doubled.push(num * 2);
});
// Should use map! (nÃªn dÃ¹ng map)

// âŒ WRONG: DÃ¹ng map cho side effects
users.map((user) => {
    console.log(user.name); // Side effect, not transformation (side effect, khÃ´ng pháº£i biáº¿n Ä‘á»•i)
});
// Should use forEach! (nÃªn dÃ¹ng forEach)

// âŒ WRONG: Chaining map nhiá»u láº§n
const result = numbers
    .map((x) => x * 2)
    .map((x) => x + 1)
    .map((x) => x.toString());
// Should combine into single map! (nÃªn gá»™p vÃ o má»™t map)

// âŒ WRONG: DÃ¹ng reduce khi cÃ³ method Ä‘Æ¡n giáº£n hÆ¡n
const hasAdmin = users.reduce((found, user) => {
    return found || user.role === 'admin';
}, false);
// Should use .some()! (nÃªn dÃ¹ng .some())

// âŒ WRONG: Mutating trong map
const updated = users.map((user) => {
    user.lastSeen = Date.now(); // MUTATION! (thay Ä‘á»•i trá»±c tiáº¿p)
    return user;
});
```

### âœ… MAP - Transform Each Item (MAP â€“ Biáº¿n Ä‘á»•i tá»«ng pháº§n tá»­):

```javascript
// âœ… Basic transformation (biáº¿n Ä‘á»•i cÆ¡ báº£n)
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);
// [2, 4, 6, 8, 10]

// âœ… Extract properties (trÃ­ch xuáº¥t thuá»™c tÃ­nh)
const users = [
    { name: 'John', age: 25 },
    { name: 'Jane', age: 30 },
];
const names = users.map((user) => user.name);
// ['John', 'Jane']

// âœ… Transform objects (biáº¿n Ä‘á»•i object)
const usersWithIds = users.map((user, index) => ({
    id: index + 1,
    ...user,
}));
// [{ id: 1, name: 'John', age: 25 }, ...]

// âœ… Format for display (Ä‘á»‹nh dáº¡ng Ä‘á»ƒ hiá»ƒn thá»‹)
const formatted = users.map((user) => `${user.name} (${user.age} years old)`);

// âœ… Complex transformation (biáº¿n Ä‘á»•i phá»©c táº¡p)
const products = [
    { name: 'Laptop', price: 1000, tax: 0.1 },
    { name: 'Mouse', price: 50, tax: 0.1 },
];
const withTotal = products.map((product) => ({
    ...product,
    total: product.price * (1 + product.tax),
}));
```

### âœ… FILTER - Keep Items That Match (FILTER â€“ Giá»¯ cÃ¡c pháº§n tá»­ thá»a Ä‘iá»u kiá»‡n):

```javascript
// âœ… Basic filtering (lá»c cÆ¡ báº£n)
const numbers = [1, 2, 3, 4, 5, 6];
const evens = numbers.filter((num) => num % 2 === 0);
// [2, 4, 6]

// âœ… Filter by property (lá»c theo thuá»™c tÃ­nh)
const users = [
    { name: 'John', age: 25, active: true },
    { name: 'Jane', age: 30, active: false },
    { name: 'Bob', age: 35, active: true },
];
const activeUsers = users.filter((user) => user.active);

// âœ… Multiple conditions (nhiá»u Ä‘iá»u kiá»‡n)
const youngActiveUsers = users.filter((user) => user.active && user.age < 30);

// âœ… Remove falsy values (loáº¡i bá» giÃ¡ trá»‹ falsy)
const items = [1, 0, 'hello', '', null, 'world', undefined];
const truthy = items.filter(Boolean);
// [1, 'hello', 'world']

// âœ… Remove duplicates (with index check) (loáº¡i bá» trÃ¹ng láº·p â€“ dÃ¹ng index)
const numbers = [1, 2, 2, 3, 3, 4];
const unique = numbers.filter((num, index, arr) => arr.indexOf(num) === index);
// [1, 2, 3, 4]

// âœ… Complex filtering (lá»c phá»©c táº¡p)
const products = [
    { name: 'Laptop', price: 1000, inStock: true },
    { name: 'Mouse', price: 50, inStock: false },
    { name: 'Keyboard', price: 100, inStock: true },
];
const affordable = products.filter((p) => p.price < 500 && p.inStock);
```

### âœ… REDUCE - Combine Into Single Value (REDUCE â€“ Gá»™p thÃ nh má»™t giÃ¡ trá»‹ duy nháº¥t):

```javascript
// âœ… Sum numbers (tÃ­nh tá»•ng cÃ¡c sá»‘)
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((total, num) => total + num, 0);
// 15

// âœ… Find maximum (tÃ¬m giÃ¡ trá»‹ lá»›n nháº¥t)
const max = numbers.reduce((max, num) => (num > max ? num : max), numbers[0]);

// âœ… Count occurrences (Ä‘áº¿m sá»‘ láº§n xuáº¥t hiá»‡n)
const fruits = ['apple', 'banana', 'apple', 'orange', 'banana'];
const count = fruits.reduce((acc, fruit) => {
    acc[fruit] = (acc[fruit] || 0) + 1;
    return acc;
}, {});
// { apple: 2, banana: 2, orange: 1 }

// âœ… Group by property (nhÃ³m theo thuá»™c tÃ­nh)
const users = [
    { name: 'John', role: 'admin' },
    { name: 'Jane', role: 'user' },
    { name: 'Bob', role: 'admin' },
];
const byRole = users.reduce((groups, user) => {
    const role = user.role;
    groups[role] = groups[role] || [];
    groups[role].push(user);
    return groups;
}, {});
// { admin: [{...}, {...}], user: [{...}] }

// âœ… Transform array to object (chuyá»ƒn máº£ng thÃ nh object)
const users = [
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' },
];
const usersById = users.reduce((acc, user) => {
    acc[user.id] = user;
    return acc;
}, {});
// { 1: {...}, 2: {...} }

// âœ… Flatten nested arrays (lÃ m pháº³ng máº£ng lá»“ng nhau)
const nested = [[1, 2], [3, 4], [5]];
const flat = nested.reduce((acc, arr) => acc.concat(arr), []);
// [1, 2, 3, 4, 5]

// âœ… Calculate total price (tÃ­nh tá»•ng giÃ¡)
const cart = [
    { name: 'Laptop', price: 1000, quantity: 1 },
    { name: 'Mouse', price: 50, quantity: 2 },
];
const total = cart.reduce((sum, item) => sum + item.price * item.quantity, 0);
// 1100
```

### âœ… OTHER USEFUL METHODS (CÃ¡c method há»¯u Ã­ch khÃ¡c):

```javascript
// âœ… FIND - First matching item (pháº§n tá»­ khá»›p Ä‘áº§u tiÃªn)
const users = [
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' },
];
const user = users.find((u) => u.id === 2);
// { id: 2, name: 'Jane' }

// âœ… SOME - Any item matches? (cÃ³ pháº§n tá»­ nÃ o khá»›p khÃ´ng?)
const numbers = [1, 2, 3, 4, 5];
const hasEven = numbers.some((num) => num % 2 === 0);
// true

// âœ… EVERY - All items match? (táº¥t cáº£ Ä‘á»u khá»›p?)
const allEven = numbers.every((num) => num % 2 === 0);
// false

// âœ… INCLUDES - Array contains value? (máº£ng cÃ³ chá»©a giÃ¡ trá»‹ khÃ´ng?)
const hasThree = numbers.includes(3);
// true

// âœ… Chaining methods (káº¿t há»£p nhiá»u method)
const result = users
    .filter((user) => user.active)
    .map((user) => user.name)
    .sort();
```

### ğŸ¯ React-Relevant Patterns (CÃ¡c pattern liÃªn quan tá»›i React):

```javascript
// âœ… Render list of components (map) (render danh sÃ¡ch component)
const UserList = ({ users }) => (
    <div>
        {users.map((user) => (
            <UserCard key={user.id} user={user} />
        ))}
    </div>
);

// âœ… Filter then render (lá»c rá»“i render)
const ActiveUsers = ({ users }) => (
    <div>
        {users
            .filter((user) => user.active)
            .map((user) => (
                <UserCard key={user.id} user={user} />
            ))}
    </div>
);

// âœ… Calculate derived state (tÃ­nh state dáº«n xuáº¥t)
const total = items.reduce((sum, item) => sum + item.price, 0);
const average = total / items.length;

// âœ… Transform API data (biáº¿n Ä‘á»•i dá»¯ liá»‡u tá»« API)
const apiUsers = await fetch('/api/users').then((r) => r.json());
const formattedUsers = apiUsers.map((user) => ({
    id: user.user_id,
    name: `${user.first_name} ${user.last_name}`,
    email: user.email_address,
}));
```

---

## IV. LIVE CODING DEMOS (45 phÃºt)

### ğŸ¯ Demo 1: User Profile Card (â­)

```javascript
// Requirement: Transform user data and display formatted info

const rawUser = {
    first_name: 'John',
    last_name: 'Doe',
    email: 'john.doe@example.com',
    age: 25,
    address: {
        street: '123 Main St',
        city: 'New York',
        state: 'NY',
        zip: '10001',
    },
    preferences: {
        theme: 'dark',
        notifications: true,
        language: 'en',
    },
};

// âŒ Old way
function formatUserOld(user) {
    const firstName = user.first_name;
    const lastName = user.last_name;
    const email = user.email;
    const city = user.address.city;
    const state = user.address.state;
    const theme = user.preferences.theme;

    return (
        'Name: ' +
        firstName +
        ' ' +
        lastName +
        '\n' +
        'Email: ' +
        email +
        '\n' +
        'Location: ' +
        city +
        ', ' +
        state +
        '\n' +
        'Theme: ' +
        theme
    );
}

// âœ… Modern way
const formatUser = (user) => {
    const {
        first_name: firstName,
        last_name: lastName,
        email,
        address: { city, state },
        preferences: { theme = 'light' },
    } = user;

    return `Name: ${firstName} ${lastName}
Email: ${email}
Location: ${city}, ${state}
Theme: ${theme}`;
};

console.log(formatUser(rawUser));

// âœ… Even better: Return object for flexibility (tráº£ vá» object Ä‘á»ƒ linh hoáº¡t hÆ¡n)

const transformUser = ({
    first_name,
    last_name,
    email,
    age,
    address: { city, state, ...restAddress },
    preferences,
}) => ({
    fullName: `${first_name} ${last_name}`,
    email,
    age,
    location: `${city}, ${state}`,
    address: restAddress,
    ...preferences,
});

const user = transformUser(rawUser);
console.log(user);
// {
//   fullName: 'John Doe',
//   email: 'john.doe@example.com',
//   age: 25,
//   location: 'New York, NY',
//   address: { street: '123 Main St', zip: '10001' },
//   theme: 'dark',
//   notifications: true,
//   language: 'en'
// }
```

### ğŸ¯ Demo 2: Shopping Cart Manager (â­â­)

```javascript
// Requirement: Manage shopping cart with modern JS

const products = [
    { id: 1, name: 'Laptop', price: 1000, category: 'electronics' },
    { id: 2, name: 'Mouse', price: 50, category: 'electronics' },
    { id: 3, name: 'Keyboard', price: 100, category: 'electronics' },
    { id: 4, name: 'Desk', price: 300, category: 'furniture' },
    { id: 5, name: 'Chair', price: 200, category: 'furniture' },
];

const cart = [
    { productId: 1, quantity: 1 },
    { productId: 2, quantity: 2 },
    { productId: 5, quantity: 1 },
];

// âœ… Calculate cart total
const calculateTotal = (cart, products) => {
    return cart.reduce((total, item) => {
        const product = products.find((p) => p.id === item.productId);
        return total + product.price * item.quantity;
    }, 0);
};

console.log(`Total: $${calculateTotal(cart, products)}`);
// Total: $1300

// âœ… Get cart items with full details
const getCartDetails = (cart, products) => {
    return cart.map((item) => {
        const product = products.find((p) => p.id === item.productId);
        return {
            ...product,
            quantity: item.quantity,
            subtotal: product.price * item.quantity,
        };
    });
};

const cartDetails = getCartDetails(cart, products);
console.log(cartDetails);

// âœ… Group cart by category
const groupByCategory = (cartDetails) => {
    return cartDetails.reduce((groups, item) => {
        const category = item.category;
        if (!groups[category]) {
            groups[category] = [];
        }
        groups[category].push(item);
        return groups;
    }, {});
};

const grouped = groupByCategory(cartDetails);
console.log(grouped);
// {
//   electronics: [{...}, {...}],
//   furniture: [{...}]
// }

// âœ… Add item to cart (immutably)
const addToCart = (cart, productId, quantity = 1) => {
    const existingIndex = cart.findIndex(
        (item) => item.productId === productId
    );

    if (existingIndex !== -1) {
        // Update existing item
        return cart.map((item, index) =>
            index === existingIndex
                ? { ...item, quantity: item.quantity + quantity }
                : item
        );
    }

    // Add new item
    return [...cart, { productId, quantity }];
};

const newCart = addToCart(cart, 3, 1); // Add Keyboard
console.log(newCart);

// âœ… Remove item from cart (immutably)
const removeFromCart = (cart, productId) => {
    return cart.filter((item) => item.productId !== productId);
};

// âœ… Update quantity (immutably)
const updateQuantity = (cart, productId, quantity) => {
    if (quantity <= 0) {
        return removeFromCart(cart, productId);
    }

    return cart.map((item) =>
        item.productId === productId ? { ...item, quantity } : item
    );
};

// âœ… Apply discount
const applyDiscount = (total, discountPercent) => {
    return total * (1 - discountPercent / 100);
};

const finalTotal = applyDiscount(calculateTotal(cart, products), 10);
console.log(`Final Total (10% off): $${finalTotal}`);
// Final Total (10% off): $1170
```

### ğŸ¯ Demo 3: Data Processing Pipeline (â­â­â­)

```javascript
// Requirement: Process and analyze user activity data

const activities = [
    {
        userId: 1,
        action: 'login',
        timestamp: '2025-01-01T10:00:00',
        duration: 0,
    },
    {
        userId: 1,
        action: 'view',
        timestamp: '2025-01-01T10:05:00',
        duration: 300,
    },
    {
        userId: 2,
        action: 'login',
        timestamp: '2025-01-01T10:10:00',
        duration: 0,
    },
    {
        userId: 1,
        action: 'purchase',
        timestamp: '2025-01-01T10:15:00',
        duration: 120,
        amount: 100,
    },
    {
        userId: 2,
        action: 'view',
        timestamp: '2025-01-01T10:20:00',
        duration: 180,
    },
    {
        userId: 3,
        action: 'login',
        timestamp: '2025-01-01T10:25:00',
        duration: 0,
    },
    {
        userId: 2,
        action: 'purchase',
        timestamp: '2025-01-01T10:30:00',
        duration: 90,
        amount: 50,
    },
    {
        userId: 1,
        action: 'logout',
        timestamp: '2025-01-01T10:35:00',
        duration: 0,
    },
];

// âœ… Group activities by user
const byUser = activities.reduce((groups, activity) => {
    const { userId, ...rest } = activity;
    groups[userId] = groups[userId] || [];
    groups[userId].push(rest);
    return groups;
}, {});

console.log(byUser);

// âœ… Calculate user statistics
const getUserStats = (activities) => {
    // Group by user first
    const byUser = activities.reduce((acc, activity) => {
        const { userId } = activity;
        acc[userId] = acc[userId] || [];
        acc[userId].push(activity);
        return acc;
    }, {});

    // Calculate stats for each user
    return Object.entries(byUser).map(([userId, userActivities]) => {
        const purchases = userActivities.filter((a) => a.action === 'purchase');
        const totalSpent = purchases.reduce(
            (sum, p) => sum + (p.amount || 0),
            0
        );
        const totalTime = userActivities.reduce(
            (sum, a) => sum + a.duration,
            0
        );

        return {
            userId: parseInt(userId),
            totalActivities: userActivities.length,
            totalPurchases: purchases.length,
            totalSpent,
            totalTime,
            averageSessionTime: totalTime / userActivities.length,
        };
    });
};

const stats = getUserStats(activities);
console.log(stats);
// [
//   { userId: 1, totalActivities: 4, totalPurchases: 1, totalSpent: 100, ... },
//   { userId: 2, totalActivities: 3, totalPurchases: 1, totalSpent: 50, ... },
//   { userId: 3, totalActivities: 1, totalPurchases: 0, totalSpent: 0, ... }
// ]

// âœ… Find top spenders
const getTopSpenders = (stats, limit = 3) => {
    return stats
        .filter((user) => user.totalSpent > 0)
        .sort((a, b) => b.totalSpent - a.totalSpent)
        .slice(0, limit)
        .map(({ userId, totalSpent, totalPurchases }) => ({
            userId,
            totalSpent,
            totalPurchases,
            averageOrderValue: totalSpent / totalPurchases,
        }));
};

const topSpenders = getTopSpenders(stats);
console.log('Top Spenders:', topSpenders);

// âœ… Activity timeline
const getTimeline = (activities) => {
    return activities
        .map(({ timestamp, action, userId, amount }) => ({
            time: new Date(timestamp).toLocaleTimeString(),
            event: `User ${userId}: ${action}${amount ? ` ($${amount})` : ''}`,
        }))
        .sort((a, b) => a.time.localeCompare(b.time));
};

const timeline = getTimeline(activities);
console.log('Timeline:');
timeline.forEach(({ time, event }) => {
    console.log(`${time} - ${event}`);
});

// âœ… Purchase analysis
const analyzePurchases = (activities) => {
    const purchases = activities.filter((a) => a.action === 'purchase');

    if (purchases.length === 0) {
        return { count: 0, total: 0, average: 0, max: 0, min: 0 };
    }

    const amounts = purchases.map((p) => p.amount);
    const total = amounts.reduce((sum, amount) => sum + amount, 0);

    return {
        count: purchases.length,
        total,
        average: total / purchases.length,
        max: Math.max(...amounts),
        min: Math.min(...amounts),
    };
};

const purchaseAnalysis = analyzePurchases(activities);
console.log('Purchase Analysis:', purchaseAnalysis);
// {
//   count: 2,
//   total: 150,
//   average: 75,
//   max: 100,
//   min: 50
// }
```

---

## V. EXERCISES (90 phÃºt)

### ğŸ’ª Exercise 1: Variable Practice (â­) - 15 phÃºt

**Requirement**: Refactor code sá»­ dá»¥ng `let`/`const` Ä‘Ãºng cÃ¡ch.

```javascript
// Starter Code (BAD - using var):
var name = 'John Doe';
var age = 25;
var email = 'john@example.com';

if (age >= 18) {
    var status = 'adult';
    var canVote = true;
}

console.log(name, age, email, status, canVote);

for (var i = 0; i < 3; i++) {
    var message = 'Iteration ' + i;
    console.log(message);
}

console.log(i); // What value? Why?
```

**Your Task**:

1. Replace `var` vá»›i `let` hoáº·c `const` appropriately
2. Fix scope issues
3. Add comments giáº£i thÃ­ch choices

**Expected Output**: Code cháº¡y giá»‘ng nhau nhÆ°ng safer.

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Solution (Giáº£i phÃ¡p):
const name = 'John Doe'; // Never changes (khÃ´ng bao giá» thay Ä‘á»•i)
const age = 25; // Never changes (khÃ´ng bao giá» thay Ä‘á»•i)
const email = 'john@example.com'; // Never changes (khÃ´ng bao giá» thay Ä‘á»•i)

let status; // Declared outside to be accessible (khai bÃ¡o bÃªn ngoÃ i Ä‘á»ƒ cÃ³ thá»ƒ truy cáº­p)
let canVote; // Declared outside to be accessible (khai bÃ¡o bÃªn ngoÃ i Ä‘á»ƒ cÃ³ thá»ƒ truy cáº­p)

if (age >= 18) {
    status = 'adult'; // Assigned in block (gÃ¡n giÃ¡ trá»‹ trong block)
    canVote = true; // Assigned in block (gÃ¡n giÃ¡ trá»‹ trong block)
}

console.log(name, age, email, status, canVote);

for (let i = 0; i < 3; i++) {
    // let i is block-scoped to loop (let i cÃ³ pháº¡m vi trong block cá»§a vÃ²ng láº·p)
    const message = `Iteration ${i}`; // const in each iteration (const cho má»—i vÃ²ng láº·p)
    console.log(message);
}

// console.log(i); // ReferenceError - i is not defined (good!) (lá»—i tham chiáº¿u â€“ i khÃ´ng Ä‘Æ°á»£c Ä‘á»‹nh nghÄ©a, tá»‘t!)
```

**Key Points**:

-   `const` for values that never change (dÃ¹ng const cho giÃ¡ trá»‹ khÃ´ng bao giá» thay Ä‘á»•i)
-   `let` for values that will be reassigned (dÃ¹ng let cho giÃ¡ trá»‹ sáº½ Ä‘Æ°á»£c gÃ¡n láº¡i)
-   Block scope prevents accidental variable leaks (pháº¡m vi block giÃºp ngÄƒn rÃ² rá»‰ biáº¿n ngoÃ i Ã½ muá»‘n)
</details>

---

### ğŸ’ª Exercise 2: Arrow Functions & Destructuring (â­â­) - 25 phÃºt

**Requirement**: Modernize function syntax vÃ  data extraction.

```javascript
// Starter Code (OLD STYLE):
const users = [
    {
        id: 1,
        name: 'John Doe',
        email: 'john@example.com',
        address: { city: 'New York', country: 'USA' },
        age: 25,
    },
    {
        id: 2,
        name: 'Jane Smith',
        email: 'jane@example.com',
        address: { city: 'London', country: 'UK' },
        age: 30,
    },
    {
        id: 3,
        name: 'Bob Johnson',
        email: 'bob@example.com',
        address: { city: 'Paris', country: 'France' },
        age: 28,
    },
];

// Old way
function getUserInfo(user) {
    const name = user.name;
    const email = user.email;
    const city = user.address.city;
    const country = user.address.country;

    return (
        'Name: ' +
        name +
        '\n' +
        'Email: ' +
        email +
        '\n' +
        'Location: ' +
        city +
        ', ' +
        country
    );
}

function filterByAge(users, minAge) {
    const result = [];
    for (let i = 0; i < users.length; i++) {
        if (users[i].age >= minAge) {
            result.push(users[i]);
        }
    }
    return result;
}

function getEmails(users) {
    const emails = [];
    for (let i = 0; i < users.length; i++) {
        emails.push(users[i].email);
    }
    return emails;
}
```

**Your Task**:

1. Convert all functions to arrow functions (chuyá»ƒn táº¥t cáº£ functions sang arrow functions)
2. Use destructuring trong parameters (dÃ¹ng destructuring trong parameters)
3. Use template literals (dÃ¹ng template literals)
4. Replace loops vá»›i array methods (thay vÃ²ng láº·p báº±ng array methods)
5. Make code concise vÃ  readable (lÃ m code ngáº¯n gá»n vÃ  dá»… Ä‘á»c)

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Solution:

// 1. getUserInfo with destructuring & template literal
const getUserInfo = ({ name, email, address: { city, country } }) =>
    `Name: ${name}
Email: ${email}
Location: ${city}, ${country}`;

// Test
console.log(getUserInfo(users[0]));

// 2. filterByAge with arrow function & filter
const filterByAge = (users, minAge) =>
    users.filter((user) => user.age >= minAge);

// Or with destructuring:
const filterByAge = (users, minAge) => users.filter(({ age }) => age >= minAge);

// Test
console.log(filterByAge(users, 28));

// 3. getEmails with map
const getEmails = (users) => users.map((user) => user.email);

// Or with destructuring:
const getEmails = (users) => users.map(({ email }) => email);

// Test
console.log(getEmails(users));

// BONUS: Combine everything
const getUserSummaries = (users, minAge) =>
    users
        .filter(({ age }) => age >= minAge)
        .map(({ name, email, address: { city } }) => ({
            name,
            email,
            city,
        }));

console.log(getUserSummaries(users, 28));
```

</details>

---

### ğŸ’ª Exercise 3: Shopping Cart System (â­â­â­) - 40 phÃºt

**Requirement**: Build complete shopping cart vá»›i modern JS.

```javascript
// Products database
const products = [
    { id: 1, name: 'Laptop', price: 1200, category: 'electronics', stock: 5 },
    { id: 2, name: 'Mouse', price: 25, category: 'electronics', stock: 50 },
    { id: 3, name: 'Keyboard', price: 75, category: 'electronics', stock: 30 },
    { id: 4, name: 'Monitor', price: 300, category: 'electronics', stock: 15 },
    { id: 5, name: 'Desk', price: 450, category: 'furniture', stock: 8 },
    { id: 6, name: 'Chair', price: 250, category: 'furniture', stock: 12 },
];

// Starter cart
let cart = [];
```

**Your Task**: Implement cÃ¡c functions sau sá»­ dá»¥ng ES6+:

1. `addItem(cart, productId, quantity)` - Add/update item
2. `removeItem(cart, productId)` - Remove item
3. `updateQuantity(cart, productId, quantity)` - Update quantity
4. `calculateSubtotal(cart, products)` - Total before tax
5. `calculateTax(subtotal, taxRate)` - Calculate tax
6. `calculateTotal(cart, products, taxRate)` - Final total
7. `getCartSummary(cart, products)` - Detailed summary
8. `applyDiscount(total, discountCode)` - Apply discount codes
9. `checkStock(cart, products)` - Verify availability (kiá»ƒm tra tá»“n kho)
10. `suggestRelated(cart, products)` - Suggest items (gá»£i Ã½ sáº£n pháº©m)

**Rules**:

-   âŒ NO mutation of original arrays/objects (khÃ´ng thay Ä‘á»•i trá»±c tiáº¿p máº£ng/object gá»‘c)
-   âœ… Use spread operator for immutable updates (dÃ¹ng spread operator Ä‘á»ƒ cáº­p nháº­t báº¥t biáº¿n)
-   âœ… Use array methods (map, filter, reduce) (dÃ¹ng cÃ¡c array methods)
-   âœ… Use destructuring where appropriate (dÃ¹ng destructuring khi phÃ¹ há»£p)
-   âœ… Use arrow functions (dÃ¹ng arrow functions)
-   âœ… Handle edge cases (xá»­ lÃ½ cÃ¡c edge cases - bug áº©n, hiáº¿m gáº·p)

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Complete Solution:

// 1. Add or update item in cart (immutably)
const addItem = (cart, productId, quantity = 1) => {
    const existingIndex = cart.findIndex(
        (item) => item.productId === productId
    );

    if (existingIndex !== -1) {
        // Update existing item
        return cart.map((item, index) =>
            index === existingIndex
                ? { ...item, quantity: item.quantity + quantity }
                : item
        );
    }

    // Add new item
    return [...cart, { productId, quantity }];
};

// 2. Remove item from cart
const removeItem = (cart, productId) =>
    cart.filter((item) => item.productId !== productId);

// 3. Update quantity (remove if 0 or negative)
const updateQuantity = (cart, productId, quantity) => {
    if (quantity <= 0) {
        return removeItem(cart, productId);
    }

    return cart.map((item) =>
        item.productId === productId ? { ...item, quantity } : item
    );
};

// 4. Calculate subtotal
const calculateSubtotal = (cart, products) =>
    cart.reduce((total, item) => {
        const product = products.find((p) => p.id === item.productId);
        return total + (product ? product.price * item.quantity : 0);
    }, 0);

// 5. Calculate tax
const calculateTax = (subtotal, taxRate = 0.1) => subtotal * taxRate;

// 6. Calculate final total
const calculateTotal = (cart, products, taxRate = 0.1) => {
    const subtotal = calculateSubtotal(cart, products);
    const tax = calculateTax(subtotal, taxRate);
    return subtotal + tax;
};

// 7. Get detailed cart summary
const getCartSummary = (cart, products) => {
    const items = cart.map(({ productId, quantity }) => {
        const product = products.find((p) => p.id === productId);
        return {
            ...product,
            quantity,
            subtotal: product.price * quantity,
        };
    });

    const subtotal = items.reduce((sum, item) => sum + item.subtotal, 0);
    const tax = calculateTax(subtotal);
    const total = subtotal + tax;

    return {
        items,
        itemCount: cart.reduce((sum, item) => sum + item.quantity, 0),
        subtotal,
        tax,
        total,
    };
};

// 8. Apply discount codes
const discountCodes = {
    SAVE10: 0.1,
    SAVE20: 0.2,
    SUMMER: 0.15,
};

const applyDiscount = (total, code) => {
    const discount = discountCodes[code.toUpperCase()];
    if (!discount) {
        return { total, discount: 0, message: 'Invalid code' };
    }

    const discountAmount = total * discount;
    return {
        total: total - discountAmount,
        discount: discountAmount,
        message: `${discount * 100}% discount applied`,
    };
};

// 9. Check stock availability
const checkStock = (cart, products) => {
    const outOfStock = cart
        .map(({ productId, quantity }) => {
            const product = products.find((p) => p.id === productId);
            return {
                productId,
                productName: product.name,
                requested: quantity,
                available: product.stock,
                sufficient: product.stock >= quantity,
            };
        })
        .filter((item) => !item.sufficient);

    return {
        allAvailable: outOfStock.length === 0,
        outOfStock,
    };
};

// 10. Suggest related items (same category, not in cart)
const suggestRelated = (cart, products, limit = 3) => {
    const cartProductIds = cart.map((item) => item.productId);
    const cartCategories = cart
        .map(
            ({ productId }) =>
                products.find((p) => p.id === productId)?.category
        )
        .filter(
            (category, index, self) =>
                category && self.indexOf(category) === index
        );

    return products
        .filter(
            (product) =>
                !cartProductIds.includes(product.id) &&
                cartCategories.includes(product.category)
        )
        .slice(0, limit);
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TESTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Build a cart
let myCart = [];
myCart = addItem(myCart, 1, 1); // Laptop
myCart = addItem(myCart, 2, 2); // 2x Mouse
myCart = addItem(myCart, 5, 1); // Desk

console.log('Cart:', myCart);

// Get summary
const summary = getCartSummary(myCart, products);
console.log('Summary:', summary);

// Check stock
const stockCheck = checkStock(myCart, products);
console.log('Stock Check:', stockCheck);

// Calculate total with discount
const total = calculateTotal(myCart, products, 0.1);
const withDiscount = applyDiscount(total, 'SAVE20');
console.log('Total:', total);
console.log('With Discount:', withDiscount);

// Get suggestions
const suggestions = suggestRelated(myCart, products);
console.log('Suggested Products:', suggestions);

// Update quantity
myCart = updateQuantity(myCart, 2, 5); // Update mouse to 5
console.log('Updated Cart:', myCart);

// Remove item
myCart = removeItem(myCart, 5); // Remove desk
console.log('After Removal:', myCart);
```

**Testing Checklist**:

-   [ ] Adding items works (thÃªm item hoáº¡t Ä‘á»™ng Ä‘Ãºng)
-   [ ] Updating quantity works (cáº­p nháº­t sá»‘ lÆ°á»£ng hoáº¡t Ä‘á»™ng Ä‘Ãºng)
-   [ ] Removing items works (xoÃ¡ item hoáº¡t Ä‘á»™ng Ä‘Ãºng)
-   [ ] Subtotal calculates correctly (tÃ­nh subtotal Ä‘Ãºng)
-   [ ] Tax calculates correctly (tÃ­nh thuáº¿ Ä‘Ãºng)
-   [ ] Discount codes work (mÃ£ giáº£m giÃ¡ hoáº¡t Ä‘á»™ng Ä‘Ãºng)
-   [ ] Stock checking works (kiá»ƒm tra tá»“n kho hoáº¡t Ä‘á»™ng Ä‘Ãºng)
-   [ ] Suggestions show related items (gá»£i Ã½ sáº£n pháº©m liÃªn quan)
-   [ ] No mutations happen (khÃ´ng cÃ³ mutation xáº£y ra)

</details>

---

### ğŸ’ª Exercise 4: Data Analytics Pipeline (â­â­â­â­) - 60 phÃºt

**Requirement**: Process vÃ  analyze e-commerce data.

```javascript
// Sales data from API
const salesData = [
    {
        orderId: 1001,
        customerId: 'C001',
        date: '2025-01-01',
        items: [
            {
                productId: 'P001',
                name: 'Laptop',
                price: 1200,
                quantity: 1,
                category: 'electronics',
            },
            {
                productId: 'P002',
                name: 'Mouse',
                price: 25,
                quantity: 2,
                category: 'electronics',
            },
        ],
        status: 'completed',
        shippingCost: 15,
    },
    {
        orderId: 1002,
        customerId: 'C002',
        date: '2025-01-01',
        items: [
            {
                productId: 'P003',
                name: 'Desk',
                price: 450,
                quantity: 1,
                category: 'furniture',
            },
        ],
        status: 'completed',
        shippingCost: 50,
    },
    {
        orderId: 1003,
        customerId: 'C001',
        date: '2025-01-02',
        items: [
            {
                productId: 'P004',
                name: 'Chair',
                price: 250,
                quantity: 2,
                category: 'furniture',
            },
            {
                productId: 'P002',
                name: 'Mouse',
                price: 25,
                quantity: 1,
                category: 'electronics',
            },
        ],
        status: 'pending',
        shippingCost: 40,
    },
    {
        orderId: 1004,
        customerId: 'C003',
        date: '2025-01-02',
        items: [
            {
                productId: 'P001',
                name: 'Laptop',
                price: 1200,
                quantity: 1,
                category: 'electronics',
            },
            {
                productId: 'P005',
                name: 'Monitor',
                price: 300,
                quantity: 1,
                category: 'electronics',
            },
        ],
        status: 'completed',
        shippingCost: 20,
    },
    {
        orderId: 1005,
        customerId: 'C002',
        date: '2025-01-03',
        items: [
            {
                productId: 'P003',
                name: 'Desk',
                price: 450,
                quantity: 1,
                category: 'furniture',
            },
            {
                productId: 'P004',
                name: 'Chair',
                price: 250,
                quantity: 1,
                category: 'furniture',
            },
        ],
        status: 'completed',
        shippingCost: 60,
    },
];
```

**Your Task**: Implement analytics functions:

1. `getTotalRevenue(data)` - Total from all completed orders
2. `getRevenueByDate(data)` - Revenue grouped by date
3. `getRevenueByCategory(data)` - Revenue by product category
4. `getTopProducts(data, limit)` - Best selling products
5. `getCustomerStats(data)` - Customer purchase statistics
6. `getAverageOrderValue(data)` - AOV for completed orders (GiÃ¡ trá»‹ Ä‘Æ¡n hÃ ng trung bÃ¬nh (AOV) cá»§a cÃ¡c Ä‘Æ¡n Ä‘Ã£ hoÃ n thÃ nh)
7. `getProductPerformance(data)` - Detailed product metrics (CÃ¡c chá»‰ sá»‘ chi tiáº¿t vá» hiá»‡u suáº¥t sáº£n pháº©m)
8. `getDailySummary(data)` - Complete daily breakdown (BÃ¡o cÃ¡o tá»•ng há»£p theo ngÃ y)
9. `getCustomerSegments(data)` - Segment customers by spend (PhÃ¢n nhÃ³m khÃ¡ch hÃ ng theo má»©c chi tiÃªu)
10. `getProfitMargins(data, costs)` - Calculate profit margins (TÃ­nh biÃªn lá»£i nhuáº­n, giÃ¡ vá»‘n so vá»›i giÃ¡ bÃ¡n )

**Advanced Requirements**:

-   Handle incomplete data gracefully (Xá»­ lÃ½ dá»¯ liá»‡u thiáº¿u hoáº·c khÃ´ng Ä‘áº§y Ä‘á»§ má»™t cÃ¡ch an toÃ n)
-   Support filtering by date range
-   Support filtering by status
-   Calculate percentage changes
-   Format currency properly (Äá»‹nh dáº¡ng tiá»n tá»‡ Ä‘Ãºng chuáº©n)

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Complete Analytics Solution:

// Helper: Calculate order total
const getOrderTotal = ({ items, shippingCost = 0 }) =>
  items.reduce((sum, item) => sum + (item.price * item.quantity), 0) + shippingCost;

// 1. Total revenue from completed orders
const getTotalRevenue = (data) =>
  data
    .filter(order => order.status === 'completed')
    .reduce((total, order) => total + getOrderTotal(order), 0);

console.log(`Total Revenue: $${getTotalRevenue(salesData)}`);

// 2. Revenue grouped by date
const getRevenueByDate = (data) => {
  const completed = data.filter(order => order.status === 'completed');

  return completed.reduce((acc, order) => {
    const { date } = order;
    const total = getOrderTotal(order);

    acc[date] = (acc[date] || 0) + total;
    return acc;
  }, {});
};

console.log('Revenue by Date:', getRevenueByDate(salesData));

// 3. Revenue by category
const getRevenueByCategory = (data) => {
  const completed = data.filter(order => order.status === 'completed');

  return completed.reduce((acc, order) => {
    order.items.forEach(({ category, price, quantity }) => {
      acc[category] = (acc[category] || 0) + (price * quantity);
    });
    return acc;
  }, {});
};

console.log('Revenue by Category:', getRevenueByCategory(salesData));

// 4. Top selling products
const getTopProducts = (data, limit = 5) => {
  const completed = data.filter(order => order.status === 'completed');

  // Aggregate product sales
  const productSales = completed.reduce((acc, order) => {
    order.items.forEach(({ productId, name, price, quantity, category }) => {
      if (!acc[productId]) {
        acc[productId] = { productId, name, category, totalQuantity: 0, totalRevenue: 0 };
      }
      acc[productId].totalQuantity += quantity;
      acc[productId].totalRevenue += price * quantity;
    });
    return acc;
  }, {});

  // Sort and limit
  return Object.values(productSales)
    .sort((a, b) => b.totalRevenue - a.totalRevenue)
    .slice(0, limit)
    .map((product, index) => ({
      rank: index + 1,
      ...product
    }));
};

console.log('Top Products:', getTopProducts(salesData, 3));

// 5. Customer statistics
const getCustomerStats = (data) => {
  const byCustomer = data.reduce((acc, order) => {
    const { customerId, status } = order;
    const total = getOrderTotal(order);

    if (!acc[customerId]) {
      acc[customerId] = {
        customerId,
        totalOrders: 0,
        completedOrders: 0,
        pendingOrders: 0,
        totalSpent: 0
      };
    }

    acc[customerId].totalOrders++;
    if (status === 'completed') {
      acc[customerId].completedOrders++;
      acc[customerId].totalSpent += total;
    } else if (status === 'pending') {
      acc[customerId].pendingOrders++;
    }

    return acc;
  }, {});

  return Object.values(byCustomer).map(customer => ({
    ...customer,
    averageOrderValue: customer.completedOrders > 0
      ? customer.totalSpent / customer.completedOrders
      : 0
  }));
};

console.log('Customer Stats:', getCustomerStats(salesData));

// 6. Average Order Value
const getAverageOrderValue = (data) => {
  const completed = data.filter(order => order.status === 'completed');
  if (completed.length === 0) return 0;

  const total = completed.reduce((sum, order) => sum + getOrderTotal(order), 0);
  return total / completed.length;
};

console.log(`Average Order Value: $${getAverageOrderValue(salesData).toFixed(2)}`);

// 7. Product performance metrics
const getProductPerformance = (data) => {
  const completed = data.filter(order => order.status === 'completed');

  const performance = completed.reduce((acc, order) => {
    order.items.forEach(({ productId, name, price, quantity, category }) => {
      if (!acc[productId]) {
        acc[productId] = {
          productId,
          name,
          category,
          unitsSold: 0,
          revenue: 0,
          orderCount: 0
        };
      }

      acc[productId].unitsSold += quantity;
      acc[productId].revenue += price * quantity;
      acc[productId].orderCount++;
    });
    return acc;
  }, {});

  return Object.values(performance).map(product => ({
    ...product,
    averageUnitsPerOrder: product.unitsSold / product.orderCount,
    averageRevenue PerOrder: product.revenue / product.orderCount
  }));
};

console.log('Product Performance:', getProductPerformance(salesData));

// 8. Daily summary
const getDailySummary = (data) => {
  const byDate = data.reduce((acc, order) => {
    const { date, status } = order;

    if (!acc[date]) {
      acc[date] = {
        date,
        totalOrders: 0,
        completedOrders: 0,
        pendingOrders: 0,
        revenue: 0,
        items: []
      };
    }

    acc[date].totalOrders++;
    if (status === 'completed') {
      acc[date].completedOrders++;
      acc[date].revenue += getOrderTotal(order);
    } else if (status === 'pending') {
      acc[date].pendingOrders++;
    }

    acc[date].items.push(...order.items.map(item => item.productId));

    return acc;
  }, {});

  return Object.values(byDate).map(day => ({
    ...day,
    uniqueProducts: [...new Set(day.items)].length,
    averageOrderValue: day.completedOrders > 0
      ? day.revenue / day.completedOrders
      : 0,
    items: undefined // Remove items array
  }));
};

console.log('Daily Summary:', getDailySummary(salesData));

// 9. Customer segments
const getCustomerSegments = (data) => {
  const stats = getCustomerStats(data);

  const segments = {
    high: { customers: [], threshold: 1000, totalSpent: 0 },
    medium: { customers: [], threshold: 500, totalSpent: 0 },
    low: { customers: [], totalSpent: 0 }
  };

  stats.forEach(customer => {
    const { totalSpent } = customer;

    if (totalSpent >= segments.high.threshold) {
      segments.high.customers.push(customer);
      segments.high.totalSpent += totalSpent;
    } else if (totalSpent >= segments.medium.threshold) {
      segments.medium.customers.push(customer);
      segments.medium.totalSpent += totalSpent;
    } else {
      segments.low.customers.push(customer);
      segments.low.totalSpent += totalSpent;
    }
  });

  return {
    high: {
      count: segments.high.customers.length,
      totalRevenue: segments.high.totalSpent,
      averageSpend: segments.high.customers.length > 0
        ? segments.high.totalSpent / segments.high.customers.length
        : 0
    },
    medium: {
      count: segments.medium.customers.length,
      totalRevenue: segments.medium.totalSpent,
      averageSpend: segments.medium.customers.length > 0
        ? segments.medium.totalSpent / segments.medium.customers.length
        : 0
    },
    low: {
      count: segments.low.customers.length,
      totalRevenue: segments.low.totalSpent,
      averageSpend: segments.low.customers.length > 0
        ? segments.low.totalSpent / segments.low.customers.length
        : 0
    }
  };
};

console.log('Customer Segments:', getCustomerSegments(salesData));

// 10. Profit margins (assuming cost data)
const productCosts = {
  'P001': 800,  // Laptop
  'P002': 15,   // Mouse
  'P003': 300,  // Desk
  'P004': 150,  // Chair
  'P005': 200   // Monitor
};

const getProfitMargins = (data, costs) => {
  const performance = getProductPerformance(data);

  return performance.map(product => {
    const cost = costs[product.productId] || 0;
    const totalCost = cost * product.unitsSold;
    const profit = product.revenue - totalCost;
    const marginPercent = product.revenue > 0
      ? (profit / product.revenue) * 100
      : 0;

    return {
      ...product,
      totalCost,
      profit,
      marginPercent: marginPercent.toFixed(2) + '%'
    };
  }).sort((a, b) => parseFloat(b.marginPercent) - parseFloat(a.marginPercent));
};

console.log('Profit Margins:', getProfitMargins(salesData, productCosts));
```

**Complete Dashboard Output:**

```javascript
const generateDashboard = (data) => {
    const revenue = getTotalRevenue(data);
    const aov = getAverageOrderValue(data);
    const topProducts = getTopProducts(data, 3);
    const segments = getCustomerSegments(data);
    const daily = getDailySummary(data);

    return {
        overview: {
            totalRevenue: `$${revenue.toFixed(2)}`,
            averageOrderValue: `$${aov.toFixed(2)}`,
            totalOrders: data.filter((o) => o.status === 'completed').length,
        },
        topProducts,
        customerSegments: segments,
        dailyBreakdown: daily,
    };
};

console.log('=== DASHBOARD ===');
console.log(JSON.stringify(generateDashboard(salesData), null, 2));
```

</details>

---

### ğŸ’ª Exercise 5: Production-Ready Utility Library (â­â­â­â­â­) - 90 phÃºt

**Requirement**: XÃ¢y dá»±ng reusable utility library vá»›i modern JS.

**Your Task**: Táº¡o `utils.js` library vá»›i:

**Array Utilities:**

1. `chunk(array, size)` - Chia array thÃ nh cÃ¡c chunks
2. `unique(array)` - Loáº¡i bá» duplicates
3. `groupBy(array, key)` - Group theo property
4. `sortBy(array, key)` - Sort theo property
5. `pluck(array, key)` - Extract giÃ¡ trá»‹ cá»§a property

**Object Utilities:** 6. `pick(object, keys)` - Pick cÃ¡c keys cá»¥ thá»ƒ 7. `omit(object, keys)` - Omit cÃ¡c keys cá»¥ thá»ƒ 8. `merge(objects...)` - Deep merge objects 9. `flatten(object)` - Flatten nested object 10. `invert(object)` - Swap keys vÃ  values

**Function Utilities:** 11. `pipe(...fns)` - Compose functions theo thá»© tá»± left-to-right 12. `compose(...fns)` - Compose functions theo thá»© tá»± right-to-left 13. `debounce(fn, delay)` - Debounce function 14. `throttle(fn, delay)` - Throttle function 15. `memoize(fn)` - Cache function results

**Requirements**:

-   All functions must be pure (no side effects)(Táº¥t cáº£ functions pháº£i lÃ  pure (khÃ´ng cÃ³ side effects))
-   Handle edge cases
-   Add JSDoc comments
-   Include usage examples
-   Write test cases

<details>
<summary>ğŸ’¡ Solution</summary>

```javascript
// âœ… Production-Ready Utility Library

/**
 * utils.js - Modern JavaScript Utility Library
 * All functions are pure and immutable
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARRAY UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Split array into chunks of specified size
 * @param {Array} array - Input array
 * @param {number} size - Chunk size
 * @returns {Array} Array of chunks
 */
const chunk = (array, size) => {
    if (!Array.isArray(array) || size <= 0) return [];

    return array.reduce((chunks, item, index) => {
        const chunkIndex = Math.floor(index / size);
        chunks[chunkIndex] = chunks[chunkIndex] || [];
        chunks[chunkIndex].push(item);
        return chunks;
    }, []);
};

// Usage
console.log(chunk([1, 2, 3, 4, 5, 6, 7], 3));
// [[1, 2, 3], [4, 5, 6], [7]]

/**
 * Remove duplicate values from array
 * @param {Array} array - Input array
 * @returns {Array} Array with unique values
 */
const unique = (array) => {
    if (!Array.isArray(array)) return [];
    return [...new Set(array)];
};

// Usage
console.log(unique([1, 2, 2, 3, 3, 3, 4]));
// [1, 2, 3, 4]

/**
 * Group array items by key
 * @param {Array} array - Input array
 * @param {string|Function} key - Property name or function
 * @returns {Object} Grouped object
 */
const groupBy = (array, key) => {
    if (!Array.isArray(array)) return {};

    return array.reduce((groups, item) => {
        const groupKey = typeof key === 'function' ? key(item) : item[key];
        groups[groupKey] = groups[groupKey] || [];
        groups[groupKey].push(item);
        return groups;
    }, {});
};

// Usage
const users = [
    { name: 'John', role: 'admin' },
    { name: 'Jane', role: 'user' },
    { name: 'Bob', role: 'admin' },
];
console.log(groupBy(users, 'role'));
// { admin: [...], user: [...] }

/**
 * Sort array by key
 * @param {Array} array - Input array
 * @param {string|Function} key - Property or comparator
 * @param {string} order - 'asc' or 'desc'
 * @returns {Array} Sorted array (new copy)
 */
const sortBy = (array, key, order = 'asc') => {
    if (!Array.isArray(array)) return [];

    const sorted = [...array].sort((a, b) => {
        const aVal = typeof key === 'function' ? key(a) : a[key];
        const bVal = typeof key === 'function' ? key(b) : b[key];

        if (aVal < bVal) return order === 'asc' ? -1 : 1;
        if (aVal > bVal) return order === 'asc' ? 1 : -1;
        return 0;
    });

    return sorted;
};

// Usage
console.log(sortBy(users, 'name', 'asc'));

/**
 * Extract property values from array of objects
 * @param {Array} array - Input array
 * @param {string} key - Property name
 * @returns {Array} Array of values
 */
const pluck = (array, key) => {
    if (!Array.isArray(array)) return [];
    return array.map((item) => item?.[key]);
};

// Usage
console.log(pluck(users, 'name'));
// ['John', 'Jane', 'Bob']

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OBJECT UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Pick specific keys from object
 * @param {Object} object - Input object
 * @param {Array<string>} keys - Keys to pick
 * @returns {Object} New object with picked keys
 */
const pick = (object, keys) => {
    if (!object || typeof object !== 'object') return {};

    return keys.reduce((result, key) => {
        if (key in object) {
            result[key] = object[key];
        }
        return result;
    }, {});
};

// Usage
const user = {
    name: 'John',
    age: 25,
    email: 'john@example.com',
    password: 'secret',
};
console.log(pick(user, ['name', 'email']));
// { name: 'John', email: 'john@example.com' }

/**
 * Omit specific keys from object
 * @param {Object} object - Input object
 * @param {Array<string>} keys - Keys to omit
 * @returns {Object} New object without omitted keys
 */
const omit = (object, keys) => {
    if (!object || typeof object !== 'object') return {};

    return Object.keys(object).reduce((result, key) => {
        if (!keys.includes(key)) {
            result[key] = object[key];
        }
        return result;
    }, {});
};

// Usage
console.log(omit(user, ['password']));
// { name: 'John', age: 25, email: 'john@example.com' }

/**
 * Deep merge objects
 * @param {...Object} objects - Objects to merge
 * @returns {Object} Merged object
 */
const merge = (...objects) => {
    const isObject = (obj) =>
        obj && typeof obj === 'object' && !Array.isArray(obj);

    return objects.reduce((result, obj) => {
        Object.keys(obj).forEach((key) => {
            if (isObject(obj[key]) && isObject(result[key])) {
                result[key] = merge(result[key], obj[key]);
            } else {
                result[key] = obj[key];
            }
        });
        return result;
    }, {});
};

// Usage
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { b: { d: 3 }, e: 4 };
console.log(merge(obj1, obj2));
// { a: 1, b: { c: 2, d: 3 }, e: 4 }

/**
 * Flatten nested object
 * @param {Object} object - Input object
 * @param {string} separator - Key separator
 * @returns {Object} Flattened object
 */
const flatten = (object, separator = '.') => {
    const isObject = (obj) =>
        obj && typeof obj === 'object' && !Array.isArray(obj);

    const flatten = (obj, prefix = '') => {
        return Object.keys(obj).reduce((acc, key) => {
            const newKey = prefix ? `${prefix}${separator}${key}` : key;

            if (isObject(obj[key])) {
                Object.assign(acc, flatten(obj[key], newKey));
            } else {
                acc[newKey] = obj[key];
            }

            return acc;
        }, {});
    };

    return flatten(object);
};

// Usage
const nested = { a: 1, b: { c: 2, d: { e: 3 } } };
console.log(flatten(nested));
// { 'a': 1, 'b.c': 2, 'b.d.e': 3 }

/**
 * Invert object (swap keys and values)
 * @param {Object} object - Input object
 * @returns {Object} Inverted object
 */
const invert = (object) => {
    if (!object || typeof object !== 'object') return {};

    return Object.keys(object).reduce((result, key) => {
        result[object[key]] = key;
        return result;
    }, {});
};

// Usage
console.log(invert({ a: '1', b: '2', c: '3' }));
// { '1': 'a', '2': 'b', '3': 'c' }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNCTION UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Compose functions left-to-right
 * @param {...Function} fns - Functions to compose
 * @returns {Function} Composed function
 */
const pipe =
    (...fns) =>
    (value) =>
        fns.reduce((acc, fn) => fn(acc), value);

// Usage
const add5 = (x) => x + 5;
const multiply3 = (x) => x * 3;
const subtract2 = (x) => x - 2;

const calculate = pipe(add5, multiply3, subtract2);
console.log(calculate(10)); // ((10 + 5) * 3) - 2 = 43

/**
 * Compose functions right-to-left
 * @param {...Function} fns - Functions to compose
 * @returns {Function} Composed function
 */
const compose =
    (...fns) =>
    (value) =>
        fns.reduceRight((acc, fn) => fn(acc), value);

// Usage
const calculate2 = compose(subtract2, multiply3, add5);
console.log(calculate2(10)); // Same as pipe

/**
 * Debounce function (call after delay of inactivity)
 * @param {Function} fn - Function to debounce
 * @param {number} delay - Delay in milliseconds
 * @returns {Function} Debounced function
 */
const debounce = (fn, delay) => {
    let timeoutId;

    return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn(...args), delay);
    };
};

// Usage
const searchAPI = debounce((query) => {
    console.log('Searching for:', query);
}, 500);

// Only calls after 500ms of no input
searchAPI('hello');
searchAPI('hello world'); // Only this one executes

/**
 * Throttle function (call at most once per delay)
 * @param {Function} fn - Function to throttle
 * @param {number} delay - Minimum delay between calls
 * @returns {Function} Throttled function
 */
const throttle = (fn, delay) => {
    let lastCall = 0;

    return (...args) => {
        const now = Date.now();

        if (now - lastCall >= delay) {
            lastCall = now;
            fn(...args);
        }
    };
};

// Usage
const logScroll = throttle(() => {
    console.log('Scrolled!');
}, 1000);

// Calls at most once per second
window.addEventListener('scroll', logScroll);

/**
 * Memoize function (cache results)
 * @param {Function} fn - Function to memoize
 * @returns {Function} Memoized function
 */
const memoize = (fn) => {
    const cache = new Map();

    return (...args) => {
        const key = JSON.stringify(args);

        if (cache.has(key)) {
            console.log('Cache hit!');
            return cache.get(key);
        }

        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
};

// Usage
const expensiveCalculation = (n) => {
    console.log('Calculating...');
    return n * n;
};

const memoized = memoize(expensiveCalculation);
console.log(memoized(5)); // Calculating... 25
console.log(memoized(5)); // Cache hit! 25 (instant)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT (for use in other files)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export {
    // Array
    chunk,
    unique,
    groupBy,
    sortBy,
    pluck,
    // Object
    pick,
    omit,
    merge,
    flatten,
    invert,
    // Function
    pipe,
    compose,
    debounce,
    throttle,
    memoize,
};
```

**Test Suite:**

```javascript
// utils.test.js
console.log('Running tests...\n');

// Test chunk
console.assert(
    JSON.stringify(chunk([1, 2, 3, 4, 5], 2)) ===
        JSON.stringify([[1, 2], [3, 4], [5]]),
    'chunk failed'
);

// Test unique
console.assert(
    JSON.stringify(unique([1, 1, 2, 2, 3])) === JSON.stringify([1, 2, 3]),
    'unique failed'
);

// Test groupBy
const items = [
    { type: 'a', val: 1 },
    { type: 'b', val: 2 },
    { type: 'a', val: 3 },
];
const grouped = groupBy(items, 'type');
console.assert(grouped.a.length === 2, 'groupBy failed');

// Test pick
const obj = { a: 1, b: 2, c: 3 };
console.assert(
    JSON.stringify(pick(obj, ['a', 'c'])) === JSON.stringify({ a: 1, c: 3 }),
    'pick failed'
);

// Test pipe
const result = pipe(
    (x) => x + 1,
    (x) => x * 2
)(5);
console.assert(result === 12, 'pipe failed');

console.log('All tests passed! âœ“');
```

</details>

---

## VI. DEBUG LAB (20 phÃºt)

### ğŸ› Bug 1: Scope Issue

```javascript
// This code has a scope bug. Find and fix it.

function createCounters() {
    var counters = [];

    for (var i = 0; i < 3; i++) {
        counters.push(function () {
            console.log(i);
        });
    }

    return counters;
}

const counters = createCounters();
counters[0](); // Expected: 0, Actual: 3
counters[1](); // Expected: 1, Actual: 3
counters[2](); // Expected: 2, Actual: 3
```

<details>
<summary>ğŸ’¡ Solution & Explanation</summary>

```javascript
// Problem: `var` cÃ³ function-scoped, nÃªn táº¥t cáº£ functions dÃ¹ng chung cÃ¹ng má»™t `i`
// Khi cÃ¡c functions Ä‘Æ°á»£c thá»±c thi, i Ä‘Ã£ lÃ  3 (káº¿t thÃºc vÃ²ng láº·p)

// âœ… Solution 1: DÃ¹ng `let` (block-scoped)
function createCounters() {
    const counters = [];

    for (let i = 0; i < 3; i++) {
        // let táº¡o binding má»›i cho má»—i iteration
        counters.push(function () {
            console.log(i);
        });
    }

    return counters;
}

// âœ… Solution 2: DÃ¹ng closure (náº¿u buá»™c pháº£i dÃ¹ng var)
function createCounters() {
    var counters = [];

    for (var i = 0; i < 3; i++) {
        counters.push(
            (function (j) {
                return function () {
                    console.log(j);
                };
            })(i)
        ); // IIFE capture giÃ¡ trá»‹ i hiá»‡n táº¡i
    }

    return counters;
}

// âœ… Solution 3: CÃ¡ch hiá»‡n Ä‘áº¡i vá»›i map
function createCounters() {
    return [0, 1, 2].map((i) => () => console.log(i));
}
```

</details>

---

### ğŸ› Bug 2: Váº¥n Ä‘á» `this` Binding

```javascript
// Äoáº¡n code nÃ y bá»‹ máº¥t context. TÃ¬m vÃ  sá»­a nÃ³.

const user = {
    name: 'John',
    friends: ['Jane', 'Bob', 'Alice'],

    greetFriends: function () {
        this.friends.forEach(function (friend) {
            console.log(this.name + ' says hi to ' + friend);
            // TypeError: Cannot read property 'name' of undefined (KhÃ´ng thá»ƒ Ä‘á»c thuá»™c tÃ­nh 'name' cá»§a undefined)
        });
    },
};

user.greetFriends();
```

<details>
<summary>ğŸ’¡ Solution & Explanation</summary>

```javascript
// Váº¥n Ä‘á»: Regular function trong forEach lÃ m máº¥t context cá»§a `this`

// âœ… Solution 1: Arrow function (giá»¯ nguyÃªn this)
const user = {
    name: 'John',
    friends: ['Jane', 'Bob', 'Alice'],

    greetFriends: function () {
        this.friends.forEach((friend) => {
            // Arrow function!
            console.log(`${this.name} says hi to ${friend}`);
        });
    },
};

// âœ… Solution 2: Bind this
const user = {
    name: 'John',
    friends: ['Jane', 'Bob', 'Alice'],

    greetFriends: function () {
        this.friends.forEach(
            function (friend) {
                console.log(`${this.name} says hi to ${friend}`);
            }.bind(this)
        ); // Bind this má»™t cÃ¡ch tÆ°á»ng minh
    },
};

// âœ… Solution 3: LÆ°u reference cá»§a this
const user = {
    name: 'John',
    friends: ['Jane', 'Bob', 'Alice'],

    greetFriends: function () {
        const self = this; // LÆ°u reference
        this.friends.forEach(function (friend) {
            console.log(`${self.name} says hi to ${friend}`);
        });
    },
};
```

</details>

---

### ğŸ› Bug 3: Lá»—i Mutation

```javascript
// Äoáº¡n code nÃ y mutate dá»¯ liá»‡u gá»‘c. HÃ£y tÃ¬m vÃ  sá»­a lá»—i.

const originalUsers = [
    { id: 1, name: 'John', active: false },
    { id: 2, name: 'Jane', active: false },
];

function activateUsers(users) {
    return users.map((user) => {
        user.active = true; // BUG: Mutating dá»¯ liá»‡u gá»‘c!
        return user;
    });
}

const activeUsers = activateUsers(originalUsers);
console.log(originalUsers[0].active); // true (láº½ ra pháº£i lÃ  false!)
```

<details>
<summary>ğŸ’¡ Solution & Explanation</summary>

```javascript
// Váº¥n Ä‘á»: map tráº£ vá» array má»›i nhÆ°ng cÃ¡c object bÃªn trong váº«n lÃ  cÃ¹ng reference

// âœ… Giáº£i phÃ¡p: Táº¡o object má»›i
function activateUsers(users) {
    return users.map((user) => ({
        ...user, // Spread táº¡o object má»›i
        active: true,
    }));
}

// BÃ¢y giá» originalUsers khÃ´ng bá»‹ thay Ä‘á»•i
const activeUsers = activateUsers(originalUsers);
console.log(originalUsers[0].active); // false âœ“
console.log(activeUsers[0].active); // true âœ“

// âš ï¸ LÆ°u Ã½: Spread lÃ  shallow!
// Vá»›i object lá»“ng nhau, cáº§n deep copy:
const deepCopy = (users) =>
    users.map((user) => ({
        ...user,
        address: { ...user.address }, // Náº¿u user cÃ³ address lá»“ng nhau
    }));
```

</details>

---

## VII. INTERVIEW PREP (15 phÃºt)

### ğŸ’¼ Junior Level Questions

**Q1**: What's the difference between `let`, `const`, and `var`?

<details>
<summary>Expected Answer</summary>

-   **`var`**: Function-scoped, can be redeclared, hoisted
-   **`let`**: Block-scoped, cannot be redeclared, hoisted but not initialized
-   **`const`**: Block-scoped, cannot be reassigned (but objects/arrays can be mutated)

```javascript
// var: function-scoped
function test() {
    if (true) {
        var x = 1;
    }
    console.log(x); // 1 (accessible outside block)
}

// let: block-scoped
function test() {
    if (true) {
        let x = 1;
    }
    console.log(x); // ReferenceError
}

// const: cannot reassign
const x = 1;
x = 2; // Error

const user = { name: 'John' };
user.name = 'Jane'; // OK (mutation)
user = {}; // Error (reassignment)
```

</details>

**Q2**: Explain arrow functions and when NOT to use them.

<details>
<summary>Expected Answer</summary>

Arrow functions:

-   Shorter syntax
-   Lexical `this` binding (inherit from surrounding scope)
-   Cannot be used as constructors
-   No `arguments` object

Don't use arrow functions for:

-   Object methods (loses `this`)
-   Event handlers that need `this`
-   Functions that need `arguments`

```javascript
// âœ… Good uses:
const numbers = [1, 2, 3];
const doubled = numbers.map((x) => x * 2);

setTimeout(() => console.log('Hello'), 1000);

// âŒ Bad uses:
const person = {
    name: 'John',
    greet: () => console.log(this.name), // undefined!
};

button.addEventListener('click', () => {
    this.classList.toggle('active'); // this is not the button!
});
```

</details>

---

### ğŸ’¼ Mid Level Questions

**Q3**: Explain the difference between `map`, `filter`, and `reduce`. When would you use each?

<details>
<summary>Expected Answer</summary>

-   **`map`**: Transform each item, returns new array (same length)
-   **`filter`**: Keep items that pass test, returns new array (â‰¤ length)
-   **`reduce`**: Combine into single value

Use map when: Transforming data (API responses, formatting)
Use filter when: Removing items (search, validation)
Use reduce when: Aggregating (sums, grouping, flattening)

```javascript
const numbers = [1, 2, 3, 4, 5];

// map: transform each
const doubled = numbers.map((x) => x * 2);
// [2, 4, 6, 8, 10]

// filter: keep some
const evens = numbers.filter((x) => x % 2 === 0);
// [2, 4]

// reduce: combine
const sum = numbers.reduce((acc, x) => acc + x, 0);
// 15

// Real use: Transform API response
const apiUsers = response.data.map((user) => ({
    id: user.user_id,
    name: `${user.first} ${user.last}`,
    email: user.email_address,
}));
```

</details>

---

### ğŸ’¼ Senior Level Questions

**Q4**: Implement a `groupBy` function that groups array items by a key, then explain how `reduce` works internally.

<details>
<summary>Expected Answer</summary>

```javascript
// Implementation
const groupBy = (array, key) => {
    return array.reduce((groups, item) => {
        // Get the grouping key
        const groupKey = typeof key === 'function' ? key(item) : item[key];

        // Initialize group if it doesn't exist
        if (!groups[groupKey]) {
            groups[groupKey] = [];
        }

        // Add item to group
        groups[groupKey].push(item);

        return groups;
    }, {});
};

// Usage
const users = [
    { name: 'John', role: 'admin', age: 25 },
    { name: 'Jane', role: 'user', age: 30 },
    { name: 'Bob', role: 'admin', age: 35 },
];

const byRole = groupBy(users, 'role');
// { admin: [{...}, {...}], user: [{...}] }

const byAgeGroup = groupBy(users, (user) =>
    user.age < 30 ? 'young' : 'senior'
);
// { young: [{...}], senior: [{...}, {...}] }
```

**How reduce works internally**:

1. Takes accumulator (initial value) and current item
2. Executes reducer function
3. Returns new accumulator value
4. Passes to next iteration
5. Final accumulator is the result

**Key points**:

-   Accumulator can be any type (object, array, number, etc.)
-   Always return accumulator in each iteration
-   Initial value is crucial - wrong type causes bugs
-   Most powerful array method - can implement map/filter with reduce

```javascript
// Implementing map with reduce
const map = (array, fn) =>
    array.reduce((result, item) => {
        result.push(fn(item));
        return result;
    }, []);

// Implementing filter with reduce
const filter = (array, predicate) =>
    array.reduce((result, item) => {
        if (predicate(item)) {
            result.push(item);
        }
        return result;
    }, []);
```

</details>

---

**Q5**: What are the performance implications of using spread operator vs `Object.assign` vs manual property assignment for object copying?

<details>
<summary>Expected Answer</summary>

**Performance hierarchy** (fastest â†’ slowest):

1. Manual assignment (fastest)
2. `Object.assign`
3. Spread operator (slowest)

```javascript
// Benchmark example (conceptual)
const obj = { a: 1, b: 2, c: 3, d: 4, e: 5 };

// 1. Manual (fastest) ~1.0x
const manual = {
    a: obj.a,
    b: obj.b,
    c: obj.c,
    d: obj.d,
    e: obj.e,
    f: 6,
};

// 2. Object.assign (fast) ~1.2x
const assigned = Object.assign({}, obj, { f: 6 });

// 3. Spread (slower) ~1.5x
const spread = { ...obj, f: 6 };
```

**Trade-offs**:

| Method        | Performance | Readability | Maintainability | Use Case                  |
| ------------- | ----------- | ----------- | --------------- | ------------------------- |
| Manual        | â­â­â­      | â­          | â­              | Performance-critical code |
| Object.assign | â­â­        | â­â­        | â­â­            | Multiple source objects   |
| Spread        | â­          | â­â­â­      | â­â­â­          | Modern React code         |

**Real-world implications**:

-   For <100 objects/sec: Use spread (readability wins)
-   For >1000 objects/sec: Consider Object.assign
-   For >10000 objects/sec: Profile and optimize

**React context**:

```javascript
// State updates - spread is fine
setState((prevState) => ({
    ...prevState,
    count: prevState.count + 1,
}));

// Hot path rendering - might need optimization
// (But optimize only after profiling!)
```

**Memory considerations**:

-   All methods create new object (same memory cost)
-   Spread has slight overhead from transpilation
-   For large objects (>50 properties), consider immutability libraries
</details>

---

**Q6**: Design a data transformation pipeline using composition. Explain currying and partial application.

<details>
<summary>Expected Answer</summary>

**Composition Pattern**:

```javascript
// Individual transformations
const normalize = (str) => str.toLowerCase().trim();
const removeSpaces = (str) => str.replace(/\s+/g, '-');
const addPrefix = (prefix) => (str) => `${prefix}-${str}`;
const addSuffix = (suffix) => (str) => `${str}-${suffix}`;

// Compose (right to left)
const compose =
    (...fns) =>
    (value) =>
        fns.reduceRight((acc, fn) => fn(acc), value);

// Pipe (left to right) - more intuitive
const pipe =
    (...fns) =>
    (value) =>
        fns.reduce((acc, fn) => fn(acc), value);

// Build transformation pipeline
const createSlug = pipe(
    normalize, // "Hello World" â†’ "hello world"
    removeSpaces, // "hello world" â†’ "hello-world"
    addPrefix('post'), // "hello-world" â†’ "post-hello-world"
    addSuffix('2025') // "post-hello-world" â†’ "post-hello-world-2025"
);

console.log(createSlug('  Hello World  '));
// "post-hello-world-2025"
```

**Currying**:

```javascript
// Regular function
const add = (a, b, c) => a + b + c;
add(1, 2, 3); // 6

// Curried version
const addCurried = (a) => (b) => (c) => a + b + c;
addCurried(1)(2)(3); // 6

// Practical use: Create specialized functions
const add1 = addCurried(1);
const add1and2 = add1(2);
console.log(add1and2(3)); // 6

// Real-world example: Logger
const log = (level) => (message) => (timestamp) =>
    `[${timestamp}] ${level}: ${message}`;

const logError = log('ERROR');
const logErrorNow = logError('Something went wrong');
console.log(logErrorNow(new Date().toISOString()));
```

**Partial Application**:

```javascript
// Partial application helper
const partial =
    (fn, ...presetArgs) =>
    (...laterArgs) =>
        fn(...presetArgs, ...laterArgs);

// Example: fetch wrapper
const fetchJSON = (method, url, data) =>
    fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
    }).then((r) => r.json());

// Create specialized versions
const get = partial(fetchJSON, 'GET');
const post = partial(fetchJSON, 'POST');
const put = partial(fetchJSON, 'PUT');

// Use them
get('/api/users');
post('/api/users', { name: 'John' });
```

**Real-world Pipeline Example**:

```javascript
// Data transformation pipeline for API response
const transformUsers = pipe(
    // 1. Extract data array
    (response) => response.data,

    // 2. Filter active users
    (users) => users.filter((u) => u.active),

    // 3. Transform shape
    (users) =>
        users.map((u) => ({
            id: u.user_id,
            name: `${u.first_name} ${u.last_name}`,
            email: u.email_address,
        })),

    // 4. Sort by name
    (users) => users.sort((a, b) => a.name.localeCompare(b.name)),

    // 5. Add index
    (users) =>
        users.map((user, index) => ({
            ...user,
            displayOrder: index + 1,
        }))
);

// Use it
fetch('/api/users')
    .then((r) => r.json())
    .then(transformUsers)
    .then((users) => console.log(users));
```

**Key Benefits**:

-   Testable (each function is pure)
-   Reusable (compose in different ways)
-   Readable (declarative pipeline)
-   Maintainable (easy to add/remove steps)
</details>

---

## VIII. CODE REVIEW CHECKLIST (15 phÃºt)

### ğŸ“‹ ES6+ Code Review Guide

Khi review code sá»­ dá»¥ng ES6+, check cÃ¡c Ä‘iá»ƒm sau:

#### âœ… Variables & Scope

```javascript
// âŒ KHÃ”NG Tá»T
var count = 0;
if (true) {
    var count = 1; // Ghi Ä‘Ã¨ biáº¿n count bÃªn ngoÃ i
}

// âœ… Tá»T
let count = 0;
if (true) {
    let count = 1; // Pháº¡m vi (scope) riÃªng biá»‡t
}

// âœ… Tá»T HÆ N
const count = 0; // DÃ¹ng const khi khÃ´ng cáº§n gÃ¡n láº¡i
```

**Checklist**:

-   [ ] KhÃ´ng sá»­ dá»¥ng `var`
-   [ ] DÃ¹ng `const` cho cÃ¡c giÃ¡ trá»‹ khÃ´ng thay Ä‘á»•i
-   [ ] Chá»‰ dÃ¹ng `let` khi cáº§n gÃ¡n láº¡i
-   [ ] KhÃ´ng bá»‹ variable shadowing (trá»« khi cÃ³ chá»§ Ä‘Ã­ch)
-   [ ] Sá»­ dá»¥ng block scope Ä‘Ãºng cÃ¡ch

---

#### âœ… Functions

```javascript
// âŒ KHÃ”NG Tá»T
const user = {
    name: 'John',
    greet: () => {
        // Arrow function lÃ m máº¥t this
        console.log(this.name);
    },
};

// âœ… Tá»T
const user = {
    name: 'John',
    greet() {
        // Shorthand method
        console.log(this.name);
    },
};

// âŒ KHÃ”NG Tá»T
const double = (x) => {
    return x * 2;
}; // DÃ¹ng braces khÃ´ng cáº§n thiáº¿t

// âœ… Tá»T
const double = (x) => x * 2; // Gá»n gÃ ng
```

**Checklist**:

-   [ ] Arrow functions dÃ¹ng cho callbacks
-   [ ] Regular functions dÃ¹ng cho methods
-   [ ] DÃ¹ng implicit return khi cÃ³ thá»ƒ
-   [ ] KhÃ´ng dÃ¹ng parentheses khÃ´ng cáº§n thiáº¿t cho single parameter
-   [ ] KhÃ´ng dÃ¹ng braces khÃ´ng cáº§n thiáº¿t cho single expression

---

#### âœ… Destructuring

```javascript
// âŒ KHÃ”NG Tá»T
function displayUser(user) {
    const name = user.name;
    const email = user.email;
    const age = user.age;
}

// âœ… Tá»T
function displayUser({ name, email, age }) {
    // Truy cáº­p trá»±c tiáº¿p properties
}

// âŒ KHÃ”NG Tá»T
const first = arr[0];
const second = arr[1];

// âœ… Tá»T
const [first, second] = arr;
```

**Checklist**:

-   [ ] Object destructuring dÃ¹ng trong function parameters
-   [ ] Nested destructuring dÃ¹ng há»£p lÃ½ (khÃ´ng quÃ¡ sÃ¢u)
-   [ ] CÃ³ default values khi cáº§n
-   [ ] Rest operator dÃ¹ng Ä‘á»ƒ gom cÃ¡c properties cÃ²n láº¡i
-   [ ] Array destructuring dÃ¹ng cho multiple return values

---

#### âœ… Immutability

```javascript
// âŒ KHÃ”NG Tá»T
function addItem(cart, item) {
    cart.push(item); // Mutation!
    return cart;
}

// âœ… Tá»T
function addItem(cart, item) {
    return [...cart, item]; // Táº¡o array má»›i
}

// âŒ KHÃ”NG Tá»T
function updateUser(user, updates) {
    user.name = updates.name; // Mutation!
    return user;
}

// âœ… Tá»T
function updateUser(user, updates) {
    return { ...user, ...updates }; // Táº¡o object má»›i
}
```

**Checklist**:

-   [ ] KhÃ´ng mutate array trá»±c tiáº¿p (push, splice, v.v.)
-   [ ] KhÃ´ng mutate object trá»±c tiáº¿p
-   [ ] DÃ¹ng spread operator Ä‘á»ƒ copy
-   [ ] DÃ¹ng array methods (map, filter, reduce) thay cho loops
-   [ ] Functions luÃ´n return array/object má»›i

---

#### âœ… Array Methods

```javascript
// âŒ KHÃ”NG Tá»T
const doubled = [];
for (let i = 0; i < numbers.length; i++) {
    doubled.push(numbers[i] * 2);
}

// âœ… Tá»T
const doubled = numbers.map((n) => n * 2);

// âŒ KHÃ”NG Tá»T
numbers.forEach((n) => {
    console.log(n); // Side effect khÃ´ng cÃ³ transformation
});

// âœ… Tá»T
// forEach phÃ¹ há»£p cho side effects
// NhÆ°ng khÃ´ng nÃªn return báº¥t cá»© giÃ¡ trá»‹ gÃ¬ tá»« forEach

// âŒ KHÃ”NG Tá»T
const result = numbers
    .map((n) => n * 2)
    .map((n) => n + 1)
    .map((n) => n.toString());

// âœ… Tá»T
const result = numbers.map((n) => (n * 2 + 1).toString());
```

**Checklist**:

-   [ ] `map` dÃ¹ng cho transformations
-   [ ] `filter` dÃ¹ng Ä‘á»ƒ giá»¯ láº¡i items
-   [ ] `reduce` dÃ¹ng cho aggregations
-   [ ] KhÃ´ng dÃ¹ng `forEach` khi `map` / `filter` phÃ¹ há»£p hÆ¡n
-   [ ] Gá»™p nhiá»u `map` khi cÃ³ thá»ƒ
-   [ ] Array methods Ä‘Æ°á»£c chain há»£p lÃ½

---

#### âœ… Template Literals

```javascript
// âŒ KHÃ”NG Tá»T
const message = 'Hello ' + name + ', you are ' + age + ' years old';

// âœ… Tá»T
const message = `Hello ${name}, you are ${age} years old`;

// âŒ KHÃ”NG Tá»T
const html =
    '<div class="' +
    className +
    '">' +
    '<h1>' +
    title +
    '</h1>' +
    '<p>' +
    content +
    '</p>' +
    '</div>';

// âœ… Tá»T
const html = `
  <div class="${className}">
    <h1>${title}</h1>
    <p>${content}</p>
  </div>
`;
```

**Checklist**:

-   [ ] DÃ¹ng template literals thay cho string concatenation
-   [ ] Multi-line strings dÃ¹ng template literals
-   [ ] TÃ¡ch complex expressions ra variables (Ä‘á»ƒ dá»… Ä‘á»c)
-   [ ] KhÃ´ng dÃ¹ng template literals khÃ´ng cáº§n thiáº¿t cho static strings

---

### ğŸ¯ VÃ­ dá»¥ Review HoÃ n Chá»‰nh

```javascript
// âŒ BEFORE (nhiá»u issues)
var users = [];

function processUsers(data) {
    for (var i = 0; i < data.length; i++) {
        var user = data[i];
        if (user.active == true) {
            var processed = {
                id: user.id,
                name: user.first_name + ' ' + user.last_name,
                email: user.email,
            };
            users.push(processed);
        }
    }
    return users;
}

// âœ… AFTER (Ä‘Ã£ fix táº¥t cáº£ issues)
const processUsers = (data) => {
    return data
        .filter((user) => user.active === true) // So sÃ¡nh tÆ°á»ng minh
        .map(({ id, first_name, last_name, email }) => ({
            id,
            name: `${first_name} ${last_name}`,
            email,
        }));
};

// Even better: TÃ¡ch riÃªng pháº§n transformation
const transformUser = ({ id, first_name, last_name, email }) => ({
    id,
    name: `${first_name} ${last_name}`,
    email,
});

const processUsers = (data) =>
    data.filter((user) => user.active).map(transformUser);
```

**Issues ÄÃ£ ÄÆ°á»£c Fix**:

1. âœ… `var` â†’ `const`
2. âœ… Manual loop â†’ `filter` + `map`
3. âœ… String concatenation â†’ Template literal
4. âœ… Loose equality â†’ Strict equality
5. âœ… Function expression â†’ Arrow function
6. âœ… Mutation â†’ Pure function (khÃ´ng dÃ¹ng external state)
7. âœ… Manual property picking â†’ Destructuring

---

## IX. COMMON PITFALLS & SOLUTIONS (20 phÃºt)

### ğŸš¨ Pitfall 1: Const Confusion (Nháº§m láº«n vá» const)

**Problem** (Váº¥n Ä‘á»):

```javascript
const user = { name: 'John' };
user = { name: 'Jane' }; // âŒ Error: Assignment to constant (Lá»—i: GÃ¡n giÃ¡ trá»‹ cho háº±ng sá»‘)

const colors = ['red', 'green'];
colors = ['blue']; // âŒ Error: Assignment to constant (Lá»—i: GÃ¡n giÃ¡ trá»‹ cho háº±ng sá»‘)
```

**Solution** (Giáº£i phÃ¡p):

```javascript
// âœ… const ngÄƒn REASSIGNMENT (gÃ¡n láº¡i), khÃ´ng ngÄƒn MUTATION (thay Ä‘á»•i bÃªn trong)
const user = { name: 'John' };
user.name = 'Jane'; // âœ… OK - mutating object (thay Ä‘á»•i object)

const colors = ['red', 'green'];
colors.push('blue'); // âœ… OK - mutating array (thay Ä‘á»•i array)

// NhÆ°ng Ä‘á»ƒ Ä‘áº£m báº£o immutability, hÃ£y táº¡o object/array má»›i:
const updatedUser = { ...user, name: 'Jane' };
const updatedColors = [...colors, 'blue'];
```

---

### ğŸš¨ Pitfall 2: Arrow Function Returns (Return cá»§a arrow function)

**Problem** (Váº¥n Ä‘á»):

```javascript
// âŒ Returns undefined!
const getUser = () => {
  id: 1,
  name: 'John'
};

// JavaScript thinks it's a code block, not an object!
// (JavaScript hiá»ƒu Ä‘Ã¢y lÃ  block code, khÃ´ng pháº£i object)
```

**Solution** (Giáº£i phÃ¡p):

```javascript
// âœ… Bá»c object trong dáº¥u ngoáº·c ()
const getUser = () => ({
    id: 1,
    name: 'John',
});

// Hoáº·c dÃ¹ng explicit return
const getUser = () => {
    return {
        id: 1,
        name: 'John',
    };
};
```

---

### ğŸš¨ Pitfall 3: Destructuring Default Values (GiÃ¡ trá»‹ máº·c Ä‘á»‹nh khi destructuring)

**Problem** (Váº¥n Ä‘á»):

```javascript
const user = { name: 'John' };

// âŒ Age is undefined, not 25!
const { name, age = 25 } = user;
// age is undefined (not 25) because user.age exists and is undefined
// (age lÃ  undefined, khÃ´ng pháº£i 25 vÃ¬ user.age tá»“n táº¡i nhÆ°ng cÃ³ giÃ¡ trá»‹ undefined)
```

**Solution** (Giáº£i phÃ¡p):

```javascript
// âœ… Default values chá»‰ hoáº¡t Ä‘á»™ng khi property KHÃ”NG tá»“n táº¡i
const user = { name: 'John' }; // KhÃ´ng cÃ³ age
const { name, age = 25 } = user; // age lÃ  25 âœ“

// Vá»›i giÃ¡ trá»‹ undefined, dÃ¹ng nullish coalescing:
const user = { name: 'John', age: undefined };
const age = user.age ?? 25; // 25
```

---

### ğŸš¨ Pitfall 4: Spread Operator is Shallow (Spread operator lÃ  shallow copy)

**Problem** (Váº¥n Ä‘á»):

```javascript
const user = {
    name: 'John',
    address: {
        city: 'New York',
    },
};

const clone = { ...user };
clone.address.city = 'Boston'; // âŒ Mutates original! (Thay Ä‘á»•i object gá»‘c!)

console.log(user.address.city); // 'Boston' (unexpected! - khÃ´ng mong muá»‘n)
```

**Solution** (Giáº£i phÃ¡p):

```javascript
// âœ… Spread thá»§ cÃ´ng cho nested object
const clone = {
    ...user,
    address: { ...user.address },
};

// âœ… Hoáº·c dÃ¹ng deep clone utility
const deepClone = JSON.parse(JSON.stringify(user));
// (ÄÆ¡n giáº£n nhÆ°ng cÃ³ háº¡n cháº¿: máº¥t function, Date, v.v.)

// âœ… Hoáº·c dÃ¹ng thÆ° viá»‡n (production)
import { cloneDeep } from 'lodash';
const clone = cloneDeep(user);
```

---

### ğŸš¨ Pitfall 5: Map Returns Undefined (map tráº£ vá» undefined)

**Problem** (Váº¥n Ä‘á»):

```javascript
const numbers = [1, 2, 3];

// âŒ Returns [undefined, undefined, undefined]
const doubled = numbers.map((n) => {
    n * 2; // KhÃ´ng cÃ³ return!
});
```

**Solution** (Giáº£i phÃ¡p):

```javascript
// âœ… Implicit return (khÃ´ng dÃ¹ng {})
const doubled = numbers.map((n) => n * 2);

// âœ… Explicit return (cÃ³ {})
const doubled = numbers.map((n) => {
    return n * 2;
});
```

---

### ğŸš¨ Pitfall 6: Reduce Without Initial Value (reduce khÃ´ng cÃ³ initial value)

**Problem** (Váº¥n Ä‘á»):

```javascript
const numbers = [1, 2, 3, 4];

// âŒ Cháº¡y Ä‘Æ°á»£c vá»›i numbers nhÆ°ng lÃ  pattern nguy hiá»ƒm
const sum = numbers.reduce((acc, n) => acc + n);

// âŒ Lá»—i vá»›i array rá»—ng!
const empty = [];
const sum = empty.reduce((acc, n) => acc + n); // TypeError! (Lá»—i kiá»ƒu)
```

**Solution** (Giáº£i phÃ¡p):

```javascript
// âœ… LuÃ´n cung cáº¥p initial value
const sum = numbers.reduce((acc, n) => acc + n, 0);

// âœ… An toÃ n vá»›i array rá»—ng
const sum = [].reduce((acc, n) => acc + n, 0); // 0

// âœ… DÃ¹ng initial value Ä‘Ãºng vá»›i kiá»ƒu dá»¯ liá»‡u
const grouped = items.reduce((acc, item) => {
    // ...
}, {}); // Object initial value

const flattened = nested.reduce((acc, arr) => {
    // ...
}, []); // Array initial value
```

---

## X. PERFORMANCE TIPS (15 phÃºt)

### âš¡ Tip 1: Avoid Unnecessary Array Iterations (TrÃ¡nh láº·p array khÃ´ng cáº§n thiáº¿t)

```javascript
// âŒ BAD: Multiple iterations (Nhiá»u láº§n láº·p)
const result = data
    .filter((item) => item.active)
    .map((item) => item.value)
    .filter((value) => value > 10);

// âœ… GOOD: Single iteration with reduce (Má»™t láº§n láº·p vá»›i reduce)
const result = data.reduce((acc, item) => {
    if (item.active && item.value > 10) {
        acc.push(item.value);
    }
    return acc;
}, []);

// ğŸ¯ BEST: Only optimize if profiling shows it's a bottleneck!
// (Chá»‰ tá»‘i Æ°u khi profiling cho tháº¥y Ä‘Ã¢y lÃ  Ä‘iá»ƒm ngháº½n hiá»‡u nÄƒng)
// Readability usually wins over micro-optimizations
// (TÃ­nh dá»… Ä‘á»c thÆ°á»ng quan trá»ng hÆ¡n micro-optimization)
```

---

### âš¡ Tip 2: Memoize Expensive Operations (Memoize cÃ¡c phÃ©p tÃ­nh tá»‘n tÃ i nguyÃªn)

```javascript
// âŒ BAD: Recalculates every time (TÃ­nh toÃ¡n láº¡i má»—i láº§n)
function processData(data) {
    const sorted = data.sort((a, b) => b.value - a.value);
    const top10 = sorted.slice(0, 10);
    return top10;
}

// âœ… GOOD: Memoize result (Ghi nhá»› káº¿t quáº£)
const memoize = (fn) => {
    const cache = new Map();
    return (...args) => {
        const key = JSON.stringify(args);
        if (cache.has(key)) return cache.get(key);
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
};

const processData = memoize((data) => {
    const sorted = [...data].sort((a, b) => b.value - a.value);
    return sorted.slice(0, 10);
});
```

---

### âš¡ Tip 3: Use Object Lookup Instead of Array.find

(Sá»­ dá»¥ng tra cá»©u object thay vÃ¬ Array.find)

```javascript
// âŒ SLOW: O(n) for each lookup (Cháº­m: O(n) cho má»—i láº§n tÃ¬m)
const users = [
    /* large array */
];
const user1 = users.find((u) => u.id === 1);
const user2 = users.find((u) => u.id === 2);

// âœ… FAST: O(1) for each lookup (Nhanh: O(1) cho má»—i láº§n tÃ¬m)
const usersById = users.reduce((acc, user) => {
    acc[user.id] = user;
    return acc;
}, {});

const user1 = usersById[1];
const user2 = usersById[2];
```

---

## XI. Tá»”NG Káº¾T NGÃ€Y Há»ŒC & BÆ¯á»šC TIáº¾P THEO (10 phÃºt)

### ğŸ¯ HÃ´m nay Ä‘Ã£ há»c:

#### Core Concepts (KhÃ¡i niá»‡m cá»‘t lÃµi):

-   âœ… `let`/`const` vÃ  block scope
-   âœ… Arrow functions vÃ  `this` binding
-   âœ… Template literals
-   âœ… Destructuring (objects & arrays)
-   âœ… Spread/Rest operators
-   âœ… Array methods (`map`, `filter`, `reduce`)

#### Key Takeaways (Äiá»ƒm quan trá»ng):

1. **LuÃ´n dÃ¹ng `const`** máº·c Ä‘á»‹nh, chá»‰ dÃ¹ng `let` khi cáº§n reassignment
2. **Arrow functions** dÃ¹ng cho callbacks, regular functions dÃ¹ng cho methods
3. **Destructuring** giÃºp code sáº¡ch vÃ  dá»… Ä‘á»c hÆ¡n
4. **Spread operator** dÃ¹ng cho immutable updates (ráº¥t quan trá»ng vá»›i React)
5. **Array methods** thay tháº¿ loops Ä‘á»ƒ code dá»… Ä‘á»c hÆ¡n

---

### ğŸ“ Self-Assessment Questions:

Tá»± tráº£ lá»i cÃ¡c cÃ¢u há»i sau (khÃ´ng cáº§n code):

1. Khi nÃ o dÃ¹ng `let` vs `const`?
2. Táº¡i sao arrow function khÃ´ng phÃ¹ há»£p lÃ m object method?
3. Spread operator shallow hay deep copy?
4. Khi nÃ o dÃ¹ng `map` vs `forEach` vs `reduce`?
5. LÃ m sao trÃ¡nh mutation khi update object trong array?

<details>
<summary>ğŸ’¡ Answers</summary>

1. **let vs const**: DÃ¹ng `const` cho values khÃ´ng reassign. DÃ¹ng `let` chá»‰ khi cáº§n reassignment (loops, counters). Const khÃ´ng prevent mutation (object/array methods váº«n hoáº¡t Ä‘á»™ng).

2. **Arrow functions as methods**: Arrow functions cÃ³ lexical `this` (inherit tá»« surrounding scope), khÃ´ng pháº£i dynamic `this`. Object methods cáº§n dynamic `this` Ä‘á»ƒ reference object itself.

3. **Spread shallow/deep**: Spread operator lÃ  **shallow copy**. Chá»‰ copy level Ä‘áº§u tiÃªn. Nested objects/arrays váº«n lÃ  references. Cáº§n spread manually hoáº·c dÃ¹ng deep clone utility.

4. **map vs forEach vs reduce**:

    - `map`: Transform má»—i item, return new array
    - `forEach`: Side effects only, return undefined
    - `reduce`: Aggregate thÃ nh single value (hoáº·c build complex result)

5. **Avoid mutation**: DÃ¹ng `map` Ä‘á»ƒ create new array vá»›i updated objects: `items.map((item, i) => i === index ? { ...item, ...updates } : item)`
 </details>

---

### ğŸ”— NgÃ y mai sáº½ há»c:

#### ES6+ Advanced (Day 2):

-   **Promises & async/await** - Asynchronous operations - Báº¥t Ä‘á»“ng bá»™
-   **Modules** - Tá»• chá»©c code vá»›i import/export
-   **Optional chaining** - Truy cáº­p thuá»™c tÃ­nh an toÃ n vá»›i chaining
-   **Nullish coalescing** - Xá»­ lÃ½ giÃ¡ trá»‹ máº·c Ä‘á»‹nh vá»›i (??)
-   **Advanced array methods** - flatMap, find, some, every

#### Preparation:

-   [ ] Review hÃ´m nay's exercises
-   [ ] Complete any unfinished challenges
-   [ ] Read about Promises (optional)
-   [ ] Install Node.js (if not yet installed)

---

### ğŸ“š Additional Resources:

#### Official Docs:

-   [MDN: JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
-   [MDN: Array Methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)

#### Practice:

-   [JavaScript30](https://javascript30.com/) - 30 coding challenges
-   [Exercism JavaScript Track](https://exercism.org/tracks/javascript) - Practice with mentoring

#### Deep Dives:

-   [JavaScript Info](https://javascript.info/) - Comprehensive tutorial
-   [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) - Book series

---

## XII. HOMEWORK & PRACTICE (Optional)

### ğŸ  Tonight's Practice:

#### 1. Refactor Old Code (30 phÃºt)

TÃ¬m old JavaScript code cá»§a báº¡n (hoáº·c code online) vÃ  refactor sá»­ dá»¥ng ES6+:

-   Replace `var` vá»›i `let`/`const`
-   Convert functions sang arrow functions
-   Add destructuring
-   Replace loops vá»›i array methods

#### 2. Build Mini Project (60 phÃºt)

**Todo List Manager** (Pure JavaScript, NO React yet):

```javascript
// Requirements:
// - Add/remove/update todos
// - Filter by status (all/active/completed)
// - Sort by date/priority
// - Calculate statistics
// - All using ES6+ features
```

#### 3. Code Challenge (45 phÃºt)

Code cÃ¡c hÃ m tiá»‡n Ã­ch sau:

-   `flatten(array, depth)` - Flatten nested arrays. LÃ m pháº³ng máº£ng lá»“ng nhau theo Ä‘á»™ sÃ¢u (depth)
-   `difference(arr1, arr2)` - Items in arr1 not in arr2. Láº¥y cÃ¡c pháº§n tá»­ cÃ³ trong arr1 nhÆ°ng khÃ´ng cÃ³ trong arr2
-   `intersection(arr1, arr2)` - Items in both arrays. Láº¥y cÃ¡c pháº§n tá»­ xuáº¥t hiá»‡n á»Ÿ cáº£ hai máº£ng
-   `union(arr1, arr2)` - All unique items. Gá»™p hai máº£ng thÃ nh má»™t máº£ng duy nháº¥t khÃ´ng trÃ¹ng láº·p
-   `partition(array, predicate)` - Split by condition. TÃ¡ch máº£ng dá»±a trÃªn Ä‘iá»u kiá»‡n (predicate)

---

## ğŸ‰ CONGRATULATIONS!

Báº¡n Ä‘Ã£ hoÃ n thÃ nh **NgÃ y 1: ES6+ Essentials cho React**!

### ğŸ“Š Progress Tracker:

```
PHASE 1: React Fundamentals (Week 1-4)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Week 1: Modern JavaScript (Days 1-5)
â”œâ”€ [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘] 20% Complete
â”‚  â””â”€ Day 1: ES6+ Essentials âœ…
â”‚  â””â”€ Day 2: ES6+ Advanced
â”‚  â””â”€ Day 3: React Basics & JSX
â”‚  â””â”€ Day 4: Components & Props
â”‚  â””â”€ Day 5: Events & Conditional Rendering
```

**You're on track!** ğŸš€

---

### ğŸ’¬ Final Tips:

1. **Practice Daily** - Code má»—i ngÃ y, dÃ¹ chá»‰ 30 phÃºt
2. **Build Real Things** - Apply concepts vÃ o projects thá»±c táº¿
3. **Debug Actively** - Má»—i bug lÃ  cÆ¡ há»™i há»c
4. **Ask Questions** - KhÃ´ng cÃ³ cÃ¢u há»i ngu, chá»‰ cÃ³ ngÆ°á»i khÃ´ng há»i
5. **Review Often** - Quay láº¡i material nÃ y khi cáº§n

---

### â“ Questions Before Next Lesson?

Review checklist:

-   [ ] Hiá»ƒu khÃ¡c biá»‡t let/const/var
-   [ ] Thoáº£i mÃ¡i vá»›i arrow functions
-   [ ] Biáº¿t khi nÃ o dÃ¹ng destructuring
-   [ ] Hiá»ƒu spread operator vÃ  immutability
-   [ ] ThÃ nh tháº¡o map/filter/reduce

Náº¿u cÃ²n unclear á»Ÿ báº¥t ká»³ pháº§n nÃ o, hÃ£y review láº¡i section Ä‘Ã³ trÆ°á»›c khi chuyá»ƒn sang Day 2!

---

**See you tomorrow for Day 2: ES6+ Advanced!** ğŸ‘‹
